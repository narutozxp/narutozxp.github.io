<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Static Timing Analysis for Nanometer Designs:A Practical Approach(v2) | narutozxp</title><meta name="keywords" content="STA"><meta name="author" content="narutozxp"><meta name="copyright" content="narutozxp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="description test">
<meta property="og:type" content="article">
<meta property="og:title" content="Static Timing Analysis for Nanometer Designs:A Practical Approach(v2)">
<meta property="og:url" content="https://www.narutozxp.top/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v2/index.html">
<meta property="og:site_name" content="narutozxp">
<meta property="og:description" content="description test">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.narutozxp.top/img/19.webp">
<meta property="article:published_time" content="2022-07-13T10:00:21.000Z">
<meta property="article:modified_time" content="2023-05-31T16:07:30.000Z">
<meta property="article:author" content="narutozxp">
<meta property="article:tag" content="STA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.narutozxp.top/img/19.webp"><link rel="shortcut icon" href="/img/myself.webp"><link rel="canonical" href="https://www.narutozxp.top/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Great%20Vibes" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Static Timing Analysis for Nanometer Designs:A Practical Approach(v2)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-31 16:07:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script> <link rel="stylesheet" href="/css/custom.css"> <link rel="stylesheet" href="/css/font.css"> <script src="https://wavedrom.com/wavedrom.min.js" type="text/javascript"></script> <script src="https://wavedrom.com/skins/default.js" type="text/javascript"></script> <script src="https://wavedrom.com/skins/dark.js" type="text/javascript"></script> <script src="https://wavedrom.com/skins/narrow.js" type="text/javascript"></script> <script src="https://wavedrom.com/skins/lowkey.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts-gl/dist/echarts-gl.min.js" type="text/javascript"></script> <script data-pjax src="https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.js" type="text/javascript"></script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/abcjs/abcjs-audio.css"/> <script defer data-pjax src="https://cn.vercount.one/js" type="text/javascript"></script>
<script data-pjax type="text/javascript"> WaveDrom.ProcessAll(); mermaid.run(); </script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.5.0/style.css" /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"> <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script> <meting-js id="2217718183" server="netease" type="playlist" autoplay = "false" api = "https://v.iarc.top/?server=:server&type=:type&id=:id&r=:r" mini = "true" fixed = "true" loop = "all" order = 'random' list-folded = "true"> </meting-js><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myself.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/19.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">narutozxp</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Static Timing Analysis for Nanometer Designs:A Practical Approach(v2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-13T10:00:21.000Z" title="发表于 2022-07-13 10:00:21">2022-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-31T16:07:30.000Z" title="更新于 2023-05-31 16:07:30">2023-05-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IC/">IC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">111k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>368分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Static Timing Analysis for Nanometer Designs:A Practical Approach(v2)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">
<h1 id="绪论">绪论</h1>
<blockquote>
<p>众所周知，静态时序分析是IC工程师必备知识点，也是秋招中笔试面试的高频考点。<br>
网上不乏优秀视频课，如V3学院尤老师、小梅哥、IC创新学院邸志雄老师的课。<br>
《Static Timing Analysis for Nanometer Designs:A Practical Approach》，可堪称静态时序分析的“圣经”吧！<br>
由于网上找不到此书的翻译，因此笔者决定开坑进行对“圣经”的翻译~！希望可以在加深对静态时序分析的学习同时，完成这一本书的翻译方便大家以后更好地从中学习吧。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-8e02c51213dbc09e2bd57bd6df30a8c5_720w.jpg"></p>
<hr>
<p>本章节概述了纳米级（nanometer）设计下的静态时序仿真过程<br>
本章节解决了如下问题：</p>
<ul>
<li>什么是静态时序分析（static timing analysis）？</li>
<li>噪声（noise）与串扰（crosstalk）会带来什么影响 ？</li>
<li>如何使用静态时序分析？</li>
<li>在整个设计流程中的哪个阶段会应用静态时序分析？</li>
</ul>
<h2 id="纳米设计">纳米设计</h2>
<p>​ 在半导体器件中，金属互连走线通常用于在电路的各个部分之间建立连接以实现设计。众所周知，随着工艺技术的缩小，这些互连走线会影响设计的性能。对于深亚微米或纳米工艺技术，互连中的耦合会引起噪声和串扰——这两种情况都会限制设计的运行速度。虽然噪声和耦合效应在老一代技术中可以忽略不计，但它们在纳米技术中发挥着重要作用。因此，物理设计应考虑串扰和噪声的影响，然后设计验证应包括串扰和噪声的影响。</p>
<h2 id="什么是静态时序分析">什么是静态时序分析？</h2>
<p>​ 静态时序分析（也称为 STA）是可用于验证数字设计时序的众多技术之一。用于验证时序的另一种方法是时序仿真，它可以验证设计的功能和时序。术语时序分析用于指代这两种方法之一 - 静态时序分析或时序仿真。因此，时序分析只是指对时序问题的设计进行分析。</p>
<p>​ STA 是静态的，因为设计分析是静态执行的，不依赖于施加到输入引脚的数据值。这与基于仿真的时序分析形成对比，在基于仿真的时序分析中，对输入信号应用刺激，观察并验证结果行为，然后随着新输入刺激的应用而推进时间，并观察和验证新行为，依此类推。</p>
<p>​ 给定一个设计以及一组输入时钟定义和设计外部环境的定义，静态时序分析的目的是验证设计是否可以以额定速度运行。也就是说，设计可以在指定的时钟频率下安全运行，而不会出现任何时序违规。图 1-1 展示了静态时序分析的基本功能 。<strong>DUA</strong> 是被分析的设计。一些时序检查的例子是建立和保持检查。建立检查确保数据可以在给定的时钟周期内到达触发器。保持检查确保数据至少保持最短时间，从而不会出现意外的数据通过触发器：也就是说，它确保触发器正确捕获预期数据。这些检查确保正确的数据已准备就绪并可用于捕获并锁定新状态。</p>
<p>​</p>
<p><img src="https://img-blog.csdnimg.cn/2021080420153454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 静态时序分析更重要的方面是对整个设计进行一次分析，并对设计的所有可能路径和场景执行所需的时序检查。因此，STA 是一种用于验证设计时序的完整而详尽的方法。</p>
<p>​ 分析中的设计通常使用指定的硬件描述语言（例如 VHDL 或 Verilog HDL）。外部环境（包括时钟定义）通常使用 SDC或等效格式指定。 SDC 是一种时序约束规范语言。时序报告采用 ASCII 格式，通常有多列，每一列显示路径延迟的一个属性。</p>
<h2 id="为什么使用静态时序分析">为什么使用静态时序分析？</h2>
<p>​ 静态时序分析是对设计的所有时序检查的完整而详尽的验证。其他时序分析方法（例如仿真）只能验证设计中受激励影响的部分。通过时序仿真进行验证与所使用的测试向量一样详尽。模拟和验证具有 10-1亿个门的设计的所有时序条件非常缓慢，并且无法完全验证时序。因此，很难通过模拟进行详尽的验证。</p>
<p>​ 另一方面，静态时序分析提供了一种更快、更简单的方法来检查和分析设计中的所有时序路径是否存在任何时序违规。考虑到当今 ASIC 的复杂性，其中可能包含 10 到 1 亿个门，静态时序分析已成为详尽验证设计时序的必要条件。</p>
<h3 id="串扰和噪声crosstalk-and-noise">串扰和噪声（Crosstalk and Noise）</h3>
<p>​ 设计功能及其性能可能会受到噪声的限制。噪声是由于与其他信号的串扰或主输入或电源上的噪声而产生的。噪声影响可以限制设计运作频率，并且也可能导致功能故障。因此，一个设计实现必须经过验证证明它的稳健性，这意味着它可以在不影响设计的额定性能情况下承受噪声。</p>
<p>​ 基于逻辑仿真的验证无法处理串扰、噪声和片上变化的影响。</p>
<p>​ 本书中描述的分析方法不仅涵盖了传统的时序分析技术，还涵盖了噪声分析，以验证包括噪声影响在内的设计。</p>
<h2 id="设计流程">设计流程</h2>
<p>​ 本节主要描述本书其余部分使用的上下文中的 CMOS数字设计流程。还简要描述了它对 FPGA 和异步设计的适用性。</p>
<h3 id="cmos数字设计">CMOS数字设计</h3>
<p>​ 在 CMOS 数字设计流程中，静态时序分析可以在实现的许多不同阶段执行。图 1-2 显示了一个典型的流程。</p>
<p><img src="https://img-blog.csdnimg.cn/20210804215939871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ STA 很少在 RTL 级别完成，因为此时验证设计的功能性比验证时序更为重要。也不是所有的时序信息都可用，因为块的描述在行为级。一旦 RTL 级的设计被综合到门级，STA 用于验证设计的时序。STA 也可以在执行逻辑优化之前运行 - 目标是识别最差或关键的时序路径。 STA可以在逻辑优化后重新运行来查看是否仍有需要优化的失败路径，或确定关键路径。</p>
<p>​ 在物理设计开始时，时钟树被认为是理想的，即它们具有零延迟。一旦物理设计开始并且在时钟树构建之后，就可以执行 STA 来再次检查时序。实际上，在物理设计期间，可以在每一步执行 STA 以识别最差路径。</p>
<p>​ 在物理实现中，逻辑单元通过互连金属走线连接。金属走线的寄生 RC（电阻和电容）会影响通过这些走线的信号路径延迟。在典型的纳米设计中，互连的寄生效应可以解释设计中的大部分延迟和功耗。因此，任何设计分析都应评估互连对性能特征（速度、功率等）的影响。如前所述，信号走线之间的耦合会产生噪声，设计验证必须包括噪声对性能的影响。</p>
<p>​ 在逻辑设计阶段，由于没有与布局相关的物理信息，因此可以假设为理想互连；可能更有兴趣查看导致最坏路径的逻辑。此阶段使用的另一种技术是使用线载模型估算互连的长度。线载模型根据单元的扇出提供估计的 RC。</p>
<p>​ 在最终确定走线的布线（ <strong>routing</strong>）之前，实施工具使用布线距离的估计来获得布线的 RC 寄生效应。由于布线还没有最终确定，所以这个阶段称为全局布线阶段（<strong>global route</strong>），以区别于最终布线阶段（<strong>final route</strong>）。在物理设计的全局布线阶段，简化布线用于估计布线长度，布线估计用于确定计算布线延迟所需的电阻和电容。在这个阶段，不能包括耦合的影响。详细布线完成后，使用提取工具得到的实际 RC 值，可以分析耦合的影响。但是，物理设计工具可能仍会使用近似值来帮助改善计算 RC 值的运行时间。</p>
<p>​ 提取工具用于从布线设计中提取详细的寄生参数（RC 值）。这样的提取工具可以选择在迭代优化期间以较小的运行时间和较不精确的RC值获得寄生参数，也可以选择在最终验证过程中以较大的运行时间提取非常精确的RC值。</p>
<p>​ 总而言之，静态时序分析可以在门级网表上执行，具体取决于：</p>
<ol type="1">
<li>互连（interconnect）是怎么建模 的-——理想互连、线载模型、具有近似 RC 的全局布线或具有准确 RC 的真实布线。</li>
<li>时钟是怎么建模 的-——时钟是理想的（零延迟）还是传播的（实际延迟）。</li>
<li>是否包括信号之间的耦合——是否分析了任何串扰噪声。</li>
</ol>
<p>​ 图 1-2 似乎暗示 STA 是在实现步骤之外完成的，也就是说，STA 是在每个综合、逻辑优化和物理设计步骤之后完成的。实际上，这些步骤中的每一个都在其功能范围内执行集成（和增量）STA。例如，逻辑优化步骤中的时序分析引擎，它是用于识别优化器需要处理的关键路径。同样，布局工具中的集成时序分析引擎用于在布局逐步进行时保持设计的时序。</p>
<h3 id="fpga设计">FPGA设计</h3>
<p>​ STA 的基本流程在 FPGA 中仍然有效。尽管 FPGA 中的布线受限于通道，但提取寄生效应和执行 STA 的机制与 CMOS 数字设计流程相同。例如，STA执行时，可以假设互联是理想的，或者使用线载模型，假设时钟树是理想的或真实的，假设全局布线，或者使用真实布线进行寄生。</p>
<h3 id="异步设计">异步设计</h3>
<p>​ STA 的原理也适用于异步设计。人们可能对从设计中的一个信号到另一个信号的时序更感兴趣，而不是对可能不存在的情况进行建立和保持检查。因此，大多数检查可能是点对点时序检查，或偏斜 STA 检查。用于分析耦合引起的毛刺的噪声分析适用于任何设计——异步或同步。此外，噪声分析对时序的影响，包括耦合的影响，也适用于异步设计。</p>
<h2 id="不同设计阶段的sta">不同设计阶段的STA</h2>
<p>​ 在逻辑级（门级，还没有物理设计），STA可以使用：</p>
<ol type="1">
<li>理想互连或基于线载模型的互连。</li>
<li>具有延迟和抖动估计值的理想时钟。</li>
</ol>
<p>​ 在物理设计阶段，除了上述模式外，STA 还可以使用：</p>
<ol type="1">
<li>互连 -——范围可以从全局布线估计、具有近似提取的真实布线或具有准确signoff提取的真实路由。</li>
<li>时钟树 -——真正的时钟树。</li>
<li>包括和不包括串扰的影响</li>
</ol>
<h2 id="静态时序分析的局限性">静态时序分析的局限性</h2>
<p>​ 虽然时序和噪声分析在分析所有可能情况下的时序问题方面做得非常出色，但最先进的技术仍然不允许 STA 完全取代仿真。 这是因为在时序验证的一些方面不能被STA 完全捕获和验证。</p>
<p>​ STA的一些局限性：</p>
<ol type="1">
<li>复位顺序：检查在异步或同步复位后，所有触发器是否复位到其所需的逻辑值。这是无法使用静态计时分析进行检查的。芯片可能无法复位。这是因为某些声明（如信号的初始值）不会被合成，只能在模拟过程中进行验证。</li>
<li>X处理：STA技术只处理逻辑0和逻辑1（或者高和低）、上升和下降的逻辑域。设计中的未知值X会导致不确定值在设计中传播，这无法通过STA进行检查。尽管STA中的噪声分析可以通过设计分析和传播 glitches，但 glitches分析和传播的范围与作为基于模拟的纳米设计时序验证一部分的X处理非常不同。</li>
<li>PLL设置：PLL配置可能未正确加载或设置。</li>
<li>异步时钟域交叉：STA不检查是否使用了正确的时钟同步器。需要其他工具来确保在存在异步时钟域交叉的地方存在正确的时钟同步器。</li>
<li>IO接口时序：可能无法仅根据STA约束指定IO接口要求。例如，设计者可以使用SDRAM仿真模型为双数据速率（Double Data Rate，DDR）接口选择详细的电路级仿真。模拟的目的是确保可以以足够的余量读取和写入存储器，而且，如果有延迟锁相环（Delay Locked Loop，DLL），可以控制DLL以便在必要时对齐信号。</li>
<li>模拟和数字块之间的接口：由于STA不处理模拟块，验证方法需要确保这两种块之间的连接正确。</li>
<li>错误路径（False paths）：静态时序分析验证通过逻辑路径的时序是否满足所有约束，如果通过逻辑路径的时序不符合要求的规范，则标记违规。在许多情况下，STA 可能会将逻辑路径标记为失败路径，即使逻辑可能永远无法通过该路径传播。当系统应用程序从不使用这样的路径或者在故障路径的敏感化期间使用相互矛盾的条件时，就会发生这种情况。这种时序路径被称为虚假路径，因为它们永远无法实现。在设计中指定适当的时序约束（包括错误路径和多周期路径约束）时，STA 结果的质量会更好。在大多数情况下，设计人员可以利用设计的固有知识并指定约束条件，以便在 STA 期间消除错误路径。</li>
<li>FIFO 指针不同步：当两个期望同步的有限状态机实际上不同步时，STA 无法检测到问题。在功能仿真期间，两个有限状态机可能始终同步并同步变化。然而，在考虑延迟之后，有限状态机中的一个可能与另一个不同步，很可能是因为一个有限状态机比另一个更早退出复位。这种情况是STA无法检测到的。</li>
<li>时钟同步逻辑：STA无法检测时钟生成逻辑与时钟定义不匹配的问题。 STA 假设时钟发生器将提供时钟定义中指定的波形。可能对时钟发生器逻辑执行了错误的优化，例如导致在其中一条可能没有受到适当的约束路径上插入大延迟。或者，添加的逻辑可能会改变时钟的占空比。 STA 无法检测到这些潜在条件中的任何一个。</li>
<li>跨时钟周期的功能行为：静态时序分析无法建模或模拟跨时钟周期变化的功能行为。</li>
</ol>
<p>​ 尽管存在这些问题，STA 被广泛用于验证设计的时序，并且带有时序或带有单位延迟的仿真用于检查极端情况的备份，更简单地用于验证设计的正常功能模式。</p>
<h2 id="功率考虑">功率考虑</h2>
<p>​ 功耗是设计实施中的一个重要考虑因素。大多数设计需要在电路板和系统的功率预算内运行。由于符合标准和/或由于芯片必须在其中运行的电路板或系统上的热预算，也可能引起功率考虑。总功率和待机功率通常有单独的限制。待机功率限制通常适用于手持设备或电池供电设备。</p>
<p>​ 在大多数实际设计中，功率和时序通常是齐头并进的。设计人员希望使用更快（或更高速度）的单元来满足速度考虑，但可能会遇到可用功耗的限制。在为设计选择工艺技术和单元库时，功耗是一个重要的考虑因素。</p>
<h2 id="可靠性考虑">可靠性考虑</h2>
<p>​ 设计实现必须满足可靠性要求。如第 1.4.1 节所述，金属互连走线具有限制设计性能的寄生 RC。除了寄生效应之外，还需要设计金属走线宽度，同时考虑可靠性因素。例如，高速时钟信号需要足够宽才能满足可靠性考虑，例如电迁移。</p>
<h2 id="书的大纲">书的大纲</h2>
<p>​ 虽然静态时序分析从表面上看可能是一个非常简单的概念，但这种分析背后有很多背景知识。基本概念范围从单元延迟的准确表示到以最小的悲观计算最坏的路径延迟。计算单元延迟、组合块计时、时钟关系、多个时钟域和门控时钟的概念构成了静态时序分析的重要基础。为设计编写正确的 SDC 确实是一个挑战。</p>
<p>​ 这本书是按照自下而上的顺序编写的——首先介绍简单的概念，然后在后面的章节中介绍更高级的主题。本书首先介绍了准确的单元延迟（第 3 章）。以有效的方式估计或计算精确的互连延迟及其表示是第 4 章的主题。计算由单元和互连组成的路径的延迟是第 5 章的主题。信号完整性，即信号切换对相邻网络的影响以及它如何影响沿路径的延迟，是第 6 章的主题。准确地表示具有时钟定义和路径异常的 DUA 环境是第 7 章的主题。STA 中执行的时序检查的详细信息在第 6 章中描述8. 跨各种接口的 IO 时序建模是第 9 章的主题。最后，第 10 章详细介绍高级时序检查，例如片上变化、时钟门控检查、电源管理和统计时序分析。附录提供了 <strong>SDC（用于表示时序约束）、SDF（用于表示单元和网络的延迟）和 SPEF（用于表示寄生）</strong>的详细描述。</p>
<p>​ 第 7 章到第 10 章提供了 STA 验证的核心。前面的章节为更好地理解STA所需的nuts<br>
and bolts 知识提供了坚实的基础和详细描述。</p>
<h1 id="sta概念">STA概念</h1>
<blockquote>
<p>介绍 CMOS 逻辑的基础知识以及与静态时序分析相关的时序术语。</p>
</blockquote>
<h2 id="cmos-逻辑设计">CMOS 逻辑设计</h2>
<h3 id="mos基本结构">MOS基本结构</h3>
<p>​ 图2.1描述了MOS晶体管（NMOS和PMOS）的物理实现。源区和漏区之间的距离是MOS晶体管的沟道长度。用于构建 MOS 晶体管的最小沟道长度通常是 CMOS 技术工艺的最小特征尺寸。例如，0.25mm 技术允许制造沟道长度为 0.25mm 或更大的 MOS 晶体管。通过缩小通道几何形状，晶体管尺寸变得更小，随后在给定区域中可以封装更多晶体管。正如我们将在本章后面看到的，这也允许设计以更快的速度运行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809140101587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="cmos-逻辑门">CMOS 逻辑门</h3>
<p>​ CMOS 逻辑门是使用 NMOS 和 PMOS 晶体管构建的。图 2-2 显示了 CMOS 反相器的示例。根据输入的状态，CMOS 反相器有两种稳定状态。当输入 A 为低电平（Vss 或逻辑 0）时，NMOS 晶体管关闭，PMOS 晶体管开启，导致输出 Z 被拉至 Vdd，即逻辑 1。当输入 A 为高电平（Vdd 或逻辑 1）时，NMOS 晶体管导通，PMOS 晶体管关闭，导致输出 Z 被拉至 Vss，即逻辑 0。在上述两种状态中的任何一种状态下，CMOS 反相器都是稳定的，并且不会从输入 A 或电源 Vdd 汲取任何电流。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809140302345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ CMOS 反相器的特性可以扩展到任何 CMOS 逻辑门。在 CMOS 逻辑门中，输出节点通过上拉结构（由 PMOS 晶体管组成）连接到 Vdd，通过下拉结构（由 NMOS 晶体管组成）连接到 Vss。例如，图 2-3 显示了一个两输入 CMOS 与非门。在本例中，上拉结构由两个并联的 PMOS 晶体管组成，下拉结构由两个串联的 NMOS 晶体管组成。</p>
<p>​ 对于任何 CMOS 逻辑门，上拉和下拉结构都是互补的。对于逻辑 0 或逻辑 1 的输入，这意味着如果上拉级打开，下拉级将关闭，同样如果上拉级关闭，下拉级将被关闭在。下拉和上拉结构由 CMOS 门实现的逻辑功能控制。例如，在CMOS与非门中，控制下拉结构的功能是“A和B”，即在A和B都为逻辑1时开启下拉。同理，控制上拉结构的函数是“not A or not B”，即在A或B逻辑-0时开启上拉。这些特性确保基于控制上拉结构的功能将输出节点逻辑拉至 Vdd。由于下拉结构是由一个互补功能控制。</p>
<p>​ 对于逻辑 0 或逻辑 1 的输入，CMOS 逻辑门在稳定状态下不会从输入或电源汲取任何电流，因为上拉和下拉结构不能同时打开 1。 CMOS 逻辑的另一个重要方面是输入仅对前一级构成容性负载。</p>
<p>​ CMOS逻辑门是一个反相门，意思是单个开关输入（上升或下降）只能引起输出反方向开关，即输出不能与开关输入同方向开关。然而，CMOS 逻辑门可以级联以组合更复杂的逻辑功能 - 反相和非反相。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809141857950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="标准单元">标准单元</h3>
<p>​ 芯片中的大多数复杂功能通常使用基本构建块设计，这些构建块实现简单的逻辑功能，例如和、或、与非、与或反转、或与反转和触发器。这些基本构建块是预先设计的，被称为标准单元（standard cells）。标准单元的功能和时序是预先表征的，可供设计人员使用。然后，设计人员可以使用标准单元作为构建块来实现所需的功能。</p>
<p>​ 前一小节中描述的 CMOS 逻辑门的关键特性适用于所有 CMOS 数字设计。所有数字 CMOS 单元都设计为在输入处于稳定逻辑状态时没有从电源汲取电流（泄漏除外）。因此，大部分功耗与设计中的活动有关，并且是由设计中 CMOS 单元输入的充电和放电引起的。</p>
<p>​ 什么是逻辑 1 或逻辑 0？在 CMOS 单元中，两个值 VIHmin 和 VILmax 定义了限值。也就是说，任何高于 VIHmin 的电压值都被视为逻辑 1，而任何低于 VILmax 的电压值都被视为逻辑 0。参见图 2-4。具有 1.2V Vdd 电源的 CMOS 0.13mm 反相器单元的典型值为 VILmax 的 0.465V 和 VIHmin 的 0.625V。 VIHmin 和 VILmax 值源自电池的直流传输特性。直流传输特性在第 6.2.3 节中有更详细的描述。</p>
<p><img src="https://img-blog.csdnimg.cn/2021080914221793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 有关 CMOS 技术的更多详细信息，请参阅参考书目中列出的相关文本之一。</p>
<h2 id="cmos-单元的建模">CMOS 单元的建模</h2>
<p>​ 如果一个单元输出引脚驱动多个扇出单元，则单元输出引脚上的总电容是它所驱动的单元的所有输入电容之和加上构成网络的所有线段的电容之和加上驱动单元的输出电容。请注意，在 CMOS 单元中，单元的输入仅呈现电容性负载。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809142409726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 2-5 显示了一个单元格 G1 驱动其他三个单元格 G2、G3 和 G4 的示例。 Cs1、Cs2、Cs3 和 Cs4 是构成网络的线段的电容值。因此：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total <span class="built_in">cap</span> (Output G1) = Cout(G1) + Cin(G2) + Cin(G3) +</span><br><span class="line">                        Cin(G4) + Cs1 + Cs2 + Cs3 + Cs4</span><br><span class="line"><span class="comment">#Cout 是单元的输出引脚电容。</span></span><br><span class="line"><span class="comment">#Cin 是单元的输入引脚电容。</span></span><br></pre></td></tr></table></figure>
<p>​ 这是当单元 G1 切换时需要充电或放电的电容，因此该总电容值会影响单元 G1 的时序。</p>
<p>​ 从时序的角度来看，我们需要对 CMOS 单元进行建模，以帮助我们分析通过单元的时序。对于每个输入引脚指定输入引脚电容。虽然大多数 CMOS 逻辑单元不包括输出引脚的引脚电容，但也可能存在输出引脚电容。</p>
<p>​ 当输出为逻辑 1 时，输出级的上拉结构开启，并提供从输出到 Vdd 的路径。类似地，当输出为逻辑 0 时，输出级的下拉结构提供了从输出到 Vss 的路径。当 CMOS 单元切换状态时，切换速度取决于输出网络上的电容充电或放电的速度。输出网络上的电容（图 2-5）分别通过上拉和下拉结构充电和放电。请注意，上拉和下拉结构中的通道对输出充电和放电路径构成电阻。充电和放电路径电阻是决定 CMOS 单元速度的主要因素。上拉电阻的倒数称为电池的输出高驱动。输出上拉结构越大，上拉电阻越小，单元的输出高驱动越大。更大的输出结构也意味着单元的面积更大。输出上拉结构越小，单元面积越小，其输出高驱动也越小。上拉结构的相同概念可以应用于决定下拉路径电阻和输出低电平驱动的下拉结构。通常，单元被设计为具有相似的驱动强度（大或小）用于上拉和下拉结构。</p>
<p>​ 输出驱动决定了可以驱动的最大容性负载。最大容性负载决定了扇出的最大数量，即它可以驱动多少个其他单元。较高的输出驱动对应于较低的输出上拉和下拉电阻，这允许电池在输出引脚上对较高的负载进行充电和放电。</p>
<p>​ 图 2-6 显示了 CMOS 单元的等效抽象模型。该模型的目标是抽象单元的时序行为，因此仅对输入和输出阶段进行建模。该模型不捕获单元固有延迟或电气行为。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809143255936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ CpinA 是输入 A 上单元的输入引脚电容。 Rdh 和 Rdl 是单元的输出驱动电阻，并根据单元驱动的负载确定输出引脚 Z 的上升和下降时间。该驱动器还决定了单元的最大扇出限制。</p>
<p>​ 图 2-7 显示了与图 2-5 相同的网络，但具有等效的单元模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809143413771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cwire = Cs1 + Cs2 + Cs3 + Cs4</span><br><span class="line">Output charging delay (<span class="name">for</span> high or low) =</span><br><span class="line">                    Rout * (<span class="name">Cwire</span> + Cin2 +Cin3 + Cin4)</span><br></pre></td></tr></table></figure>
<p>​ 在上面的表达式中，Rout 是 Rdh 或 Rdl 之一，其中 Rdh 是上拉的输出驱动电阻，Rdl 是下拉的输出驱动电阻。</p>
<h2 id="开关波形">开关波形</h2>
<p>​ 当通过激活 SW0 开关将电压施加到 RC 网络时，如图 2-8(a) 所示，输出变为逻辑 1。假设 SW0 激活时输出为 0V，输出端的电压转换由以下等式描述：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?V%20%3D%20Vdd%20*%20%5B1%20-%20e%5E%7B%20-t/%28Rdh%20*%20Cload%29%7D%20%5D"></p>
<p>​ 这种上升的电压波形如图 2-8(b) 所示。乘积 (Rdh * Cload) 称为 RC 时间常数 - 通常这也与输出的转换时间有关。</p>
<p>​ 当输出从逻辑 1 变为逻辑 0 时，由于输入变化导致 SW0 断开连接并激活 SW1，输出转换如图 2-8(c) 所示。输出电容通过打开的 SW1 开关放电。这种情况下的电压转换由以下等式描述：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?V%20%3D%20Vdd%20*%20e%5E%7B-t/%28Rdl%20*%20Cload%29%7D"></p>
<p><img src="https://img-blog.csdnimg.cn/2021081012103514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在 CMOS 单元中，输出端充电和放电波形与图 2-8 中的 RC 充电和放电波形不同，因为 PMOS 上拉和 NMOS 下拉晶体管在短时间内同时导通。图 2-9 显示了 CMOS 反相器单元内输出从逻辑 1 切换到逻辑 0 的各个阶段的电流路径。图 2-9(a) 显示了上拉和下拉结构都打开时的电流。 之后，上拉结构关闭，电流如图 2-9(b) 所示。输出达到最终状态后，由于电容 Cload 已完全放电，因此没有电流流动。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810121919332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 2-10(a) 显示了 CMOS 单元输出端的代表性波形。请注意过渡波形如何逐渐向 Vss 轨道和 Vdd 轨道弯曲，波形的线性部分位于中间。</p>
<p>​ 在本文中，我们将使用如图 2-10(b) 所示的简单绘图来描绘一些波形。它显示了具有一些转换时间的波形，即从一种逻辑状态转换到另一种逻辑状态所需的时间。图2-10(c)示出了使用0跃迁时间的相同波形，即理想波形。我们将在本文中交替使用这两种形式来解释这些概念，但实际上，每个波形都有其真实的边缘特征，如图 2-10(a) 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810122118721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="传播延迟propagation-delay">传播延迟（Propagation Delay）</h2>
<p>​ 考虑一个 CMOS 反相器单元及其输入和输出波形。单元的<strong>传播延迟</strong>是根据开关波形上的一些测量点定义的。这些点是使用以下四个变量定义的：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入下降沿的阈值点：</span></span><br><span class="line">input_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"><span class="comment"># 输入上升沿的阈值点：</span></span><br><span class="line">input_threshold_pct_rise : <span class="number">50.0</span>;</span><br><span class="line"><span class="comment"># 输出下降沿的阈值点：</span></span><br><span class="line">output_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"><span class="comment"># 输出上升沿的阈值点：</span></span><br><span class="line">output_threshold_pct_rise : <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这些变量是用于描述单元库的命令集的一部分（该命令集在 Liberty中进行了描述）。这些阈值规格以 Vdd 或电源的百分比表示。大多数标准单元库的延迟测量通常使用 50% 阈值。</p>
<p>​ 上升沿是从逻辑 0 到逻辑 1 的过渡。下降沿是从逻辑 1 到逻辑 0 的转变。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810123207592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以图 2-11 逆变器单元及其引脚处的波形示例。传播延迟表示为：</p>
<ol type="1">
<li>输出下降延迟 (Tf)</li>
<li>输出上升延迟 (Tr)</li>
</ol>
<p>​ 一般来说，这两个值是不同的。图 2-11 显示了如何测量这两个传播延迟。</p>
<p>​ 如果我们查看理想波形，传播延迟就是两个边沿之间的延迟。如图 2-12 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081012340583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="波形转换slew-of-a-waveform">波形转换（Slew of a Waveform）</h2>
<p>​ 转换速率（ slew rate ）被定义为变化速率。在静态时序分析中，根据过渡（transition）是慢还是快来测量上升或下降的波形。转换（slew）通常用<strong>转换时间（transition time）</strong>来衡量，即信号在两个特定电平之间转换所花费的时间。请注意，转换时间实际上与转换速率成反比——转换时间越大，转换速度越慢，反之亦然。图2-10显示了CMOS单元输出的典型波形。在两端的波形是渐近的，很难确定准确的开始和结束的过渡点。因此，转换时间是根据特定的阈值水平来定义的。例如， 转换阈值设置可以是:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Falling edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">70.0</span>;</span><br><span class="line"></span><br><span class="line"># Rising edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">70.0</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这些值被指定为Vdd的百分比。<strong>阈值设置（threshold settings）</strong>指定下降的反转为下降沿达到Vdd的70%和30%的时间差。同样地，<strong>上升设置</strong>指定上升幅度是上升边达到Vdd的30%和70%的时间差。如图2-13所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810124746610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个例子如图2-14显示，下降边的转换（slew）测量为20-80(80%到20%)，上升边测量为10-90(10%到90%)。这里是本例的阈值设置。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810125014894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Falling edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">20.0</span>;</span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line"># Rising edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">10.0</span>;</span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">90.0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="信号之间的偏差skew-between-signals">信号之间的偏差（Skew between Signals）</h2>
<p>​ <strong>偏差（skew）</strong>是两个或多个信号（可能是数据、时钟或两者）之间的时间差。例如，如果一个时钟树有500个端点，偏移量为50ps，则表示最长路径和最短时钟路径之间的延迟差为50ps。图2-15显示了时钟树的示例。时钟树的起点通常是定义时钟的节点。时钟树的端点通常是同步元件（如触发器 flip-flops）的时钟引脚。<strong>时钟延迟（ Clock latency）</strong>是从时钟源到终点所花费的总时间。<strong>时钟偏移（Clock skew）</strong>是时钟树端点处到达时间的差异。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810130309549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个理想的时钟树是一个假设时钟源具有无限驱动的树，也就是说，时钟可以无延迟地驱动无限源。此外，假设时钟树中存在的任何单元具有零延迟。</p>
<p>​ 在逻辑设计的早期阶段，STA通常使用理想的时钟树执行，因此分析的重点是数据路径。在理想的时钟树中，时钟偏移默认为0ps。可以使用<strong>set_clock_Latency</strong>命令显式指定时钟树的延迟。以下示例对时钟树的延迟进行建模：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_clock_latency <span class="number">2.2</span> [get_clocks BZCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Both rise and fall latency is 2.2ns.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use options -rise and -fall if different.</span></span><br></pre></td></tr></table></figure>
<p>​ 时钟树的时钟偏移也可以通过使用set_Clock_INDUCTION命令显式指定其值来表示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_clock_uncertainty <span class="number">0.250</span> -setup <span class="selector-attr">[get_clocks BZCLK]</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty <span class="number">0.100</span> -hold <span class="selector-attr">[get_clocks BZCLK]</span></span><br></pre></td></tr></table></figure>
<p>​ <strong>set_clock_uncertainty</strong>指定一个窗口，在该窗口内可以出现时钟边沿。时钟边沿时序的不确定性，是为了考虑几个因素，例如时钟周期抖动（ clock period jitter ）和用于时序验证的附加裕度（additional margins）。每一个真实的时钟源都有一个有限的抖动——一个时钟边沿可以出现的窗口。clock period jitter由所使用的时钟发生器的类型决定。实际上，没有理想的时钟，也就是说，所有时钟都有有限的抖动，在指定时钟不确定性时，应包括时钟周期抖动。</p>
<p>​ 在实现时钟树之前，时钟不确定性还必须包括实现的预期时钟偏差。</p>
<p>​ 可以为建立检查（ setup checks ）和保持检查（hold checks）指定不同的时钟不确定性。保持检查不需要将时钟抖动包含在不确定性中，因此通常为hold指定较小的时钟不确定性值。</p>
<p>​ 图 2-16 显示了设置不确定性为 250ps 的时钟示例。图 2-16(b) 显示在传播到下一个触发器阶段的逻辑的时间中，如何去除不确定性。这相当于验证设计以更高的频率运行。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081013300295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上所述，<strong>set_clock_uncertainty</strong> 还可用于对任何附加裕度（additional margins）进行建模。例如，设计人员可能会在设计过程中使用 50ps 的时序余量作为额外坏情况的考虑（additional pessimism）。该组件可以添加并包含在 <strong>set_clock_uncertainty</strong> 命令中。通常，在实现时钟树之前，<strong>set_clock_uncertainty</strong> 命令用于指定一个值，该值包括时钟抖动加上估计的时钟偏斜加上额外坏情况的考虑（additional pessimism）。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_clock_latency <span class="number">2.0</span> [get_clocks USBCLK]</span><br><span class="line"></span><br><span class="line">set_clock_uncertainty <span class="number">0.2</span> [get_clocks USBCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The 200ps may be composed of 50ps clock jitter,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 100ps clock skew and 50ps additional pessimism.</span></span><br></pre></td></tr></table></figure>
<p>​ 稍后我们将看到 <strong>set_clock_uncertainty</strong> 如何影响建立和保持检查。最好将时钟不确定性视为最终<strong>偏斜（slack）</strong>计算的偏移量。</p>
<h2 id="时序弧timing-arcs-and-unateness">时序弧（Timing Arcs and Unateness）</h2>
<p>​ 每个cell都有多个时序弧。例如，组合逻辑单元（如and、or、nand、nor 、adder单元）从单元的每个输入到每个输出具有时序弧。顺序单元（如触发器flip-flops ）具有从时钟到输出的时序弧，和关于时钟的数据管脚的时序约束。每个时序弧都有一个时序感测（timing sense），即输入上不同类型的转换如何改变输出。如果输入上的上升过渡导致输出上升（或不改变），而输入上的下降过渡导致输出下降（或不改变），则为<strong>正时序弧（positive unate）</strong>。例如，and和or类型单元格的计时弧为正。见图2-17（a）。</p>
<p>​ <strong>负时序弧（negative unate）</strong>是指，输入上的上升过渡导致输出有下降过渡（或不改变）和在输入上的下降过渡，使输出具有上升过渡（或不改变）。例如，nand和nor类型单元的时序弧为负。见图2-17（b）。</p>
<p>​ 在<strong>non-unate时序弧</strong>中，输出转换不能仅从输入的变化方向确定，还取决于其他输入的状态。例如，异或（xor）单元（异或）中的时序弧是<strong>non-unate</strong>的。1见图2-17（c）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810135249557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ <strong>Unateness</strong> 对于时序非常重要，因为它指定了边沿（过渡transitions）如何在单元格中传播以及它们如何在单元格的输出中显示。</p>
<p>​ 人们可以利用时序弧的<strong>non-unateness</strong>性，例如当使用异或<strong>（xor ）</strong>单元时，翻转时钟的极性。参见图2-18中的示例。如果输入<strong>POLCTRL</strong>为逻辑-0，则单元<strong>UXOR0</strong>输出上的时钟<strong>DDRCLK</strong>与输入时钟<strong>MEMCLK</strong>具有相同的极性。如果<strong>POLCTRL</strong>是逻辑1，则单元<strong>UXOR0</strong>输出上的时钟与输入时钟<strong>MEMCLK</strong>的极性相反。</p>
<p>​</p>
<p><img src="https://img-blog.csdnimg.cn/20210810140906591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="最小和最大时序路径min-and-max-timing-paths">最小和最大时序路径（Min and Max Timing Paths）</h2>
<p>​ 逻辑通过逻辑路径传播的总延迟称为<strong>路径延迟（path delay）</strong>。这相当于通过路径上各种逻辑单元和网络的延迟之和。通常，逻辑可以通过多条路径传播到所需的目标点。实际路径取决于逻辑路径上其他输入的状态。如图 2-19 示例。由于到达目的地的路径有多条，因此可以得到到达目的点的最大时间和最小时间。最大时间和最小时间对应的路径分别称为最大路径和最小路径。两个端点之间的最大路径是具有最大延迟的路径（也称为最长路径）。同样地，最小路径是延迟最小的路径（也称为最短路径）。</p>
<p>​ 数据路径示例如图2-19所示。UFF1和UFF3之间的最大路径假定是通过UNAND0、UBUF2、UOR2和UNAND6单元的路径。UFF1和UFF3之间的最小路径被认为是通过UOR4和UNAND6单元的路径。注意，在这个例子中，最大值和最小值是与目的点(即触发器UFF3的D引脚)相关的。</p>
<p>​ 最大路径通常被称为<strong>late path</strong>，而最小路径通常被称为<strong>early path</strong>。</p>
<p>​ 当考虑从UFF1到UFF3等触发器到触发器路径时，其中一个触发器启动数据，另一个触发器捕获数据。在本例中，由于UFF1启动数据，因此UFF1被称为启动触发器。因为UFF3捕获数据，所以UFF3被称为捕获触发器。请注意，启动和捕获术语总是与触发器到触发器路径有关。例如，UFF3将成为通往捕获UFF3产生的数据的触发器路径的启动触发器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810142219455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="时钟域clock-domains">时钟域（Clock Domains）</h2>
<p>​ 在同步逻辑设计中，一个周期时钟信号锁存计算到触发器中的新数据。新的数据输入是基于前一个时钟周期的触发器值。因此，锁存数据用于计算下一个时钟周期的数据。</p>
<p>​ 一个时钟通常为多个触发器服务。由一个时钟服务的一组触发器称为其时钟域。在典型设计中，可能存在多个时钟域。例如，200个触发器可以由USBCLK计时，1000个触发器可以由时钟MEMCLK馈送。图2-20描述了触发器和时钟。在本例中，我们说有两个时钟域。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810144453255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个令人感兴趣的问题是时钟域是彼此相关还是相互独立。答案取决于是否存在从一个时钟域开始并在另一个时钟域结束的任何数据路径。如果没有这样的路径，我们可以安全地说这两个时钟域是彼此独立的。这意味着没有从一个时钟域开始并在另一个时钟域结束的定时路径。</p>
<p>​ 如果确实存在跨越时钟域的数据路径(参见图2-21)，则必须决定这些路径是否是真实的。真实路径的一个例子是，具有2倍速度时钟的触发器驱动到具有1倍速度时钟的触发器中。错误路径的一个例子是，设计者明确地将时钟同步器逻辑放置在两个时钟域之间。在这种情况下，即使看起来存在从一个时钟域到下一个时钟域的时序路径，它也不是真正的时序路径，因为数据不受限制在一个时钟周期内通过同步器逻辑传播。这样的路径被称为假路径(不是真实路径)，因为时钟同步器确保数据正确地从一个域传递到下一个域。可以使用<strong>set_false_path</strong>规范指定时钟域之间的假路径，例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks USBCLK]</span></span><br><span class="line"></span><br><span class="line">-<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks MEMCLK]</span></span><br><span class="line"></span><br><span class="line"># This specification is explained in more detail in Chapter <span class="number">8</span>.</span><br></pre></td></tr></table></figure>
<p>​ 即使未在图2-21中描述，时钟域交叉也可能以两种方式发生，即从USBCLK时钟域到MEMCLK时钟域，以及从MEMCLK时钟域到USBCLK时钟域。这两种情况都需要在STA中正确理解和处理。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081014483352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 讨论时钟域之间路径的原因是什么？通常，一种设计具有大量时钟，并且在时钟域之间可以有无数条路径。识别哪些时钟域交叉是真实的，哪些时钟交叉不是真实的是时序验证工作的一个重要部分。这使设计人员能够专注于仅验证真正时序路径。</p>
<p>​ 图2-22显示了时钟域的另一个示例。多路复用器选择一个时钟源——它是一个或另一个，取决于设计的操作模式。只有一个时钟域，但有两个时钟，这两个时钟被认为是互斥的，因为一次只有一个时钟是活动的。因此，在该示例中，重要的是要注意，USBCLK和USBCLKx2的两个时钟域之间永远不可能存在路径（假设多路复用器控制是静态的，并且这种路径在设计中的其他地方不存在）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810150540411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="操作条件operating-conditions">操作条件（Operating Conditions）</h2>
<p>​ 静态定时分析通常在特定操作条件下执行*****。操作条件定义为工艺、电压和温度（<strong>Process, Voltage and Temperature PVT）</strong>的组合。单元延迟和互连延迟是根据指定的操作条件计算的。</p>
<p>******STA 可以在具有不同电压的单元的设计上执行。稍后我们将看到这些是如何处理的。 STA 也可以统计执行，这在第 10 章中描述。*</p>
<p>​ 半导体代工厂为数字设计提供了三种制造工艺模型：慢工艺模型、典型工艺模型和快速工艺模型。慢速和快速工艺模型代表了铸造厂制造过程的极端角落。对于稳健设计，该设计在制造过程的极端角落以及温度和电源的极端环境中得到验证。图 2-23(a) 显示了cell delays如何随工艺角变化。图 2-23(b) 显示cell delays如何随电源电压变化，图 2-23(c) 显示cell delays如何随温度变化。因此，决定用于各种静态时序分析的工作条件非常重要。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810151148148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ STA 使用何种操作条件的选择还取决于单元库可用的操作条件。三个标准操作条件是：</p>
<ol type="1">
<li>WCS（Worst-Case Slow）：过程（process）缓慢，温度（temperature）最高（比如 125C），电压（voltage）最低（比如标称 1.2V 减 10%）。对于使用低电源的纳米技术，可能还有另一个最坏情况的慢角，对应于慢工艺、最低电源和最低温度。低温下的延迟并不总是小于高温下的延时 。这是因为纳米技术降低了与电源相关的设备阈值电压（Vt）裕度。在这种情况下，在低电源条件下，轻负载电池在低温下的延迟高于高温下的延迟。对于高Vt（更高的阈值，更大的延迟）或甚至是标准Vt（常规阈值，更低的延迟）小区来说尤其如此。这种延迟在较低温度下增加的反常行为称为温度反转。见图2-23（c）。</li>
<li>TYP (Typical)：过程（process）是典型的，温度（temperature）是标称的（比如25C），电压（voltage）是标称的（比如1.2V）。</li>
<li>BCF（Best-Case Fast）：过程（process）快速，温度（temperature）最低（比如-40℃），电压（voltage）最高（比如标称1.2V加10%）。</li>
</ol>
<p>​ 功率分析的环境条件通常与静态定时分析的环境条件不同。对于功率分析，工作条件可能为：</p>
<ol type="1">
<li>ML (Maximal Leakage)：过程很快，温度最高（比如125C），电压也最高（比如1.2V加10%）。该角对应于最大泄漏功率。对于大多数设计，此角也对应于最大有功功率。</li>
<li>TL (Typical Leakage)：过程是典型的，温度最高（比如125C），电压为标称值（比如1.2V）。这是指大多数设计中泄漏具有代表性的情况，因为在正常操作中，由于功率损耗，芯片温度会更高。</li>
</ol>
<p>​ 静态定时分析基于为STA加载和链接的库。可以使用<strong>set_operating_conditions</strong>命令明确指定设计的操作条件。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_operating_conditions “WCCOM” -library mychip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the operating condition called WCCOM defined in the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cell library mychip.</span></span><br></pre></td></tr></table></figure>
<p>​ 单元库在各种操作条件下可用，选择用于分析的操作条件取决于为STA加载的内容。</p>
<h1 id="标准单元库standard-cell-library">标准单元库（Standard Cell Library）</h1>
<blockquote>
<p>​ 描述了常用库单元描述中的时序相关信息。本章仅关注与时序、串扰和功率分析相关的属性，尽管库单元包含多个属性。纳米技术中对时序的主要影响是互连。</p>
</blockquote>
<p>​ 除了时序信息外，库单元描述还包含几个属性（attributes），如单元面积和功能，这些属性与时序无关，但在RTL合成过程中相关。在本章中，我们只关注与时序和功率计算相关的属性（attributes）。</p>
<p>​ 可以使用各种标准格式来描述库单元。虽然各种格式的内容基本相似，但我们已经使用Liberty语法描述了库单元示例。</p>
<p>​ 本章的开始部分描述了线性和非线性时序模型（linear and the non-linear timing models ），然后是第3.7节描述的纳米技术的高级时序模型。</p>
<h2 id="引脚电容pin-capacitance">引脚电容（Pin Capacitance）</h2>
<p>​ 单元的每个输入和输出都可以指定引脚处的电容。在大多数情况下，电容仅针对单元输入而不是输出指定，即大多数单元库中的输出引脚电容为 0。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pin (INP1) &#123;</span><br><span class="line"></span><br><span class="line">capacitance: <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">rise_capacitance: <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">rise_capacitance_range: (<span class="number">0.48</span>, <span class="number">0.52</span>);</span><br><span class="line"></span><br><span class="line">fall_capacitance: <span class="number">0.45</span>;</span><br><span class="line"></span><br><span class="line">fall_capacitance_range: (<span class="number">0.435</span>, <span class="number">0.46</span>);</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上面的示例显示了输入 <strong>INP1</strong> 的引脚电容值的一般规范。在最基本的形式中，引脚电容被指定为单个值（在上例中为 0.5 个单位）。 （电容单位通常是皮法，并在库文件的开头指定）。单元描述还可以为<strong>rise_capacitance</strong>（0.5 个单位）和<strong>fall_capacitance</strong>（0.45 个单位）指定单独的值，它们指的是用于引脚INP1 上的上升和下降转换的值。也可以将<strong>rise_capacitance</strong> 和<strong>fall_capacitance</strong> 值指定为一个范围，并在说明中指定下限和上限值。</p>
<h2 id="时序建模timing-modeling">时序建模（Timing Modeling）</h2>
<p>​ 单元时序模型旨在为设计环境中单元的各种实例提供准确的时序。时序模型通常是从单元的详细电路模拟中获得，以模拟单元运行的实际场景。为单元的每个时序弧指定时序模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810161210759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 让我们首先考虑一个简单的逆变器逻辑单元的时序弧，如图3-1所示，因为它是一个逆变器，在输入端的上升（下降）转变导致输出处的下降（上升）转变。单元的两种延迟特性是：</p>
<ol type="1">
<li>Tr：输出上升延迟</li>
<li>Tf：输出下降延迟</li>
</ol>
<p>​ 请注意，延迟是基于单元库中定义的阈值点来测量的（参见第2.4节），通常为50%Vdd。因此，从输入超过其阈值点到输出超过其阈值点，测量延迟。</p>
<p>​ 通过逆变器单元的时序电弧延迟取决于两个因素：</p>
<ol type="1">
<li>输出负载（output load），即逆变器输出引脚的电容负载。</li>
<li>输入端信号的转换时间（transition time）。</li>
</ol>
<p>​ 延迟值与负载电容直接相关——负载电容越大，延迟越大。在大多数情况下，延迟随着输入转换时间的增加而增加。在某些情况下，输入阈值（用于测量延迟）与单元的内部开关点有显着差异。在这种情况下，通过单元的延迟可能会表现出相对于输入转换时间的非单调行为 - 较大的输入转换时间可能会产生较小的延迟，尤其是在输出负载较轻的情况下。</p>
<p>​ 单元输出的转换（slew）主要取决于输出电容——输出转换时间随着输出负载的增加而增加。因此，根据单元类型及其输出负载，输入处的大转换（大转换时间）可以改善输出处。图 3-2 显示了单元输出的转换时间可以根据单元输出的负载而改善或恶化的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810162357165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="线性时序模型linear-timing-model">线性时序模型（Linear Timing Model）</h3>
<p>​ 一个简单的时序模型是线性延迟模型，其中单元的延迟和输出转换时间表示为两个参数的线性函数：<strong>输入转换时间和输出负载电容</strong>。通过单元的延迟 D 的线性模型的一般形式如下所示。</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?D%20%3D%20D0%20+%20D1%20*%20S%20+%20D2%20*%20C"></p>
<p>​ 其中 D0、D1、D2 是常数，S 是输入转换时间，C 是输出负载电容。线性延迟模型在亚微米技术的输入转换时间和输出电容范围内不准确因此，大多数单元库目前使用更复杂的模型，例如非线性延迟模型。</p>
<h3 id="非线性延迟模型non-linear-delay-model">非线性延迟模型（Non-Linear Delay Model）</h3>
<p>​ 大多数单元库都包含表（table）模型，用于指定单元的各种时序弧的延迟和时序检查。一些用于纳米技术的较新的时序库还提供了基于电流源的高级时序模型（例如 CCS、ECSM 等），本章稍后将对其进行介绍。table型称为 NLDM（非线性延迟模型），用于延迟、输出转换或其他时序检查。</p>
<p>​ table模型捕获了通过单元输入引脚的输入转换时间和单元输出的总输出电容的各种组合的延迟。</p>
<p>​ 延迟的 NLDM 模型以二维形式呈现，两个独立变量是<strong>输入转换时间（</strong>nput transition time <strong>）</strong>和<strong>输出负载电容</strong>（output load capacitance），table中的条目表示延迟。以下是典型逆变器单元的此类table示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pin (<span class="variable constant_">OUT</span>) &#123;</span><br><span class="line"></span><br><span class="line">max_transition : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;INP1&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_rise</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values (  <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0513, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.1018, 0.2327, 0.6476&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1334, 0.2973, 0.7252&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values (  <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0617, 0.1537,  0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.0918, 0.2027,  0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1034, 0.2273,  0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在上面的示例中，描述了输出引脚 <strong>OUT</strong> 的延迟。单元描述的这一部分包含从引脚 INP1 到引脚 OUT 的时序弧的上升和下降延迟模型，以及引脚 OUT 上的 <strong>max_transition</strong> 允许时间。上升和下降延迟（对于输出引脚）有单独的模型，它们分别标记为 <strong>cell_rise</strong> 和 <strong>cell_fall</strong>。索引的类型和表查找索引的顺序在查找表模板 <strong>delay_template_3x3</strong> 中描述。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lu_table_template</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">variable_1 : input_net_transition;</span><br><span class="line"></span><br><span class="line">variable_2 : total_output_net_capacitance;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入转换和输出电容可以是任意顺序，即variable_1可以是输出电容。但是，这些名称在库中的所有模板中通常是一致的。 */</span></span><br></pre></td></tr></table></figure>
<p>​ 此查找表模板指定表中的第一个变量是输入转换时间，第二个变量是输出电容。表值像嵌套循环一样指定，其中第一个索引 (<strong>index_1</strong>) 是外部（或变化最小）变量，第二个索引 (<strong>index_2</strong>) 是内部（或变化最大）变量，依此类推。每个变量有三个条目，因此它对应于一个 3×3 表。在大多数情况下，表的条目也像表一样格式化，然后可以将第一个索引 (<strong>index_1</strong>) 视为行索引，而第二个索引 (<strong>index_2</strong>) 变得等效于列索引。索引值（例如 1000）是虚拟占位符，它们被 <strong>cell_fall</strong> 和 <strong>cell_rise</strong> 延迟表中的实际索引值覆盖。指定索引值的另一种方法是在模板定义中指定索引值，而不是在 <strong>cell_rise</strong> 和 <strong>cell_fall</strong> 表中指定它们。这样的模板看起来像这样：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lu_table_template</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">variable_1 : input_net_transition;</span><br><span class="line"></span><br><span class="line">variable_2 : total_output_net_capacitance;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>&quot;);</span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.16</span>, <span class="number">0.35</span>, <span class="number">1.43</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 根据延迟表，0.3ns 的输入下降转换时间和 0.16pf 的输出负载将对应于 0.1018ns 的反相器上升延迟。由于输入端的下降跃迁导致逆变器输出上升，上升延迟的表查找涉及反相器输入处的下降转换。</p>
<p>​ 这种在表格中将延迟表示为两个变量（转换时间和电容）的函数的形式称为非线性延迟模型，因为延迟随输入转换时间和负载电容的非线性变化在此类表中表示。</p>
<p>​ 表模型也可以是 3 维的——一个例子是具有互补输出 Q 和 QN 的触发器，这在第 3.8 节中进行了描述。</p>
<p>​ NLDM 模型不仅用于延迟，还用于单元输出的转换时间，其特征在于输入转换时间和输出负载。因此，有单独的二维表用于计算单元的输出上升和下降转换时间。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pin (<span class="variable constant_">OUT</span>) &#123;</span><br><span class="line"></span><br><span class="line">max_transition : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;INP&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.1 */</span> <span class="string">&quot;0.0417, 0.1337, 0.4680&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.3 */</span> <span class="string">&quot;0.0718, 0.1827, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.7 */</span> <span class="string">&quot;0.1034, 0.2173, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0817, 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.1018, 0.2327, 0.7676&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1334, 0.2973, 0.8452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 有两个这样的过渡时间表：rise_transition 和fall_transition。如第 2 章所述，转换时间是根据特定的转换阈值测量的，通常是电源的 10%-90%。</p>
<p>​ 如上所示，具有 NLDM 模型的逆变器单元具有下表：</p>
<ul>
<li>Rise delay</li>
<li>Fall delay</li>
<li>Rise transition</li>
<li>Fall transition</li>
</ul>
<p>​ 给定这种单元的输入转换时间和输出电容，如图 3-3 所示，从 cell_rise 表中获得 15ps 输入转换时间（下降）和 10fF 负载的上升延迟，从20ps 输入转换时间（上升）和 10fF 负载的 cell_fall 表。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810185804406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 指定单元正在反转的信息在哪里？该信息被指定为时序弧的<strong>timing_sense</strong> 字段的一部分。在某些情况下，此字段未指定，但应从引脚功能派生。</p>
<p>​ 对于示例反相器单元，时序弧为<strong>negative_unate</strong>，这意味着输出引脚转换方向与输入引脚转换方向相反（负）。因此，cell_rise 表查找对应于输入引脚的下降转换时间。</p>
<h4 id="非线性延迟模型查找示例example-of-non-linear-delay-model-lookup">非线性延迟模型查找示例（Example of Non-Linear Delay Model Lookup）</h4>
<p>​ 本节通过示例说明表模型的查找。如果输入转换时间和输出电容对应于表条目，则表查找是微不足道的，因为时序值直接对应于表中的值。下面的示例对应于查找不对应于表中任何可用条目的一般情况。在这种情况下，使用二维内插来提供结果时序值。为表插值选择每个维度中两个最近的表索引。考虑输入转换时间为 0.15ns 和输出电容为 1.16pF 的下降转换表（上面指定的示例表）。下面再现了与二维插值相关的下降过渡表的相应部分。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3 . . .&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;. . . 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;. . . 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;. . . 0.2327, 0.7676&quot;</span></span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>​ 在下面的公式中，两个 index_1 值表示为 x1 和 x2；两个index_2值分别记为y1和y2，对应的表值分别记为T11、T12、T21和T22。</p>
<p>如果 (x0, y0) 需要查表，则通过插值获得查找值 T00，由下式给出：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?T00%3D%20x20*%20y20*%20T11+%20x20*%20y01*%20T12+%20x01*%20y20*%20T21+%20x01*%20y01*%20T22"></p>
<p>这里</p>
<p>x01= (x0- x1) / (x2- x1)<br>
x20= (x2- x0) / (x2- x1)<br>
y01= (y0- y1) / (y2- y1)<br>
y20= (y2- y0) / (y2- y1)</p>
<p>​ 用 0.15 代替 index_1 和 1.16 代替 index_2 导致 fall_transition 值：</p>
<p>T00= 0.75 * 0.25 * 0.1937 + 0.75 * 0.75 * 0.7280 +<br>
0.25 * 0.25 * 0.2327 + 0.25 * 0.75 * 0.7676 = 0.6043</p>
<p>​ 请注意，上述等式对于内插和外推均有效 - 即当指数 (x0, y0) 位于指数的特征范围之外时。例如，对于 index_1 为 0.05 和 index_2 为 1.7 的表查找，获得下降过渡值如下：</p>
<p>T00= 1.25 * (-0.25) * 0.1937 + 1.25 * 1.25 * 0.7280 +<br>
(-0.25) * (-0.25) * 0.2327 + (-0.25) * 1.25 * 0.7676<br>
= 0.8516</p>
<h3 id="阈值规格和转换时间降额threshold-specifications-and-slew-derating">阈值规格和转换时间降额（Threshold Specifications and Slew Derating）</h3>
<p><strong>slew（即transition time）</strong>值基于库中指定的测量阈值。大多数上一代库（0.25 毫米或更早）使用 10% 和 90% 作为压摆或转换时间的测量阈值。</p>
<p>​ 选择转换阈值以对应于波形的线性部分。随着技术变得越来越精细，实际波形最线性的部分通常在 30% 到 70% 之间。因此，大多数新一代时序库将转换测量点指定为 Vdd 的 30% 和 70%。但是，由于之前测量的转换时间在 10% 到 90% 之间，因此在填充库时测量的转换时间通常在 30% 到 70% 之间加倍。这由通常指定为 0.5 的转换降额系数指定。 30% 和 70% 的转换阈值（转换降额为 0.5）导致等效的测量点为 10% 和 90%。阈值设置示例如下所示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Threshold definitions */</span></span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">30.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">70.0</span>;</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">30.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">70.0</span>;</span><br><span class="line"></span><br><span class="line">input_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">input_threshold_pct_rise : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">output_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">output_threshold_pct_rise : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">slew_derate_from_library : <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p>​ 上述设置指定库表中的转换时间必须乘以 0.5 才能获得与转换阈值 (30-70) 设置相对应的转换时间。这意味着转换表中的值（以及相应的索引值）实际上是 10-90 个值。在表征过程中，转换是在 30-70 处测量的，库中的转换数据对应于将测量值外推到 10% 到 90% ((70 - 30)/(90 - 10) = 0.5)。</p>
<p>​ 具有一组不同转换阈值设置的另一个示例可能包含：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Threshold definitions 20/80/1 */</span></span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">20.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">20.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* slew_derate_from_library not specified */</span></span><br></pre></td></tr></table></figure>
<p>​ 在这个 20-80 转换率阈值设置的示例中，没有指定 <strong>slew_derate_from_library</strong>（暗示默认值为 1.0），这意味着库中的转换时间数据没有降额。转换表中的值直接对应于 20-80 表征的转换值。见图 3-4 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810194438619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是单元库中转换阈值设置的另一个示例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : <span class="number">20.00</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">80.00</span>;</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">20.00</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">80.00</span>;</span><br><span class="line"></span><br><span class="line">slew_derate_from_library : <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure>
<p>​ 在这种情况下，slew_derate_from_library 设置为 0.6，并且将特征转换跳变点指定为 20% 和 80%。这意味着库中的转换表数据对应于 0% 到 100% ((80 - 20)/(100 - 0) = 0.6) 外推值。如图 3-5 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810194924432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 指定slew降额时，延迟计算期间内部使用的slew值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">library_transition_time_value * slew_derate</span><br></pre></td></tr></table></figure>
<p>​ 这是延迟计算工具内部使用的转换，对应于特征转换阈值测量点。</p>
<h2 id="时序模型组合单元timing-models---combinational-cells">时序模型——组合单元（Timing Models - Combinational Cells）</h2>
<p>​ 让我们考虑两个输入和单元格的时序弧。该单元格的两个时序弧都是positive_unate；因此，输入引脚上升对应于输出上升，反之亦然。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810200940748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于二输入and单元，有四种延迟：</p>
<ul>
<li>A -&gt; Z: Output rise</li>
<li>A -&gt; Z: Output fall</li>
<li>B -&gt; Z: Output rise</li>
<li>B -&gt; Z: Output fall</li>
</ul>
<p>​ 这意味着对于 NLDM 模型，将有四个表模型用于指定延迟。类似地，也将有四个这样的表模型用于指定输出转换时间。</p>
<h3 id="延迟和转换模型delay-and-slew-models">延迟和转换模型（Delay and Slew Models）</h3>
<p>​ 一个三输入 nand 单元的输入 INP1 到输出 OUT 的时序模型示例如下所示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">pin (<span class="variable constant_">OUT</span>) &#123;</span><br><span class="line"></span><br><span class="line">max_transition : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;INP1&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_rise</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0513, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1018, 0.2327, 0.6476&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1334, 0.2973, 0.7252&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0417, 0.1337, 0.4680&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0718, 0.1827, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2173, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0617, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0918, 0.2027, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2273, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0817, 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1018, 0.2327, 0.7676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1334, 0.2973, 0.8452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在此示例中，使用两个单元延迟表 <strong>cell_rise</strong> 和 <strong>cell_fall</strong> 以及两个转换表<strong>rise_transition</strong> 和 <strong>fall_transition</strong> 来描述从 <strong>INP1</strong> 到 <strong>OUT</strong> 的时序弧的特性。输出 <strong>max_transition</strong> 值也包含在上面的示例中。</p>
<p><strong>Positive or Negative Unate</strong></p>
<p>​ 如第 2.7 节所述，<strong>nand</strong> 单元示例中的时序弧为<strong>negative unate</strong>，这意味着输出引脚转换方向与输入引脚转换方向相反（负）。因此，<strong>cell_rise</strong> 表查找对应于输入引脚的下降转换时间。另一方面，通过<strong>and</strong>单元格或<strong>or</strong>单元格的时序弧是<strong>positive unate</strong>，因为输出转换与输入转换的方向相同。</p>
<h3 id="通用组合块general-combinational-block">通用组合块（General Combinational Block）</h3>
<p>​ 考虑具有三个输入和两个输出的组合块。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811145716416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 像这样的块可以有许多时序弧。通常，时序弧可以从块的每个输入到每个输出。如果从输入到输出的逻辑路径是non-inverting 或 positive unate，则输出具有与输入相同的极性。如果是反相逻辑路径是negative unate，则输出与输入极性相反；因此，当输入上升时，输出下降。这些时序弧表示通过块的传播延迟。</p>
<p>​ 一些通过组合单元格的时序弧可以是positive unate 也可以是negative unatee。一个例子是通过两输入异或单元的时序弧。两输入异或（ xor ）单元的输入处的转换 可导致输出转换沿相同或相反的转换方向，具体取决于单元的另一个输入的逻辑状态。这些时序弧可以被描述为non-unate或两组不同的 positive unate 和 negative unate 时序模型，它们依赖于状态。此类依赖于状态的表在第 3.5 节中有更详细的描述。</p>
<h2 id="时序模型顺序单元timing-models---sequential-cells">时序模型——顺序单元（Timing Models - Sequential Cells）</h2>
<p>​ 考虑图 3-8 中所示的顺序单元的时序弧。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811150517858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于同步输入（synchronous inputs），例如引脚 D（或 SI、SE），有以下时序弧：</p>
<ul>
<li>Setup check arc (rising and falling)</li>
<li>Hold check arc (rising and falling)</li>
</ul>
<p>​ 对于异步输入（asynchronous inputs），例如 pin CDN，有以下时序弧：</p>
<ul>
<li>Recovery check arc</li>
<li>Removal check arc</li>
</ul>
<p>​ 对于触发器的同步输出，例如引脚 Q 或 QN，有以下时序弧：</p>
<ul>
<li>CK-to-output propagation delay arc (rising and falling)</li>
</ul>
<p>​ 所有同步时序弧都与时钟的有效边沿有关，时钟的边沿使顺序单元捕获数据。此外，时钟引脚和异步引脚等清零，可以进行脉宽定时检查。图 3-9 显示了使用各种信号波形的时序检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811151034861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="同步检查建立和保持synchronous-checks-setup-and-hold">同步检查：建立和保持（Synchronous Checks: Setup and Hold）</h3>
<p>​ 需要建立和保持同步时序检查，以便通过时序单元正确传递数据。这些检查验证数据输入在时钟的有效边沿是明确的，并且正确的数据在有效边沿被锁存。这些时序检查验证数据输入在活动时钟边沿附近是否稳定。当数据输入必须保持稳定时，激活时钟之前的最短时间称为建立时间（setup time）。从超过阈值的最新数据信号（通常为Vdd的50%）到超过其阈值的活动时钟边缘（通常为Vdd的50%）的时间间隔是<strong>setup time</strong>。类似地，保持时间（hold time）是数据输入必须在时钟活动边缘之后保持稳定的最短时间。从超过其阈值的活动时钟边缘到超过其阈值的最早数据信号的时间间隔是<strong>hold time</strong>。如前所述，时序单元时钟的有效边沿是导致时序单元捕获数据的上升沿或下降沿。</p>
<p><strong>建立和保持检查示例（Example of Setup and Hold Checks）</strong></p>
<p>​ 顺序单元的同步管脚的setup 和hold constraints通常以二维表格的形式描述，如下所示。下面的示例显示触发器数据引脚的setup 和hold时序信息。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">pin (D) &#123;</span><br><span class="line"></span><br><span class="line">direction : input;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : <span class="string">&quot;setup_rising&quot;</span>;</span><br><span class="line"></span><br><span class="line">rise_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;0.063, 0.093,  0.112&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span> <span class="string">&quot;0.526, 0.644,  0.824&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span> <span class="string">&quot;0.720, 0.839,  0.930&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fall_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;0.762, 0.895,  0.969&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span> <span class="string">&quot;0.804, 0.952,  0.166&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span> <span class="string">&quot;0.159, 0.170,  0.245&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : <span class="string">&quot;hold_rising&quot;</span>;</span><br><span class="line"></span><br><span class="line">rise_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>(  <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;-0.220, -0.339, -0.584&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span> <span class="string">&quot;-0.247, -0.381, -0.729&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span> <span class="string">&quot;-0.398, -0.516, -0.864&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fall_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>);<span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>(  <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;-0.028,  -0.397, -0.489&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span>  <span class="string">&quot;-0.408,  -0.527, -0.649&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span>  <span class="string">&quot;-0.705,  -0.839, -0.580&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上面的示例显示了输入管脚D上相对于顺序单元的时钟CK的上升沿的设setup 和hold constraints。二维模型是根据受约束的_-pin（D）和相关的_-pin（CK）处的过渡时间建立的。 二维查找表基于库中描述的模板<strong>setuphold_template_3x3。</strong>对于上述示例，查找表模板<strong>setuphold_template_3x3</strong>描述为：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lu_table_template</span>(setuphold_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">variable_1 : constrained_pin_transition;</span><br><span class="line"></span><br><span class="line">variable_2 : related_pin_transition;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*受约束管脚和相关管脚可以是任意顺序，即variable_1可以是相关管脚转换。但是，这些名称通常在库中的所有模板中都是一致的*/</span></span><br></pre></td></tr></table></figure>
<p>​ 与前面的示例一样，表中的设置值被指定为一个嵌套循环，第一个索引index_1是外部（或变化最小）变量，第二个索引index_2是内部（或变化最大）变量，依此类推。因此，当D引脚上升过渡时间为0.4ns，CK引脚上升过渡时间为0.84ns时，D引脚上升沿的设置约束为0.112ns—该值从rise_constraint 表中读取。对于D引脚的下降沿，setup constraint将检查设置表的fall_constraint表。对于过渡时间与索引值不对应的setup and hold constraint表的查找，第3.2节中描述的non-linear model查找的一般程序适用。</p>
<p>​ 请注意，setup constraint的rise_constraint和fall_constraint表指的是constrained_pin。使用的时钟转换由timing_type 确定，该类型指定单元是上升沿触发还是下降沿触发。</p>
<p><strong>建立和保持检查中的负值（Negative Values in Setup and Hold Checks）</strong></p>
<p>​ 请注意，上面示例中的一些hold值为负值。这是可以接受的，并且通常发生在从触发器引脚到数据内部锁存点的路径长于相应的时钟的路径时。</p>
<p>​ 因此，负 hold check意味着触发器的数据管脚可以在时钟管脚之前改变，并且仍然满足hold time check。</p>
<p>​ 触发器的setup值也可以为负值。这意味着在触发器的引脚上，数据可以在时钟引脚之后更改，并且仍然满足setup time check。</p>
<p>​ setup和hold都可以是负数吗？不。为使setup和hold检查一致，setup和hold值之和应为正值。因此，如果setup（或hold）检查包含负值，则相应的hold（或setup）应为正值，以便setup加上hold值为正值。有关负hold值的示例，请参见图3-10。由于setup必须在hold之前进行，因此setup加hold是一个正数。setup加hold time是要求数据信号稳定的区域宽度。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811154415788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于触发器，在扫描数据输入引脚上有一个负的hold时间是有帮助的。这在时钟偏移（clock skew）方面提供了灵活性，并且可以消除几乎所有缓冲器插入的需要，以便在scan mode中修复hold冲突（scan mode是触发器串行连接形成扫描链的模式-触发器的输出通常串行连接到下一个触发器的扫描数据输入引脚；这些连接用于测试性）。</p>
<p>​ 与同步数据输入上的setup 或 hold check类似，有约束检查控制异步管脚。下面将描述这些。</p>
<h3 id="异步检查asynchronous-checks">异步检查（Asynchronous Checks）</h3>
<p><strong>恢复和去除检查（Recovery and Removal Checks）</strong></p>
<p>​ 异步引脚（如Asynchronous clear或Asynchronous set）覆盖单元格的任何同步行为。当异步引脚激活时，输出由异步引脚控制，而不是由数据输入中的时钟锁存控制。但是，当异步引脚变为非活动时，时钟的活动边缘开始在数据输入中锁定。异步恢复和删除约束检查验证异步引脚在下一个活动时钟边缘已明确返回到非活动状态。</p>
<p>​ <strong>恢复时间（recovery time）</strong>是异步输入在下一个有效时钟沿之前被取消置位后稳定的最短时间。</p>
<p>​ 类似地，<strong>移除时间（removal time）</strong>是有效时钟边沿之后异步引脚必须保持有效状态才能取消置位的最短时间。</p>
<p>​ 异步删除和恢复检查分别在第 8.6 节和第 8.7 节中描述。</p>
<p><strong>脉冲宽度检查（Pulse Width Checks）</strong></p>
<p>​ 除了同步和异步时序检查之外，还有一项检查可确保单元输入引脚的脉冲宽度满足最低要求。例如，如果时钟引脚的脉冲宽度小于指定的最小值，则时钟可能无法正确锁存数据。也可以为相关的同步和异步引脚指定脉冲宽度检查。可以为高脉冲和低脉冲指定最小脉冲宽度检查。</p>
<p><strong>恢复、去除和脉冲宽度检查示例（Example of Recovery, Removal and Pulse Width Checks）</strong></p>
<p>​ 下面给出了触发器异步清除引脚 CDN 的恢复时间、移除时间和脉冲宽度检查的示例。恢复和移除检查是针对时钟引脚 CK 的。由于恢复和移除检查是为置位的异步引脚定义的，因此下面的示例中仅存在上升约束。引脚 CDN 的最小脉冲宽度检查是针对低脉冲。由于 CDN 引脚为低电平有效，因此该引脚上的高脉冲宽度没有限制，因此未指定。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pin</span>(<span class="params">CDN</span>) &#123;</span><br><span class="line"></span><br><span class="line">direction : input;</span><br><span class="line"></span><br><span class="line">capacitance : <span class="number">0.002236</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CDN&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : min_pulse_width;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_constraint</span>(<span class="params">width_template_3x1</span>) &#123; <span class="comment">/*low pulse check*/</span></span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.032  0.504  0.788 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.034,  0.060,  0.377&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : recovery_rising;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_constraint</span>(<span class="params">recovery_template_3x3</span>) &#123; <span class="comment">/* CDN rising */</span></span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.032  0.504  0.788 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.032 */</span>  <span class="string">&quot;-0.198,  -0.122, 0.187&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.504 */</span>  <span class="string">&quot;-0.268,  -0.157, 0.124&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.788 */</span>  <span class="string">&quot;-0.490,  -0.219, -0.069&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CP&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : removal_rising;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_constraint</span>(<span class="params">removal_template_3x3</span>) &#123; <span class="comment">/* CDN rising */</span></span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.032  0.504  0.788 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.032 */</span>  <span class="string">&quot;0.106, 0.167,  0.548&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.504 */</span>  <span class="string">&quot;0.221, 0.381,  0.662&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.788 */</span>  <span class="string">&quot;0.381, 0.456,  0.778&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传播延迟propagation-delay-1">传播延迟（Propagation Delay）</h3>
<p>​ 顺序单元的传播延迟是从时钟的有效边沿到输出的上升沿或下降沿。这是负边沿触发的触发器的传播延迟弧示例，从时钟引脚 CKN 到输出 Q。这是一个非同步的时序弧，因为时钟的有效边沿可能导致上升或下降输出 Q 上的边缘。这是延迟表：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CKN&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : falling_edge;</span><br><span class="line"></span><br><span class="line">timing_sense : non_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_rise</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0513, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.1018, 0.2327, 0.6476&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1334, 0.2973, 0.7252&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0417, 0.1337, 0.4680&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0718, 0.1827, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2173, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0617, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0918, 0.2027, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2273, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0817, 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1018, 0.2327, 0.7676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1334, 0.2973, 0.8452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 与前面的示例一样，输出延迟以输入转换时间和输出引脚电容的二维表表示。然而，在本例中，要使用的输入转换时间是 CKN 引脚的下降转换时间，因为这是一个下降沿触发的触发器。这由上面示例中的构造timing_type 指示。上升沿触发触发器将指定rising_edge 作为其timing_type。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CKP&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : rising_edge;</span><br><span class="line"></span><br><span class="line">timing_sense : non_unate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cell_rise</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态相关模型state-dependent-models">状态相关模型（State-Dependent Models）</h2>
<p>​ 在许多组合块中，输入和输出之间的时序弧取决于块中其他引脚的状态。输入和输出引脚之间的这些时序弧可以是positive unate, negative unat，或者都是positive unate弧，都是negative unat 弧。一个例子是 xor 或 xnor 单元，其中输出的时序可以是positive unate 或negative unat。在这种情况下，时序行为可能会因模块其他输入的状态而异。通常，描述了取决于引脚状态的多个时序模型。这种模型被称为<strong>状态相关模型（state-dependent models）</strong>。</p>
<p><strong>XOR、XNOR 和顺序单元（XOR, XNOR and Sequential Cells）</strong></p>
<p>考虑一个两输入异或单元的例子。当另一个输入 A2 为逻辑 0 时，从输入 A1 到输出 Z 的时序路径为正值。当输入 A2 为逻辑 1 时，从 A1 到 Z 的路径为负 unate。这两个时序模型是使用状态相关模型指定的。当 A2 为逻辑 0 时，从 A1 到 Z 的时序模型指定如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pin (Z) &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">direction</span> : output;</span><br><span class="line"></span><br><span class="line">max_capacitance : <span class="number">0.0842</span>;</span><br><span class="line"></span><br><span class="line">function : <span class="string">&quot;(A1Â2)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A1&quot;</span>;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">sdf_cond : <span class="string">&quot;A2 == 1&#x27;b0&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : positive_unate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cell_rise</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.0272</span>, <span class="number">0.0576</span>, <span class="number">0.1184</span>&quot;); <span class="comment">/* Input slew */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.0102</span>, <span class="number">0.0208</span>, <span class="number">0.0419</span>&quot;); <span class="comment">/* Output load */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>( \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.0581</span>, <span class="number">0.0898</span>, <span class="number">0.2791</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.0913</span>, <span class="number">0.1545</span>, <span class="number">0.2806</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.0461</span>, <span class="number">0.0626</span>, <span class="number">0.2838</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 使用 when 条件指定依赖于状态的条件。虽然单元模型摘录仅说明了 cell_rise 延迟，但其他时序模型（cell_fall、rise_transition 和 fall_transition 表）也指定了相同的 when 条件。为另一个 when 条件指定单独的时序模型 - 对于 A2 为逻辑 1 的情况。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A1&quot;</span>;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">sdf_cond : <span class="string">&quot;A2 == 1&#x27;b1&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.0272, 0.0576, 0.1184&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.0102, 0.0208, 0.0419&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0784, 0.1019, 0.2269&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0943, 0.1177, 0.2428&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0997, 0.1796, 0.2620&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ sdf_cond 用于指定生成 SDF 时要使用的计时弧的条件 - 请参阅第 3.9 节中的示例和附录 B 中描述的 COND 构造。</p>
<p>​ 状态相关模型用于各种类型的时序弧。许多时序单元使用状态相关模型指定建立或保持时序约束。接下来指定使用状态相关模型进行保持约束的扫描触发器的示例。在这种情况下，指定了两组模型 - 一组在扫描启用引脚 SE 处于活动状态时，另一组在扫描启用引脚处于非活动状态时。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pin (D) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : hold_rising;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!SE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fall_constraint</span>(hold_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">index_1</span>(&quot;<span class="number">0.08573</span>, <span class="number">0.2057</span>, <span class="number">0.3926</span>&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">index_2</span>(&quot;<span class="number">0.08573</span>, <span class="number">0.2057</span>, <span class="number">0.3926</span>&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>(&quot;-<span class="number">0.05018</span>, -<span class="number">0.02966</span>, -<span class="number">0.00919</span>&quot;,\</span><br><span class="line"></span><br><span class="line">&quot;-<span class="number">0.0703</span>, -<span class="number">0.05008</span>, -<span class="number">0.0091</span>&quot;,\</span><br><span class="line"></span><br><span class="line">&quot;-<span class="number">0.1407</span>, -<span class="number">0.1206</span>, -<span class="number">0.1096</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 当 SE 引脚为逻辑 0 时使用上述模型。一个类似的模型用 when 条件 SE 指定为 logic-1。</p>
<p>​ 一些时序关系是使用状态相关和非状态相关模型指定的。在这种情况下，如果单元的状态已知并且包含在状态相关模型之一中，则时序分析将使用状态相关模型。如果状态相关模型不涵盖单元格的条件，则使用来自非状态相关模型的时序。考虑一种情况，其中hold constraint仅由逻辑 0 处的 SE 的一个 when 条件指定，并且没有为逻辑 1 处的 SE 指定单独的状态相关模型。在这种情况下，如果 SE 设置为逻辑 1，则使用来自非状态相关模型的保持约束。如果保持约束没有非状态依赖模型，则不会有任何 active hold constraint！</p>
<p>​ 可以为时序库中的任何属性指定状态相关模型。因此，对于power,leakage power, transition time, rise and fall delays, timing constraints等，可能存在状态相关的规范。下面给出了状态相关leakage power规范的示例：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">leakage_power</span>() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;A1 !A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">259.8</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">leakage_power</span>() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;A1 A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">282.7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="黑匣子的接口时序模型">黑匣子的接口时序模型</h2>
<p>​ 本节介绍黑匣子（任意模块或块）的 IO 接口的时序弧。时序模型捕获黑盒 IO 接口的时序。黑盒接口模型可以具有组合以及顺序时序弧。一般来说，这些弧也可以是状态相关的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811162815116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于图 3-11 所示的示例，时序弧可以放置在以下类别下：</p>
<ul>
<li>输入到输出组合弧（Input to output combinational arc:）：这对应于从输入到输出的直接组合路径，例如从输入端口 FIN 到输出端口 FOUT。</li>
<li>输入顺序弧（Input sequential arc）：这被描述为连接到触发器 D 引脚的输入的建立或保持时间。通常，在连接到触发器的 D 引脚之前，模块的输入可能存在组合逻辑。这方面的一个例子是在端口 DIN 上相对于时钟 ACLK 的设置检查。</li>
<li>异步输入弧（Asynchronous input arc）：这类似于触发器的输入异步引脚的恢复或移除时序约束。一个例子是触发器 UFF0 的异步清除引脚的输入 ARST。</li>
<li>输出顺序弧（Output sequential arc）：这类似于时钟输出连接到触发器Q 的输出传播时序。一般来说，触发器输出和模块输出之间可以有组合逻辑。一个例子是从时钟 BCLK 到触发器 UFF1 输出到输出端口 DOUT 的路径。</li>
</ul>
<p>​ 除了上面的时序弧，还可以对黑匣子的外部时钟引脚进行脉宽检查。也可以定义内部节点并在这些内部节点上定义生成的时钟以及指定进出这些节点的定时弧。总之，黑盒模型可以具有以下时序弧：</p>
<ul>
<li>组合逻辑路径的输入输出时序弧。</li>
<li>从同步输入到相关时钟引脚的建立和保持时序弧。</li>
<li>相关时钟引脚的异步输入的恢复和移除时序弧。</li>
<li>从时钟引脚到输出引脚的输出传播延迟。</li>
</ul>
<h2 id="高级时序建模advanced-timing-modeling">高级时序建模（Advanced Timing Modeling）</h2>
<p>​ 时序模型（例如 NLDM）表示通过基于输出负载电容和输入转换时间的时序弧的延迟。实际上，电池输出看到的负载由电容和互连电阻组成。由于 NLDM 方法假设输出负载是纯电容性的，因此互连电阻成为一个问题。即使互连电阻不为零，当互连电阻的影响很小时，也可以使用这些 NLDM 模型。在存在电阻互连的情况下，延迟计算方法通过获得单元输出处的等效有效电容来改进 NLDM 模型。延迟计算工具中使用的“有效”电容方法获得等效电容，该电容在单元的输出端具有与具有 RC 互连的单元相同的延迟。有效电容方法在第 5.2 节中作为延迟计算的一部分进行了描述。</p>
<p>​ 随着特征尺寸的缩小，由于波形变得高度非线性，互连电阻的影响会导致很大的不准确性。各种建模方法为单元输出驱动器提供了额外的精度。从广义上讲，这些方法通过等价电流源驱动的输出状态建模获得更高的精度。</p>
<p>这些方法的示例是 - CCS（Composite Current Source复合电流源）或 ECSM（Effective<br>
Current Source Model有效电流源模型）。例如，CCS 时序模型通过使用随时间变化和电压相关的电流源为单元输出驱动器建模提供了额外的精度。通过指定不同场景下接收器引脚电容1和输出充电电流的详细模型来提供时序信息。接下来描述 CCS 模型的细节。</p>
<h3 id="接收器引脚电容receiver-pin-capacitance">接收器引脚电容（Receiver Pin Capacitance）</h3>
<p>​ 接收器引脚电容对应于为 NLDM 模型指定的输入引脚电容。与 NLDM 模型的引脚电容不同，CCS 模型允许在转换波形的不同部分分别指定接收器电容。由于互连 RC 和等效输入非线性电容（由于来自单元内输入设备的米勒效应），接收器电容值在转换波形上的不同点发生变化。因此，该电容在波形的初始（或前导）部分与波形的尾随部分被不同地建模。</p>
<p>​ 接收器引脚电容可以在引脚级别指定（如在 NLDM 模型中），其中通过该引脚的所有时序弧都使用该电容值。或者，接收器电容可以在定时弧级指定，在这种情况下，可以为不同的定时弧指定不同的电容模型。下面描述这两种指定接收器引脚电容的方法。</p>
<p><strong>在引脚级别指定电容</strong></p>
<p>当在引脚级别指定时，接下来给出接收器引脚电容的一维表规范示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pin (IN) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">receiver_capacitance1_rise (&quot;Lookup_table_4&quot;) &#123;</span><br><span class="line"></span><br><span class="line">index_1: (<span class="string">&quot;0.1, 0.2, 0.3, 0.4&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>(&quot;<span class="number">0.001040</span>, <span class="number">0.001072</span>, <span class="number">0.001074</span>, <span class="number">0.001085</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ index_1 指定该引脚输入转换时间的索引。一维表中的value指定了波形前导部分输入引脚处上升波形的接收器电容。</p>
<p>​ 上面显示的receiver_capacitance1_rise 类似，receiver_capacitance2_rise 指定输入上升波形尾部的上升电容。下降电容（下降输入波形的引脚电容）分别由属性receiver_capacitance1_fall 和receiver_capacitance2_fall 指定。</p>
<p><strong>在定时电弧级别指定电容</strong></p>
<p>​ 接收器引脚电容也可以用时序弧指定为输入转换时间和输出负载的二维表。下面给出了时序弧级别的规范示例。此示例指定了引脚 IN 波形前导部分的接收器引脚上升电容，作为输入引脚 IN 的转换时间和输出引脚 OUT 的负载的函数。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN&quot;</span> ;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">receiver_capacitance1_rise (&quot;Lookup_table_4x4&quot;) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">index_1</span>(&quot;<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>&quot;); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">index_2</span>(&quot;<span class="number">0.01</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>&quot;); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>(&quot;<span class="number">0.001040</span> , <span class="number">0.001072</span> , <span class="number">0.001074</span> , <span class="number">0.001075</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.001148</span> , <span class="number">0.001150</span> , <span class="number">0.001152</span> , <span class="number">0.001153</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.001174</span> , <span class="number">0.001172</span> , <span class="number">0.001172</span> , <span class="number">0.001172</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.001174</span> , <span class="number">0.001171</span> , <span class="number">0.001177</span> , <span class="number">0.001174</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上面的例子指定receiver_capacitance1_rise 的模型。该库包括receiver_capacitance2_rise、receiver_capacitance1_fall 和receiver_capacitance2_fall 规范的类似定义。</p>
<p>上面的例子指定了receiver_capacitance1_rise 的模型。该库包括receiver_capacitance2_rise、receiver_capacitance1_fall 和receiver_capacitance2_fall 规范的类似定义。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811165515440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="输出电流">输出电流</h3>
<p>​ 在 CCS 模型中，非线性时序用输出电流表示。输出电流信息被指定为依赖于输入转换时间和输出负载的查找表。</p>
<p>​ 输出电流针对输入转换时间和输出电容的不同组合而指定。对于这些组合中的每一个，都指定输出电流波形。本质上，这里的波形是指指定为时间函数的输出电流值。使用output_current_fall 指定的下降输出波形的输出电流示例如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN&quot;</span> ;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">output_current_fall () &#123;</span><br><span class="line"></span><br><span class="line">    vector (&quot;LOOKUP_TABLE_1x1x5&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    reference_time : <span class="number">5.06</span>; <span class="comment">/* Time of input crossing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    threshold */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">index_1</span>(&quot;<span class="number">0.040</span>&quot;); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">index_2</span>(&quot;<span class="number">0.900</span>&quot;); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">index_3</span>(&quot;<span class="number">5.079</span>e+<span class="number">00</span>, <span class="number">5.093</span>e+<span class="number">00</span>, <span class="number">5.152</span>e+<span class="number">00</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">5.170</span>e+<span class="number">00</span>, <span class="number">5.352</span>e+<span class="number">00</span>&quot;);<span class="comment">/* Time values */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output charging current: */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">values</span>(&quot;-<span class="number">5.784</span>e-<span class="number">02</span>, -<span class="number">5.980</span>e-<span class="number">02</span>, -<span class="number">5.417</span>e-<span class="number">02</span>,</span><br><span class="line"></span><br><span class="line">    -<span class="number">4.257</span>e-<span class="number">02</span>, -<span class="number">2.184</span>e-<span class="number">03</span>&quot;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ reference_time 属性是指输入波形越过延迟阈值的时间。 index_1 和 index_2 是指输入转换时间和使用的输出负载，index_3 是时间。 index_1 和 index_2（输入转换时间和输出电容）只能有一个值。 index_3 是指时间值，表值是指相应的输出电流。因此，对于给定的输入转换时间和输出负载，可以使用作为时间函数的输出电流波形。还指定了其他输入转换时间和输出电容组合的附加查找表。</p>
<p>​ 使用 output_current_rise 指定的上升输出波形的输出电流的描述类似。</p>
<h3 id="模型串扰噪声分析models-for-crosstalk-noise-analysis">模型串扰噪声分析（Models for Crosstalk Noise Analysis）</h3>
<p>​ 本节介绍用于串扰噪声（或毛刺glitch）分析的 CCS 模型。这些被描述为 CCSN（CCS noise）模型。 CCS noise模型是结构模型，代表单元内不同的 CCB（Channel Connected Blocks通道连接块）。</p>
<p>​ 什么是CCB？ CCB是指单元的源漏通道连接部分。例如，单级单元（如反相器、与非单元和非单元）仅包含一个 CCB——整个单元通过使用一个通道连接区域连接。多级单元，例如和单元，或或单元，包含多个 CCB。</p>
<p>​ CCSN 模型通常指定为由单元输入驱动的第一个 CCB，以及驱动单元输出的最后一个 CCB。这些是使用稳态电流、输出电压和传播噪声模型指定的。</p>
<p>​ 对于单级组合单元，如 nand 和 nor 单元，CCS 噪声模型是为每个时序弧指定的。这些单元只有一个 CCB，因此模型是从单元的输入引脚到输出引脚。</p>
<p>​ 下面描述了一个 nand 单元的示例模型：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123; <span class="comment">/* First stage CCB */</span></span><br><span class="line"></span><br><span class="line">is_needed : true;</span><br><span class="line"></span><br><span class="line">stage_type : both; <span class="comment">/*CCB contains pull-up and pull-down*/</span></span><br><span class="line"></span><br><span class="line">is_inverting : true;</span><br><span class="line"></span><br><span class="line">miller_cap_rise : <span class="number">0.8</span>;</span><br><span class="line"></span><br><span class="line">miller_cap_fall : <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">dc_current (ccsn_dc) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;-<span class="number">0.9</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.35</span>, <span class="number">1.8</span>&quot;); <span class="comment">/* Input voltage */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;-<span class="number">0.9</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.35</span>, <span class="number">1.8</span>&quot;); <span class="comment">/* Output voltage*/</span></span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">1.56</span>, <span class="number">0.42</span>, . . .&quot;); <span class="comment">/* Current at output pin */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">output_voltage_rise () &#123;</span><br><span class="line"></span><br><span class="line">vector (ccsn_ovrf) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.01</span>&quot;); <span class="comment">/* Rail-to-rail input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.001</span>&quot;); <span class="comment">/* Output net capacitance */</span></span><br><span class="line"></span><br><span class="line">index_3 (&quot;<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.8</span>&quot;); <span class="comment">/* Time */</span></span><br><span class="line"></span><br><span class="line">values (&quot;<span class="number">0.27</span>, <span class="number">0.63</span>, <span class="number">0.81</span>&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">output_voltage_fall () &#123;</span><br><span class="line"></span><br><span class="line">vector (ccsn_ovrf) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.01</span>&quot;); <span class="comment">/* Rail-to-rail input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.001</span>&quot;); <span class="comment">/* Output net capacitance */</span></span><br><span class="line"></span><br><span class="line">index_3 (&quot;<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>&quot;); <span class="comment">/* Time */</span></span><br><span class="line"></span><br><span class="line">values (&quot;<span class="number">0.81</span>, <span class="number">0.63</span>, <span class="number">0.27</span>&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">propagated_noise_low () &#123;</span><br><span class="line"></span><br><span class="line">vector (ccsn_pnlh) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.5</span>&quot;); <span class="comment">/* Input glitch height */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.6</span>&quot;); <span class="comment">/* Input glitch width */</span></span><br><span class="line"></span><br><span class="line">index_3 (&quot;<span class="number">0.05</span>&quot;); <span class="comment">/* Output net capacitance */</span></span><br><span class="line"></span><br><span class="line">index_4 (&quot;<span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.7</span>&quot;); <span class="comment">/* Time */</span></span><br><span class="line"></span><br><span class="line">values (&quot;<span class="number">0.19</span>, <span class="number">0.23</span>, <span class="number">0.19</span>, <span class="number">0.11</span>&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">propagated_noise_high () &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 我们现在描述 CCS noise模型的属性。属性 ccsn_first_stage 表示该模型用于 nand 单元的第一阶段 CCB。如前所述，nand cell只有一个CCB。属性 is_needed 几乎总是正确的，但对于非功能性单元（例如称重单元和天线单元）的除外。值为 both 的 stage_type 指定此阶段具有上拉和下拉结构。 miller_cap_rise 和 miller_cap_fall 分别代表上升和下降输出转换的<strong>米勒电容</strong>。</p>
<p><em>由于输入和输出端子之间的电容放大，米勒电容解释了反相级等效输入电容的增加。</em></p>
<p><strong>直流电流（DC Current）</strong></p>
<p>​ dc_current 表代表输入和输出引脚电压的不同组合的输出引脚上的直流电流。 index_1 指定输入电压，index_2 指定输出电压。二维表中的值指定了 CCB 输出端的直流电流。输入电压和输出电流均以库单位指定（通常为Volt 和 mA）。对于从输入 IN1 到 nand 单元的 OUT 的示例 CCS 噪声模型，-0.9V 的输入电压和 0V 的输出电压导致输出端的直流电流为 0.42mA。</p>
<p><strong>输出电压（Output Voltage）</strong></p>
<p>​ output_voltage_rise 和 output_voltage_fall 结构分别包含 CCB 输出上升和下降的时序信息。这些被指定为 CCB 输出节点的多维表。多维表被组织成多个表，指定不同input transition time和output net capacitances的上升和下降输出电压。每个表都有 index_1 指定rail-to-rail 输入转换时间速率，index_2 指定输出净电容。 index_3 指定输出电压跨越特定阈值点的次数（在本例中为 0.9V 的 Vdd 电源的 30%、70% 和 90%）。在每个多维表中，电压交叉点是固定的，在index_3中指定了CCB输出节点与电压交叉时的时间值。</p>
<p><strong>传播噪声（Propagated Noise）</strong></p>
<p>​ 传播噪声高和传播噪声低模型指定多维表，这些表通过 CCB 提供噪声传播信息。这些模型表征从 CCB 输入到输出的串扰毛刺（或噪声）传播。表征在输入端使用对称三角波。传播噪声的多维表被组织成多个表，指定 CCB 输出端的毛刺波形。这些多维表包含：</p>
<ul>
<li>input glitch magnitude (in index_1),</li>
<li>input glitch width (in index_2),</li>
<li>CCB output net capacitance (in index_3), and</li>
<li>time (in index_4).</li>
</ul>
<p>​ CCB 输出电压（或通过 CCB 传播的噪声）在表中指定。</p>
<p><strong>两级单元的噪声模型（Noise Models for Two-Stage Cells）</strong></p>
<p>​ 就像单级单元一样，两级单元（例如and cells 和 or cells）的 CCS 噪声模型通常被描述为时序弧的一部分。由于这些单元包含两个单独的 CCB，噪声模型分别为 ccsn_first_stage 和另一个为 ccsn_last_stage 指定。例如，对于双输入and单元，CCS 噪声模型由第一阶段和最后阶段的单独模型组成。这在接下来说明。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN1 to internal node between stages */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123; <span class="comment">/* Internal node to output */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN2&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN2 to internal node between stages */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal node to output */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as from IN1 */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>为 IN2 指定的 ccsn_last_stage 中的模型与为 IN1 描述的 ccsn_last_stage 中的模型相同。</p>
<p><strong>多级和顺序单元的噪声模型（Noise Models for Multi-stage and Sequential Cells）</strong></p>
<p>​ 复杂组合或顺序单元的 CCS 噪声模型通常作为引脚规范的一部分进行描述。这不同于单级或两级单元，如 nand、nor 和，或者 CCS 噪声模型通常在引脚对基础上指定为时序弧的一部分。复杂的多级和顺序单元通常由所有输入引脚的 ccsn_first_stage 模型和输出引脚的另一个 ccsn_last_stage 模型描述。这些单元的 CCS 噪声模型不是时序弧的一部分，但通常是为引脚指定的。</p>
<p>​ 如果输入和输出之间的内部路径多达两个 CCB 级，噪声模型也可以表示为引脚对时序弧的一部分。通常，多级单元描述可以将一些 CCS 噪声模型指定为引脚对时序弧的一部分，而其他一些噪声模型可以通过引脚描述指定。</p>
<p>​ 下面的示例具有使用引脚描述以及部分时序弧指定的 CCS 噪声模型。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pin (CDN) &#123;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">pin (CP) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">pin (D) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">pin (Q) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CDN&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pin (QN) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 请注意，上面触发器单元的一些 CCS 模型是用引脚定义的。那些在输入引脚上定义的引脚规范被指定为 ccsn_first_stage，输出引脚 QN 的 CCS 模型被指定为 ccsn_last_stage。此外，两级 CCS 噪声模型被描述为 CDN 到 Q 的时序弧的一部分。因此，此示例表明单元可以将 CCS 模型指定为引脚规范的一部分和时序组的一部分。</p>
<h3 id="其他噪声模型">其他噪声模型</h3>
<p>​ 除了上述 CCS noise模型外，一些单元库还可以提供其他模型来表征噪声。其中一些模型在 CCS noise模型出现之前就在使用了。如果 CCS noise模型可用，则不需要这些附加模型。为了完整性，我们在下面描述了一些早期的噪声模型。</p>
<p>​ DC 裕度模型（Models for DC margin）：DC 裕度是指单元输入引脚允许的最大 DC 变化，它可以使单元保持稳定状态，即不会在输出端引起毛刺。例如，输入低电平的直流裕度是指输入引脚处的最大直流电压值，而不会在输出端引起任何转换。</p>
<p>​ 抗噪模型（Models for noise immunity）：抗噪模型指定输入引脚允许的毛刺幅度。这些通常根据以毛刺宽度和输出电容作为两个指标的二维表来描述。表中的值对应于输入引脚允许的毛刺幅度。这意味着任何小于指定幅度和宽度的毛刺都不会通过单元传播。可以指定抗噪模型的不同变体，例如：</p>
<ul>
<li>noise_immunity_high</li>
<li>noise_immunity_low</li>
<li>noise_immunity_above_high (overshoot)</li>
<li>noise_immunity_below_low (undershoot).</li>
</ul>
<h2 id="功耗建模power-dissipation-modeling">功耗建模（Power Dissipation Modeling）</h2>
<p>​ 单元库包含与单元中的功耗相关的信息。这包括有功功率以及待机或泄漏功率。顾名思义，有功功率与设计中的活动有关，而待机功率是在待机模式下消耗的功率，这主要是由于泄漏造成的。</p>
<h3 id="有功功率active-power">有功功率（Active Power）</h3>
<p>​ 有功功率与单元输入和输出引脚的活动有关。单元中的有功功率来自输出负载的充电以及内部开关。这两者通常分别称为output switching power 和 internal switching power。</p>
<p>​ 输出开关功率（output switching power）与单元类型无关，仅取决于输出容性负载、开关频率和单元的电源。内部开关功率取决于单元的类型，因此该值包含在单元库中。下面描述库中内部开关电源的规格。</p>
<p>​ 内部开关电源在单元库中称为 internal power。这是当单元的输入或输出有活动时单元内的功耗。对于组合电池，输入引脚转换会导致输出切换，从而产生内部开关电源。例如，只要输入切换（在输入处有上升或下降转换），逆变器单元就会消耗功率。库中的内部电源描述为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pin (<span class="variable constant_">Z1</span>) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">power_down_function : <span class="string">&quot;!VDD + VSS&quot;</span>;</span><br><span class="line"></span><br><span class="line">related_power_pin : <span class="variable constant_">VDD</span>;</span><br><span class="line"></span><br><span class="line">related_ground_pin : <span class="variable constant_">VSS</span>;</span><br><span class="line"></span><br><span class="line">internal_power () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line">power (template_2x2) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.4&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.05, 0.1&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.05  0.1 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.045, 0.050&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;0.055, 0.056&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上例显示了从输入引脚 A 到电池输出引脚 Z1 的功耗。模板中的 2x2 表是根据引脚 A 的输入转换和引脚 Z1 的输出电容。请注意，虽然该表包括输出电容，但表中的值仅对应于内部开关，不包括输出电容的贡献。这些值代表每个开关转换（上升或下降）在电池中耗散的内部能量。这些单位源自库中的其他单位（通常电压以伏特 (V) 为单位，电容以皮法 (pF) 为单位，这映射到以皮焦 (pJ) 为单位的能量）。因此，库中的内部功率实际上指定了每次转换消耗的内部能量。</p>
<p>​ 除了功率表之外，上面的示例还说明了电源引脚、接地引脚和断电功能的规范，该功能指定了电池可以断电的条件。这些构造允许在不同电源可能断电的设计和场景中使用多个电源。下图显示了每个单元的电源引脚规格。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cell (NAND2) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">pg_pin (VDD) &#123;</span><br><span class="line"></span><br><span class="line">pg_type : primary_power;</span><br><span class="line"></span><br><span class="line">voltage_name : COREVDD1;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pg_pin (VSS) &#123;</span><br><span class="line"></span><br><span class="line">pg_type : primary_ground;</span><br><span class="line"></span><br><span class="line">voltage_name : COREGND1;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 电源规范语法允许单独构造上升和下降功率（指输出检测）。就像时序弧一样，功率规范也可以与状态相关。例如，异或单元的状态相关功耗可以指定为依赖于各种输入的状态。</p>
<p>​ 对于组合单元，开关功率是在输入输出引脚对的基础上指定的。然而，对于具有互补输出 Q 和 QN 的触发器等时序单元，CLK-&gt;Q 转换也会导致 CLK-&gt;QN 转换。因此，库可以将内部开关功率指定为一个三维表，如下所示。下面示例中的三个维度分别是 CLK 的输入压摆和 Q 和 QN 的输出电容。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pin (Q) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="title function_">internal_power</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CLK&quot;</span>;</span><br><span class="line"></span><br><span class="line">equal_or_opposite_output : <span class="string">&quot;QN&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_power</span>(<span class="params">energy_template_3x2x2</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.02, 0.2, 1.0&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.005, 0.2&quot;</span>); <span class="comment">/* Output Q capacitance */</span></span><br><span class="line"></span><br><span class="line">index_3 (<span class="string">&quot;0.005, 0.2&quot;</span>); <span class="comment">/* Output QN capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/* 0.005  0.2 */</span> <span class="comment">/*  0.005  0.2 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.02 */</span> <span class="string">&quot;0.060, 0.070&quot;</span>,  <span class="string">&quot;0.061,  0.068&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.2 */</span> <span class="string">&quot;0.061, 0.071&quot;</span>,  <span class="string">&quot;0.063,  0.069&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.0 */</span> <span class="string">&quot;0.062, 0.080&quot;</span>,  <span class="string">&quot;0.068,  0.075&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_power</span>(<span class="params">energy_template_3x2x2</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.02, 0.2, 1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.005, 0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_3 (<span class="string">&quot;0.005, 0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.070, 0.080&quot;</span>, <span class="string">&quot;0.071, 0.078&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.071, 0.081&quot;</span>, <span class="string">&quot;0.073, 0.079&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.066, 0.082&quot;</span>, <span class="string">&quot;0.068, 0.085&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 即使输出或内部状态没有转换，也可以消耗开关功率。一个常见的例子是在触发器的时钟引脚上切换的时钟。触发器在每次时钟切换时消耗功率 - 通常是由于触发器单元内部的反相器的切换。即使触发器输出不切换，时钟引脚切换引起的功率也会耗散。因此，对于时序单元，输入引脚功率是指单元内部的功耗，即输出不转换时的功耗。下面是输入引脚电源规格的示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">cell (DFF) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">pin (CLK) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">rise_power () &#123;</span><br><span class="line"></span><br><span class="line">power (template_3x1) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.4</span>&quot;); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">values ( /*  <span class="number">0.1</span>  <span class="number">0.25</span>  <span class="number">0.4</span> */ \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.045</span>, <span class="number">0.050</span>,  <span class="number">0.090</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fall_power () &#123;</span><br><span class="line"></span><br><span class="line">power (template_3x1) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.4</span>&quot;);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.045</span>, <span class="number">0.050</span>, <span class="number">0.090</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 此示例显示了 CLK 引脚切换时的电源规格。这表示即使输出不切换时时钟切换导致的功耗。</p>
<p><strong>时钟引脚的功率是否被重复计算了（Double Counting Clock Pin Power?）</strong></p>
<p>​ 请注意，触发器还包含由于 CLK-&gt;Q 转换引起的功耗。因此，重要的是 CLK-&gt;Q 功率规格表中的值不包括由于对应于输出 Q 不切换时的条件的 CLK 内部功率的贡献。</p>
<p>​ 上述准则是指应用工具使用功率表的一致性，并确保在功率计算过程中不会重复计算由于时钟输入而指定的内部功率。</p>
<h3 id="泄露功率leakage-power">泄露功率（Leakage Power）</h3>
<p>​ 大多数标准单元都设计为仅在输出或状态发生变化时才耗散功率。当电池通电但没有活动时消耗的任何功率都是由于非零泄漏电流。泄漏可能是由于 MOS 器件的亚阈值电流或由于通过栅极氧化物的隧道电流。在前几代 CMOS 工艺技术中，漏电功率一直可以忽略不计，在设计过程中也不是主要考虑因素。然而，随着技术的缩小，泄漏功率变得越来越重要，与有功功率相比不再可以忽略不计。</p>
<p><em>高 Vt 单元是指阈值电压高于工艺技术标准的单元。</em></p>
<p>​ 上所述，泄漏功率贡献来自两种现象：MOS 器件中的亚阈值电流和栅极氧化物隧穿。通过使用高 Vt 单元，可以降低亚阈值电流；然而，由于高 Vt 单元的速度降低，因此需要进行权衡。高 Vt 单元具有较小的泄漏但速度较慢。类似地，低 Vt 单元具有更大的泄漏但允许更快的速度。通过切换到高（或低）Vt 单元，栅极氧化物隧道效应不会显着改变。因此，控制泄漏功率的一种可能方式是使用高 Vt 单元。与高 Vt 和标准 Vt 单元之间的选择类似，设计中使用的单元强度是泄漏和速度之间的权衡。更高强度的单元具有更高的泄漏功率，但提供更高的速度。与电源管理相关的权衡在第 10.6 节中详细描述。</p>
<p>​ 亚阈值 MOS 泄漏与温度具有很强的非线性相关性。在大多数工艺技术中，随着器件结温从 25C 增加到 125C，亚阈值泄漏会增加 10 到 20 倍。栅极氧化物隧道效应的贡献相对于温度或器件的 Vt 而言是相对不变的。在 100 纳米及以上工艺技术中可忽略不计的栅极氧化物隧道效应，已成为 65 纳米或更精细技术在较低温度下泄漏的重要因素。例如，对于 65nm 或更精细的工艺技术，栅极氧化物隧道泄漏可能等于室温下的亚阈值泄漏。在高温下，亚阈值泄漏仍然是泄漏功率的主要贡献者。</p>
<p>​ 为库中的每个单元指定了泄漏功率。例如，逆变器单元可能包含以下规格：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell_leakage_power : <span class="number">1.366</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这是单元中耗散的泄漏功率 - 泄漏功率单位在库的标题中指定，通常以纳瓦为单位。通常，泄漏功率取决于单元的状态，并且可以使用 when 条件指定状态相关值。</p>
<p>​ 例如，INV1 单元格可以具有以下规范：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cell_leakage_power : <span class="number">0.70</span>;</span><br><span class="line"></span><br><span class="line">leakage_power() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!I&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">1.17</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leakage_power() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;I&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">0.23</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 其中 I 是 INV1 单元的输入引脚。应该注意的是，规范包括一个默认值（在when条件之外），并且默认值通常是在when条件内指定的泄漏值的平均值。</p>
<h2 id="单元库其他属性other-attributes-in-cell-library">单元库其他属性（Other Attributes in Cell Library）</h2>
<p>​ 除了时序信息之外，库中的单元描述还指定了时序弧的区域、功能和 SDF 条件。本节简要介绍了这些内容；有关更多详细信息，请参阅 Liberty 手册。</p>
<p><strong>面积规格（Area Specification）</strong></p>
<p>​ area规范提供了一个单元格或单元格组的面积。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area : <span class="number">2.35</span>;</span><br></pre></td></tr></table></figure>
<p>​ 以上指定单元格的面积为 2.35 个面积单位。这可以代表单元使用的实际硅面积，也可以是面积的相对量度。</p>
<p><strong>功能规格（Function Specification）</strong></p>
<p>​ function规范指定引脚（或引脚组）的功能。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pin (Z) &#123;</span><br><span class="line"></span><br><span class="line">function: <span class="string">&quot;IN1 &amp; IN2&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 以上指定了两个输入and单元的 Z 引脚的功能。</p>
<p><strong>SDF条件（SDF Condition）</strong></p>
<p>​ SDF 条件属性支持标准延迟格式 (SDF) 文件生成和反注释期间的条件匹配。正如when为时序分析的状态相关模型指定条件一样，SDF注释的状态相关时序使用的相应规范由sdf_cond表示。</p>
<p>​ 以下示例说明了这一点：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A1&quot;</span>;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">sdf_cond : <span class="string">&quot;A2 == 1&#x27;b0&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : positive_unate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cell_rise</span>(delay_template_7x7) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表征和操作条件characterization-and-operating-conditions">表征和操作条件（Characterization and Operating Conditions）</h2>
<p>单元库指定了创建库的特征和操作条件。例如，库的标题可能包含以下内容：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nom_process : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">nom_temperature : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nom_voltage : <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">voltage_map(COREVDD1, <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">voltage_map(COREGND1, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">operating_conditions(&quot;BCCOM&quot;)&#123;</span><br><span class="line"></span><br><span class="line">process : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">temperature : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">voltage : <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">tree_type : <span class="string">&quot;balanced_tree&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 标称环境条件（指定为 nom_process、nom_temperature 和 nom_voltage）指定了表征库的过程、电压和温度。操作条件指定使用该库中的单元的条件。如果特性和工作条件不同，延迟计算时得到的时序值需要降额；这是通过使用库中指定的降额因子（k 因子）来实现的。</p>
<p>​ 在不同于用于表征的条件下使用降额获得时序值会导致时序计算不准确。仅当在感兴趣的条件下表征库不可行时才采用降额程序。</p>
<p><strong>什么是过程变量？（What is the Process Variable?）</strong></p>
<p>​ 与作为物理量的温度和电压不同，该过程不是可量化的量。出于数字表征和验证的目的，它可能是一种缓慢、典型或快速的过程。因此， 1.0（或任何其他值）的过程值是什么意思？答案如下。</p>
<p>​ 库表征是一个耗时的过程，并且表征不同工艺角的库可能需要数周时间。过程变量设置允许使用以特定过程角为特征的库用于不同过程角的时序计算。过程的 k 因子可用于降低从特征过程到目标过程的延迟。如上所述，降额因子的使用会在时序计算过程中引入不准确性。跨工艺条件降额特别不准确，很少使用。总而言之，指定不同过程值（例如 1.0 或任何其他值）的唯一功能是允许在很少（如果曾经）使用的条件下降额。</p>
<h3 id="使用k因子降额">使用K因子降额</h3>
<p>​ 如上所述，降额因子（称为 k 因子）用于在操作条件与特征条件不同时获得延迟。 k 因子是近似因子。库中 k 因子的示例如下所示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* k-factors */</span></span><br><span class="line"></span><br><span class="line">k_process_cell_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_cell_leakage_power : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_cell_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_fall_transition : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_hold_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_hold_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_internal_power : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_min_pulse_width_high : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_min_pulse_width_low : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_pin_cap : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_recovery_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_recovery_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_rise_transition : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_setup_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_setup_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_wire_cap : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_wire_res : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_temp_cell_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_cell_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_fall_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_temp_hold_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_hold_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_min_pulse_width_high : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_min_pulse_width_low : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_min_period : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_rise_propagation : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_fall_propagation : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_recovery_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_recovery_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_rise_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_temp_setup_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_setup_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_volt_cell_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_cell_rise : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_fall_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_volt_hold_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_hold_rise : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_min_pulse_width_high : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_min_pulse_width_low : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_min_period : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_rise_propagation : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_fall_propagation : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_recovery_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_recovery_rise : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_rise_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_volt_setup_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_setup_rise : -<span class="number">0.42</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这些因素用于在延迟计算期间操作条件的过程、电压或温度与库中的标称条件不同时获得时序。请注意，k_volt 因子为负，这意味着延迟随着电压供应的增加而减少，而 k_temp 因子是正的，这意味着延迟通常随着温度的升高而增加（除了在 2.10 节中描述的表现出温度反转现象的电池）。 k 因子的使用方法如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Result with derating = Original_value *</span><br><span class="line"></span><br><span class="line">( 1 + k_process * DELTA_Process</span><br><span class="line"></span><br><span class="line"><span class="addition">+ k_volt * DELTA_Volt</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ k_temp * DELTA_Temp)</span></span><br></pre></td></tr></table></figure>
<p>​ 例如，假设一个库在 1.08V 和 125C 下具有慢速过程模型。如果要获得 1.14V 和 100C 的延迟，则慢速工艺模型的单元上升延迟可通过下式获得：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derated_delay = Library_delay *</span><br><span class="line"></span><br><span class="line">( <span class="number">1</span> + k_volt_cell_rise * 0.06</span><br><span class="line"></span><br><span class="line">- k_temp_cell_rise * <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>​ 假设使用了上面概述的 k_factors，则前面的等式映射为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derated_delay = Library_delay * (<span class="number">1</span> - <span class="number">0.42</span> * 0.06 - 0.0012 * <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">= Library_delay * <span class="number">0.9448</span></span><br></pre></td></tr></table></figure>
<p>​ 降额条件下的延迟计算为原始延迟的 94.48%。</p>
<h3 id="库单元library-units">库单元（Library Units）</h3>
<p>​ 单元描述具有库单位方面的所有值。这些单位是使用 Liberty 命令集在库文件中声明的。电压、时间、电容和电阻的单位声明如下例所示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">library(&quot;my_cell_library&quot;) &#123;</span><br><span class="line"></span><br><span class="line">voltage_unit : <span class="string">&quot;1V&quot;</span>;</span><br><span class="line"></span><br><span class="line">time_unit : <span class="string">&quot;1ns&quot;</span>;</span><br><span class="line"></span><br><span class="line">capacitive_load_unit (<span class="number">1.000000</span>, pf);</span><br><span class="line"></span><br><span class="line">current_unit : <span class="number">1</span>mA;</span><br><span class="line"></span><br><span class="line">pulling_resistance_unit : <span class="string">&quot;1kohm&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在本文中，我们假设库时间单位以纳秒 (ns) 为单位，电压以伏特 (V) 为单位，每次跃迁的内部功率以皮焦 (pJ) 为单位，泄漏功率以纳瓦 (nW) 为单位，电容值为以皮法 (pF) 为单位，电阻值以 Kohms 为单位，面积单位为平方微米 (mm2)，除非明确指定以帮助解释。</p>
<h1 id="互连寄生interconnect-parasitics">互连寄生（Interconnect Parasitics）</h1>
<blockquote>
<p>​ 本章概述了处理和表示互连寄生的各种技术，用于设计的时序验证。</p>
</blockquote>
<p>在数字设计中，<strong>连接标准单元和模块引脚的导线称为网络（net）</strong>。net通常只有一个驱动，而它可以驱动多个扇出单元或块。物理实现后，net可以在芯片的多个金属层上移动。不同的金属层可以有不同的电阻和电容值。对于等效电学表示，通常将net分成若干段，每个段由等效寄生参数表示。我们将互连迹线（interconnect trace）称为段的同义词，也就是说，它是特定金属层上网络的一部分。</p>
<h2 id="互连rlcrlc-for-interconnect">互连RLC（RLC for Interconnect ）</h2>
<p>​ 互连电阻来自设计实现中各种金属层和通孔中的互连走线。图 4-1 显示了穿过各种金属层和通孔的示例网络。因此，互连电阻可以被认为是单元的输出引脚和扇出单元的输入引脚之间的电阻。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811223318663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 互连电容的贡献也来自金属走线，包括接地电容以及相邻信号路径之间的电容。</p>
<p>​ 电感是由电流回路引起的。通常，电感的影响在芯片内可以忽略，仅在封装和板级分析时考虑。在芯片级设计中，电流回路又窄又短——这意味着电流返回路径是通过靠近布线的电源或接地信号。在大多数情况下，时序分析不考虑片上电感。对片上电感分析的任何进一步描述超出了本书的范围。接下来描述互连电阻和电容的表示。</p>
<p>​ 一段互连走线的电阻和电容 (RC) 理想地由分布式 RC 树表示，如图 4-2 所示。在该图中，RC 树的总电阻和电容 - 分别为 Rt 和 Ct -—对应于 Rp* L 和 Cp* L，其中 Rp、Cpare 每单位长度的走线互连电阻和电容值，L 是走线长度。 Rp、Cp 值通常从提取的各种配置的寄生参数中获得，由 ASIC 代工厂提供。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811224212859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Rt%3D%20Rp*%20L"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Ct%3D%20Cp*%20L"></p>
<p>​ RC 互连可以用各种简化模型表示。这些在下面的小节中进行了描述。</p>
<h3 id="t--model">T -model</h3>
<p>​ 在 T 模型表示中，总电容 Ct 建模为连接在电阻树的中间。总电阻 Rt 分为两部分（每部分都是 Rt/2），Ct连接在电阻树的中点，如图 4-3 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811224538943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="pi--model">Pi -model</h3>
<p>​ 在图 4-4 所示的 Pi 模型中，总电容 Ct 分为两部分（每部分为 Ct/2）并连接在电阻的任一侧。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811224759975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 更准确的分布RC树的表示是通过将Rt和Ct分解成多个部分得到的。对于分解成的N段，R和C的每一个中间段都是Rt/ N和Ct/ N。末端段可以按照T-model或Pi-model的概念建模。图4-5为末端段采用T-model的N段，图4-6为末端段采用Pi-model的N段。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811225427529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通过对 RC 互连建模的广泛概述，我们现在描述如何在<strong>布局前阶段（ pre-layout）（通过估计）或布局后阶段（post-layout）（通过详细提取）</strong>利用寄生互连。下一节描述了预布局过程中寄生互连的建模。</p>
<h2 id="线载模型wireload-models">线载模型（Wireload Models）</h2>
<p>​ 在布局规划或布局之前，线载模型可用于估计电容、电阻和互连引起的面积开销。线载模型用于根据网络的扇出数量估计网络的长度。线载模型取决于块的面积，不同面积的设计可以选择不同的线载模型。线载模型还将估计的网络长度映射到电阻、电容和相应的布线面积开销。</p>
<p>​ 块内的平均线长与块的大小密切相关；平均net长度随着块大小的增加而增加。图 4-7 显示，对于不同的区域（芯片或块大小），通常会使用不同的线载模型来确定寄生参数。因此，该图描绘了较小尺寸块的较小电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811225832869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是线载模型的示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wire_load (“wlm_conservative”) &#123;</span><br><span class="line"></span><br><span class="line">resistance : <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">capacitance : <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">area : <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line">slope : <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">1</span>, <span class="number">2.6</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">2</span>, <span class="number">2.9</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">3</span>, <span class="number">3.2</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">4</span>, <span class="number">3.6</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">5</span>, <span class="number">4.1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ <strong>resistance</strong>是互连线单位长度的电阻值，<strong>capacitance</strong>是互连线单位长度的电容值，<strong>area</strong>是互连线单位长度的面积开销，<strong>slope</strong>是用于扇出-长度（<strong>fanout_length</strong>）表中未指定的数据点的外推斜率。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811230104270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 线载模型说明了如何将线的长度描述为扇出的函数。上面的例子如图 4-8 所示。对于表中未明确列出的任何扇出数，互连长度是使用具有指定斜率的线性外推法获得的。例如，扇出 8 会导致以下结果：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Length = 4.1 + (8 - 5) <span class="emphasis">* 0.5 = 5.6 units</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Capacitance = Length *</span> cap<span class="emphasis">_coeff(1.1) = 6.16 units</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Resistance = Length * res_</span>coeff(5.0) = 28.0 units</span><br><span class="line"></span><br><span class="line">Area overhead due to interconnect = Length <span class="emphasis">* area_coeff(0.05)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">= 0.28 area units</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">互连线长度 = 4.1 + （8 - 5） *</span> 0.5 = 5.6</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">电容值 = 5.6 <span class="emphasis">* 1.1 = 6.16</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">电阻值 = 5.6 *</span> 5 =28.0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">面积开销 = 5.6 <span class="emphasis">* 0.05 = 0.28</span></span><br></pre></td></tr></table></figure>
<p>​ length, capacitance, resistance 和 area的单位在liberty中指定。</p>
<h3 id="互连树interconnect-trees">互连树（Interconnect Trees）</h3>
<p>​ 一旦确定了预布局互连的电阻和电容估计值，比如 Rwire 和 Cwire，下一个问题就是互连的结构。互连RC结构如何相对于驱动单元定位？这很重要，因为从驱动引脚到负载引脚的互连延迟取决于互连的结构。通常，互连延迟取决于路径上的互连电阻和电容。因此，此延迟可能因网络所采用的拓扑而异。</p>
<p>​ 对于预布局估计，互连 RC 树可以使用以下三种不同表示法之一来表示（见图 4-9）。请注意，在三种情况中的每一种情况下，总互连长度（以及电阻和电容估计值）都相同。</p>
<ul>
<li>最佳情况树（Best-case tree）：</li>
</ul>
<p>​ 在最佳情况树中，假设目标（负载）引脚在物理上与驱动相邻。因此，在通向目标引脚的路径中，没有任何导线电阻。来自其他扇出引脚的所有导线电容和引脚电容仍充当驱动引脚上的负载。</p>
<ul>
<li>平衡树（ Balanced tree）：</li>
</ul>
<p>​ 在这种情况下，假设每个目标引脚都位于互连线的单独部分。到目的地的每条路径都会看到总导线电阻和电容的相等部分。</p>
<ul>
<li>最坏情况树（Worst-case tree）：</li>
</ul>
<p>​ 在这种情况下，假设所有目标引脚都位于线路的远端。因此，每个目标引脚都会看到总导线电阻和总导线电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231129319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="指定线载模型specifying-wireload-models">指定线载模型（Specifying Wireload Models）</h3>
<p>​ 使用以下命令指定线载模型：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_wire_load_model “wlm_cons” -library “lib_stdcell”</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令表示使用单元库lib_stdcell中的线负载模型wlm_cons</span></span><br></pre></td></tr></table></figure>
<p>​ 当网络跨越层次边界时，可以根据线载模式将不同的线载模型应用于每个层次边界中网络的不同部分。这些线载模式是：</p>
<ul>
<li>top</li>
<li>enclosed</li>
<li>segmented</li>
</ul>
<p>​ 可以使用 set_wire_load_mode 规范指定线载模式，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_wire_load_mode enclosed</span><br></pre></td></tr></table></figure>
<p>​ 在<strong>top</strong>线载模式下，层次结构内的所有网络都继承顶层的线载模型，即忽略低层模块中指定的任何线载模型。因此，顶级线载模型优先。对于图 4-10 所示的示例，块 B1 中指定的 wlm_cons 线载模型优先于块 B2、B3 和 B4 中指定的所有其他线载模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231729233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在<strong>enclosed</strong>线载模式下，完全包围网络的块的线载模型用于整个网络。对于图 4-11 所示的示例，网络 NETQ 包含在块 B2 中，因此块 B2 的线载模型 wlm_light 用于该网络。完全包含在块 B3 中的其他网络使用 wlm_aggr 线载模型，而完全包含在块 B5 中的网络使用 wlm_typ 线载模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231810122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在<strong>segmented</strong>线负载模式下，网络的每段（segment）都从包含该段的块中获取其线负载模型，网络的每个部分都在该层次内使用适当的线负载模型。图4-12举例说明了一个网络NETQ，它的三段分别在三个块中。B3块中此网络的扇出互连使用wlm_aggr线负载模型，B4块中使用wlm_typ线负载模型，B2块中使用wlm_light线负载模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231852215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通常，根据模块的芯片面积选择线载模型。但是，这些可以根据用户的判断进行修改或更改。例如，可以为 0 到 400 之间的块区域选择线载模型 wlm_aggr，为 400 到 1000 之间的区域选择线载模型 wlm_typ，以及为 1000 或更高的区域选择线载模型 wlm_cons。线载模型通常在单元库中定义 - 但是用户也可以定义自定义线载模型。可以选择在单元库中将默认线载模型指定为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_wire_load: <span class="string">&quot;wlm_light&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​ 在单元库中定义了基于面积选择线载模型的线载选择组。这是一个这样的例子：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wire_load_selection (WireAreaSelGrp)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">0</span>, <span class="number">50000</span>, &quot;wlm_light&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">50000</span>, <span class="number">100000</span>, &quot;wlm_cons&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">100000</span>, <span class="number">200000</span>, &quot;wlm_typ&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">200000</span>, <span class="number">500000</span>, &quot;wlm_aggr&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 一个单元库可以包含许多这样的选择组。通过使用 set_wire_load_selection_group 规范，可以选择特定的一个用于 STA。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_wire_load_selection_group WireAreaSelGrp</span><br></pre></td></tr></table></figure>
<p>​ 本节描述了在物理实现之前，即在预布局阶段期间对估计寄生参数的建模。下一节描述了从布局中提取的寄生参数的表示。</p>
<h2 id="提取寄生参数的表示representation-of-extracted-parasitics">提取寄生参数的表示（Representation of Extracted Parasitics）</h2>
<p>​ 从布局中提取的寄生参数可以用三种格式描述：</p>
<ul>
<li>详尽寄生参数格式 ：Detailed Standard Parasitic Format（DSPF）</li>
<li>精简寄生参数格式 ：Reduced Standard Parasitic Format（RSPF）</li>
<li>标准寄生参数格式 ：Standard Parasitic Extraction Format（SPEF）</li>
</ul>
<p>​ 一些工具提供了寄生生物的专有二进制表示，如SBPF；这有助于保持较小的文件大小，并加快工具对寄生生物的读取。下面简要介绍上述三种格式。</p>
<h3 id="详细标准寄生格式detailed-standard-parasitic-format">详细标准寄生格式（Detailed Standard Parasitic Format）</h3>
<p><em>电路模拟器可读的格式，如SPICE。更多信息，请参阅[NAG75]或任何关于模拟集成电路设计或模拟的书籍</em>。</p>
<p>​ 使用DSPF格式时，详尽的寄生参数以<strong>SPICE</strong>格式表示。<strong>SPICE</strong>中的Comment语句用于表明单元类型、单元引脚及其电容。电阻和电容值采用标准<strong>SPICE</strong>语法，并且单元实例也包含在此表示格式中。这种格式的优势在于，DSPF文件可以用作<strong>SPICE</strong>仿真器本身的输入。但是，缺点是DSPF语法过于详细和冗长，导致模块的总文件大小非常大。因此，这种格式在实际中仅用于相对较小的一组网络。</p>
<p>​ 这里是一个示例DSPF文件，它描述了从主输入IN到缓冲器BUF的输入引脚a的互连，以及从BUF的输出引脚OUT到主输出引脚OUT的另一个网络。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.SUBCKT</span> <span class="selector-tag">TEST_EXAMPLE</span> <span class="selector-tag">OUT</span> <span class="selector-tag">IN</span></span><br><span class="line"></span><br><span class="line">* <span class="selector-tag">Net</span> <span class="selector-tag">Section</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">GROUND_NET</span> <span class="selector-tag">VSS</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">NET</span> <span class="selector-tag">IN</span> <span class="number">4.9</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">P</span> (IN I <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">4.1</span>)</span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">I</span> (<span class="attribute">BUF1</span>:A BUF A I <span class="number">0.0</span> <span class="number">0.7</span> <span class="number">4.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C1</span> <span class="selector-tag">IN</span> <span class="selector-tag">VSS</span> <span class="number">2.3</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C2</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">A</span> <span class="selector-tag">VSS</span> <span class="number">2.6</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">R1</span> <span class="selector-tag">IN</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">A</span> <span class="number">4.8</span><span class="selector-tag">E00</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">NET</span> <span class="selector-tag">OUT</span> <span class="number">4.47</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">S</span> (<span class="attribute">OUT</span>:<span class="number">1</span> <span class="number">8.3</span> <span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">P</span> (OUT O <span class="number">0.0</span> <span class="number">8.3</span> <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">I</span> (<span class="attribute">BUF1</span>:OUT BUF1 OUT O <span class="number">0.0</span> <span class="number">4.9</span> <span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C3</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">OUT</span> <span class="selector-tag">VSS</span> <span class="number">3.5</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C4</span> <span class="selector-tag">OUT</span>:<span class="number">1</span> <span class="selector-tag">VSS</span> <span class="number">4.9</span><span class="selector-tag">E-03PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C5</span> <span class="selector-tag">OUT</span> <span class="selector-tag">VSS</span> <span class="number">4.8</span><span class="selector-tag">E-03PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">R2</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">OUT</span> <span class="selector-tag">OUT</span>:<span class="number">1</span> <span class="number">12.1</span><span class="selector-tag">E00</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">R3</span> <span class="selector-tag">OUT</span>:<span class="number">1</span> <span class="selector-tag">OUT</span> <span class="number">8.3</span><span class="selector-tag">E00</span></span><br><span class="line"></span><br><span class="line">*<span class="selector-tag">Instance</span> <span class="selector-tag">Section</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">X1</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">A</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">OUT</span> <span class="selector-tag">BUF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ENDS</span></span><br></pre></td></tr></table></figure>
<p>​ DSPF中的非标准<strong>SPICE</strong>语句是以 * |开头，并具有以下格式：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*|I(InstancePinName InstanceName PinName PinType PinCap X Y)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|P(PinName PinType PinCap X Y)</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|NET NetName NetCap</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|S(SubNodeName X Y)</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|GROUND_NET NetName</span></span><br></pre></td></tr></table></figure>
<h3 id="精简标准寄生格式reduced-standard-parasitic-format">精简标准寄生格式（Reduced Standard Parasitic Format）</h3>
<p>​ 在RSPF表示中，寄生以简化形式表示。简化格式包括电压源和受控电流源。RSPF格式也是SPICE文件，因为它可以读入类似SPICE的模拟器。RSPF格式要求减少详细的寄生并映射到减少的格式中。因此，这是RSPF表示的一个缺点，因为寄生提取过程的重点通常是提取精度，而不是简化为类似RSPF的紧凑格式。RSPF表示的另一个限制是双向信号流不能用这种格式表示。</p>
<p>​ 下面是一个RSPF文件的示例。原始设计和等效表示如图4-13所示。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Design Name : TEST1</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Date : 7 September 2002</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Time : 02:00:00</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Resistance Units : 1 ohms</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Capacitance Units : 1 pico farads</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*| RSPF 1.0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>| DELIMITER &quot;<span class="emphasis">_&quot;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">.SUBCKT TEST1 OUT IN</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*| GROUND_</span>NET VSS</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|NET CP 0.075PF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|DRIVER CKBUF<span class="emphasis">_Z CKBUF Z</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*|S (CKBUF_</span>Z<span class="emphasis">_OUTP 0.0 0.0)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">R1 CKBUF_</span>Z CKBUF<span class="emphasis">_Z_</span>OUTP 8.85</span><br><span class="line"></span><br><span class="line">C1 CKBUF<span class="emphasis">_Z_</span>OUTP VSS 0.05PF</span><br><span class="line"></span><br><span class="line">C2 CKBUF<span class="emphasis">_Z VSS 0.025PF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*|LOAD SDFF1_</span>CP SDFF1 CP</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|S (SDFF1_CP_INP 0.0 0.0)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">E1 SDFF1_CP_INP VSS CKBUF_Z VSS 1.0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">R2 SDFF1_CP_INP SDFF1_CP 52.0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">C3 SDFF1_CP VSS 0.1PF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|LOAD SDFF2<span class="emphasis">_CP SDFF2 CP</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*|S (SDFF2_</span>CP<span class="emphasis">_INP 0.0 0.0)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">E2 SDFF2_</span>CP<span class="emphasis">_INP VSS CKBUF_</span>Z VSS 1.0</span><br><span class="line"></span><br><span class="line">R3 SDFF2<span class="emphasis">_CP_</span>INP SDFF2<span class="emphasis">_CP 43.5</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">C4 SDFF2_</span>CP VSS 0.1PF</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*Instance Section</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">X1 SDFF1_Q SDFF1_QN SDFF1_D SDFF1_CP SDFF1_CD VDD VSS SDFF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">X2 SDFF2_Q SDFF2_QN SDFF2_D SDFF2_CP SDFF2_CD VDD VSS SDFF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">X3 CKBUF_Z CKBUF_A VDD VSS CKBUF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">.ENDS</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">.END</span></span><br></pre></td></tr></table></figure>
<p>​ 此文件具有以下功能：</p>
<ul>
<li>在每个扇出单元的输入引脚上都使用0.1pF的电容（C3和C4）和电阻（R2和R3）对引脚到引脚（pin-to-pin）的互连延迟进行建模，电阻值的选取原则是使RC延迟对应于引脚到引脚的互连延迟。驱动单元输出引脚上的π型负载模拟了通过该单元的延迟。</li>
<li>输入端的RC元件由理想电压源（E1和E2）驱动，该电压源等于驱动单元输出端的电压。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210811232851569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="标准寄生交换格式standard-parasitic-extraction-format">标准寄生交换格式（Standard Parasitic Extraction Format）</h3>
<p>​ SPEF 是一种紧凑的格式，可以表示详细的寄生参数。下面显示了具有两个扇出的网络示例。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*D_NET NET_27 0.77181</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>CONN</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*I *</span>8:Q O <span class="emphasis">*L 0 *</span>D CELL1</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*I *</span>10:I I <span class="emphasis">*L 12.3</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>CAP</span><br><span class="line"></span><br><span class="line">1 <span class="emphasis">*9:0 0.00372945</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2 *</span>9:1 0.0206066</span><br><span class="line"></span><br><span class="line">3 <span class="emphasis">*9:2 0.035503</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4 *</span>9:3 0.0186259</span><br><span class="line"></span><br><span class="line">5 <span class="emphasis">*9:4 0.0117878</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6 *</span>9:5 0.0189788</span><br><span class="line"></span><br><span class="line">7 <span class="emphasis">*9:6 0.0194256</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">8 *</span>9:7 0.0122347</span><br><span class="line"></span><br><span class="line">9 <span class="emphasis">*9:8 0.00972101</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">10 *</span>9:9 0.298681</span><br><span class="line"></span><br><span class="line">11 <span class="emphasis">*9:10 0.305738</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">12 *</span>9:11 0.0167775</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*RES</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1 *</span>9:0 <span class="emphasis">*9:1 0.0327394</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2 *</span>9:1 <span class="emphasis">*9:2 0.116926</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3 *</span>9:2 <span class="emphasis">*9:3 0.119265</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4 *</span>9:4 <span class="emphasis">*9:5 0.0122066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">5 *</span>9:5 <span class="emphasis">*9:6 0.0122066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6 *</span>9:6 <span class="emphasis">*9:7 0.0122066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">7 *</span>9:8 <span class="emphasis">*9:9 0.142205</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">8 *</span>9:9 <span class="emphasis">*9:10 3.85904</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">9 *</span>9:10 <span class="emphasis">*9:11 0.142205</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">10 *</span>9:12 <span class="emphasis">*9:2 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">11 *</span>9:13 <span class="emphasis">*9:6 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">12 *</span>9:1 <span class="emphasis">*9:9 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">13 *</span>9:5 <span class="emphasis">*9:10 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">14 *</span>9:12 <span class="emphasis">*8:Q 0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">15 *</span>9:13 <span class="emphasis">*10:I 0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>END</span><br></pre></td></tr></table></figure>
<p>​ 寄生参数 R 和 C 的单位在 SPEF 文件的开头指定。附录 C 中提供了对 SPEF 的更详细描述。 由于其表示的紧凑性和完整性，SPEF 是表示设计中寄生效应的首选格式。</p>
<h2 id="表示耦合电容representing-coupling-capacitances">表示耦合电容（Representing Coupling Capacitances）</h2>
<p>​ 上一节说明了将网络电容表示为接地电容（grounded capacitances）的情况。由于纳米技术中的大多数电容是侧壁电容（sidewall capacitances），这些电容的正确表示是信号到信号耦合电容（coupling capacitance）。</p>
<p>​ DSPF 中耦合电容的表示是原始 DSPF 标准的附加内容，因此不是唯一的。耦合电容在两组耦合网络之间复制。这意味着 DSPF 不能直接读入 SPICE，因为两组网络中的耦合电容是重复的。一些输出 DSPF 的工具通过在两个耦合网络中包含一半的耦合电容来解决这种差异。</p>
<p>​ RSPF 是简化的表示，因此不适合表示耦合电容。</p>
<p>​ SPEF 标准以统一和明确的方式处理耦合电容，因此是当对串扰时序感兴趣时选择的提取格式。此外，SPEF 是文件大小方面的紧凑表示，用于表示有和没有耦合的寄生效应。</p>
<p>​ 如附录 C 中所述，管理文件大小的机制之一是在文件开头设置名称目录。许多提取工具现在在 SPEF 文件的开头指定一个网络名称目录（将网络名称映射到索引），以避免重复网络名称的冗长。这显着减小了文件大小。 SPEF 的附录中显示了名称为目录的示例。</p>
<h2 id="分层方法hierarchical-methodology">分层方法（Hierarchical Methodology）</h2>
<p>​ 大型复杂设计在物理设计过程中通常需要分层方法来进行寄生提取和时序验证。在这种情况下，块的寄生参数在块级别被提取，然后可以在更高层次的层次结构中使用。</p>
<p>​ 一个块的布局提取寄生参数可用于与布局尚未完成的另一个块的时序验证。在这种情况下，布局完整块的布局提取寄生参数通常与基于线载模型的pre-layout块的估计寄生参数一起使用。</p>
<p>​ 在分层流的情况下，顶级布局已完成但块仍表示为黑盒（pre-layou），基于线载模型的寄生参数估计可用于较低级别的块以及布局提取的寄生参数最高水平。块的布局完成后，可以将顶部的布局提取寄生参数和块缝合在一起。</p>
<h3 id="在布局中复制块block-replicated-in-layout">在布局中复制块（Block Replicated in Layout）</h3>
<p>​ 如果一个设计块在布局中被多次复制，则一个实例的寄生提取可以用于所有实例。这要求对于块的各种实例化，块的布局在所有方面都相同。例如，从块内布线的网络来看，布局环境应该没有区别。这意味着块级网络不与块外的任何网络电容耦合。实现这一点的一种方法是确保没有顶层网络在块上布线，并且在块边界附近布线的网络有足够的屏蔽或间距。</p>
<h2 id="减少关键网络寄生效应reducing-parasitics-for-critical-nets">减少关键网络寄生效应（Reducing Parasitics for Critical Nets）</h2>
<p>​ 本节简要概述了管理关键网络寄生效应影响的常用技术。</p>
<h3 id="降低互连电阻reducing-interconnect-resistance">降低互连电阻（Reducing Interconnect Resistance）</h3>
<p>​ 对于关键网络，保持低转换值（或快速转换时间）很重要，这意味着应降低互连电阻。通常，有两种方法可以实现低电阻：</p>
<ul>
<li>宽走线（Wide trace）：走线比最小宽度更宽可降低互连电阻，而不会导致寄生电容显着增加。因此，减少了总的 RC 互连延迟和转换时间。</li>
<li>上层（较厚）金属布线（Routing in upper (thicker) metals）：上层金属层通常具有低电阻率，可用于布线关键信号。低互连电阻减少了互连延迟以及目标引脚的转换时间。</li>
</ul>
<h3 id="增加线距increasing-wire-spacing">增加线距（Increasing Wire Spacing）</h3>
<p>​ 增加走线之间的间距会降低网络的耦合电容和总电容。大耦合电容会增加串扰，避免串扰是在相邻走线中长距离布线的网络的重要考虑因素。</p>
<h3 id="相关网络的寄生参数parasitics-for-correlated-nets">相关网络的寄生参数（Parasitics for Correlated Nets）</h3>
<p>​ 在很多情况下，一组网络必须在时序上匹配。一个例子是高速 DDR 接口的字节通道内的数据信号。由于字节通道内的所有信号看到相同的寄生信号很重要，因此所有信号都在同一金属层中布线。例如，虽然金属层 M2 和 M3 具有相同的平均值和相同的统计变化，但这些变化是独立的，因此这两个金属层中的寄生变化不会相互跟踪。因此，如果关键信号的时序匹配很重要，那么每个金属层的布线必须相同。</p>
<h1 id="延迟计算delay-calculation">延迟计算（Delay Calculation）</h1>
<blockquote>
<p>解释了如何为布局前和布局后时序验证计算单元延迟和路径延迟。本章扩展了前面章节中描述的概念，介绍了整个设计的时序。本章概述了用于 pre-layout 和 post-layout时序验证的基于单元设计的延迟计算。</p>
</blockquote>
<p>前几章重点介绍了互连和单元库的建模。单元和互连建模技术用于获得设计时序。</p>
<h2 id="概述overview">概述（Overview）</h2>
<h3 id="延迟计算基础delay-calculation-basics">延迟计算基础（Delay Calculation Basics）</h3>
<p>​ 典型的设计包括各种组合单元和顺序单元。我们使用图5-1所示的示例的逻辑片段来描述延迟计算的概念。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812001608262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><em>标准单元库通常不为单元输出指定引脚电容。</em></p>
<p>​ 每个单元的库描述指定每个输入引脚的引脚电容值。因此，设计中的每个网络都有一个电容负载，它是网络中每个扇形输出的引脚电容负载加上互连的任何贡献的总和。为了简单起见，本节不考虑互连的贡献，这些贡献将在后面的章节中描述。在不考虑互连寄生的情况下，图5-1中的内部网络NET0具有由UAND1和UNOR2单元的输入引脚电容组成的网络电容。输出O1具有UNOR2单元的引脚电容加上逻辑块输出的任何电容负载。输入I1和I2具有对应于UAND1和UINV0单元的引脚电容。通过这种抽象，图5-1中的逻辑设计可以用图5-2中所示的等效表示来描述。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812001957161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如第3章所述，单元库包含各种时序弧的NLDM定时模型。非线性模型表示为输入过渡时间和输出电容的二维表格。逻辑单元的输出跃迁时间也被描述为一个二维表，表示输入跃迁和网络总输出电容。因此，如果在逻辑块的输入端指定了输入转换时间（或转换slew），则可以从库单元描述中获得通过UINV0单元和UAND1单元（对于输入I1）的时序弧的输出转换时间和延迟。通过扇出单元扩展相同的方法，则可以获得通过UAND1单元的另一条时序弧（从NET0到O1）以及通过UNOR2单元的过渡时间和延迟。对于多输入单元（如UAND1），不同的输入引脚可以提供不同的输出过渡时间值。扇出网络过渡时间的选择取决于转换合并选项，如第5.4节所述。使用上述方法，可根据输入引脚的过渡时间和输出引脚的电容获得通过任何逻辑单元的延迟。</p>
<h3 id="互连延迟计算delay-calculation-with-interconnect">互连延迟计算（Delay Calculation with Interconnect）</h3>
<p><strong>预布局时序（Pre-layout Timing）</strong></p>
<p>​ 如第4章所述，在预布局时序验证期间，使用线性负载模型估算了互连寄生参数。在许多情况下，线性负载模型中的电阻贡献被设置为0。在这种情况下，线性负载贡献纯粹是电容性的，上一节中描述的延迟计算方法适用于获得设计中所有时序弧的延迟。</p>
<p>​ 在线性性负载模型包括互连电阻影响的情况下，NLDM模型与单元延迟的总网络电容一起使用。由于互连是电阻式的，因此从驱动单元的输出到扇出单元的输入引脚会有额外的延迟。</p>
<p><strong>布局后时序（Post-layout Timing）</strong></p>
<p>​ 金属走线的寄生参数映射到驱动单元和目标单元之间的RC网络中。使用图5-1的示例，网络的互连电阻如图5-3所示。内部网络（如图5-1中的NET0）映射到多个子节点，如图5-3所示。因此，逆变单元UINV0的输出负载由RC结构组成。由于NLDM表格是关于输入转换和输出电容的，因此输出引脚处的电阻负载意味着NLDM表格不直接适用。下一节将介绍使用具有电阻互连的NLDM。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812002829549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="使用有效电容的单元延迟cell-delay-using-effective-capacitance">使用有效电容的单元延迟（Cell Delay using Effective Capacitance）</h2>
<p>​ 如上所述，当单元输出端的负载包括互连电阻时，NLDM模型不能直接使用。相反，采用“有效”电容法来处理电阻效应。</p>
<p>​ 有效电容法试图找到可用作等效负载的单个电容，以便原始设计以及具有等效电容负载的设计在单元输出的定时方面表现相似。这种等效单电容被称为<strong>有效电容（effective capacitance）</strong>。</p>
<p>​ 图5-4（a）所示为扇出端带有RC互连的单元。RC互连由图5-4（b）所示的等效RC PI网络表示。有效电容的概念是获得等效输出电容Ceff（如图5-4（c）所示），其通过电池的延迟与RC负载的原始设计相同。一般来说，RC负载的电池输出波形与单个电容负载的波形非常不同。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812003116665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图5-5显示了总电容、有效电容和实际RC互连的单元输出波形的代表性波形。选择有效电容Ceff时，应确保图5-4（c）中单元输出端的延迟（在过渡中点测量）与图5-4（a）中的延迟相同。如图5-5所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812003230102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 关于PI等效表示，有效电容可表示为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Ceff%20%3D%20C1%20+%20k%20*%20C2%2C%200%20%3C%3D%20k%20%3C%3D%201"></p>
<p>​ 其中C1为近端电容，C2为远端电容，如图5-4（b）所示。k值介于0和1之间。在互连电阻可忽略不计的情况下，有效电容几乎等于总电容。这可以通过在图5-4（b）中将R设置为0来直接解释。类似地，如果互连电阻相对较大，则有效电容几乎等于近端电容C1（图5-4（b））。这可以通过将R增加到极限情况来解释，在极限情况下，R变为无穷大（本质上是一个开路）。</p>
<p>​ 有效电容是以下各项的函数：</p>
<ul>
<li>驱动单元</li>
<li>从驱动单元看，负载的特性或负载的输入阻抗</li>
</ul>
<p>​ 对于给定的互连线，输出驱动较弱的单元将比驱动较强的单元具有更大的有效电容。因此有效电容的值将介于最小值C1（对于较大的互连电阻或者较强的驱动单元）与最大值C1+C2（对于小到可忽略的互连电阻或较弱的驱动单元）之间。注意，目标引脚的转换要晚于驱动单元的输出。近端电容充电速度比远端电容快的现象也被称为互连线的电阻屏蔽效应（resistive shielding effect），因为驱动单元只能看到一部分远端电容。</p>
<p>​ 与通过在库中直接查找NLDM模型计算延迟不同，延迟计算工具通过迭代程序获得有效电容。在算法方面，第一步是获得实际RC负载的单元输出所看到的驱动点阻抗。使用二阶AWE或Arnoldi算法1等任何方法计算实际RC负载的驱动点阻抗。计算有效电容的下一步是在两种情况下，将转移的电荷等效到过渡的中点。当使用实际RC负载（基于驱动点阻抗）时，电池输出处转移的电荷与使用有效电容作为负载时的电荷传输量相匹配，请注意，电荷转移仅在过渡中点之前匹配。该过程从有效电容的估计开始，然后迭代更新估计值。在大多数实际情况下，有效电容值在少量迭代内收敛。</p>
<p>​ 因此，有效电容近似是计算单元延迟的良好模型。然而，使用有效电容获得的输出摆幅与电池输出的实际波形不一致。单元输出处的波形，尤其是波形后半部分的波形，不能用有效电容近似表示。请注意，在典型场景中，感兴趣的波形不在单元输出处，而是在互连的目标点处，即扇出单元的输入管脚处。</p>
<p>​ 有多种方法可以计算互连终点处的延迟和波形。在许多实现中，有效电容程序还计算驱动单元的等效戴维南电压源。戴维南源由一个斜坡源和一个串联电阻Rd组成，如图5-6所示。串联电阻Rd对应于电池输出级的下拉（或上拉）电阻。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081213310699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 本节介绍了使用有效电容替代RC互连来计算通过驱动单元的延迟。有效电容的计算还提供了等效的戴维宁电压源模型，然后将其用于获取通过RC互连的时序。接下来将具体介绍获取通过RC互连时序信息的过程。</p>
<h2 id="互连延迟interconnect-delay">互连延迟（Interconnect Delay）</h2>
<p>​ 如第4章所述，网络的互连寄生通常由RC电路表示。RC互连可以是预布局或后布局。虽然布局后寄生互连可包括与相邻网络的耦合，但基本延迟计算将所有电容（包括耦合电容）视为对地电容。图5-7显示了网络及其驱动单元和扇出单元的寄生示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812134515330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 采用有效电容法，分别获得了通过驱动单元和通过互连的延迟。有效电容法通过驱动单元以及单元输出端的等效戴维南源提供延迟。然后使用戴维南源分别计算通过互连的延迟。互连部分具有一个输入和与目的地管脚一样多的输出。使用互连输入端的等效戴维南电压源，计算每个目标引脚的延迟。如图5-6所示。</p>
<p>​ 在布局前进行分析时，RC互连结构由RC树类型决定，而RC互连结构又决定了互连线延迟。4.2节中已详细介绍了三种类型的RC互连树表示形式，所选的RC树类型通常在库中定义。通常，最坏情况（worst-case）的慢速库会选择最坏情况的RC树，因为该类型的树提供了最大的互连线延迟。类似地，最佳情况（best-case）的RC树结构中不包括从源引脚到目标引脚的任何电阻，通常在最佳情况的快速工艺角时被选择。因此，最佳情况RC树的互连延迟等于零。典型（typical）情况RC树和最坏情况RC树的互连延迟的处理方式与布局后RC互连一样。</p>
<h3 id="elmore延迟">Elmore延迟</h3>
<p>​ Elmore延迟适用于RC树。什么是RC树？RC树满足以下三个条件：</p>
<ul>
<li>具有单个输入（源）节点。</li>
<li>没有任何电阻回路。</li>
<li>所有电容都位于节点和接地之间。</li>
</ul>
<p>​ Elmore延迟可以看作是找到每段的延迟，即R与下游电容的乘积，然后取各延迟之和。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812140213384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 到各个中间节点的延迟表示为：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Td1= C1* R1;</span><br><span class="line"></span><br><span class="line">Td2= C1* R1+ C2* (R1+ R2);</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">Tdn= S(i=<span class="number">1</span>,N) Ci(S(j=<span class="number">1</span>,i) Rj); <span class="comment"># Elmore delay equation</span></span><br></pre></td></tr></table></figure>
<p>​ Elmore延迟在数学上考虑的是脉冲响应的第一时刻。 现在，我们将Elmore延迟模型进行如下简化表示：互连线的寄生电阻与电容分别为Rwire和Cwire，互连线远端的引脚电容由负载电容Cload来建模。等效的RC网络可以简化为π模型或T模型，分别如前面章节四中图4-4和图4-3所示。两种模型都具有如下走线延迟（基于Elmore延迟方程）：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Rwire*%20%28Cwire/%202%20+%20Cload%29"></p>
<p>​ 这是因为Cload在其充电路径中看到整个导线电阻，而Cwire电容在T表示中看到Rwire/2，在PI表示中Cwire/2在其充电路径中看到Rwire。上述方法也可以扩展到更复杂的互连结构。</p>
<p>​ 下面给出了使用带平衡RC树（以及最坏情况RC树）的线负载模型计算网络Elmore延迟的示例。</p>
<p>​ 使用平衡RC树模型时，网络的电阻和电容在网络的各个分支之间平均分配（假设扇出为N）。对于具有引脚负载Cpin的分支，使用平衡RC树的延迟为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net delay = (<span class="name">Rwire/</span> N) * (<span class="name">Cwire/</span> (<span class="number">2</span> * N) + Cpin)</span><br></pre></td></tr></table></figure>
<p>​ 使用最坏情况RC树模型时，网络的每个分支终点都考虑了网络的电阻和整个电容。此时的延迟值如下所示，这里的Cpins是所有扇出的总引脚负载：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Net delay = Rwire* (<span class="name">Cwire/</span> <span class="number">2</span> + Cpins)</span><br></pre></td></tr></table></figure>
<p>​ 图5-9显示了一个设计示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812141848894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果我们使用最坏情况RC树模型来计算网络N1的延迟，我们将得到：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Net delay = Rwire* (<span class="name">Cwire/2</span> + Cpins)</span><br><span class="line"></span><br><span class="line">          = <span class="number">0.3</span> * (<span class="number">0.5</span> + <span class="number">2.3</span>) = <span class="number">0.84</span></span><br></pre></td></tr></table></figure>
<p>​ 如果我们使用平衡树模型，我们得到网络N1的两个分支的以下延迟：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Net delay to NOR2 input pin = (<span class="number">0.3</span>/2) * (<span class="number">0.5</span>/2 + <span class="number">1.3</span>)</span><br><span class="line"></span><br><span class="line">                            = <span class="number">0.2325</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Net delay to BUF input pin= (<span class="number">0.3</span>/2) * (<span class="number">0.5</span>/2 + <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">                            = <span class="number">0.1875</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶互连延迟估计higher-order-interconnect-delay-estimation">高阶互连延迟估计（Higher Order Interconnect Delay Estimation）</h3>
<p>​ 如上所述，Elmore延迟是脉冲响应的第一个时刻。AWE（Asymptotic Waveform Evaluation渐近波形评估）、Arnoldi或其他方法匹配高阶响应矩。通过考虑高阶估计，可以获得更高的互连延迟计算精度。</p>
<h3 id="全芯片延迟计算full-chip-delay-calculation">全芯片延迟计算（Full Chip Delay Calculation）</h3>
<p>​ 到目前为止，本章描述了单元延迟的计算以及单元输出端的互连。因此，给定单元输入端的过渡时间，可以计算通过单元的延迟和单元输出端的互连线的延迟。互连远端（目的地或汇点）的过渡时间是下一级的输入，整个设计过程中都会重复此过程，这样就计算出了设计中每个时序弧的延迟。</p>
<h2 id="转换合并slew-merging">转换合并（Slew Merging）</h2>
<p>​ 当多个转换（slew）到达一个公共点时会发生什么情况，例如在多输入单元或多驱动网络的情况下？这种公共点称为转换合并点（slew merge point）。选择哪个slew在slew merge point向前传播？考虑图5-10所示的2输入单元。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081215150016.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于引脚 A 上的信号变化，引脚 Z 处的转换提前到达但上升缓慢（缓慢s转换）。由于引脚 B 上的信号变化，引脚 Z 处的转换延迟到达，但上升很快（快速转换）。在转换合并点，例如 pin Z应该选择哪个slew进行进一步传播？</p>
<p>​ 根据如下所述执行的时序分析的类型(最大或最小)，这些转换值中的任何一个都可能是正确的。</p>
<p>​ 执行最大路径分析时有两种可能性：</p>
<ul>
<li>最差转换传播（Worst slew propagation）：此模式选择合并点的最差转换进行传播。这将是图5-10(A)中的slew。对于通过管脚A-&gt;Z的时序路径，此选择是精确的，但对于通过管脚B-&gt;Z的任何时序路径则是悲观的。</li>
<li>最差到达传播（Worst arrival propagation）：此模式选择合并点的最差到达时间进行传播。这与图5-10(b)中的摆动相对应。在这种情况下选择的摆幅对于通过管脚B-&gt;Z的时序路径是精确的，但是对于通过管脚A-&gt;Z的时序路径是乐观的。</li>
</ul>
<p>​ 同样，执行最小路径分析时有两种可能性：</p>
<ul>
<li>最佳转换传播（Best slew propagation）：此模式选择要传播的合并点处的最佳转换。这将是图5-10(b)中的回转。对于通过管脚B-&gt;Z的定时路径，该选择是精确的，但是对于通过管脚A-&gt;Z的任何时序路径，该选择较小。对于通过A-&gt;Z的路径，路径延迟小于实际值，因此对于最小路径分析是悲观的。</li>
<li>最佳到达传播（Best arrival propagation）：此模式选择合并点的最佳到达时间进行传播。这与图5-10(A)中的转换slew相对应。这种情况下选择的slew对于通过管脚A-&gt;Z的时序路径是精确的，但是选择的值大于通过管脚B-&gt;Z的定时路径的实际值。对于通过B-&gt;Z的路径，路径延迟大于实际值，因此对于最小路径分析是乐观的。</li>
</ul>
<p>​ 设计者可以在静态时序分析环境之外执行延迟计算以生成SDF。在这种情况下，延迟计算工具通常使用最差的转换传播（worst slew propagation）。所得到的SDF对于最大路径分析是足够的，但是对于最小路径分析可能是乐观的。</p>
<p>​ 大多数静态时序分析工具使用最差和最好的转换传播作为它们的默认设置，因为它以保守的方式限制了分析。但是，在分析特定路径时，可以使用精确的转换传播。准确的转换传播可能需要在时序分析工具中启用一个选项。因此，重要的是要了解静态时序分析工具中默认使用的转换传播模式，并了解其可能过于悲观的情况。</p>
<h2 id="不同的转换阈值different-slew-thresholds">不同的转换阈值（Different Slew Thresholds）</h2>
<p>​ 通常，库指定单元角色化过程中使用的<strong>转换(转换时间)【slew (transition time)】</strong>阈值。问题是，当具有一组转换阈值的单元驱动具有不同组转换阈值设置的其他单元时，会发生什么情况？考虑图5-11所示的情况，其中特征为20-80转换阈值的单元驱动两个扇出单元；一个转换阈值为10-90，另一个转换阈值为30-70，转换降低率为0.5。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812152816468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 单元格U1的转换设置在单元库中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : 20.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : 80.00</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">slew_derate_from_library : 1.00</span><br><span class="line"></span><br><span class="line">input_threshold_pct_fall : 50.00</span><br><span class="line"></span><br><span class="line">output_threshold_pct_fall : 50.00</span><br><span class="line"></span><br><span class="line">input_threshold_pct_rise : 50.00</span><br><span class="line"></span><br><span class="line">output_threshold_pct_rise : 50.00</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : 20.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : 80.00</span><br></pre></td></tr></table></figure>
<p>​ 来自另一个库的单元格U2可以具有如下定义的转换设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : 10.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : 90.00</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">slew_derate_from_library : 1.00</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : 10.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : 90.00</span><br></pre></td></tr></table></figure>
<p>​ 来自另一个库的单元格U3可以具有如下定义的转换设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : 30.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : 70.00</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">slew_derate_from_library : 0.5</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : 30.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : 70.00</span><br></pre></td></tr></table></figure>
<p>​ 上面只显示了U2和U3的转换相关设置；输入和输出阈值的延迟相关设置为50%，上面没有显示。延迟计算工具根据连接网络的单元的转换阈值计算转换时间。图5-11显示了U1/Z处的转换如何与该引脚上的开关波形相对应。利用U1/Z的等效戴维南源获得扇出单元输入端的开关波形。根据U2/A和U3/A的波形及其转换阈值，延迟计算工具计算U2/A和U3/A的转换。请注意，U2/A的转换基于10-90设置，而用于U3/A的转换基于30-70设置，然后根据库中指定的slew_derate 0.5递减。此示例说明如何根据扇出单元的切换波形和转换阈值设置计算扇出单元输入端的转换时间。</p>
<p>​ 在可能不考虑互连电阻的预布局（pre-layout）设计阶段时，可以按以下方式计算具有不同阈值的网络处的转换时间。例如，10%-90%转换阈值和20%-80%转换阈值之间的关系为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slew2080 / (<span class="number">0.8</span> - <span class="number">0.2</span>) = slew1090 /(<span class="number">0.9</span> - <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>​ 因此，具有 10-90 个测量点的 500ps 转换对应于具有 20-80 个测量点的 (500ps * 0.6) / 0.8 = 375ps 转换。类似地，具有 20-80 个测量点的 600ps 转换对应于具有 10-90 个测量点的 (600ps * 0.8) / 0.6 = 800ps 转换。</p>
<h2 id="个同的电压域different-voltage-domains">个同的电压域（Different Voltage Domains）</h2>
<p>​ 典型的设计可能对芯片的不同部分使用不同的电源电平。在这种情况下，电平转换单元用于不同电源域之间的接口。电平转换单元在一个电源域接受输入并在另一个电源域提供输出。例如，标准单元输入可以是 1.2V，其输出可以是降低的电源，可能是 0.9V。图 5-12 显示了一个示例</p>
<p><img src="https://img-blog.csdnimg.cn/20210812154006234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，延迟是根据 50% 阈值点计算的。对于接口单元的不同引脚，这些点处于不同的电压。</p>
<h2 id="路径延迟计算path-delay-calculation">路径延迟计算（Path Delay Calculation）</h2>
<p>​ 一旦每个时序弧的所有延迟都可用，设计中单元的时序就可以表示为时序图。通过组合单元的时序可以表示为从输入到输出的时序弧。类似地，互连由从源到每个目的地（或汇）点的相应弧表示为单独的时序弧。一旦整个设计由相应的弧线注释，计算路径延迟涉及将沿路径的所有网络和单元时序弧线相加。</p>
<h3 id="组合路径延迟combinational-path-delay">组合路径延迟（Combinational Path Delay）</h3>
<p>​ 考虑串联的三个逆变器，如图 5-13 所示。在考虑从网络 N0 到网络 N3 的路径时，我们同时考虑上升沿和下降沿路径。假设在网络 N0 处有一个上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812160505527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 可以指定第一个逆变器输入端的 transition time (or slew)；如果没有这样的规范，则假定过渡时间为 0（对应于理想步长）。输入 UINVa/A 的转换时间是通过使用上一节中指定的互连延迟模型来确定的。相同的延迟模型也用于确定网络 N0 的延迟 Tn0。</p>
<p>​ 基于在UINVa的输出处的负载的RC获得在输出UINVa / Z的有效电容。然后在输入UINVa / A，并在输出UINVa / Z等效有效负荷的转换时间是用于获得单元输出下降延迟。</p>
<p>​ 引脚 UINVa/Z 处的等效戴维南源模型用于通过使用互连模型确定引脚 UINVb/A 处的转换时间。互连模型还用于确定网络 N1 上的延迟 Tn1。</p>
<p>​ 一旦知道输入 UINVb/A 处的转换时间，就可以类似地使用通过 UINVb 计算延迟的过程。 UINVb/Z 处的 RC 互连和 UINVc/A 引脚的引脚电容用于确定 N2 处的有效负载。 UINVb/A 的转换时间用于确定通过反相器 UINVb 的上升延迟，依此类推。</p>
<p>​ 最后阶段的负载由提供的任何明确的负载规范确定，或者在没有规范的情况下仅使用网络 N3 的线负载。</p>
<p>​ 上述分析假设在网络 N0 处有一个上升沿。对于网络 N0 上的下降沿的情况，可以进行类似的分析。因此，在这个简单的示例中，有两条时序路径具有以下延迟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tfall= Tn0rise+ Tafall+ Tn1fall+ Tbrise+ Tn2rise+ Tcfall+ Tn3fall</span><br><span class="line"></span><br><span class="line">Trise= Tn0fall+ Tarise+ Tn1rise+ Tbfall+ Tn2fall+ Tcrise+ Tn3rise</span><br></pre></td></tr></table></figure>
<p>​ 通常，由于驱动单元输出端的戴维南源模型不同，通过互连的上升和下降延迟可能不同。</p>
<h3 id="触发器的路径path-to-a-flip-flop">触发器的路径（Path to a Flip-flop）</h3>
<p><strong>输入到触发器路径（Input to Flip-flop Path）</strong></p>
<p>​ 考虑如图5-14从输入SDT到触发器UFF1的路径的时序。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812161429433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 我们需要同时考虑上升沿和下降沿路径。对于输入 SDT 上升沿的情况，数据路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn1rise+%20Tafall+%20Tn2fall+%20Tbuf1fall+%20Tn3fall+%20Tbrise+%20Tn4rise"></p>
<p>​ 同样，对于输入 SDT 的下降沿，数据路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn1fall+%20Tarise+%20Tn2rise+%20Tbuf1rise+%20Tn3rise+%20Tbfall+%20Tn4fall"></p>
<p>​ 输入 MCLK 上升沿的捕获时钟路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn5rise+%20Tbuf2rise+%20Tn6rise"></p>
<p><strong>触发器到触发器路径（Flip-flop to Flip-flop Path）</strong></p>
<p>​ 图 5-15 显示了两个触发器和相应时钟路径之间的数据路径示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812162002320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ UFF0/Q 上升沿的数据路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tck2qrise+%20Tn1rise+%20Tafall+%20Tn2fall+%20Tbfall+%20Tn3fall"></p>
<p>​ 输入 PCLK 上升沿的启动时钟路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn4rise+%20T5rise+%20Tn5arise"></p>
<p>​ 输入 PCLK 上升沿的捕获时钟路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn4rise+%20T5rise+%20Tn5brise+%20T6rise+%20Tn6rise"></p>
<p>​ 请注意，需要考虑单元的完整性，因为边缘方向在通过单元时可能会发生变化。</p>
<h3 id="多路径multiple-paths">多路径（Multiple Paths）</h3>
<p>​ 在任意两点之间，可以有许多路径。最长的路径是花费时间最长的路径；这也称为最坏路径、延迟路径或最大路径。最短的路径是需要最短时间的路径；这也称为最佳路径、早期路径或最小路径。</p>
<p>​ 通过图 5-16 中的时序弧查看逻辑和延迟。两个触发器之间最长的路径是通过单元 UBUF1、UNOR2 和 UNAND3。两个触发器之间的最短路径是通过单元 UNAND3。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812162514247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="裕量计算slack-calculation">裕量计算（Slack Calculation）</h2>
<p>​ 裕量（Slack）是信号需要到达时间（Required Time）与实际到达时间（Arrival Time）之差。在图5-17中，要求数据在7ns时保持稳定才能满足建立时间（setup）要求。但是，数据在1ns时就已稳定。因此，裕量为6ns（= 7ns-1ns）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812163011691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 假设所需的数据时间是从捕获触发器的设置时间获得的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Slack = Required_time - <span class="type">Arrival_time</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Required_time</span> <span class="operator">=</span> Tperiod - Tsetup(capture_flip_flop)</span><br><span class="line"></span><br><span class="line">= <span class="number">10</span> - <span class="number">3</span> = 7<span class="type">ns</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Arrival_time</span> <span class="operator">=</span> 1<span class="type">ns</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Slack</span> <span class="operator">=</span> <span class="number">7</span> - <span class="number">1</span> = 6ns</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">需要到达时间Required_Time = Tperiod - Tsetup = <span class="number">10</span> - <span class="number">3</span> = 7ns</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">实际到达时间Arrival_Time = 1ns</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">裕量Slack = Required_Time - Arrival_Time = <span class="number">7</span> - <span class="number">1</span> = 6ns</span><br></pre></td></tr></table></figure>
<p>​ 同样，如果两个信号之间的偏斜（skew）要求为100ps，并且测得的偏斜为60ps，则偏斜的裕量为40ps（= 100ps-60ps）。</p>
<h1 id="串扰和噪声crosstalk-and-noise-1">串扰和噪声（Crosstalk and Noise）</h1>
<blockquote>
<p>在纳米技术中，串扰的影响在设计的信号完整性中起着重要作用。本章描述相关的噪声和串扰分析，即毛刺分析和串扰分析。这些技术使 ASIC 从时序的角度表现稳定运行。</p>
</blockquote>
<p>在深亚微米技术中，串扰对设计的信号完整性起着重要作用。串扰噪声是指两个或多个信号之间活动的无意耦合。相关的噪声和串扰分析技术，即故障分析和串扰分析，允许在静态时序分析期间包括这些影响，本章对此进行了描述。这些技术可用于使ASIC性能稳定。</p>
<h2 id="概述overview-1">概述（Overview）</h2>
<p>​ 噪声（noise）是指影响芯片正常运行的非期望或无意影响。在纳米技术中，噪声会影响设备的功能或时序。</p>
<p>​ 为什么会有噪声和信号完整性？</p>
<p>​ 噪声在深亚微米技术中扮演重要角色的原因有几个：</p>
<ul>
<li>金属层数量的增加：例如，0.25mm 或 0.3mm 工艺有四到五个金属层，在 65nm 和 45nm 工艺几何结构中增加到十个或更多金属层。图 4-1 描绘了金属互连的多层。</li>
<li>垂直主导金属纵横比：这意味着与早期工艺几何形状中的宽而细不同，线又细又高。因此，更大比例的电容由侧壁耦合电容组成，该电容映射到相邻线之间的线对线电容。</li>
<li>更精细的几何形状带来更高的布线密度：因此，在紧密的物理距离上封装了更多的金属线。</li>
<li>更多数量的交互设备和互连：因此，更多的有源标准单元和信号走线被封装在相同的硅区域中，从而导致更多的交互。</li>
<li>由于频率更高，波形更快：：快速边沿速率会导致更多的电流尖峰以及对相邻迹线和单元的更大耦合影响。</li>
<li>更低的电源电压：电源电压的降低为噪声留下了很小的余量。</li>
</ul>
<p>​ 在本章中，我们特别研究了串扰噪声的影响。串扰噪声是指两个或多个信号之间的无意耦合活动。串扰噪声是由管芯上相邻信号之间的电容耦合引起的。这会导致网络上的开关活动对耦合信号造成意外影响。 受影响的信号称为受害者（victim），而产生影响的信号称为攻击者（aggressor）。请注意，两个耦合的网络可能会相互影响，并且通常一个网络可能既是受害者又是攻击者。</p>
<p>​ 图 6-1 显示了几个信号线耦合在一起的示例。描述了耦合互连的分布式 RC 提取与几个驱动器和扇出单元。在此示例中，网络 N1 和 N2 将 Cc1 Cc4 作为它们之间的耦合电容，而 Cc2 Cc5 是网络 N2 和 N3 之间的耦合电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816105032486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><em>一些分析工具将毛刺（glitch）称为噪声。同样，一些工具使用串扰（crosstalk ）来指代串扰对延迟的影响。</em></p>
<p>​ 从广义上讲，串扰有两种类型的噪声影响 - 毛刺（glitch）指的是由于相邻干扰源的开关活动耦合而在稳定的受害信号上引起的噪声，以及由开关耦合引起的时序变化（串扰增量延迟）受害者的活动与攻击者的转换活动。这两种类型的串扰噪声的在接下来的两个部分进行说明。</p>
<h2 id="串扰毛刺分析crosstalk-glitch-analysis">串扰毛刺分析（Crosstalk Glitch Analysis）</h2>
<h3 id="基础知识basics">基础知识（Basics）</h3>
<p>​ 由于开关攻击者通过耦合电容传输的电荷，稳定的信号网络可能会出现毛刺（正或负）。图 6-2 说明了由上升的攻击者网络的串扰引起的正毛刺。两个网络之间的耦合电容被描述为一个集总电容 Cc 而不是分布式耦合，这是为了简化下面的说明，而又不失一般性。在提取的网表的典型表示中，耦合电容可能分布在多个段上，如前面第 6.1 节中所见。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816111131981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在此示例中，NAND2 单元 UNAND0 对其输出网络（标记为 Aggressor）进行切换和充电。一些电荷也通过耦合电容 Cc 转移到受害网络并导致正毛刺。转移的电荷量与攻击者和受害网络之间的耦合电容 Cc 直接相关。在受害网络的接地电容上传输的电荷会导致该网络出现故障。由于传输的电荷通过驱动单元 INV2 的下拉阶段耗散，因此受害网络上的稳定值（在这种情况下为 0 或低）恢复。</p>
<p>​ 引起的毛刺的大小取决于多种因素。其中一些因素是：</p>
<ul>
<li>攻击者网络和受害者之间的耦合电容：耦合电容越大，毛刺的幅度越大。</li>
<li>攻击者网络的转换（slew）：攻击者网络的转换速度越快，毛刺的幅度就越大。通常，更快的转换是因为驱动攻击者网络的单元具有更高的输出驱动强度。</li>
<li>受害网络接地电容：受害网络上的接地电容越小，毛刺的幅度越大。</li>
<li>受害网络驱动强度：驱动受害网络的单元的输出驱动强度越小，毛刺的幅度越大。</li>
</ul>
<p>​ 总体而言，虽然受害网络上的稳定值得到恢复，但毛刺会由于下述原因影响电路的功能。</p>
<ul>
<li>毛刺幅度可能大到足以被扇出单元视为不同的逻辑值（例如，逻辑 0 处的受害者可能表现为扇出单元的逻辑 1）。这对于顺序单元（触发器、锁存器）或存储器尤其重要，其中时钟故障或异步设置/复位可能对设计的功能造成灾难性影响。类似地，锁存器输入端数据信号上的毛刺会导致不正确的数据被锁存，如果在输入数据时出现毛刺，这也可能是灾难性的。</li>
<li>即使受害网络不驱动顺序单元，宽毛刺也可能通过受害网络的扇出传播并到达顺序单元输入，对设计造成灾难性后果。</li>
</ul>
<h3 id="毛刺类型types-of-glitches">毛刺类型（Types of Glitches）</h3>
<p>​ 毛刺具有许多不同种类：</p>
<p><strong>上升和下降毛刺（Rise and Fall Glitches）</strong></p>
<p>​ 前面小节中的讨论说明了受害者网络上的<strong>上升毛刺（Rise Glitch）</strong>，该受害者网络一直稳定在低电平。类似的情况是在稳定的高电平信号上出现负毛刺，电平下降切换的攻击者网络会在稳定的高电平信号上引起<strong>下降毛刺（Fall Glitch）</strong>。</p>
<p><strong>过冲和欠冲毛刺（Overshoot and Undershoot Glitches）</strong></p>
<p>​ 当一个上升的攻击者与一个稳定高电平的受害者网络结合时会发生什么？仍然存在使受害网络电压高于其稳定高值的毛刺。这种毛刺称为<strong>过冲毛刺（overshoot glitch）</strong>。类似地，当耦合到稳定的低电平受害网络时，下降的攻击者会导致受害网络上出现<strong>欠冲毛刺</strong>（<strong>Undershoot Glitches</strong>）。</p>
<p>​ 图 6-3 说明了由串扰引起的所有四种毛刺情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816113509497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上一小节所述，毛刺由耦合电容、攻击者转换和受害者网络的驱动强度决定。毛刺计算基于开关攻击者注入的电流量、受害者网络的RC互连以及驱动受害者网络的单元的输出阻抗。详细的毛刺计算基于库模型；用于计算的相关噪声模型是第3章中描述的标准单元库模型的一部分。第3.7节中的输出 dc_current模型与单元的输出阻抗相关。</p>
<h3 id="毛刺阈值和传播glitch-thresholds-and-propagation">毛刺阈值和传播（Glitch Thresholds and Propagation）</h3>
<p>​ 如何确定网络上的毛刺是否可以通过扇出单元传播？正如前面的小节所讨论的，由开关干扰源耦合引起的毛刺可以通过扇出单元传播，具体取决于扇出单元和毛刺属性，例如毛刺高度和毛刺宽度。这种分析可以基于直流或交流噪声阈值。 DC 噪声分析仅检查毛刺幅度并且是保守的，而 AC 噪声分析检查其他属性，例如毛刺宽度和扇出单元输出负载。下面描述了在毛刺的 DC 和 AC 分析中使用的各种阈值指标。</p>
<p><strong>直流阈值（DC Thresholds）</strong></p>
<p>​ DC 噪声容限（noise margin）是用于检查毛刺幅度的检查，指的是确保正确的逻辑功能同时，单元输入的 DC 噪声限制。例如，只要输入保持在单元的 VIL 最大值以下，反相器单元的输出就可以是高的（即，保持在 VOH 的最小值以上）。类似地，只要输入保持在 VIH 最小值以上，反相器单元的输出就可以是低的（即保持在 VOL 最大值以下）。这些限制是根据单元的直流传输特性获得的，并且可以填充在单元库中。</p>
<p>​ VOH 是被视为逻辑 1 或高的输出电压范围。 VIL 是被视为逻辑零或低的输入电压范围。 VIH 是被视为逻辑 1 的输入电压范围。 VOL 是被视为逻辑零的输出电压范围。图 6-4 给出了逆变器单元输入-输出直流传输特性的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816115208725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ VILmax 和 VIHmin 限制也称为 DC 裕度限制。基于 VIH 和 VIL 的直流裕度是稳态噪声限值。因此，这些可以用作确定毛刺是否会通过扇出单元传播的过滤器。 DC 噪声容限限制适用于单元的每个输入引脚。通常，对于rise_glitch（输入低）和fall_glitch（输入高），DC 裕度限制是分开的。 DC 裕度的模型可以指定为单元库描述的一部分。无论毛刺的宽度如何，低于 DC 裕度限制的毛刺（例如，低于扇出引脚 VILmax 的上升毛刺）都无法通过扇出传播。因此，保守的毛刺分析检查峰值电压电平（对于所有毛刺）是否满足扇出单元的 VIL 和 VIH 电平。只要所有网络满足扇出单元的 VIL 和 VIH 水平，尽管存在任何毛刺，就可以得出结论，毛刺对设计的功能没有影响（因为毛刺不会导致输出改变）。</p>
<p>​ 图 6-5 显示了直流裕度限制的示例。对于设计中的所有网络，DC 噪声容限也可以固定为相同的限制。可以设置最大的可容忍噪声（或毛刺）幅度，高于该幅度的噪声可以通过单元传播到输出引脚。通常，此检查可确保毛刺电平小于 VILmax 且大于 VIHmin。高度通常表示为电源的百分比。因此，如果 DC 噪声容限设置为 30%，则表明任何大于电压摆幅 30% 的毛刺高度都被识别为潜在毛刺，它可以通过单元传播并可能影响设计的功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816120651510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 并非所有幅度大于直流噪声容限的毛刺都能改变单元的输出。在确定毛刺是否会传播到输出时，毛刺的宽度也是一个重要的考虑因素。单元输入处的窄毛刺通常不会对单元输出造成任何影响。然而，无论信号噪声宽度如何，直流噪声容限仅使用恒定的最坏情况值。参见图 6-6。这提供了噪声抑制水平，它是对单元噪声容限的非常保守的估计。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816120828210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>交流阈值（AC Thresholds）</strong></p>
<p>​ 如上小节所述，毛刺分析的 DC 裕度限制是保守的，因为这些限制是在最坏情况下分析设计的。 DC 裕量限制验证即使毛刺任意宽，也不会影响设计的正常运行。</p>
<p>​ 在大多数情况下，设计可能无法通过保守的 DC 噪声分析限制。因此，必须验证毛刺对毛刺宽度和单元输出负载的影响。通常，如果毛刺很窄或者如果扇出单元具有大的输出电容，则毛刺不会影响正常的功能操作。毛刺宽度和输出电容的影响都可以用扇出单元的惯性来解释。通常，单级单元将停止比通过单元的延迟窄得多的任何输入毛刺。这是因为对于窄毛刺，毛刺在扇出单元可以响应之前就结束了。因此，非常窄的毛刺不会对电池产生任何影响。由于输出负载增加了通过单元的延迟，因此增加输出负载具有将输入端毛刺的影响降至最低的效果，尽管它具有增加单元延迟的不利影响。</p>
<p>​ AC 噪声抑制如图 6-7 所示（对于固定输出电容）。深色阴影区域代表良好或可接受的毛刺，因为这些毛刺太窄或太短，或两者兼而有之，因此对单元的功能行为没有影响。浅阴影区域表示不良或不可接受的毛刺，因为这些毛刺太宽或太高，或既宽又高，因此在单元输入端的这种毛刺会影响单元的输出。在毛刺较宽的极限情况下，毛刺阈值对应于DC噪声裕量，如图6-7所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816123436993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于给定的单元，增加输出负载会增加噪声容限，因为它会增加惯性延迟和可以通过单元的毛刺宽度。下面通过一个例子来说明这种现象。图 6-8(a) 显示了一个无负载的逆变器单元，其输入端有一个正毛刺。输入毛刺高于单元的直流裕度，并导致逆变器输出出现毛刺。图 6-8(b) 显示了在其输出端带有一些负载的相同逆变器单元。输入端相同的输入毛刺会导致输出上的毛刺小得多。如果逆变器单元的输出负载更高，如图 6-8(c) 所示，则逆变器单元的输出没有任何毛刺。因此，增加输出端的负载会使单元更不受从输入端传播到输出端的噪声的影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816133000422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上所述，低于 AC 阈值（图 6-7 中的 AC 噪声抑制区域）的毛刺可以被忽略，或者可以认为扇出单元不受此类毛刺的影响。 AC 阈值（或抗扰度）区域取决于输出负载和毛刺宽度。如第3章中所述，抗扰度模型（noise immunity model）包括上述AC噪声抑制的影响，3.7节中介绍的<strong>propagated_noise</strong>模型除了对通过单元的传播进行建模外，还包括了AC噪声阈值的影响。</p>
<p>​ 如果毛刺大于 AC 阈值会发生什么？在毛刺幅度超过 AC 阈值的情况下，单元输入处的毛刺会在单元输出处产生另一个毛刺。输出毛刺高度和宽度是输入毛刺宽度和高度以及输出负载的函数。此信息在单元库中进行了表征，其中包含输出毛刺幅度和宽度的详细表格或函数，作为输入引脚毛刺幅度、毛刺宽度和输出引脚负载的函数。毛刺传播由包含在库单元描述中的<strong>propagated_noise</strong>模型控制。<strong>propagated_noise</strong>（低和高）模型在第 3 章中详细描述。</p>
<p>​ 基于以上内容，在扇出单元的输出处计算毛刺，并在扇出网络上进行相同的检查（以及毛刺传播到扇出），依此类推。</p>
<p>虽然我们在上面的讨论中使用了通用术语“毛刺”，但应注意，这分别适用于前一小节中提到的所有类型的毛刺：上升毛刺（由早期模型中的<strong>propagated_noise_high</strong>或<strong>noise_immunity_high</strong>建模），下降毛刺（由早期模型中的<strong>propagated_noise_low</strong>或<strong>noise_immunity_low</strong>建模），过冲毛刺（由<strong>noise_immunity_above_high</strong>建模）和欠冲毛刺（由<strong>noise_immunity_below_low</strong>建模）。</p>
<p>​ 总之，单元的不同输入对毛刺阈值有不同的限制，毛刺阈值是毛刺宽度和输出电容的函数。这些限制对于输入高（低转换毛刺）和输入低（高转换毛刺）是分开的。噪声分析会检查毛刺的峰值和宽度，并分析它是否可以被忽略或它是否可以传播到扇出。</p>
<h3 id="多个干扰源的噪声累积noise-accumulation-with-multiple-aggressors">多个干扰源的噪声累积（Noise Accumulation with Multiple Aggressors）</h3>
<p>​ 图 6-9 描述了由于单个攻击者网络切换和在受害网络上引入串扰毛刺引起的耦合。一般而言，受害网络可以电容耦合到许多网络。当多个网络同时切换时，由于有多个攻击者，串扰耦合噪声对受害者的影响更加复杂。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816133759845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于多个攻击者引起的耦合的大多数分析都会添加由于每个攻击者引起的毛刺效应，并计算对受害者的累积影响。这可能看起来很保守，但它确实表明了受害者最坏的情况。另一种方法是使用 RMS（均方根）方法。使用 RMS 选项时，受害设备上的毛刺幅度是通过取个别攻击者引起的毛刺的均方根来计算的。</p>
<h3 id="干扰源时序相关性aggressor-timing-correlation">干扰源时序相关性（Aggressor Timing Correlation）</h3>
<p>​ 对于由多个干扰源引起的串扰毛刺，分析必须包括干扰源网络的时序相关性，并确定多个干扰源是否可以同时切换。 STA 从攻击者网络的时序窗口中获取此信息。在时序分析过程中，得到网络最早和最晚的切换时间。这些时间代表网络可以在一个时钟周期内切换的时序窗口。切换窗口（上升和下降）提供有关攻击者网络是否可以一起切换的必要信息。</p>
<p>​ 根据多个干扰源是否可以同时切换，将单个干扰源造成的毛刺组合起来用于受害网络。作为第一步，毛刺分析为每个潜在干扰源分别计算四种类型的毛刺（上升、下降、欠冲和过冲）。下一步结合来自各个干扰源的故障贡献。多个干扰源可以针对每种类型的毛刺单独组合。例如，考虑耦合到攻击者网络 A1、A2、A3 和 A4 的受害者网络 V。在分析过程中，A1、A2 和 A4 可能会导致上升和过冲毛刺，而只有 A2 和 A3 会导致欠冲和下降毛刺。</p>
<p>​ 考虑另一个示例，其中当攻击者网络转换时，四个攻击者网络会导致上升的毛刺。图 6-10 显示了由每个攻击者网络引起的时序窗口和毛刺幅度。根据时序窗口，毛刺分析确定导致最大毛刺的干扰源切换的最坏可能组合。在这个例子中，切换窗口区域被分为四个 bin - 每个 bin 显示可能的干扰源切换。图 6-10 还描述了来自每个干扰源的毛刺贡献。 Bin 1 具有 A1 和 A2 切换，这可能导致 0.21 (= 0.11+ 0.10) 的毛刺幅度。 Bin 2 具有 A1、A2 和 A3 切换，这会导致毛刺幅度为 0.30 (= 0.11+ 0.10+ 0.09)。 Bin 3 具有 A1 和 A3 切换，这会导致毛刺幅度为 0.20 (= 0.11 +0.09)。 Bin 4 具有 A3 和 A4 切换，这会导致毛刺幅度为 0.32 (= 0.09+ 0.23)。</p>
<p>​ 因此，bin 4 具有 0.32 的最坏可能的毛刺幅度。请注意，不使用时序窗口的分析将预测组合毛刺幅度为 0.53 (= 0.11+ 0.10+ 0.09 +0.23)，这可能过于悲观。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816134634802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="干扰源功能相关性aggressor-functional-correlation">干扰源功能相关性（Aggressor Functional Correlation）</h3>
<p>​ 对于多个干扰源，通过考虑网络可能切换的切换窗口，使用时序窗口减少了分析中的悲观情绪。此外，另一个需要考虑的因素是各种信号之间的功能相关性。例如，scan（在DFT test mode） 控制信号仅在扫描模式期间切换，并且在设计的功能或任务模式期间稳定。因此，在功能模式期间，扫描控制信号不会对其他信号造成毛刺。扫描控制信号只能是扫描模式期间的干扰源。在某些情况下，测试时钟和功能时钟是相互排斥的，因此测试时钟仅在测试期间当功能时钟关闭时才有效。在这些设计中，由测试时钟控制的逻辑和由功能时钟控制的逻辑创建了两组不相交的干扰源。在这种情况下，测试时钟控制的干扰源不能与功能时钟控制的其他干扰源结合进行最坏情况噪声计算。功能相关的另一个例子是两个干扰源，它们是彼此的补充（逻辑相反）。在这种情况下，信号及其补码不能在相同方向上切换以计算串扰噪声。</p>
<p>​ 图 6-11 显示了网络 N1 与其他三个网络 N2、N3 和 N4 耦合的示例。在功能关联中，需要考虑网络的功能。假设网络 N4 是一个常数（例如，模式设置网络），因此不能成为网络 N1 上的干扰源，尽管它是耦合的。假设 N2 是一个网络，它是调试总线的一部分，但在功能模式下处于稳定状态。因此，网络 N2 不能成为网络 N1 的干扰源。假设网络 N3 携带功能数据，只有网络 N3 可以被视为网络 N1 的潜在干扰源。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816135228719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="串扰延迟分析crosstalk-delay-analysis">串扰延迟分析（Crosstalk Delay Analysis）</h2>
<h3 id="基础知识basics-1">基础知识（Basics）</h3>
<p>​ 纳米设计中典型网络的电容提取由许多相邻导体的贡献组成。其中一些是接地电容，而其他许多来自作为其他信号网络一部分的走线。接地电容和信号间电容如图 6-1 所示。在基本延迟计算期间，所有这些电容都被视为网络总电容的一部分（不考虑任何串扰）。当相邻网络稳定（或未切换）时，信号间电容可被视为接地。当相邻网络切换时，通过耦合电容的充电电流会影响网络的时序。根据攻击者网络切换的方向，从网络上看到的等效电容可以更大或更小。这在下面的一个简单示例中进行了解释。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816135701239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 6-12 显示了网络 N1，它有一个到相邻网络（标记为 Aggressor）的耦合电容 Cc 和一个到地的电容 Cg。此示例假设网络 N1 在输出端具有上升过渡，并根据攻击者网络是否同时切换来考虑不同的场景。</p>
<p>​ 如下文所述，驱动单元在各种情况下所需的电容性电荷可能不同。</p>
<ul>
<li>攻击者网络处于稳定状态：在这种情况下，网络N1的驱动单元将提供电荷使Cg和Cc充电至Vdd。因此，该网络的驱动单元提供的总电荷为（Cg + Cc）* Vdd。这种情况可以进行基本的延迟计算，因为在这种情况下未考虑来自攻击者网络的串扰。表6-13中为此情况下在网络N1电平切换前后Cg和Cc中的电荷量：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210816141300400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>攻击者网络朝同方向切换电平： 在这种情况下，往同方向电平切换的攻击者网络可以起辅助驱动单元的作用。如果攻击者网络同时以相同的转换slew（相同的transition time）进行电平切换，则驱动单元提供的总电荷仅为（Cg * Vdd ）。如果攻击者网络的转换比N1网络转换更快，则所需的实际电荷可能甚至小于（Cg * Vdd），因为攻击者网络也可以为Cg提供充电电流。因此，在攻击者朝相同方向切换电平时，来自驱动单元的所需电荷会小于表6-13中描述的攻击者处于稳定状态时的所需电荷。因此，当攻击者网络朝相同方向切换电平时会导致网络N1切换电平的延迟更短， 延迟的减少被标记为负串扰延迟（negative crosstalk delay）。这种情况请参见表6-14，通常会在进行最小路径分析时考虑此情况。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021081614141976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>攻击者网络朝相反方向切换电平：在这种情况下，耦合电容需要从-Vdd充电到Vdd。因此在电平切换前后，耦合电容上的电荷变化量为（2 * Cc * Vdd），网络N1的驱动单元以及攻击者网络均需要提供额外的电荷。这种情况会导致网络N1切换电平的延迟更大，延迟的增加被标记为正串扰延迟（positive crosstalk delay）。这种情况请参阅表6-15，通常会在进行最大路径分析时考虑此情况。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210816141630904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 上面的例子说明了 Cc 在各种情况下的充电以及它如何影响交换网络的延迟（标记为 N1）。该示例仅考虑网络 N1 处的上升过渡，但类似的分析也适用于下降过渡。</p>
<h3 id="正负串扰positive-and-negative-crosstalk">正负串扰（Positive and Negative Crosstalk）</h3>
<p>​ 基本延迟计算（没有任何串扰）假设驱动单元为网络总电容 Ctotal (= Cground +Cc) 的轨到轨（rail-to-rail）转换提供所有必要的电荷。如前一小节所述，当耦合（攻击者）网络和受害者网络在相反方向切换时，耦合电容 Cc 所需的电荷更大。在相反方向上的攻击者切换增加了受害网络的驱动单元所需的电荷量，并增加了受害网络的驱动单元和互连的延迟。</p>
<p>​ 类似地，当耦合（攻击者）网络和受害者网络在同一方向切换时，Cc 上的电荷在受害者和攻击者转换之前和之后保持不变。这减少了受害网络的驱动单元所需的电荷。减少了驱动单元和受害网络互连的延迟。</p>
<p>​ 如上所述，受害者和攻击者的并发切换会影响受害者转换的时间。根据干扰源的切换方向，串扰延迟效应可以是正的（减缓受害转换）或负的（加速受害转换）。</p>
<p>​ 图 6-16 显示了正串扰延迟效应的示例。当受害网络发生下降过渡时，攻击者网络正在上升。相反方向的攻击者网络切换增加了受害网络的延迟。正串扰会影响驱动单元和互连——这两者的延迟都会增加。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816142120804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图6-17显示了串扰延迟为负的情况。攻击者网络与受害者网络同时上升，攻击者网络与受害者网络朝相同方向的电平切换可减少受害者网络的延迟。如前所述，负串扰（negative crosstalk）会影响驱动单元和互连线的时序，两者的延迟都会减小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816142342734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 注意，最差的正串扰延迟和最差的负串扰延迟会分别针对上升和下降延迟进行计算。一般来说，由于串扰而导致的最大上升时间、最小上升时间、最大下降时间、最大下降时间延迟的干扰源是不同的，这将在下面的小节中进行介绍。</p>
<h3 id="多个干扰源的累积accumulation-with-multiple-aggressors">多个干扰源的累积（Accumulation with Multiple Aggressors）</h3>
<p>​ 具有多个干扰源的串扰延迟分析涉及对每个干扰源的串扰造成的影响进行累加。这类似于第 6.2 节中描述的串扰毛刺分析。当多个网络同时切换时，由于多个攻击者，对受害者的串扰延迟效应会变得更加复杂。</p>
<p>​ 由于多个干扰源引起的耦合的大多数分析都会添加每个攻击者的增量贡献并计算对受害者的累积影响。这可能看起来很保守，但它确实表明受害设备上的最坏情况串扰延迟。</p>
<p>​ 与用于串扰毛刺分析的多个干扰源的分析类似，也可以使用均方根 (RMS) 来添加贡献，这比单个贡献的直和更不悲观。</p>
<h3 id="攻击者-受害者时间相关性aggressor-victim-timing-correlation">攻击者-受害者时间相关性（Aggressor Victim Timing Correlation）</h3>
<p>​ 串扰延迟分析的时序相关处理在概念上类似于第 6.2 节中描述的串扰毛刺分析的时序相关。串扰会影响受害者的延迟，前提是攻击者可以与受害者同时切换。这是使用攻击者和受害者的时序窗口确定的。如第 6.2 节所述，时序窗口表示网络可以在一个时钟周期内切换的最早和最晚切换时间。如果攻击者和受害者的时序窗口重叠，则计算串扰对延迟的影响。对于多个攻击者，多个攻击者的时序窗口也进行了类似的分析。计算各种时序仓中的可能影响，并考虑串扰延迟影响最严重的时序仓进行延迟分析。</p>
<p>​ 考虑下面的示例，其中三个攻击者网络可以影响受害者网络的时间。攻击者网络 (A1, A2, A3) 电容耦合到受害者网络 (V) 并且它们的时序窗口与受害者网络重叠。图 6-18 显示了时序窗口和每个干扰源可能造成的串扰延迟影响。基于时序窗口，串扰延迟分析确定引起最大串扰延迟影响的干扰源切换的最坏可能组合。在这个例子中，时间窗口重叠区域被分成三个 bin - 每个 bin 显示可能的攻击者切换。 Bin 1 具有 A1 和 A2 切换，这会导致串扰延迟影响为 0.26 (= 0.12 +0.14)。 Bin 2 具有 A1 切换，这会导致 0.14 的串扰延迟影响。 Bin 3 具有 A3 切换，可导致 0.23 的串扰延迟影响。因此，bin 1 具有 0.26 的最坏可能的串扰延迟影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816150505788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如前所述，串扰延迟分析将分别计算四种类型的串扰延迟。串扰延迟的四种类型是：正上升延迟（上升沿提前到达）、负上升延迟（上升沿滞后到达）、正下降延迟和负下降延迟。通常，在这四种情况下，网络可以具有不同的攻击者组合。例如，受害者网络具有攻击者网络A1、A2、A3和A4。在串扰延迟分析过程中，A1、A2、A4可能对正上升和负下降延迟有影响，而A2和A3对负上升和正下降延迟有影响。</p>
<h3 id="攻击者-受害者功能相关性aggressor-victim-functional-correlation">攻击者-受害者功能相关性（Aggressor Victim Functional Correlation）</h3>
<p>​ 除了时序窗口，串扰延迟计算还可以考虑各种信号之间的功能相关性。例如，扫描控制信号仅在扫描模式期间切换并且在设计的功能或任务模式期间稳定。因此，扫描控制信号在功能模式期间不能成为干扰源。在扫描模式期间，扫描控制信号只能是干扰源，在这种情况下，这些信号不能与其他功能信号组合以进行最坏情况噪声计算。</p>
<p>​ 功能相关的另一个例子是两个干扰源互为补充的场景。在这种情况下，信号及其补码永远不能在相同方向上切换以计算串扰噪声。当可用时，可以利用这种类型的函数相关信息，从而通过确保只有实际可以一起切换的信号作为干扰源被包括在内，从而使串扰分析结果不悲观。</p>
<h2 id="使用串扰延迟进行时序验证timing-verification-using-crosstalk-delay">使用串扰延迟进行时序验证（Timing Verification Using Crosstalk Delay）</h2>
<p>​ 需要为设计中的每个单元和互连线计算以下四种类型的串扰延迟影响：</p>
<ul>
<li>正上升延迟（Positive rise delay）：上升沿提前到达</li>
<li>负上升延迟（Negative rise delay）：上升沿滞后到达</li>
<li>正下降延迟（Positive fall delay）：下降沿提前到达</li>
<li>负下降延迟（Negative fall delay）：下降沿滞后到达</li>
</ul>
<p>​ 然后在时序分析期间利用串扰延迟贡献来验证最大和最小路径（setup and hold checks）。启动和捕获触发器的时钟路径处理方式不同。本节描述了用于建立和保持检查的数据路径和时钟路径分析的详细信息。</p>
<h3 id="建立时间分析setup-analysis">6.4.1建立时间分析（Setup Analysis）</h3>
<p>​ 具有串扰分析功能的 STA 使用数据路径和时钟路径的最坏情况串扰延迟来验证设计。考虑图 6-19 中所示的逻辑，其中数据路径和时钟路径上的各种网络可能会发生串扰。建立时间检查的最坏情况是启动时钟路径（launch clock path）和数据路径都具有正串扰，而捕获时钟路径（capture clock path）具有负串扰。发射时钟路径和数据路径上的正串扰贡献延迟了数据到达捕获触发器。此外，捕获时钟路径上的负串扰导致捕获触发器提前计时。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816152033601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 基于以上描述，建立时间（或最大路径）分析假设：</p>
<ul>
<li>发起时钟路径出现正串扰延迟，因此发起数据较迟。</li>
<li>数据路径出现正串扰延迟，因此数据到达目的地需要更长的时间。</li>
<li>捕获时钟路径出现负串扰延迟，因此数据被捕获触发器提早捕获。</li>
</ul>
<p>​ 由于建立时间检查的启动和捕获时钟沿不同（通常相隔一个时钟周期），公共时钟路径（图 6-19）可能对启动和捕获时钟沿有不同的串扰贡献。</p>
<h3 id="保持时间分析hold-analysis">6.4.2保持时间分析（Hold Analysis）</h3>
<p>​ STA 的最坏情况保持时间（或最小路径）分析类似于上一小节中描述的最坏情况设置分析。根据图 6-19 中所示的逻辑，当启动时钟路径和数据路径都具有负串扰并且捕获时钟路径具有正串扰时，会发生保持时间检查的最坏情况。发射时钟路径和数据路径上的负串扰贡献导致数据提前到达捕获触发器。此外，捕获时钟路径上的正串扰导致捕获触发器的时钟延迟。</p>
<p>​ 与时钟路径公共部分上的串扰相关的保持时间和建立时间分析之间存在一个重要区别。对于保持时间分析，启动和捕获时钟边沿通常是相同的边沿。通过公共时钟部分的时钟沿不能对启动时钟路径和捕获时钟路径具有不同的串扰贡献。因此，最坏情况保持时间分析消除了公共时钟路径中的串扰影响。</p>
<p>​ 因此，具有串扰的STA最差情况保持时间（或最小路径）分析将假定：</p>
<ul>
<li>发起时钟（不包括公共时钟路径部分）的串扰延迟影响为负，因此可以较早地发起数据；</li>
<li>数据路径的串扰延迟影响为负，因此数据会较早到达目的地；</li>
<li>捕获时钟（不包括公共时钟路径部分）的串扰延迟影响为正，因此捕获触发器会较迟地捕获数据</li>
</ul>
<p>​ 如上所述，保持时间分析不考虑对时钟树公共部分的串扰影响。仅针对时钟树的非公共部分计算启动时钟的正串扰贡献和捕获时钟的负串扰贡献。在用于保持分析的 STA 报告中，公共时钟路径可能会显示启动时钟路径和捕获时钟路径的不同串扰贡献。然而，来自公共时钟路径的串扰贡献作为单独的行项目被移除，标记为公共路径悲观消除。 STA 报告中常见路径悲观消除的示例在第 10.1 节中提供。</p>
<p>​ 如前一小节所述，建立时间分析涉及时钟的两个不同边沿，它们可能会在时序上受到不同的影响。因此，在建立时间分析期间，对启动和捕获时钟路径都考虑了公共路径串扰贡献。</p>
<p>​ 时钟信号至关重要，因为时钟树上的任何串扰都会直接转化为时钟抖动并影响设计的性能。因此，应特别考虑减少时钟信号上的串扰。一种常见的噪声避免方法是时钟树的屏蔽——这将在第 6.6 节中详细讨论。</p>
<h2 id="计算复杂性computational-complexity">计算复杂性（Computational Complexity）</h2>
<p>​ 大型纳米设计通常过于复杂，无法在合理的周转时间内分析每个耦合电容。典型网络的寄生提取包含与许多相邻信号的耦合电容。大型设计通常需要为寄生提取和串扰延迟和毛刺分析进行适当的设置。选择这些设置是为了提供可接受的分析精度，同时确保 CPU 要求仍然可行。本节介绍一些可用于分析大型纳米设计的技术。</p>
<p><strong>分层设计和分析（Hierarchical Design and Analysis）</strong></p>
<p>​ 第 4.5 节介绍了验证大型设计的分层方法。类似的方法也适用于降低提取和分析的复杂性。</p>
<p>​ 对于大型设计，在一次运行中获得寄生提取通常是不切实际的。可以单独提取每个分层块的寄生参数。这反过来又要求在设计实现中使用分层设计方法。这意味着分层块内的信号和块外的信号之间没有耦合。这可以通过在块上不布线或通过在块上添加屏蔽层来实现。此外，信号网络不应靠近模块边界布线，靠近模块边界布线的任何网络都应屏蔽。这避免了与来自其他块的网络的任何耦合。</p>
<p><strong>耦合电容滤波（Filtering of Coupling Capacitances）</strong></p>
<p>​ 即使对于中等大小的模块，寄生效应通常也会包括大量非常小的耦合电容。可以在提取或分析过程中过滤小耦合电容。</p>
<p>这样的过滤是基于以下原则的：</p>
<ul>
<li>较小的值：在串扰或噪声分析中，可以忽略非常小的耦合电容，例如低于1fF。在提取过程中，数值较小的耦合电容可以视为接地电容。</li>
<li>耦合比：耦合对受害者网络的影响是基于耦合电容相对于受害者网络总电容的相对值。具有较小耦合比（例如低于0.001）的攻击者网络可以从串扰延迟分析或串扰毛刺分析中排除。</li>
<li>合并小型干扰源：可以将影响很小的多个干扰源映射为一个较大的虚拟干扰源。这可能有点悲观，但可以简化分析。可以通过切换干扰源的子集来缓解一些悲观度，干扰源的确切子集可以通过统计方法来确定。</li>
</ul>
<h2 id="噪声避免技术noise-avoidance-techniques">噪声避免技术（Noise Avoidance Techniques）</h2>
<p>​ 前面的部分描述了串扰效应的影响和分析。在本节中，我们将介绍一些可在物理设计阶段使用的噪声避免技术。</p>
<ul>
<li>屏蔽（Shielding）：此方法要求将屏蔽线放置在关键信号的任一侧。屏蔽连接到电源或接地导轨。关键信号的屏蔽确保关键信号没有主动干扰源，因为同一金属层中最近的邻居是固定电位的屏蔽走线。虽然不同金属层中的路径可能存在一些耦合，但大多数耦合电容是由于同一层中的电容耦合。由于不同金属层（上方和下方）通常会正交走线，这样跨层的电容耦合会最小化。因此，将屏蔽线放置在同一金属层中可确保关键信号的耦合最小。在由于布线拥塞而无法使用接地或电源轨进行屏蔽的情况下，具有低开关活动（例如在功能模式期间固定的扫描控制）的信号可以作为关键信号的直接邻居进行布线。这些屏蔽方法可确保不会因相邻设备的电容耦合而产生串扰。</li>
<li>线间距（Wire spacing）：这减少了与相邻网络的耦合。</li>
<li>快速转换率（Fast slew rate）：网络上的快速转换率意味着网络不易受串扰影响，并且本质上不受串扰效应的影响。</li>
<li>保持良好的稳定电源（Maintain good stable supply）：这对于减少由于电源变化引起的抖动而不是串扰很重要。由于电源上的噪声，时钟信号上可能会引入大量噪声。应添加足够的去耦电容以将电源噪声降至最低。</li>
<li>保护环（Guard ring）：基板中的保护环（或双保护环）有助于保护关键模拟电路免受数字噪声的影响。</li>
<li>深 n 阱（Deep n-well）：这与上述类似，因为模拟部分具有深 n 阱有助于防止噪声耦合到数字部分。</li>
<li>隔离块（Isolating a block）：在分层设计流程中，可以将布线晕圈（halos）添加到块的边界；此外，还可以将隔离缓冲器（isolation buffers）添加到块的每个IO中。</li>
</ul>
<h1 id="配置-sta-环境configuring-the-sta-environment">配置 STA 环境（Configuring the STA Environment）</h1>
<blockquote>
<p>第 7 章是后续章节的先决条件。它描述了如何配置时序分析环境。描述了指定时钟、IO 特性、伪路径和多周期路径的方法。</p>
</blockquote>
<p>正确约束的说明对于分析STA结果非常重要。应准确指定设计环境，以便STA分析能够识别设计中的所有时序问题。STA的准备包括设置时钟、指定IO定时特性以及指定伪路径和多周期路径。在继续下一章关于时间验证之前，彻底理解本章非常重要。</p>
<h2 id="什么是sta环境what-is-the-sta-environment">什么是STA环境？（What is the STA Environment?）</h2>
<p>​ 大多数数字设计都是同步的，从上一个时钟周期计算的数据锁存在活动时钟边缘的触发器中。考虑图7-1所示的典型同步设计，假设分析设计（DUA）与其他同步设计相互作用。这意味着DUA从时钟触发器接收数据，并将数据输出到DUA外部的另一个时钟触发器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816171100811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 要在此设计上执行STA，需要指定触发器的时钟，以及通向设计的所有路径和退出设计的所有路径的时序约束。</p>
<p>​ 图7-1中的示例假设只有一个时钟，C1、C2、C3、C4和C5表示组合块。组合块C1和C5不在所分析的设计范围内。</p>
<p>​ 在典型设计中，从一个时钟域到另一个时钟域可以有多个时钟，具有多条路径。以下各节介绍如何在此类场景中指定环境。</p>
<h2 id="指定时钟specifying-clocks">指定时钟（Specifying Clocks）</h2>
<p>​ 要定义时钟，我们需要提供以下信息：</p>
<ul>
<li>时钟源（Clock source）：它可以是设计的端口，也可以是设计内部单元的引脚（通常是时钟生成逻辑的一部分）。</li>
<li>周期（Period）：时钟的周期。</li>
<li>占空比（Duty cycle）：高电平持续时间（正相位）和低电平持续时间（负相位）。</li>
<li>边沿时间（Edge times）：上升沿和下降沿的时刻。</li>
</ul>
<p>​ 图7-2显示了基本定义。通过定义时钟，所有内部时序路径（所有触发器到触发器路径）都受到约束；这意味着所有内部路径都可以仅使用时钟规格进行分析。时钟规范规定触发器到触发器的路径必须占用一个周期。我们将在后面描述如何放宽这一要求（一个周期时间）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816171510415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是一个基本的时钟约束规范：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create_clock \</span><br><span class="line"></span><br><span class="line"><span class="deletion">-name SYSCLK \</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-period 20 \</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-waveform &#123;0 5&#125; \</span></span><br><span class="line"></span><br><span class="line">[get_ports2SCLK]</span><br></pre></td></tr></table></figure>
<p>​ 时钟的名称为SYSCLK，在端口SCLK处定义。SYSCLK的周期指定为20个单位-如果未指定，则默认时间单位为纳秒(通常，时间单位指定为技术库的一部分。）波形中的第一个参数指定上升沿出现的时间，第二个参数指定下降沿出现的时间。</p>
<p>​ <strong>waveform</strong>选项中可以指定任意数量的边。但是，所有边缘必须在一个周期内。沿时间从时间零点后的第一个上升沿开始交替，然后是下降沿，然后是上升沿，依此类推。这意味着<strong>waveform</strong>列表中的所有时间值必须是单调递增的。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-waveform &#123;time_rise time_fall time_rise time_fall ...&#125;</span></span><br></pre></td></tr></table></figure>
<p>​ 此外，必须指定偶数条边。 <strong>waveform</strong>选项指定一个时钟周期内的波形，然后该时钟周期自身重复。</p>
<p>​ 如果未指定<strong>waveform</strong>选项，默认值为：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-waveform &#123;0, period/2&#125;</span></span><br></pre></td></tr></table></figure>
<p>​ 这里是一个没有波形规范的时钟规范示例（见图7-3）。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period <span class="number">5</span> <span class="selector-attr">[get_ports SCAN_CLK]</span></span><br></pre></td></tr></table></figure>
<p>​ 在此约束中，由于未指定<strong>-name</strong>选项，因此时钟的名称与端口的名称相同，即SCAN_CLK。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816174503166.png" alt="img"></p>
<p>​ 以下是时钟约束的另一个示例，其中波形的边沿在一个周期的中间位置（见图7-4）。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name BDYCLK -period <span class="number">15</span> \</span><br><span class="line"></span><br><span class="line">-waveform &#123;<span class="number">5</span> <span class="number">12</span>&#125; <span class="selector-attr">[get_ports GBLCLK]</span></span><br></pre></td></tr></table></figure>
<p>​ 时钟的名称为BDYCLK，在端口GBLCLK处定义。实际上，保持时钟名称与端口名称相同是一个好主意。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816174641550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这里有更多的时钟约束示例。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See Figure 7-5(a):</span></span><br><span class="line"></span><br><span class="line">create_clock -period 10 -<span class="keyword">waveform</span> &#123;<span class="number">5</span> <span class="number">10</span>&#125; [get_ports FCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a clock with the rising edge at 5ns and the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># falling edge at 10ns.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See Figure 7-5(b):</span></span><br><span class="line"></span><br><span class="line">create_clock -period 125 \</span><br><span class="line"></span><br><span class="line">-<span class="keyword">waveform</span> &#123;<span class="number">100</span> <span class="number">150</span>&#125; [get_ports ARMCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Since the first edge has to be rising edge,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the edge at 100ns is specified first and then the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># falling edge at 150ns is specified. The falling edge</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at 25ns is automatically inferred.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021081617482936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See Figure 7-6(a):</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">1.0</span> -waveform &#123;<span class="number">0.5</span> <span class="number">1.375</span>&#125; MAIN_CLK</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first rising edge and the next falling edge</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is specified. Falling edge at 0.375ns is inferred</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># automatically.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See Figure 7-6(b):</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">1.2</span> -waveform &#123;<span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.8</span> <span class="number">1.0</span>&#125; JTAG_CLK</span><br><span class="line"></span><br><span class="line"><span class="comment"># Indicates a rising edge at 300ps, a falling edge at 400ps,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a rising edge at 800ps and a falling edge at 1ns, and this</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pattern is repeated every 1.2ns.</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">1.27</span> \</span><br><span class="line"></span><br><span class="line">-waveform &#123;<span class="number">0</span> <span class="number">0.635</span>&#125; [get_ports clk_core]</span><br><span class="line"></span><br><span class="line">create_clock -name TEST_CLK -period <span class="number">17</span> \</span><br><span class="line"></span><br><span class="line">-waveform &#123;<span class="number">0</span> <span class="number">8.5</span>&#125; -add [get_ports &#123;ip_io_clk[<span class="number">0</span>]&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -add option allows more than one clock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specification to be defined at a port.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210816175123952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><em>锁相环PLL（Phase-locked loop）：在专用集成电路中常用来产生高频时钟 。</em></p>
<p>​ 除上述属性外，还可以选择指定时钟源处的转换时间。在某些情况下，例如某些PLL模型的输出或输入端口，该工具无法自动计算过渡时间。在这种情况下，明确指定时钟源处的转换时间非常有用。这是使用<strong>set_clock_transition</strong>命令指定的。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_clock_transition -rise <span class="number">0.1</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br><span class="line"></span><br><span class="line">set_clock_transition -fall <span class="number">0.12</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br></pre></td></tr></table></figure>
<p>​ 这个约束仅适用于理想时钟，一旦构建了时钟树就将其忽略，因为此时将会使用时钟引脚上的实际过渡时间。如果在输入端口上定义了时钟，也可以使用<strong>set_input_transition</strong>命令（参见7.7节）来约束时钟的转换。</p>
<h3 id="时钟不确定性clock-uncertainty">时钟不确定性（Clock Uncertainty）</h3>
<p>​ 可以使用 set_clock_uncertainty 约束指定时钟周期的时序不确定性。不确定性可用于模拟可以减少有效时钟周期的各种因素。这些因素可以是时钟抖动和任何其他可能希望用于时序分析的悲观因素。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_clock_uncertainty -setup <span class="number">0.2</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -hold <span class="number">0.05</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br></pre></td></tr></table></figure>
<p>​ 注意，建立时间检查的时钟不确定度将减少可用的有效时钟周期，如图7-7所示。对于保持时间检查，时钟不确定度将用作需要满足的额外时序裕量。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816180618575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下命令可用于指定跨时钟边界路径上的时钟不确定度，称为时钟间不确定度（inter-clock uncertainty）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> VIRTUAL_SYS_CLK -<span class="selector-tag">to</span> SYS_CLK \</span><br><span class="line"></span><br><span class="line">-hold <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> VIRTUAL_SYS_CLK -<span class="selector-tag">to</span> SYS_CLK \</span><br><span class="line"></span><br><span class="line">-setup <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> SYS_CLK -<span class="selector-tag">to</span> CFG_CLK -hold <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> SYS_CLK -<span class="selector-tag">to</span> CFG_CLK -setup <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>​ 图 7-8 显示了两个不同时钟域 SYS_CLK 和 CFG_CLK 之间的路径。根据上述时钟间不确定性约束，100ps 用作建立时间检查的不确定性，50ps 用作保持时间检查的不确定性。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816180942927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="时钟延迟clock-latency">时钟延迟（Clock Latency）</h3>
<p>​ 可以使用<strong>set_clock_latency</strong>命令指定时钟的延迟。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rise clock latency on MAIN_CLK is 1.8ns:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency <span class="number">1.8</span> -rise [get_clocks MAIN_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fall clock latency on all clocks is 2.1ns:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency <span class="number">2.1</span> -fall [all_clocks]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -rise, -fall refer to the edge at the clock pin of a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flip-flop.</span></span><br></pre></td></tr></table></figure>
<p>​ 时钟延迟有两种类型：网络延迟（network latency）和源延迟（source latency）。网络延迟是从时钟定义点 (create_clock) 到触发器时钟引脚的延迟。源延迟，也称为插入延迟（insertion delay），是从时钟源到时钟定义点的延迟。源延迟可以代表片上或片外延迟。图 7-9 显示了这两种情况。触发器时钟引脚的总时钟延迟是源延迟和网络延迟的总和。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816181315130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 下面是一些指定源和网络延迟的示例命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify a network latency (no -source option) of 0.8ns for</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rise, fall, max and min:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 0.8 [get_clocks CLK_CONFIG]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a source latency:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 1.9 -<span class="built_in">source</span> [get_clocks SYS_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a min source latency:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 0.851 -<span class="built_in">source</span> -min [get_clocks CFG_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a max source latency:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 1.322 -<span class="built_in">source</span> -max [get_clocks CFG_CLK]</span><br></pre></td></tr></table></figure>
<p>​ 源延迟和网络延迟之间的一个重要区别是：一旦为设计建立了时钟树，就可以忽略网络延迟（假设指定了<strong>set_propagated_clock</strong>命令）。但是，即使在建立时钟树之后，源延迟也会保留。网络延迟是在进行时钟树综合（Clock Tree Synthesis）之前对时钟树延迟的估计值。在时钟树综合完成后，从时钟源到触发器时钟引脚的总时钟延迟是源延迟加上时钟树从时钟定义点到触发器的实际延迟。</p>
<p>​ 生成时钟在下一节中描述，虚拟时钟在 7.9 节中描述。</p>
<h2 id="生成时钟generated-clocks">生成时钟（Generated Clocks）</h2>
<p>​ 生成时钟是从主时钟派生的时钟。主时钟是使用 <strong>create_clock</strong> 命令定义的时钟。</p>
<p>​ 在基于主时钟的设计中生成新时钟时，可以将新时钟定义为生成时钟。例如，如果时钟有一个 3 分频电路，则可以在该电路的输出端定义一个生成时钟。这个定义是必需的，因为 STA 不知道分频逻辑输出端的时钟周期已经改变，更重要的是新的时钟周期是什么。图 7-10 显示了生成时钟的示例，该时钟是主时钟 CLKP 的 2 分频。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816181909431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name CLKP 10 [get_pins UPLL0/CLKOUT]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a master clock with name CLKP of period 10ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with 50% duty cycle at the CLKOUT pin of the PLL.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">create_generated_clock -name CLKPDIV2 -<span class="built_in">source</span> UPLL0/CLKOUT \</span><br><span class="line"></span><br><span class="line">-divide_by 2 [get_pins UFF0/Q]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a generated clock with name CLKPDIV2 at the Q</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pin of flip-flop UFF0. The master clock is at the CLKOUT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pin of PLL. And the period of the generated clock is double</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># that of the clock CLKP, that is, 20ns.</span></span><br></pre></td></tr></table></figure>
<p>​ 可以在触发器的输出端口定义一个新时钟是主时钟，而非生成时钟吗？答案是肯定的，这确实是可能的，但是它也有一些缺点。定义主时钟而不是生成时钟会创建一个新的时钟域。通常这不是问题，除了在设置STA约束时需要处理更多的时钟域外。相反，将新时钟定义为生成时钟不会创建新的时钟域，并且生成时钟会被认为与其主时钟同相，生成时钟不需要进行额外的约束。因此，尽量将内部新生成的时钟定义为生成时钟，而不是将其声明为另一个主时钟。</p>
<p>​ 主时钟和生成时钟之间的另一个重要区别是时钟源的概念。在主时钟中，时钟的源点位于主时钟的定义点。在生成时钟中，时钟源是主时钟的源，而不是生成时钟的源。这意味着在时钟路径报告中，时钟路径的起点始终是主时钟定义点。这是生成时钟相对于定义新主时钟的一大优势，因为对于新主时钟的情况不会自动包含源延迟。</p>
<p>​ 图 7-11 显示了一个多路复用器的示例，其两个输入都有时钟。在这种情况下，无需在多路复用器的输出上定义时钟。如果选择信号设置为常数，多路复用器的输出会自动获得正确的时钟传播。如果多路复用器的选择引脚不受约束，则两个时钟都通过多路复用器传播以供 STA 使用。在这种情况下，STA 可能会报告 TCLK 和 TCLKDIV5 之间的路径。请注意，这种路径是不可能的，因为选择线只能选择多路复用器输入之一。在这种情况下，可能需要设置一条错误路径或指定这两个时钟之间的独占时钟关系，以避免报告错误路径。这当然假设设计中其他地方的 TCLK 和 TCLKDIV5 之间没有路径。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816182406213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果多路复用器选择信号不是静态的并且可以在设备操作期间发生变化，会发生什么情况？在这种情况下，会对多路复用器输入端进行时钟门控（clock gating）检查。时钟门控检查在第 10 章中解释；这些检查确保多路复用器输入处的时钟相对于多路复用器选择信号安全切换。</p>
<p>​ 图 7-12 显示了一个示例，其中时钟 SYS_CLK 由触发器的输出进行门控。由于触发器的输出可能不是常数，因此处理这种情况的一种方法是在和单元的输出处定义一个与输入时钟相同的生成时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816182624967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create_clock 0.1 [get_ports SYS_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a master clock of period 100ps with 50%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># duty cycle.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">create_generated_clock -name CORE_CLK -divide_by 1 \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> SYS_CLK [get_pins UAND1/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a generated clock called CORE_CLK at the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output of the and cell and the clock waveform is</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># same as that of the master clock.</span></span><br></pre></td></tr></table></figure>
<p>​ 下一个示例是频率高于源时钟频率的生成时钟。图 7-13 显示了波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816182823594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period 10 -waveform &#123;0 5&#125; [get_ports PCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a master clock with name PCLK of period 10ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with rise edge at 0ns and fall edge at 5ns.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name PCLKx2 \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> [get_ports PCLK] \</span><br><span class="line"></span><br><span class="line">-multiply_by 2 [get_pins UCLKMULTREG/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a generated clock called PCLKx2 from the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># master clock PCLK and the frequency is double that of</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the master clock. The generated clock is defined at the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output of the flip-flop UCLKMULTREG.</span></span><br></pre></td></tr></table></figure>
<p>​ 请注意，-multiply_by 和 -divide_by 选项指的是时钟频率，即使在主时钟定义中指定了时钟周期。</p>
<p><strong>时钟门控单元输出的主时钟示例（Example of Master Clock at Clock Gating Cell Output）</strong></p>
<p>​ 考虑图7-14中所示的时钟门控示例，两个时钟分别输入进一个与门单元中，问题是与门单元的输出是什么呢？如果与门单元的输入均为时钟，则可以安全地在与门单元的输出端定义一个新的主时钟，因为该单元的输出与任何一个输入时钟都没有相位关系的可能性很小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816183141286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name SYS_CLK -period <span class="number">4</span> -waveform &#123;<span class="number">0</span> <span class="number">2</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_pins UFFSYS/Q]</span></span><br><span class="line"></span><br><span class="line">create_clock -name CORE_CLK -period <span class="number">12</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_pins UFFCORE/Q]</span></span><br><span class="line"></span><br><span class="line">create_clock -name MAIN_CLK -period <span class="number">12</span> -waveform &#123;<span class="number">0</span> <span class="number">2</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_pins UAND2/Z]</span></span><br><span class="line"></span><br><span class="line"># Create <span class="selector-tag">a</span> master clock instead of <span class="selector-tag">a</span> generated clock</span><br><span class="line"></span><br><span class="line"># at the output of the and cell.</span><br></pre></td></tr></table></figure>
<p>​ 在内部引脚上创建时钟的一个缺点是它会影响路径延迟计算并迫使设计人员手动计算源延迟。</p>
<p><strong>使用Edge和Edge_shift选项生成时钟（Generated Clock using Edge and Edge_shift Options）</strong></p>
<p>​ 图 7-15 显示了生成时钟的示例。除了两个异相时钟之外，还会生成一个 2 分频时钟。图中还显示了时钟的波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816183432972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 下面给出了该示例中所有时钟的定义。衍生时钟的定义使用了<strong>-edges</strong>选项，这是定义衍生时钟的另一种方法。该选项采用源主时钟{上升，下降，上升}的边沿列表，以形成新的衍生时钟。主时钟的第一个上升沿是沿1，第一个下降沿是沿2，下一个上升沿是沿3，依此类推。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">create_clock 2 [get_ports DCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Name of clock is DCLK, has period of 2ns with a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rise edge at 0ns and a fall edge at 1ns.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name DCLKDIV2 -edges &#123;2 4 6&#125; \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> DCLK [get_pins UBUF2/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The generated clock with name DCLKDIV2 is defined at</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the output of the buffer. Its waveform is formed by</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># having a rise edge at edge 2 of the source clock,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fall edge at edge 4 of the source clock and the next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rise edge at edge 6 of the source clock.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name PH0CLK -edges &#123;3 4 7&#125; \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> DCLK [get_pins UAND0/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The generated clock PH0CLK is formed using</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the 3, 4, 7 edges of the source clock.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name PH1CLK -edges &#123;1 2 5&#125; \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> DCLK [get_pins UAND1/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The generated clock with name PH1CLK is defined at</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the output of the and cell and is formed with</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># edges 1, 2 and 5 of the source clock.</span></span><br></pre></td></tr></table></figure>
<p>​ 如果生成时钟的第一个边沿是下降沿怎么办？考虑生成的时钟 G3CLK，如图 7-16 所示。可以通过指定边沿 5、7 和 10 来定义此类生成的时钟，如下面的时钟约束所示。自动推断 1ns 处的下降沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816194947185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_generated_clock -name G3CLK -edges &#123;<span class="number">5</span> <span class="number">7</span> <span class="number">10</span>&#125; \</span><br><span class="line"></span><br><span class="line">-source DCLK <span class="selector-attr">[get_pins UAND0/Z]</span></span><br></pre></td></tr></table></figure>
<p>​ -edge_shift 选项可与 -edges 选项结合使用，以指定相应边沿的任何移位以形成新生成的波形。它指定边列表中每个边的移动量（以时间为单位）。这是使用此选项的示例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period 10 -waveform &#123;0 5&#125; [get_ports MIICLK]</span><br><span class="line"></span><br><span class="line">create_generated_clock -name MIICLKDIV2 -<span class="built_in">source</span> MIICLK \</span><br><span class="line"></span><br><span class="line">-edges &#123;1 3 5&#125; [get_pins UMIICLKREG/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a divide-by-2 clock.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name MIIDIV2 -<span class="built_in">source</span> MIICLK \</span><br><span class="line"></span><br><span class="line">-edges &#123;1 1 5&#125; -edge_shift &#123;0 5 0&#125; [get_pins UMIIDIV/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a divide-by-2 clock with a duty cycle different</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from the source clock&#x27;s value of 50%.</span></span><br></pre></td></tr></table></figure>
<p>​ 边沿列表中的边沿列表必须按非递减顺序排列，但同一边沿可用于两个条目以指示独立于源时钟占空比的时钟脉冲。上例中的 -edge_shift 选项指定第一个边沿是通过将（源时钟的边沿 1）移动 0ns 获得的，第二个边沿是通过将（源时钟的边沿 1）移动 5ns 获得的，第三个边沿是通过以下方式获得的将（源时钟的边沿 5）移动 0ns。图 7-17 显示了波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816195804748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>使用Invert 选项生成的时钟（Generated Clock using Invert Option）</strong></p>
<p>​ 这是生成时钟的另一个示例；这个使用 -invert 选项。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>period <span class="number">10</span> [get_ports <span class="type">CLK</span>]</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">NCLKDIV2</span> <span class="operator">-</span>divide_by <span class="number">2</span> <span class="operator">-</span>invert \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source <span class="type">CLK</span> [get_pins <span class="type">UINVQ</span><span class="operator">/</span><span class="type">Z</span>]</span><br></pre></td></tr></table></figure>
<p>​ -invert 选项在应用所有其他生成的时钟选项后将反转应用于生成的时钟。图 7-18 显示了生成这种反相时钟的原理图。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816200520277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>生成时钟的时钟延迟（Clock Latency for Generated Clocks）</strong></p>
<p>​ 也可以为生成的时钟指定时钟延迟。在生成时钟上指定的源延迟指定了从主时钟定义到生成时钟定义的延迟。因此，到由生成时钟驱动的触发器的时钟引脚的总时钟延迟是主时钟的源延迟、生成时钟的源延迟和生成时钟的网络延迟之和。如图 7-19 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816200716786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个生成时钟可以有另一个生成时钟作为其源，即可以有生成时钟的生成时钟，以此类推。但是，生成的时钟只能有一个主时钟。生成时钟的更多示例将在后面的章节中描述。</p>
<p><strong>典型时钟生成场景（Typical Clock Generation Scenario）</strong></p>
<p>​ 图 7-20 显示了时钟分布如何出现在典型 ASIC 中的场景。振荡器在芯片外部并产生低频（典型值 10-50 MHz）时钟，片上 PLL 将其用作参考时钟以生成高频低抖动时钟（典型值 200-800 MHz） .然后将该 PLL 时钟馈送到时钟分频器逻辑，该逻辑为 ASIC 生成所需的时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816200902113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在时钟分配的一些分支上，可能有时钟门，用于在必要时关闭设计的非活动部分的时钟以节省功耗。 PLL 的输出端还可以有一个多路复用器，以便在必要时可以绕过 PLL。</p>
<p>​ 在进入设计的芯片输入引脚上为参考时钟定义了一个主时钟，在 PLL 的输出端定义了第二个主时钟。 PLL 输出时钟与参考时钟没有相位关系。因此，输出时钟不应是参考时钟的生成时钟。最有可能的是，时钟分频器逻辑生成的所有时钟都被指定为 PLL 输出的主时钟的生成时钟。</p>
<h2 id="约束输入路径constraining-input-paths">约束输入路径（Constraining Input Paths）</h2>
<p>​ 本节将介绍输入路径的约束。这里需要注意的一点是，STA无法检查不受约束的路径上的任何时序，因此需要约束所有路径以进行时序分析。在后面的章节中会介绍一些示例，其中一些示例可能并不关心某些逻辑，因而这些输入路径可能可以不用约束。例如，设计人员可能并不在乎一些输入控制信号的时序，因此可能并不需要进行本节中将要介绍的时序检查。但是，本节假定我们要约束全部的输入路径。</p>
<p>​ 图 7-21 显示了被分析设计 (DUA) 的输入路径。触发器 UFF0 位于设计外部，并向设计内部的触发器 UFF1 提供数据。数据通过输入端口 INP1 连接。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816201705213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ CLKA 的时钟定义指定了时钟周期，它是两个触发器 UFF0 和 UFF1 之间可用的总时间量。外部逻辑所用的时间是 Tclk2q，即启动触发器 UFF0 的 CK 到 Q 延迟，加上 Tc1，即通过外部组合逻辑的延迟。因此，输入引脚 INP1 上的延迟规范定义了 Tclk2q 加上 Tc1 的外部延迟。在本例中，此延迟是相对于时钟 CLKA 指定的。</p>
<p>​ 这是输入延迟约束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">Tclk2q</span> <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="type">Tc1</span>  <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span>clock <span class="type">CLKA</span> <span class="operator">-</span>max [expr <span class="type">Tclk2q</span> <span class="operator">+</span> <span class="type">Tc1</span>] \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">INP1</span>]</span><br></pre></td></tr></table></figure>
<p>​ 该约束指定输入 INP1 上的外部延迟为 1.5ns，这与时钟 CLKA 相关。假设 CLKA 的时钟周期为 2ns，则 INP1 引脚的逻辑只有 500ps (= 2ns - 1.5ns) 可用于在设计内部传播。此输入延迟规范映射到输入约束，即 Tc2 加上 UFF1 的 Tsetup 必须小于 500ps，触发器 UFF1 才能可靠地捕获触发器 UFF0 启动的数据。请注意，上面的外部延迟被指定为最大数量。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816202533838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 让我们考虑同时考虑最大和最小延迟的情况，如图 7-22 所示。以下是此示例的限制条件。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period <span class="number">15</span> -waveform &#123;<span class="number">5</span> <span class="number">12</span>&#125; [get_ports CLKP]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">clock</span> CLKP -<span class="built_in">max</span> <span class="number">6.7</span> [get_ports INPA]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">clock</span> CLKP -<span class="built_in">min</span> <span class="number">3.0</span> [get_ports INPA]</span><br></pre></td></tr></table></figure>
<p>​ INPA 的最大和最小延迟源自 CLKP 到 INPA 的延迟。最大和最小延迟分别指最长和最短路径延迟。这些通常也可能对应于最坏情况下的慢速（最大时序角）和最佳情况下的快速（最小时序角）。因此，最大延迟对应于最大拐角处的最长路径延迟，最小延迟对应于最小拐角处的最短路径延迟。在我们的示例中，1.1ns 和 0.8ns 是 Tck2q 的最大和最小延迟值。组合路径延迟 Tc1 的最大延迟为 5.6ns，最小延迟为 2.2ns。 INPA 上的波形显示了数据到达设计输入的窗口以及预期稳定的时间。从 CLKP 到 INPA 的最大延迟为 6.7ns (= 1.1ns +5.6ns)。最小延迟为 3ns (= 0.8ns+ 2.2ns)。这些延迟是根据时钟的有效边沿指定的。在给定外部输入延迟的情况下，设计内部的可用建立时间是慢角（slow corner）下的8.3ns（= 15ns-6.7ns）和快角（fast corner）下的12ns（= 15ns-3.0ns）中的最小值。因此，8.3ns是用来可靠地捕获DUA内部数据的可用时间。</p>
<p>​ 以下是输入约束的更多示例。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_input_delay -clock clk_core <span class="number">0.5</span> <span class="selector-attr">[get_ports bist_mode]</span></span><br><span class="line"></span><br><span class="line">set_input_delay -clock clk_core <span class="number">0.5</span> <span class="selector-attr">[get_ports sad_state]</span></span><br></pre></td></tr></table></figure>
<p>​ 由于未指定<strong>max</strong>或<strong>min</strong>选项，因此500ps这个值将同时用于最大延迟和最小延迟。此外部输入延迟是相对于时钟clk_core的上升沿指定的（如果输入延迟是相对于时钟的下降沿指定的，则必须使用<strong>-clock_fall</strong>选项）。</p>
<h2 id="约束输出路径constraining-output-paths">约束输出路径（Constraining Output Paths）</h2>
<p>​ 本节将借助以下三个说明性示例描述输出路径的约束。</p>
<p><strong>示例 A</strong></p>
<p>​ 图 7-23 显示了通过分析设计的输出端口的路径示例。 Tc1 和 Tc2 是通过组合逻辑的延迟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816203740975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时钟 CLKQ 的周期定义了触发器 UFF0 和 UFF1 之间的总可用时间。外部逻辑的总延迟为 Tc2 加 Tsetup。该总延迟 Tc2 Tsetup 必须指定为输出延迟规范的一部分。请注意，输出延迟是相对于捕获时钟指定的。数据必须及时到达外部触发器UFF1以满足其建立时间要求。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">Tc2</span>  <span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="type">Tsetup</span> <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock <span class="type">CLKQ</span> <span class="operator">-</span>max [expr <span class="type">Tc2</span> <span class="operator">+</span> <span class="type">Tsetup</span>] \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">OUTB</span>]</span><br></pre></td></tr></table></figure>
<p>​ 这指定相对于时钟边沿的最大外部延迟为 Tc2 加 Tsetup；并且应该对应5ns的延迟。可以类似地指定最小延迟。</p>
<p><strong>示例 B</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210816204314813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 7-24 显示了具有最小和最大延迟的示例。最大路径延迟为 7.4ns（= 最大 Tc2 加上 Tsetup = 7 0.4）。最小路径延迟为 -0.2ns（= 最小 Tc2 减去 Thold = 0 - 0.2）。因此输出约束为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period <span class="number">20</span> -waveform &#123;<span class="number">0</span> <span class="number">15</span>&#125; [get_ports CLKQ]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> CLKQ -<span class="built_in">min</span> <span class="number">-0.2</span> [get_ports OUTC]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> CLKQ -<span class="built_in">max</span> <span class="number">7.4</span> [get_ports OUTC]</span><br></pre></td></tr></table></figure>
<p>​ 图 7-24 中的波形显示了何时 OUTC 必须稳定才能被外部触发器可靠地捕获。这描述了数据必须在所需的稳定区域开始之前在输出端口准备好，并且必须保持稳定直到稳定区域结束。这映射到 DUA 内部输出端口 OUTC 的逻辑时序要求。</p>
<p><strong>示例 C</strong></p>
<p>​ 这是显示输入和输出规范的另一个示例。该模块有两个输入，DATAIN 和 MCLK，以及一个输出 DATAOUT。图 7-25 显示了预期的波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816204919108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period <span class="number">100</span> -waveform &#123;<span class="number">5</span> <span class="number">55</span>&#125; [get_ports MCLK]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">25</span> -<span class="built_in">max</span> -<span class="built_in">clock</span> MCLK [get_ports DATAIN]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">5</span> -<span class="built_in">min</span> -<span class="built_in">clock</span> MCLK [get_ports DATAIN]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_output_delay <span class="number">20</span> -<span class="built_in">max</span> -<span class="built_in">clock</span> MCLK [get_ports DATAOUT]</span><br><span class="line"></span><br><span class="line">set_output_delay <span class="number">-5</span> -<span class="built_in">min</span> -<span class="built_in">clock</span> MCLK [get_ports DATAOUT]</span><br></pre></td></tr></table></figure>
<h2 id="时序路径组timing-path-groups">时序路径组（Timing Path Groups）</h2>
<p>​ 设计中的时序路径可被视为路径的集合。每条路径都有一个起点和一个终点（a startpoint and an endpoint）。有关一些示例路径，请参见图 7-26。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816205341683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在STA中，时序路径是根据有效的起点和终点（valid startpoints and valid endpoints）来划分的。有效的起点包括：输入端口或者同步器件（如触发器和存储器）的时钟引脚。有效的终点包括：输出端口或者同步器件的数据输入引脚。因此，有效的时序路径包括：</p>
<ul>
<li>从输入端口到输出端口</li>
<li>从输入端口到触发器或存储器的数据输入引脚</li>
<li>从一个触发器或存储器的时钟引脚到另一个触发器或存储器的数据输入引脚</li>
<li>从一个触发器或存储器的时钟引脚到输出端口</li>
</ul>
<p>​ 图7-26中的有效时序路径包括：</p>
<ul>
<li>输入端口A到输出端口Z</li>
<li>输入端口A到触发器UFFA的D引脚</li>
<li>触发器UFFA的CK引脚到触发器UFFB的D引脚</li>
<li>触发器UFFB的CK引脚到输出端口Z</li>
</ul>
<p>​ 时序路径可以根据与路径终点相关的时钟分为不同<strong>时序路径组（path groups）</strong>。因此，每个时钟都有一组与之相关的时序路径。还有一个<strong>默认时序路径组（default path group）</strong>，其中包括了所有non-clocked（异步）路径。</p>
<p>在图7-27的示例中，时序路径分组为：</p>
<ul>
<li>CLKA组：输入端口A到触发器UFFA的D引脚</li>
<li>CLKB组：触发器UFFA的CK引脚到触发器UFFB的D引脚</li>
<li>默认组：输入端口A到输出端口Z、触发器UFFB的CK引脚到输出端口Z</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210816210303673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ <strong><em>*静态时序分析和报告通常对每个路径组分别执行。*</em></strong></p>
<h2 id="外部属性建模modeling-of-external-attributes">外部属性建模（Modeling of External Attributes）</h2>
<p>​ 虽然 create_clock、set_input_delay 和 set_output_delay 足以约束设计中的所有路径以执行时序分析，但这些不足以为模块的 IO 引脚获得准确的时序。还需要以下属性来准确地对设计环境进行建模。对于输入，需要指定输入的转换。可以使用以下方式提供此信息：</p>
<ul>
<li><strong>set_drive*<em>（此命令已过时，不推荐使用。）*</em></strong></li>
<li><strong>set_driving_cell</strong></li>
<li><strong>set_input_transition</strong></li>
</ul>
<p>​ 对于输出，需要指定输出引脚看到的容性负载。这是通过使用以下命令约束指定的：</p>
<ul>
<li><strong>set_load</strong></li>
</ul>
<h3 id="驱动强度建模modeling-drive-strengths">驱动强度建模（Modeling Drive Strengths）</h3>
<p>​ <strong>set_drive</strong>和<strong>set_driving_cell</strong>约束用于对驱动模块输入端口的外部单元的驱动强度进行建模。在没有这些约束的默认情况下，假定所有输入都具有无限的驱动强度，即输入引脚的过渡时间为0。</p>
<p>​ <strong>set_drive</strong>明确指定了DUA输入引脚上的驱动电阻值，该电阻值越小，驱动强度越高，电阻值为0表示无限的驱动强度。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816211046175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_drive <span class="number">100</span> UCLK</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies a drive resistance of 100 on input UCLK.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Rise drive is different from fall drive:</span></span><br><span class="line"></span><br><span class="line">set_drive -rise <span class="number">3</span> [all_inputs]</span><br><span class="line"></span><br><span class="line">set_drive -fall <span class="number">2</span> [all_inputs]</span><br></pre></td></tr></table></figure>
<p>​ 输入端口的驱动用于计算第一个单元的转换时间。指定的驱动值还用于计算存在任何 RC 互连时从输入端口到第一个单元的延迟。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Delay_to_first_gate =</span><br><span class="line"></span><br><span class="line">(<span class="name">drive</span> * load_on_net) + interconnect_delay</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">延迟值 = （驱动强度 * 网络负载） + 互连线延迟</span><br></pre></td></tr></table></figure>
<p>​ set_driving_cell 命令提供了一种更方便、更准确的方法来描述端口的驱动能力。 set_driving_cell 可用于指定驱动输入端口的单元。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816211526653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">set_driving_cell -lib_cell INV3 \</span><br><span class="line"></span><br><span class="line">-library slow <span class="selector-attr">[get_ports INPB]</span></span><br><span class="line"></span><br><span class="line"># The <span class="selector-tag">input</span> INPB is driven by an INV3 cell</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">from</span> library slow.</span><br><span class="line"></span><br><span class="line">set_driving_cell -lib_cell INV2 \</span><br><span class="line"></span><br><span class="line">-library tech13g <span class="selector-attr">[all_inputs]</span></span><br><span class="line"></span><br><span class="line"># Specifies that the cell INV2 <span class="selector-tag">from</span> <span class="selector-tag">a</span> library tech13g is</span><br><span class="line"></span><br><span class="line"># the driving cell for <span class="attribute">all</span> inputs.</span><br><span class="line"></span><br><span class="line">set_driving_cell -lib_cell BUFFD4 -library tech90gwc \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_ports &#123;testmode[3]</span>&#125;]</span><br><span class="line"></span><br><span class="line"># The <span class="selector-tag">input</span> testmode<span class="selector-attr">[3]</span> is driven by <span class="selector-tag">a</span> BUFFD4 cell</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">from</span> library tech90gwc.</span><br></pre></td></tr></table></figure>
<p>​ 与驱动规范一样，输入端口的驱动单元用于计算第一个单元的转换时间，并在存在任何互连时计算从输入端口到第一个单元的延迟。</p>
<p>​ set_driving_cell 命令的一个警告是，由于输入端口上的容性负载而导致的驱动单元的增量延迟作为输入上的附加延迟包括在内。</p>
<p>​ 作为上述方法的替代方法，set_input_transition 命令提供了一种在输入端口表达转换的便捷方式。可以选择指定参考时钟。以下是图 7-30 中所示示例的规范以及其他示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816211750305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set_input_transition <span class="number">0.85</span> <span class="selector-attr">[get_ports INPC]</span></span><br><span class="line"></span><br><span class="line"># Specifies an <span class="selector-tag">input</span> <span class="attribute">transition</span> of <span class="number">850</span>ps on port INPC.</span><br><span class="line"></span><br><span class="line">set_input_transition <span class="number">0.6</span> <span class="selector-attr">[all_inputs]</span></span><br><span class="line"></span><br><span class="line"># Specifies <span class="selector-tag">a</span> <span class="attribute">transition</span> of <span class="number">600</span>ps on <span class="attribute">all</span> <span class="selector-tag">input</span> ports.</span><br><span class="line"></span><br><span class="line">set_input_transition <span class="number">0.25</span> <span class="selector-attr">[get_ports SD_DIN*]</span></span><br><span class="line"></span><br><span class="line"># Specifies <span class="selector-tag">a</span> <span class="attribute">transition</span> of <span class="number">250</span>ps on <span class="attribute">all</span> ports with</span><br><span class="line"></span><br><span class="line"># pattern SD_DIN*.</span><br><span class="line"></span><br><span class="line"># Min and max values can optionally be specified using</span><br><span class="line"></span><br><span class="line"># the -min and -max options.</span><br></pre></td></tr></table></figure>
<p>​ 总之，需要输入端的转换值来确定输入路径中第一个单元的延迟。在没有此约束的情况下，假设理想的过渡值为 0，这可能不现实。</p>
<p><strong>7.7.2 容性负载建模（Modeling Capacitive Load）</strong></p>
<p>​ <strong>set_load</strong>约束在输出端口上设置了电容性负载，以模拟由输出端口驱动的外部负载。默认情况下，端口上的电容性负载为0。可以将负载显式地指定为电容值或某个单元的输入引脚电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816212347576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">set_load 5 [get_ports OUTX]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Places a 5pF load on output port OUTX.</span></span><br><span class="line"></span><br><span class="line">set_load 25 [all_outputs]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets 25pF load capacitance on all outputs.</span></span><br><span class="line"></span><br><span class="line">set_load -pin_load 0.007 [<span class="keyword">get_ports</span> &#123;shift_write[<span class="number">31</span>]&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Place 7fF pin load on the specified output port.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A load on the net connected to the port can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specified using the -wire_load option.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If neither -pin_load nor -wire_load option is used,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the default is the -pin_load option.</span></span><br></pre></td></tr></table></figure>
<p>​ 指定输出负载很重要，因为该值会影响驱动输出的单元的延迟。在没有这样的规范的情况下，假设负载为 0，这可能是不现实的。</p>
<p>​ set_load 命令还可用于在设计中指定内部网络上的负载。下面是一个例子：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_load <span class="number">0.25</span> [get_nets UCNT5/NET6]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the net capacitance to be 0.25pF.</span></span><br></pre></td></tr></table></figure>
<h2 id="设计规则检查design-rule-checks">设计规则检查（Design Rule Checks）</h2>
<p>​ STA中两个常用的设计规则是最大过渡时间-<strong>max_transition</strong>和最大电容-<strong>max_capacitance</strong>。这些规则将会检查设计中的所有端口和引脚是否满足过渡时间和电容的规定约束。这些规则可以使用以下命令指定：</p>
<ul>
<li><strong>set_max_transition</strong></li>
<li><strong>set_max_capacitance</strong></li>
</ul>
<p>​ 作为STA的一部分，任何设计规则的违例（violation）均以裕量（slack）的形式报告。以下是些例子：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_max_transition <span class="number">0.6</span> IOBANK</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets a limit of 600ps on IOBANK.</span></span><br><span class="line"></span><br><span class="line">set_max_capacitance <span class="number">0.5</span> [current_design]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Max capacitance is set to 0.5pf on all nets in</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># current design.</span></span><br></pre></td></tr></table></figure>
<p>网络上的电容是通过将所有引脚电容加上任何IO负载再加上网络上的任何互连电容的总和计算得出的。下图7-32为一个示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210816212753559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Total <span class="built_in">cap</span> on net N1 =</span><br><span class="line"></span><br><span class="line">pin <span class="built_in">cap</span> of UBUF1:pin/A +</span><br><span class="line"></span><br><span class="line">pin <span class="built_in">cap</span> of UOR2:pin/B +</span><br><span class="line"></span><br><span class="line">load <span class="built_in">cap</span> specified on output port OUTP +</span><br><span class="line"></span><br><span class="line">wire/routing <span class="built_in">cap</span></span><br><span class="line"></span><br><span class="line">= 0.05 + 0.03 + 0.07 + 0.02</span><br><span class="line"></span><br><span class="line">= 0.17pF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Total <span class="built_in">cap</span> on net N2 =</span><br><span class="line"></span><br><span class="line">pin <span class="built_in">cap</span> of UBUF2/A +</span><br><span class="line"></span><br><span class="line">wire/routing <span class="built_in">cap</span> from input to buffer</span><br><span class="line"></span><br><span class="line">= 0.04 + 0.03</span><br><span class="line"></span><br><span class="line">= 0.07pF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">网络N1的总电容 = UBUF1的A引脚电容 + UOR2的B引脚电容 + OUTP的输出负载电容 + 走线互连电容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> = 0.05 + 0.03 + 0.07 + 0.02 = 0.17 pF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">网络N2的总电容 = UBUF2的A引脚电容 + 走线互连电容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> = 0.03 + 0.04 = 0.07 pF</span><br></pre></td></tr></table></figure>
<p>​ 过渡时间是延迟计算的一部分。对于图7-32中的示例（假设UBUF2单元使用线性延迟模型）：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Transition time on pin UBUF2/A =</span><br><span class="line"></span><br><span class="line">drive of 21<span class="emphasis">* total cap on net N2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">= 2 *</span> 0.07 = 0.14ns = 140ps</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Transition time on output port OUTP =</span><br><span class="line"></span><br><span class="line">drive resistance of UBUF2/Z <span class="emphasis">* total cap of net N1 =</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1 *</span> 0.17 = 0.17ns = 170ps</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> UBUF2的A引脚过渡时间 = 2 <span class="emphasis">* 网络N2的总电容</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">                     = 2 *</span> 0.07 = 0.14ns = 140ps</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">输出端口OUTP过渡时间 = UBUF2的Z引脚的驱动电阻 <span class="emphasis">* 网络N1的总电容</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">                    = 1 *</span> 0.17 = 0.17ns = 170ps</span><br></pre></td></tr></table></figure>
<p>​ 还可以为设计指定其他设计规则检查，比如：<strong>set_max_fanout</strong>（指定设计中所有引脚的扇出约束），<strong>set_max_area</strong>（用于设计）。但是，这些检查适用于综合（synthesis）而非STA。</p>
<h2 id="虚拟时钟virtual-clocks">虚拟时钟（Virtual Clocks）</h2>
<p>​ 虚拟时钟是存在但不与设计的任何引脚或端口相关联的时钟。它用作 STA 分析中的参考，以指定相对于时钟的输入和输出延迟。图 7-33 显示了一个适用虚拟时钟的示例。分析中的设计从 CLK_CORE 获取时钟，但驱动输入端口 ROW_IN 的时钟是 CLK_SAD。在这种情况下，如何指定输入端口 ROW_IN 上的 IO 约束？同样的问题发生在输出端口 STATE_O 上。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816213259546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 为了处理这种情况，可以定义一个不指定源端口或引脚的虚拟时钟。在图 7-33 的示例中，为 CLK_SAD 和 CLK_CFG 定义了虚拟时钟。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock -<span class="keyword">name</span> VIRTUAL_CLK_SAD -period <span class="number">10</span> -waveform <span class="comment">&#123;2 8&#125;</span></span><br><span class="line"></span><br><span class="line">create_clock -<span class="keyword">name</span> VIRTUAL_CLK_CFG -period <span class="number">8</span> \</span><br><span class="line"></span><br><span class="line">-waveform <span class="comment">&#123;0 4&#125;</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">10</span> [get_ports CLK_CORE]</span><br></pre></td></tr></table></figure>
<p>​ 定义了这些虚拟时钟后，可以相对于该虚拟时钟指定 IO 约束。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLK_SAD -<span class="built_in">max</span> <span class="number">2.7</span> \</span><br><span class="line"></span><br><span class="line">[get_ports ROW_IN]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> VIRTUAL_CLK_CFG -<span class="built_in">max</span> <span class="number">4.5</span> \</span><br><span class="line"></span><br><span class="line">[get_ports STATE_O]</span><br></pre></td></tr></table></figure>
<p>​ 图 7-34 显示了输入路径上的时序关系。这将被分析设计中的输入路径限制为 5.3ns 或更小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816214101770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 7-35 显示了输出路径上的时序关系。这将被分析设计中的输出路径限制为 3.5ns 或更小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816214502403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ -min 选项在 set_input_delay 和 set_output_delay 约束中指定时，用于验证快速（或最小）路径。使用虚拟时钟只是限制输入和输出 (IO) 的一种方法；设计人员也可以选择其他方法来约束 IO。</p>
<h2 id="完善时序分析refining-the-timing-analysis">完善时序分析（Refining the Timing Analysis）</h2>
<p>用于约束分析的四个常用命令是：</p>
<ul>
<li><strong>set_case_analysis</strong> ：在单元的引脚或输入端口上指定常量值。</li>
<li><strong>set_disable_timing</strong> ：中断单元的时序弧。</li>
<li><strong>set_false_path</strong> ：指定实际不存在的路径，这意味着在STA中不需要检查这些路径。</li>
<li><strong>set_multicycle_path</strong> ：指定可能花费超过一个时钟周期的路径。</li>
</ul>
<p>第8章将详细讨论<strong>set_false_path</strong>和<strong>set_multicycle_path</strong>约束。</p>
<h3 id="指定非活动信号specifying-inactive-signals">指定非活动信号（Specifying Inactive Signals）</h3>
<p>​ 在设计中，某些信号在芯片的特定模式下会具有恒定值。例如，如果芯片中具有DFT（可测性设计）逻辑，则在正常功能模式下，芯片的TEST引脚将一直为0。为STA指定这样的常量值通常很有用，除了不必报告任何不相关的路径之外，这还有助于减少分析空间。例如，如果未将TEST引脚设置为常数，则可能会存在一些奇怪的长路径，而这些长路径在功能模式下永远不会存在。通过使用<strong>set_case_analysis</strong>约束来指定此类常数信号。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_case_analysis <span class="number">0</span> TEST</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[3]</span>&#125;]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[2]</span>&#125;]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[1]</span>&#125;]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[0]</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>​ 如果设计具有多种功能模式，而只需要分析其中一种功能模式，则可以使用<strong>set_case_analysis</strong>来指定要分析的模式。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_case_analysis <span class="number">1</span> func_mode<span class="selector-attr">[0]</span></span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> func_mode<span class="selector-attr">[1]</span></span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">1</span> func_mode<span class="selector-attr">[2]</span></span><br></pre></td></tr></table></figure>
<p>​ 请注意，可以在设计中的任何引脚上指定案例分析。案例分析的另一个常见应用是设计可以在多个时钟上运行，并且适当时钟的选择由多路复用器控制。为了使 STA 分析更容易并减少 CPU 运行时间，对每个时钟选择分别进行 STA 是有益的。图 7-36 显示了多路复用器选择具有不同设置的不同时钟的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816215020860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_case_analysis <span class="number">1</span> <span class="type">UCORE</span><span class="operator">/</span><span class="type">UMUX0</span><span class="operator">/</span><span class="type">CLK_SEL</span>[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">1</span> <span class="type">UCORE</span><span class="operator">/</span><span class="type">UMUX1</span><span class="operator">/</span><span class="type">CLK_SEL</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="type">UCORE</span><span class="operator">/</span><span class="type">UMUX2</span><span class="operator">/</span><span class="type">CLK_SEL</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>​ 第一个 set_case_analysis 导致为 MIICLK 选择 PLLdiv16。 PLLdiv8 的时钟路径被阻塞，不会通过多路复用器传播。因此，没有使用时钟 PLLdiv8 分析时序路径（假设时钟在多路复用器之前没有进行任何翻转）。类似地，最后一个 set_case_analysis 导致为 ADCCLK 选择 SCANCLK，并阻塞 CLK200 的时钟路径。</p>
<h3 id="打破单元格中的时序弧breaking-timing-arcs-in-cells">打破单元格中的时序弧（Breaking Timing Arcs in Cells）</h3>
<p>​ 每个单元都有从其输入到输出的时序弧，并且时序路径可能会通过这些时序弧中的其中一个。在某些情况下，单元中的一条路径可能无法发生。例如可能有这样一种情况，其中时钟连接到多路复用器的选择端，而多路复用器的输出是数据路径的一部分。在这种情况下，中断多路复用器选择引脚和输出引脚之间的时序弧可能很有用。图7-37为一个示例，通过多路复用器选择端的路径不是有效的数据路径。可以使用<strong>set_disable_timing</strong>命令来中断这种时序弧。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_disable_timing -<span class="selector-tag">from</span> S -<span class="selector-tag">to</span> Z <span class="selector-attr">[get_cells UMUX0]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210816215423784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于时序弧不再存在，因此需要分析的时序路径更少。另一个类似用法的例子是禁用触发器的最小时钟脉冲宽度检查。</p>
<p>​ 使用<strong>set_disable_timing</strong>命令需要格外小心，因为它会删除通过指定引脚的所有时序路径。在可能的情况下，最好使用<strong>set_false_path</strong>和<strong>set_case_analysis</strong>命令。</p>
<h2 id="点对点规范point-to-point-specification">点对点规范（Point-to-Point Specification）</h2>
<p>​ 可以通过使用<strong>set_min_delay</strong>和<strong>set_max_delay</strong>命令来约束点对点路径，这将引脚到引脚之间的路径延迟限制在了命令指定值内。该约束将覆盖所有默认的单周期时序路径以及此类路径的任何多周期路径约束。<strong>set_max_delay</strong>约束了指定路径的最大延迟，而<strong>set_min_delay</strong>约束了指定路径的最小延迟。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay <span class="number">5.0</span> -<span class="selector-tag">to</span> UFF0/D</span><br><span class="line"></span><br><span class="line"># <span class="attribute">All</span> paths <span class="selector-tag">to</span> D-pin of flip-flop should take <span class="number">5</span>ns max.</span><br><span class="line"></span><br><span class="line">set_max_delay <span class="number">0.6</span> -<span class="selector-tag">from</span> UFF2/<span class="selector-tag">Q</span> -<span class="selector-tag">to</span> UFF3/D</span><br><span class="line"></span><br><span class="line"># <span class="attribute">All</span> paths between the two flip-flops should take <span class="selector-tag">a</span></span><br><span class="line"></span><br><span class="line"># max of <span class="number">600</span>ps.</span><br><span class="line"></span><br><span class="line">set_max_delay <span class="number">0.45</span> -<span class="selector-tag">from</span> UMUX0/Z -through UAND1/<span class="selector-tag">A</span> -<span class="selector-tag">to</span> UOR0/Z</span><br><span class="line"></span><br><span class="line"># Sets max delay for the specified paths.</span><br><span class="line"></span><br><span class="line">set_min_delay <span class="number">0.15</span> -<span class="selector-tag">from</span> &#123;UAND0/<span class="selector-tag">A</span> UXOR1/<span class="selector-tag">B</span>&#125; -<span class="selector-tag">to</span> &#123;UMUX2/SEL&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在上述示例中，需要注意的是，使用非标准的内部引脚将迫使它们成为起点和终点，并在这些点处分割路径。</p>
<p>​ 还可以类似地指定从一个时钟到另一个时钟的点对点约束。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set_max_delay <span class="number">1.2</span> -<span class="keyword">from</span> [get_clocks SYS_CLK] \</span><br><span class="line"></span><br><span class="line">-to [get_clocks CFG_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># All paths between these two clock domains are restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># to a max of 1200ps.</span></span><br><span class="line"></span><br><span class="line">set_min_delay <span class="number">0.4</span> -<span class="keyword">from</span> [get_clocks SYS_CLK] \</span><br><span class="line"></span><br><span class="line">-to [get_clocks CFG_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The min delay between any path between the two</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clock domains is specified as 400ps.</span></span><br></pre></td></tr></table></figure>
<p>​ 如果路径上有多个时序约束，例如时钟频率约束、<strong>set_max_delay</strong>和<strong>set_min_delay</strong>，则最严格的那个约束是始终用于检查的约束。多个时序约束可能是先应用某些全局（global）约束，然后再应用某些局部（local）约束。</p>
<h2 id="路径分割path-segmentation">路径分割（Path Segmentation）</h2>
<p>​ 路径分段（path segmentation）是指将时序路径分解为可以进行时序分析的较小路径。</p>
<p>​ 时序路径具有起点和终点，可以使用<strong>set_input_delay</strong>和<strong>set_output_delay</strong>命令在时序路径上创建其它起点和终点。通常在单元的输出引脚上指定<strong>set_input_delay</strong>来定义新起点，而通常在单元的输入引脚上指定<strong>set_output_delay</strong>来定义新终点。这些约束定义了新的时序路径，它是原始时序路径的子集。</p>
<p>​ 考虑图7-38中所示的路径。为SYSCLK定义时钟后，待分析的时序路径即为从UFF0 / CK到UFF1 / D。如果仅对报告从UAND2 / Z到UAND6 / A的路径延迟感兴趣，则可以使用以下两个命令：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">STARTPOINT</span> [get_pins <span class="type">UAND2</span><span class="operator">/</span><span class="type">Z</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="type">ENDPOINT</span> [get_pins <span class="type">UAND6</span><span class="operator">/</span><span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">0</span> <span class="variable">$STARTPOINT</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="number">0</span> <span class="variable">$ENDPOINT</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210816220118351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 定义这些约束会导致从UFF0 / CK到UFF1 / D的原始时序路径被分段，并分别在UAND2 / Z和UAND6 / A处创建内部起点和内部终点。现在，时序报告将明确显示此新路径。请注意，还会自动创建另外两条时序路径，一条从UFF0 / CK到UAND2 / Z，另一条从UAND6 / A到UFF1 / D。因此，原始的时序路径已被分为了三个部分，每个部分分别进行时序分析。</p>
<p>​ set_disable_timing、set_max_delay 和 set_min_delay 命令也会导致时序路径被分段。</p>
<h1 id="时序验证timing-verification">时序验证（Timing Verification）</h1>
<blockquote>
<p>描述了时序检查，这个各种时序检查是作为各种时序分析的一部分执行。其中包括amongst others - setup、保持和异步恢复和移除检查。这些时序检查旨在彻底验证被分析设计的时序。</p>
</blockquote>
<p>两个主要检查是建立时间检查和保持时间检查。一旦在触发器的时钟引脚上定义了时钟，就会自动推断出该触发器的建立时间检查和保持时间检查。时序检查通常在多种条件下执行，包括最坏情况下的慢速条件和最佳情况下的快速条件。通常，最坏情况下的慢速条件对于建立时间检查至关重要，而最佳情况下的快速条件对于保持时间检查至关重要-尽管保持时间检查也可能在最坏情况下的慢速条件下执行。</p>
<p>本章中给出的示例假设网络延迟为零；这样做是为了简单，不会改变本文提出的概念。</p>
<h2 id="建立时间时序检查setup-timing-check">建立时间时序检查（Setup Timing Check）</h2>
<p>​ 建立时间检查（setup timing check）验证时钟和触发器的数据引脚之间的时序关系，以便满足建立时间要求。换句话说，建立时间检查确保数据在触发器输入之前在触发器的输入端可用。在时钟的有效边沿到达触发器之前，数据应该稳定一段时间，即触发器的建立时间。这一要求确保数据被可靠地捕获到触发器中。图 8-1 显示了典型触发器的建立时间要求。建立时间检查验证触发器的建立时间要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210817185011986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通常，有一个发起触发器（用于发起数据的触发器）和捕获触发器（用于捕获数据的触发器），这个捕获触发器的建立时间要求必须满足。建立时间检查将验证从发起触发器到捕获触发器的最长（或最大）路径，这两个触发器的时钟可以相同也可以不同。建立时间检查是从发起触发器中时钟的第一个有效沿到捕获触发器中时钟后面最接近的那个有效沿。建立时间检查将确保上一个时钟周期发起的数据准备好在一个周期后被捕获。</p>
<p><img src="https://img-blog.csdnimg.cn/20210817185456886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 现在我们研究一个简单的示例，如图8-2所示，其中发起触发器和捕获触发器具有相同的时钟。时钟CLKM的第一个上升沿在<strong>Tlaunch</strong>时间后出现在发起触发器的时钟引脚上，由该时钟沿发起的数据出现在触发器<strong>UFF1</strong>的D引脚的所需时间为<strong>Tlaunch + Tck2q + Tdp</strong>。时钟CLKM的第二个上升沿（通常在一个周期后检查建立时间）出现在捕获触发器<strong>UFF1</strong>的时钟引脚上的时间为<strong>Tcycle + Tcapture</strong>。这两个时间之差必须大于触发器UFF1的建立时间要求，以确保触发器UFF1可靠地捕获数据。</p>
<p>​ 建立时间检查可以用数学公式表示：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tlaunch+%20Tck2q+%20Tdp%3C%20Tcapture+%20Tcycle-%20Tsetup"></p>
<p>​ 其中Tlaunch是发起触发器UFF0的时钟树延迟，Tdp是组合逻辑数据路径的延迟，Tcycle是时钟周期，Tcapture是捕获触发器UFF1的时钟树延迟。</p>
<p>​ 换句话说，数据到达捕获触发器D引脚所花费的总时间必须小于时钟传输到捕获触发器所花费的时间加上时钟周期再减去建立时间要求。</p>
<p>​ 由于建立时间检查受到<strong>-max</strong>的约束，因此建立时间检查始终使用最长或最大的时序路径。出于同样的原因，通常在延迟最大的慢工艺角（slow corner）下执行建立时间检查。</p>
<h3 id="触发器到触发器路径flip-flop-to-flip-flop-path">触发器到触发器路径（Flip-flop to Flip-flop Path）</h3>
<p>​ 以下是一份建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820100554269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 该报告中显示发起触发器（由<strong>Startpoint</strong>指定）的实例名称为UFF0，由时钟CLKM的上升沿触发。捕获触发器（由<strong>Endpoint</strong>指定）为UFF1，也由时钟CLKM的上升沿触发。路径组（<strong>Path Group</strong>）显示它属于路径组CLKM。如上一章所述，设计中的所有路径都基于捕获触发器的时钟归类为路径组。路径类型（<strong>Path Type</strong>）显示此报告中的延迟均为最大路径延迟，表明这是建立时间检查。这是因为建立时间检查对应于通过逻辑的最大（或最长路径）延迟。注意，保持时间检查对应于通过逻辑的最小（或最短路径）延迟。</p>
<p>​ <strong>Incr</strong>列显示了指定端口或引脚的单元或网络延迟增量，<strong>Path</strong>列显示了数据实际到达和需要到达的路径累积延迟，这是用于此示例的时钟约束：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">    <span class="selector-attr">[get_ports CLKM]</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -setup <span class="number">0.3</span> <span class="selector-attr">[all_clocks]</span></span><br><span class="line"></span><br><span class="line">set_clock_transition -rise <span class="number">0.2</span> <span class="selector-attr">[all_clocks]</span></span><br><span class="line"></span><br><span class="line">set_clock_transition -fall <span class="number">0.15</span> <span class="selector-attr">[all_clocks]</span></span><br></pre></td></tr></table></figure>
<p>​ 启动路径（ <strong>launch path</strong>）需要 0.26ns 才能到达触发器 UFF1 的 D 引脚 - 这是到达捕获触发器输入的时间。捕获边沿（建立时间检查时为一个周期）为10ns。为该时钟指定了 0.3ns 的时钟不确定性（<strong>clock uncertainty</strong>） - 因此，时钟周期减少了不确定性余量。时钟不确定性包括由于时钟源中的抖动（ <strong>jitter</strong> ）和用于分析的任何其他时序裕量而导致的周期时间变化。触发器的建立时间 0.04ns（称为库建立时间<strong>library setup time</strong>）从总捕获路径中扣除，产生所需的时间为 9.66ns。由于到达时间为 0.26ns，因此该时序路径上存在 9.41ns 的正裕量（ <strong>positive<br>
slack</strong>）。请注意，所需时间和到达时间之间的差异可能看起来为 9.40 ns - 但实际值​​是 9.41 ns，出现在报告中。之所以存在异常，是因为报告仅显示小数点后两位，而内部计算和存储的值比报告的值具有更高的精度。</p>
<p>​ 时序报告中的时钟网络延迟（<strong>clock network delay</strong>）是什么？为什么将其标记为<strong>ideal</strong>？时序报告中的这一行表明时钟树被认为是<strong>ideal</strong>的，时钟路径中的任何缓冲器（<strong>buffer</strong>）都假定为零延迟。一旦构建了时钟树，就可以将时钟网络标记为“<strong>propagated</strong>”，从而使得时钟路径显示实际延迟值，如下一个示例时序报告中所示：0.11ns延迟是发起时钟上的时钟网络延迟，而0.12ns延迟是捕获触发器上的时钟网络延迟。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082010421111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时序路径报告可以选择包含扩展的时钟路径，即明确显示时钟树。这是一个这样的例子。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820104322715.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820104352977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，时钟缓冲器 UCKBUF0、UCKBUF1 和 UCKBUF2 出现在上面的路径报告中，并提供了如何计算时钟树延迟的详细信息。</p>
<p>​ 如何计算第一个时钟单元 UCKBUF0 的延迟？如前几章所述，单元延迟是根据单元的输入转换时间和输出电容计算的。因此，问题是在时钟树中第一个单元的输入处使用什么转换时间。可以使用 <strong>set_input_transition</strong> 命令明确指定第一个时钟单元输入引脚上的转换时间（或转换）。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_input_transition -rise <span class="number">0.3</span> <span class="selector-attr">[get_ports CLKM]</span></span><br><span class="line"></span><br><span class="line">set_input_transition -fall <span class="number">0.45</span> <span class="selector-attr">[get_ports CLKM]</span></span><br></pre></td></tr></table></figure>
<p>​ 在上面显示的 <strong>set_input_transition</strong> 命令中，我们将输入上升转换时间指定为 0.3ns，将下降转换时间指定为 0.45ns。在没有输入转换命令的情况下，在时钟树的原点假设理想的转换，这意味着上升和下降转换时间都是 0ns。</p>
<p>​ 时序报告中的“<strong>r”</strong>和“<strong>f”</strong>字符表示时钟或数据信号的上升沿（和下降沿）。上一个时序路径报告中显示了一条从UFF0 / Q的下降沿开始到UFF1 / D的上升沿结束的路径。由于UFF1 / D可以为0或1，因此也可以有一条路径在UFF1 / D的下降沿结束。以下就是这样一条路径：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820104910404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820104951692.png" alt="img"></p>
<p>​ 注意，触发器时钟引脚的边沿（称为有效边沿<strong>active edge</strong>）保持不变。它只能是上升或下降有效沿，具体取决于触发器是由上升沿触发的还是由下降沿触发的。</p>
<p>​ 什么是时钟源延迟（<strong>clock source latency</strong>）？ 这也被称为插入延迟（<strong>insertion delay</strong>），是时钟从其源端传播到待分析设计的时钟定义点所花费的时间，如图8-3所示，这对应于设计之外的时钟树延迟。例如，如果该设计是较大模块的一部分，则时钟源延迟是指直到待分析设计时钟引脚为止的时钟树延迟。可以使用<strong>set_clock_latency</strong>命令明确指定此延迟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820105246379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_clock_latency -source -rise <span class="number">0.7</span> <span class="selector-attr">[get_clocks CLKM]</span></span><br><span class="line"></span><br><span class="line">set_clock_latency -source -fall <span class="number">0.65</span> <span class="selector-attr">[get_clocks CLKM]</span></span><br></pre></td></tr></table></figure>
<p>​ 如果没有这样的命令，则假定延迟为 0。这是早期路径报告中使用的假设。请注意，源延迟不会影响设计内部且具有相同启动时钟和捕获时钟的路径。这是因为相同的延迟被添加到启动时钟路径和捕获时钟路径。然而，这种延迟确实会影响经过分析设计的输入和输出的时序路径。</p>
<p>​ 如果没有<strong>-source</strong>选项，则<strong>set_clock_latency</strong>命令将定义时钟网络延迟，这是从DUA中时钟定义点到触发器的时钟引脚的延迟。时钟网络延迟用于在建立时钟树之前（即在时钟树综合之前）对通过时钟路径的延迟进行建模。一旦建立了时钟树并标记为了“已传播”（propagated），便会忽略此时钟网络延迟约束。<strong>set_clock_latency</strong>命令也可用于对从主时钟到其衍生时钟的延迟进行建模，如7.3节所述。当时钟生成逻辑不是设计的一部分时，该命令也可用于建模片外时钟延迟。</p>
<h3 id="触发器路径的输入input-to-flip-flop-path">触发器路径的输入（Input to Flip-flop Path）</h3>
<p>​ 这是通过输入端口到触发器的路径报告示例。图 8-4 显示了与输入路径和时钟波形相关的原理图。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820110055339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820110145903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820110415499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 首先要注意的是第一行中的<strong>input port clocked by VIRTUAL_CLKM</strong>。如7.9节中所述，该时钟可以被认为是驱动设计输入端口INA的虚拟触发器，该虚拟触发器的时钟为<strong>VIRTUAL_CLKM</strong>。此外，从该虚拟触发器的时钟引脚到输入端口INA的最大延迟指定为2.55ns，在报告中显示为<strong>input external delay</strong>。可以使用以下SDC命令指定这些参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name VIRTUAL_CLKM -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">max</span> <span class="number">2.55</span> [get_ports INA]</span><br></pre></td></tr></table></figure>
<p>​ 请注意，虚拟时钟VIRTUAL_CLKM的定义没有与设计中任何引脚相关，这是因为它是在设计之外定义的（它是虚拟的）。输入延迟约束<strong>set_input_delay</strong>指定了相对于虚拟时钟的延迟。</p>
<p>​ 输入路径从端口INA开始，如何计算连接到端口INA的第一个单元UINV1的延迟呢？一种方法是指定输入端口INA的驱动单元，该驱动单元用于确定驱动强度，从而确定端口INA上的转换时间，然后用于计算单元UINV1的延迟。在输入端口INA上没有任何转换时间约束的情况下，将假定端口上的过渡时间是理想的，即过渡时间为0ns。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_driving_cell -lib_cell BUFF \</span><br><span class="line"></span><br><span class="line">    -library lib013lwc <span class="selector-attr">[get_ports INA]</span></span><br></pre></td></tr></table></figure>
<p>​ 图8-4还展示了如何进行建立时间检查。数据必须到达UFF2 / D的时间为9.85ns，但是数据实际到达的时间为2.65ns，因此该报告显示该路径的正裕量为7.2ns。</p>
<p><strong>具有实际时钟的输入路径（Input Path with Actual Clock）</strong></p>
<p>​ 也可以根据实际时钟指定输入到达时间；这些不一定必须针对虚拟时钟进行指定。实际时钟的示例是设计中内部引脚或输入端口上的时钟。图 8-5 描述了一个示例，其中端口 CIN 上的输入约束是相对于输入端口 CLKP 上的时钟指定的。此约束指定为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_input_delay <span class="operator">-</span>clock <span class="type">CLKP</span> <span class="operator">-</span>max <span class="number">4.3</span> [get_ports <span class="type">CIN</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021082011165374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这里是这个约束对应的输入路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820111749641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820111818649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，起始点（Startpoint）与预期一致，将输入端口的延迟参考时钟指定为了CLKP。</p>
<h3 id="触发器到输出路径flip-flop-to-output-path">触发器到输出路径（Flip-flop to Output Path）</h3>
<p>​ 与上述输入端口约束类似，输出端口可以相对于虚拟时钟或设计的内部时钟、输入时钟端口或输出时钟端口受到约束。这是一个示例，显示了相对于虚拟时钟约束的输出引脚 ROUT。输出约束如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_output_delay -clock VIRTUAL_CLKP \</span><br><span class="line"></span><br><span class="line">    -max <span class="number">5.1</span> <span class="selector-attr">[get_ports ROUT]</span></span><br><span class="line"></span><br><span class="line">set_load <span class="number">0.02</span> <span class="selector-attr">[get_ports ROUT]</span></span><br></pre></td></tr></table></figure>
<p>​ 为了确定最后一个单元连接到输出端口的延迟，需要指定该端口上的负载，上面使用了<strong>set_load</strong>命令来指定输出负载。请注意，端口ROUT可能在DUA内部具有负载，而<strong>set_load</strong>约束指定的是额外的负载，即来自DUA外部的负载。在没有<strong>set_load</strong>命令约束的情况下，将假定外部负载的值为0（这可能不现实，因为该设计很可能会在其它设计中使用）。下图8-6显示了具有虚拟时钟的虚拟触发器的时序路径：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820112148155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通过输出端口的路径报告如下所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820112251974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820112447403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820112520645.png" alt="img"></p>
<p>​ 注意，指定的输出延迟在报告中显示为<strong>output external delay</strong>，其作用类似于虚拟触发器所需的建立时间。</p>
<h3 id="输入到输出路径input-to-output-path">输入到输出路径（Input to Output Path）</h3>
<p>​ 设计也可以具有从输入端口到输出端口的纯组合逻辑路径。可以像我们前面看到的输入和输出路径一样，对路径进行约束和时序分析。下图8-7显示了这种路径的一个示例，虚拟时钟同时用于指定输入和输出端口上的约束。</p>
<p>​ 以下是输入和输出延迟约束：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">max</span> <span class="number">3.6</span> [get_ports INB]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">max</span> <span class="number">5.8</span> [get_ports POUT]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820112757669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是一个时序路径报告，它经过从输入INB到输出POUT的组合逻辑。请注意，任何内部时钟延迟（如果存在）都不会对该路径报告产生影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820112902336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820112946739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820113036158.png" alt="img"></p>
<h3 id="频率直方图frequency-histogram">频率直方图（Frequency Histogram）</h3>
<p>​ 如果要绘制一个典型设计的建立时间裕量与路径数的频率直方图，则如图8-8所示。根据设计的状态（是否进行了优化） ，对于未优化的设计，零裕量（<strong>zero slack</strong>）线将更靠近右侧，而对于优化后的设计则更趋向于左侧。对于没有时序违例的设计（即没有路径的裕度为负），整个曲线将在零裕量线的右侧。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820113238363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是一个以文本形式显示的直方图，通常可以由静态时序分析工具生成。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082011334270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 前两个索引表示裕量的范围，第三个索引是该裕量范围内的路径数，例如，有941条路径的裕量范围为410ps至415ps。直方图表明该设计没有时序违例的路径，即所有路径均具有正的裕量，而关键路径的裕量值在375ps至380ps之间。</p>
<p>​ 难以满足时序要求的设计会使直方图的驼峰向左偏大，也就是说，许多路径的裕量值接近于零。通过观察频率直方图可以得出的另一结果是：可以进一步优化设计以实现零裕量的可能性，即时序收敛有多困难。如果违例路径的数量少并且负裕量值也很小，则设计相对比较容易满足所需的时序。但是，如果违例路径的数量很大并且负裕量值也很大，则这意味着设计将需要付出很大努力才能满足所需的时序。</p>
<h2 id="保持时间检查hold-timing-check">保持时间检查（Hold Timing Check）</h2>
<p>​ <strong>保持时间检查</strong>确保正在改变的触发器输出值不会传递到捕获触发器并在触发器有机会捕获其原始值之前覆盖其输出。此检查基于触发器的保持要求。触发器的保持约束要求被锁存的数据应该在时钟的有效边沿之后的指定时间内保持稳定。图 8-9 显示了典型触发器的保持要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820113626338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 就像建立时间检查一样，保持时间检查是在发起触发器（发起数据的触发器）和捕获触发器（捕获数据的触发器以及必须满足其保持时间要求的触发器）之间进行保持时间检查的。这两个触发器的时钟可以相同也可以不同。保持检查是从启动触发器时钟的一个有效边沿到捕获触发器的同一时钟边沿。因此，保持检查与时钟周期无关。保持检查在捕获触发器时钟的每个有效边沿上执行。</p>
<p>​ 现在我们来看一个简单的示例，如图8-10所示，其中发起触发器和捕获触发器具有相同的时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820113936169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 考虑时钟CLKM的第二个上升沿。时钟上升沿发起的数据需要Tlaunch + Tck2q + Tdp时间到达捕获触发器UFF1的D引脚。时钟的同一边沿需要Tcapture时间才能到达捕获触发器的时钟引脚，目的是使捕获触发器在下一个时钟周期捕获来自发起触发器的数据。如果在同一时钟周期内捕获数据，则捕获触发器中的预期数据（来自上一个时钟周期）将被覆盖，因此保持时间检查旨在确保捕获触发器中的目标数据不会被覆盖。保持时间检查可验证这两个时间之差（捕获触发器的数据到达时间和时钟到达时间）必须大于捕获触发器的保持时间，这样触发器上的数据才不会被覆盖，并且捕获到可靠的数据。</p>
<p>​ 保持时间检查可以用数学公式表示为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tlaunch+%20Tck2q+%20Tdp%3E%20Tcapture+%20Thold"></p>
<p>​ 其中<strong>Tlaunch</strong>是发起触发器的时钟树延迟，<strong>Tdp</strong>是组合逻辑数据路径中的延迟，<strong>Tcapture</strong>是捕获触发器的时钟树延迟。换句话说，由时钟边沿发起的数据到达捕获触发器D引脚所需的总时间必须大于时钟同一边沿到达捕获触发器所需的时间加上保持时间。这样可以确保UFF1 / D保持稳定状态，直到触发器的时钟引脚UFF1 / CK时钟上升沿之后的保持时间为止。</p>
<p>​ 保持时间检查对捕获触发器的数据路径施加了最小值（<strong>-min</strong>）约束，需要确定到捕获触发器D引脚的最快路径。这意味着将始终使用最短时序路径来进行保持时间检查，同样，通常在 fast timing corner下进行保持时间检查。</p>
<p>​ 即使设计中只有一个时钟，时钟树也会导致时钟在发起触发器和捕获触发器处的到达时间大不相同。为了确保可靠的数据捕获，捕获触发器的时钟沿必须在数据可改变之前到达。保持时间检查可确保（见图8-11）：</p>
<ul>
<li>当前数据发起时钟沿（<strong>Setup launch edge</strong>）的下一个时钟沿发起的数据不被当前数据捕获时钟沿（<strong>Setup receiving edge</strong>）所捕获。</li>
<li>当前数据发起时钟沿发起的数据不被当前数据捕获时钟沿的前一个时钟沿所捕获。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210820114337494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果发起时钟和捕获时钟都属于同一时钟域，则这两个保持时间检查实质上是相同的。但是，当发起时钟和捕获时钟处于不同频率或处于不同时钟域时，以上两个保持时间检查就有可能是不同的。在这种情况下，最差的保持时间检查就是所要报告的检查。上图8-11说明了这两个保持时间检查。</p>
<p>​ UFF0是发起触发器，UFF1是捕获触发器。建立时间检查在这一个数据发起时钟沿（Setup launch edge）和这一个数据捕获时钟沿（Setup receiving edge）之间。下一个数据发起时钟沿（Subsequent launch edge）不得以太快的速度传播数据，因为这可能会导致这一个数据捕获时钟沿没有时间可靠地捕获这一个数据。此外，这一个数据发起时钟沿同样不得以太快的速度传播数据，因为这可能会导致前一个数据捕获时钟沿（Preceding receiving edge）没有时间可靠地捕获前一个数据。在上述各种情况中，最差情况的保持时间检查对应于最严格的保持时间检查。</p>
<p>​ 稍后将在8.3节和8.8节中分别讨论更通用的时钟，例如用于多周期路径和多频率路径的时钟。讨论内容将涵盖建立时间检查和保持时间检查之间的关系，尤其是如何从建立时间检查中推断出保持时间检查。虽然建立时间违例会导致设计的工作频率降低，但保持时间违例会“杀死”（kill）设计，即设计在任何频率下都无法运行。因此，了解保持时间检查并解决任何违例行为非常重要。</p>
<h3 id="触发器到触发器路径flip-flop-to-flip-flop-path-1">触发器到触发器路径（Flip-flop to Flip-flop Path）</h3>
<p>​ 本节基于图 8-2 中描述的示例说明了触发器到触发器的保持路径。以下是第 8.1 节中设置检查路径示例的保持时序检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820114719336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820114811548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 注意，路径类型（<strong>Path Type</strong>）为最小值(<strong>min</strong>)，表示使用了最短路径的单元延迟值，这对应于保持时间检查。库保持时间（<strong>library hold time</strong>）指定了触发器UFF1的保持时间。如前3.4节所述，触发器的保持时间也可以为负。请注意，发起和捕获路径都是从时钟CLKM的上升沿（触发器的有效沿）开始计算的。时序报告显示，新数据最早可以到达UFF1、同时又可以安全地捕获上一个时钟周期数据的时间为0.19ns。由于新数据的实际到达时间为0.33ns，因此报告显示正的保持时间裕量（<strong>slack</strong>）为0.14ns。</p>
<p>​ 图8-12显示了时钟信号到达发起和捕获触发器时钟引脚的时间，以及数据在捕获触发器处的最早允许到达时间和实际到达时间。由于数据实际到达的时间晚于数据所需到达的时间（允许的最早到达时间），因此满足保持时间要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820115423487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>保持时间裕量计算（Hold Slack Calculation）</strong></p>
<p>​ 需要注意的一点是，为建立时间和保持时间的时序报告计算裕量值的方式有所不同。在建立时间报告中，会计算数据实际到达时间和数据需要到达时间，然后将需要到达时间减去实际到达时间，从而得到建立时间的裕量值。但是，在保持时间报告中，当我们把需要到达时间减去实际到达时间后，负的结果将转化为正的裕量值（表示满足保持时间要求），而正的结果将转化为负的裕量值（表示保持时间违例）。</p>
<h3 id="触发器路径的输入input-to-flip-flop-path-1">触发器路径的输入（Input to Flip-flop Path）</h3>
<p>​ 接下来描述来自输入端口的保持时序检查。有关示例，请参见图 8-4。输入端口上的最小延迟使用虚拟时钟指定为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">min</span> <span class="number">1.1</span> [get_ports INA]</span><br></pre></td></tr></table></figure>
<p>​ 这是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820120652343.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820120737240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"> <strong>input external delay</strong>中的值为输入延迟约束命令中的指定值。在0时刻的VIRTUAL_CLKM上升沿和CLKM上升沿之间进行保持时间检查。UFF2在不违反其保持时间的情况下捕获数据所需的到达时间为0.25ns，这表明数据应在0.25ns之后到达。由于数据实际上在1.2ns才到达，因此显示出0.95ns的正裕量。</p>
<h3 id="触发器到输出路径flip-flop-to-output-path-1">触发器到输出路径（Flip-flop to Output Path）</h3>
<p>​ 这是一个输出端口的保持时序检查。有关示例，请参见图 8-6。输出端口命令显示为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_output_delay -<span class="built_in">clock</span> VIRTUAL_CLKP \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">min</span> <span class="number">2.5</span> [get_ports ROUT]</span><br></pre></td></tr></table></figure>
<p>​ 输出延迟是相对于虚拟时钟指定的。这是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820121939421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，<strong>output external delay</strong>中的值为输出延迟约束命令中的指定值。</p>
<p><strong>触发器到具有实际时钟的输出路径（Flip-flop to Output Path with Actual Clock）</strong></p>
<p>​ 有一条输出端口保持时间检查的路径，如图8-13所示。请注意，最小输出延迟是相对于实际时钟指定的。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_output_delay -clock CLKP -min <span class="number">3.5</span> <span class="selector-attr">[get_ports QOUT]</span></span><br><span class="line"></span><br><span class="line">set_load <span class="number">0.55</span> <span class="selector-attr">[get_ports QOUT]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820122345439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="输入到输出路径input-to-output-path-1">输入到输出路径（Input to Output Path）</h3>
<p>​ 这是对输入到输出路径的保持时间检查，如图8-7所示。端口的约束为：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_load -pin_load <span class="number">0.15</span> <span class="selector-attr">[get_ports POUT]</span></span><br><span class="line"></span><br><span class="line">set_output_delay -clock VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -min <span class="number">3.2</span> <span class="selector-attr">[get_ports POUT]</span></span><br><span class="line"></span><br><span class="line">set_input_delay -clock VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -min <span class="number">1.8</span> <span class="selector-attr">[get_ports INB]</span></span><br><span class="line"></span><br><span class="line">set_input_transition <span class="number">0.8</span> <span class="selector-attr">[get_ports INB]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820122855475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 输入端口和输出端口上的延迟约束是相对于虚拟时钟指定的，因此，保持时间检查是在该虚拟时钟的上升沿（默认有效沿<strong>default active</strong>）处执行的。</p>
<h2 id="多周期路径multicycle-paths">多周期路径（Multicycle Paths）</h2>
<p>​ 在某些情况下，两个触发器之间的数据路径可能需要一个以上的时钟周期才能传播通过逻辑。在这种情况下，这条组合逻辑路径会被定义为<strong>多周期路径（multicycle path）</strong>。虽然数据还是会在每个时钟沿上都被捕获触发器捕获，但我们需要告知STA在指定数量的时钟周期之后才会出现有效的捕获时钟沿。</p>
<p>​ 图8-14是一个示例。由于数据路径最多需要三个时钟周期，因此应指定三个周期的多周期建立时间检查。为此需要指定如下的多周期建立时间约束：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">10</span> <span class="selector-attr">[get_ports CLKM]</span></span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">3</span> -setup \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/Q]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF1/D]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820123349565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 多周期建立时间约束规定，建立时间检查时从UFF0 / CK到UFF1 / D的路径最多可以花费三个时钟周期，这意味着设计每三个周期才会使用一次UFF1 / Q引脚上输出的数据，而不是每个周期都使用。</p>
<p>​ 以下是一份具有多周期约束的建立时间路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820123524421.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820123605367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820123645997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 注意，现在捕获触发器的时钟沿距离发起触发器的时钟沿三个时钟周期，为30ns。</p>
<p>​ 现在，我们来检查一下多周期路径上的保持时间检查。在最常见的情况下，我们希望保持时间检查保持不变（与单周期路径一致），如图8-14所示，这样可使数据在三个时钟周期之内任意进行改变。只有指定多周期保持时间为2，才可以获得与单周期建立时间检查情况相同的保持时间检查。这是因为在没有这样的多周期保持时间约束的情况下，默认的保持时间检查是在建立时间捕获沿的前一个有效时钟沿上执行的，这显然不是我们希望的。我们需要将执行保持时间检查的时钟沿移动到默认时钟沿之前的两个周期，因此指定了多周期保持时间为2。预期的检查如图8-15所示，通过多周期保持时间约束，数据路径的最小延迟可以小于一个时钟周期。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> -hold -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/Q]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF1/D]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820125642805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 多周期保持时间约束命令中的周期数指定了从默认保持时间检查沿（建立时间捕获沿之前的一个有效沿）需要移回多少个时钟周期。 以下是一份保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820130625460.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820130702753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820130747793.png" alt="img"></p>
<p>​ 由于此路径的多周期建立时间约束为3，因此其默认保持时间检查是在建立时间捕获沿之前的有效时钟沿上执行的。在大多数设计中，如果最大路径（或建立时间）需要N个时钟周期，则大于（N-1）个时钟周期的最小路径约束是不可行的。通过指定两个周期的多周期保持时间约束，可以将保持时间检查时钟沿移回到数据发起沿处（即0ns处），如上面的路径报告中所示。</p>
<p>​ 因此在大多数设计中，指定为N（周期）的多周期建立时间约束应伴随着指定为N-1（周期）的多周期保持时间约束。</p>
<p>​ 如果指定了N个周期的多周期建立时间约束，但缺少了相应的N-1个周期的多周期保持时间约束，会发生什么情况呢？在这种情况下，会在建立时间捕获沿之前的一个周期时钟沿上执行保持时间检查。图8-16显示了仅约束多周期建立时间为3个周期时，进行这种保持时间检查的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820130943855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如图所示，这规定了数据只能在建立时间捕获沿之前的一个周期内进行改变。因此，数据路径必须具有至少两个时钟周期的最小延迟才能满足此要求。以下是这种情况的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820131046634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820131130925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820131219273.png" alt="img"></p>
<p><strong>跨时钟域（Crossing Clock Domains）</strong></p>
<p>​ 让我们考虑在周期相同的两个不同时钟之间存在多周期路径的情况。（时钟周期也不同的情况将在本章后面进行介绍）</p>
<p>​ 例子1：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p>​ 多周期建立时间约束指定了给定路径的时钟周期数，如图8-17所示。默认建立时间捕获沿总是与发起沿相隔一个时钟周期，约束多周期建立时间为2会使建立时间捕获沿与发起沿相隔2个时钟周期。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820133856602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 多周期保持时间约束指定了保持时间检查应该在建立时间捕获沿之前几个时钟周期的时钟沿处执行，无论建立时间发起沿在何处，如图8-18所示。默认的保持时间检查是在建立时间捕获沿之前一个周期的时钟沿处执行的。约束多周期保持时间为1会将保持时间检查放置于默认保持时间检查之前一个周期的时钟沿处，因此变为建立时间捕获沿之前两个周期的时钟沿处。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820133939754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="keyword">from</span> [get_pins UFF0/CK] -<span class="keyword">to</span> [get_pins UFF3/D]</span><br><span class="line"></span><br><span class="line"># Since no -hold <span class="keyword">option</span> <span class="built_in">is</span> specified, the <span class="keyword">default</span> <span class="keyword">option</span></span><br><span class="line"></span><br><span class="line"># -setup <span class="built_in">is</span> assumed. This implies that the setup</span><br><span class="line"></span><br><span class="line"># multiplier <span class="built_in">is</span> <span class="number">2</span> <span class="built_in">and</span> the hold multiplier <span class="built_in">is</span> <span class="number">0</span>.</span><br></pre></td></tr></table></figure>
<p>​ 这是与多周期约束相对应的建立时间路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820134500508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，路径报告中指定的路径组始终是捕获触发器的路径组，在本例中为 CLKP。</p>
<p>​ 接下来是保持时间检查的路径报告。由于多周期保持时间约束默认为0，因此将在建立时间捕获沿（20ns）之前一个时钟周期的10ns处进行保持时间检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820135027590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以上报告报出了保持时间违例，这可以通过将多周期保持时间约束指定为1来消除。接下来将在一个单独的示例中说明这一点。</p>
<p>​ 例子2：</p>
<p>​ 下面给出了跨两个不同时钟域指定的多周期的另一个示例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/CK]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF3/D]</span> -setup</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">1</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/CK]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF3/D]</span> -hold</span><br><span class="line"></span><br><span class="line"># The -setup and -hold options are explicitly specified.</span><br></pre></td></tr></table></figure>
<p>​ 以下是多周期建立时间约束为2时建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820140423413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820140515351.png" alt="img"></p>
<p>​ 以下是多周期保持时间约束为1时保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820140558833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，本节中建立和保持检查的示例报告针对相同的时序角（timing corner）。然而，在最坏情况下的慢角（worst-case slow corner）通常最难满足建立时间检查（具有最低的裕量），而在最佳情况下的快速角（ best-case fast corner）通常最难满足保持检查（具有最低的裕量）。</p>
<h2 id="伪路径false-paths">伪路径（False Paths）</h2>
<p>​ 当设计的功能运行时，某些时序路径可能不真实（或不可能）存在。在执行STA时可以将这些路径设置为伪路径（false path），这样就可以关闭这些路径，那么STA就不会对这些伪路径去进行分析了。</p>
<p>​ 伪路径可能是从一个时钟域到另一个时钟域、从触发器的时钟引脚到另一触发器的输入引脚、通过一个单元的引脚、通过多个单元的引脚或这些情况的组合 。当通过单元的引脚指定了伪路径后，通过该引脚的所有路径都将被忽略，无需进行时序分析。辨别出伪路径的好处在于减少了分析空间，从而使分析可以专注于真实存在的路径，这同样有助于减少分析时间。但是，过多使用<strong>-through</strong>选项去指定伪路径同样会降低分析的速度。</p>
<p>​ 可以使用<strong>set_false_path</strong>命令来约束伪路径，以下是一些例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -<span class="keyword">from</span> [get_clocks SCAN_CLK] \</span><br><span class="line"></span><br><span class="line">    -to [get_clocks CORE_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Any path starting from the SCAN_CLK domain to the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CORE_CLK domain is a false path.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path -through [get_pins UMUX0/S]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Any path going through this pin is false.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path \</span><br><span class="line"></span><br><span class="line">    -through [get_pins SAD_CORE/RSTN]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The false path specifications can also be specified to,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># through, or from a module pin instance.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path -to [get_ports TEST_REG*]</span><br><span class="line"></span><br><span class="line"><span class="comment"># All paths that end in port named TEST_REG* are false paths.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path -through UINV/Z -through UAND0/Z</span><br><span class="line"></span><br><span class="line"><span class="comment"># Any path that goes through both of these pins</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in this order is false.</span></span><br></pre></td></tr></table></figure>
<p>​ 下面给出了一些关于设置伪路径的建议。要在两个时钟域之间设置伪路径，请使用：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks clockA]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks clockB]</span></span><br></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_false_path -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins &#123;regA_*&#125;/CP]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins &#123;regB_*&#125;/D]</span></span><br></pre></td></tr></table></figure>
<p>​ 后者这种方式要慢得多。</p>
<p>​ 另一个建议是尽可能少使用<strong>-through</strong>选项，因为它增加了运行时不必要的复杂性。仅在绝对有必要且没有替代方法可以指定该伪路径的情况下，才可以使用<strong>-through</strong>选项。</p>
<p>​ 从优化的角度来看，还有一个建议是不要将一条多周期路径约束为伪路径。如果需要在已知或可预测的时刻对信号进行采样，则无论时间间隔多大，都应使用多周期路径约束，以使路径具有一定的约束条件并进行优化以满足多周期约束。如果把一条许多时钟周期后进行采样的路径指定为了伪路径，则对设计中其余逻辑路径的优化可能会使该路径变长，甚至超出所需的时间。</p>
<h2 id="半周期路径half-cycle-paths">半周期路径（Half-Cycle Paths）</h2>
<p>​ 如果设计中同时具有负边沿触发的触发器（有效时钟沿为下降沿）和正边沿触发的触发器（有效时钟沿为上升沿），则设计中可能存在半周期路径（half-cycle path）。半周期路径可能是从一个触发器的上升沿到另一个触发器的下降沿，或者反过来。图8-19给出了一个示例，其中数据的发起沿在触发器UFF5的时钟下降沿，而数据的捕获沿在触发器UFF3的时钟上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820141254211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820141327313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意起点（Startpoint）和终点（Endpoint）中的边沿说明。时钟CLKP的下降沿出现在6ns，上升沿出现在12ns。因此，数据需要在半个周期6ns内到达捕获触发器的输入引脚。</p>
<p>​ 虽然在建立时间检查时数据路径仅有半个时钟周期，但额外的半个周期可用于保持时间检查。以下是保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820141409658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间检查通常是在捕获沿之前一个周期的捕获沿上执行的。由于捕获沿是在12ns处，因此前一个捕获沿在0ns处，故将在0ns处检查保持时间。这为保持时间检查有效地增加了半个时钟周期的裕量，因此可以看见保持时间检查有较大的正裕量（slack）。</p>
<h2 id="移除时间检查removal-timing-check">移除时间检查（Removal Timing Check）</h2>
<p>​ <strong>移除时间检查（ removal timing check）</strong>可确保在有效时钟沿与释放异步控制信号之间有足够的时间。该检查可确保有效时钟沿不带来影响，因为异步控制信号将保持有效状态，直到有效时钟沿之后一段撤销时间为止。换句话说，异步控制信号会在有效时钟沿之后被释放（变为无效），因此该时钟沿不会产生任何影响，如图8-20所示。该检查基于的是触发器异步引脚上指定的撤销时间。以下是单元库中与撤销时间检查有关的描述片段：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pin</span>(CDN) &#123;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">    <span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">    related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    timing_type : removal_rising;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820142100731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与保持时间检查一样，该检查也是针对最小路径的，不过是在触发器的异步引脚上。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820142225533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820142331725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820142519229.png" alt="img"></p>
<p>​ 终点（Endpoint）表明这是移除时间检查，且在触发器UFF6的异步引脚CDN上。该触发器的移除时间在报告中显示为<strong>library removal time</strong>，值为0.19ns。</p>
<p>​ 所有异步时序检查均被分配给了<strong>async_default</strong>路径组。</p>
<h2 id="恢复时间检查recovery-timing-check">恢复时间检查（Recovery Timing Check）</h2>
<p>​ <strong>恢复时间检查（recovery timing check）</strong>可确保异步信号变为无效状态的时刻与下一个有效时钟沿之间的时间间隔大于一个最小值。换句话说，此检查可确保在异步信号变为无效状态之后，有足够的时间恢复，以便下一个有效时钟沿可以生效。例如，考虑从异步复位变为无效的时刻到触发器有效时钟沿之间的时间间隔。如果该时间间隔太短即有效时钟沿在复位释放后太早出现，则触发器可能进入未知的状态。恢复时间检查如图8-21所示。该检查基于的是触发器异步引脚上指定的恢复时间，单元库文件中与恢复时间有关的描述片段如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pin</span>(RSN) &#123;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">    <span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">    related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    timing_type : recovery_rising;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021082014431722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与建立时间检查一样，该检查也是针对最大路径的，不过是在触发器的异步引脚上。</p>
<p>​ 以下是一份恢复时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820144815790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820144849652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 终点（Endpoint）表明这是恢复时间检查，并且触发器UFF6的恢复时间在报告中显示为<strong>library recovery time</strong>，值为0.09ns。恢复时间检查也属于<strong>async_default</strong>路径组。</p>
<h2 id="跨时钟域的时序timing-across-clock-domains">跨时钟域的时序（Timing across Clock Domains）</h2>
<h3 id="慢到快时钟域slow-to-fast-clock-domains">慢到快时钟域（Slow to Fast Clock Domains）</h3>
<p>​ 让我们来对一条从慢速时钟域到快速时钟域的路径来进行建立时间与保持时间检查，如图8-22所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820145105362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是以上示例的时钟定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]    </span><br></pre></td></tr></table></figure>
<p>​ 当发射触发器和捕获触发器的时钟频率不同时，STA通过首先确定一个共同的基周期来执行。下面给出了一个使用上述两个时钟进行STA时产生的消息示例。将较快的时钟展开，以获得一个普通周期。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expanding clock <span class="string">&#x27;CLKP&#x27;</span> <span class="keyword">to</span> base <span class="keyword">period</span> <span class="keyword">of</span> <span class="number">20.00</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">old</span> <span class="keyword">period</span> was <span class="number">5.00</span>, added <span class="number">6</span> edges).</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820145940698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图8-23中为建立时间检查。默认情况下，将使用最严格的建立时间边沿去检查，在本例中为5ns处的时钟沿。以下是此时建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150051566.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820150121371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，发起时钟沿为0ns，而捕获时钟沿为5ns。</p>
<p>​ 如前所述，保持时间检查与建立时间检查有关，并确保由当前时钟沿发起的数据不会干扰先前数据的捕获。这是保持时间检查的报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150152501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在上面的示例中，我们可以看到发起的数据在捕获时钟的第四个周期可用。让我们假设该设计的目的不是在CLKP的下一个有效沿上就捕获数据，而是在每第4个捕获沿上捕获数据。该假设给触发器之间的组合逻辑路径提供了4个CLKP周期的时间，即20ns。我们可以通过设置以下多周期路径约束来做到这一点：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">4</span> -setup \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKM]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKP]</span> -end</span><br></pre></td></tr></table></figure>
<p>​ <strong>-end</strong>选项指定了多周期4是用于终点（endpoint）或捕获时钟的。此多周期路径约束将建立时间和保持时间检查更改为了图8-24中所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150430480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是这种情况下建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150511369.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820150554384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 上图8-24中也说明了保持时间检查，请注意，保持时间检查是根据建立时间检查而决定的，默认为当前数据捕获沿之前的一个周期。以下是保持时间检查的路径报告。注意，保持时间捕获沿为15ns，比建立时间捕获沿（20ns）早一个周期（5ns）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150853329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820150925407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在大多数设计中，这不是理想的时序检查，应将保持时间检查一直移回到数据发起沿所在位置。因此，我们可以约束多周期保持时间为3。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">3</span> -hold \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKM]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKP]</span> -end</span><br></pre></td></tr></table></figure>
<p>​ 3是指将保持时间检查沿向后移三个CLKP时钟周期，即0ns时刻处。与多周期建立时间约束的区别在于：在多周期建立时间约束中，建立时间捕获沿会从默认的建立时间捕获沿向前移动指定的周期数；而在多周期保持时间约束中，保持时间检查沿会从默认的保持时间检查沿向后移动指定的周期数。<strong>-end</strong>选项意味着我们想将终点（或捕获边沿）移回指定的周期数，即捕获时钟的周期数。代替<strong>-end</strong>的另一种选项<strong>-start</strong>指定了要移动的发起时钟周期数，<strong>-end</strong>选项指定了要移动的捕获时钟周期数。<strong>-end</strong>是多周期建立时间约束的默认值，<strong>-start</strong>是多周期保持时间约束的默认值。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820151345402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 使用多周期保持时间约束，可以将保持时间检查的时钟沿往回移，检查效果如图8-25所示。具有多周期保持时间约束的保持时间检查路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820151625970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820151705142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"> 总之，如果指定了N个周期的多周期建立时间，那么很可能还应指定N-1个周期的多周期保持时间。对于慢速到快速时钟域之间的路径，多周期路径约束的一个好经验是使用<strong>-end</strong>选项。使用此选项，可以根据快速时钟的时钟周期来调整建立时间和保持时间检查。</p>
<h3 id="快到慢时钟域fast-to-slow-clock-domains">快到慢时钟域（Fast to Slow Clock Domains）</h3>
<p>​ 在本小节中，我们考虑数据路径从快速时钟域到慢速时钟域的示例。使用以下时钟定义时，默认的建立时间和保持时间检查如图8-26所示。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820151850670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 总共可能有四种建立时间检查，请参阅图8-26中的Setup1，Setup2，Setup3和Setup4。其中，最严格的是Setup4检查。以下是此最严格检查的路径报告。请注意，数据发起时钟沿为15ns，捕获时钟沿为20ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820151931654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820152024246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与建立时间检查类似，总共也可能有四种保持时间检查。图8-26中所示为最严格的保持时间检查，该检查可确保0ns处的捕获沿不捕获0ns处正在发起的数据。以下是这种情况下保持时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820152747107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820152815105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通常，设计人员可以将从快时钟域到慢时钟域的数据路径指定为多周期路径。如果想要放宽建立时间检查，比如为数据路径提供两个快时钟周期，则此多周期路径约束如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> -setup \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKP]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKM]</span> -start</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">1</span> -hold \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKP]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKM]</span> -start</span><br><span class="line"></span><br><span class="line"># The -start option refers <span class="selector-tag">to</span> the launch clock and is</span><br><span class="line"></span><br><span class="line"># the default for <span class="selector-tag">a</span> multicycle hold.</span><br></pre></td></tr></table></figure>
<p>​ 在这种情况下，图8-27中为用于建立时间和保持时间检查的时钟沿。<strong>-start</strong>选项指定周期数的单位（在这种情况下为2）是发起时钟周期（在这种情况下为CLKP）。约束多周期建立时间为2会将发起沿移动到默认发起沿之前的一个时钟沿，即在10ns而不是默认的15ns处。多周期保持时间约束确保了在0ns处发起沿发起的数据，不会被0ns处的捕获沿捕获到。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820152951953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告。与预期一样，发起时钟沿为10ns，捕获时钟沿为20ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820153345132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820153446732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告。保持时间检查是在0ns处执行的，此时捕获时钟和发起时钟均为上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820153535212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820153612143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与从慢速时钟域到快速时钟域的路径不同，在从快速时钟域到慢速时钟域的路径中，多周期路径约束的一个好经验是使用<strong>-start</strong>选项，然后再根据快速时钟调整建立时间和保持时间检查。</p>
<h2 id="例子">例子</h2>
<p>​ 在本节中，我们将介绍发起和捕获时钟的不同情况，并分别说明如何执行建立时间和保持时间检查。图8-28为所举例子的示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820153830904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>半周期路径 - 案例 1（Half-cycle Path - Case 1）</strong></p>
<p>​ 在此示例中，两个时钟具有相同的周期，但相位相反。以下是时钟定义，其波形如图8-29所示。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">10</span> <span class="number">20</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820154023190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查是从发起沿（0ns）到下一个捕获沿（10ns）的。半个时钟周期的裕量可用于保持时间检查，以验证在20ns处发起的数据是否在10ns处未被捕获沿所捕获。以下是建立时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082015415358.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820154225811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820154318780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820154417798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>半周期路径 - 案例2（Half-cycle Path - Case 2）</strong></p>
<p>​ 此示例与情况1类似，不过发起时钟和捕获时钟的相位相反。以下是时钟定义，其波形如图8-30所示。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">5</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820155433765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查从5ns的发起时钟沿到10ns的下一个捕获时钟沿。保持时间检查从5ns的发起时钟沿到0ns的捕获时钟沿。以下是建立时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820155730210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以下是保持时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082015582393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>快到慢时钟域（Fast to Slow Clock Domain）</strong></p>
<p>​ 在此示例中，捕获时钟是发起时钟的二分频。以下是时钟定义。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p>​ 波形如图8-31所示。建立时间检查是从10ns的发起沿到20ns的捕获沿，保持时间检查是从0ns的发起沿到0ns的捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820160032372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820160521761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820160553683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/2021082016063678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820160740172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>慢到快时钟域（Slow to Fast Clock Domain）</strong></p>
<p>​ 在此示例中，捕获时钟速度是发起时钟速度的2倍。图8-32中为建立时间和保持时间检查对应的时钟沿：从发起沿0ns到下一个捕获沿5ns进行建立时间检查，保持时间检查是在建立时间捕获沿前一个周期的捕获沿进行的，也就是说，发起沿和捕获沿都为0ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161515292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以下是建立时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161610709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以下是保持时间检查的路径报告</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161652557.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820161722349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="多倍时钟multiple-clocks">多倍时钟（Multiple Clocks）</h2>
<h3 id="整数倍数integer-multiples">整数倍数（Integer Multiples）</h3>
<p>​ 在设计中通常会定义多个时钟，这些时钟的频率是彼此的整数倍。在这种情况下，会通过计算所有相关时钟（related clocks）之间的公共基本周期来执行STA（如果两个时钟域之间具有数据路径，则两个时钟相关）。建立公共基本周期的目的是以便所有时钟都同步。</p>
<p>​ 以下是3个相关时钟的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKQ</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br><span class="line"><span class="type">Expanding</span> clock &#x27;<span class="type">CLKP</span>&#x27; to base period of <span class="number">20.00</span> (old period was</span><br><span class="line"></span><br><span class="line"><span class="number">5.00</span>, added <span class="number">6</span> edges).</span><br><span class="line"></span><br><span class="line"><span class="type">Expanding</span> clock &#x27;<span class="type">CLKQ</span>&#x27; to base period of <span class="number">20.00</span> (old period was</span><br><span class="line"></span><br><span class="line"><span class="number">10.00</span>, added <span class="number">2</span> edges).</span><br></pre></td></tr></table></figure>
<p>​ 分析CLKP和CLKM时钟域之间的路径时，将使用20ns的公共基本周期，如图8-33所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161919366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告，用于从较快时钟CLKP到较慢时钟CLKM的路径。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820162136359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 相应保持时间检查的路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820162233407.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820162329394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="非整数倍数non-integer-multiples">非整数倍数（Non-Integer Multiples）</h3>
<p>​ 考虑当两个频率不是彼此整数倍的时钟域之间存在数据路径的的情况。例如，发起时钟是公共时钟的8分频，而捕获时钟是公共时钟的5分频，如图8-34所示。本节将介绍在这种情况下如何执行建立时间和保持时间检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820162658968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是时钟定义，其波形如图8-35所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">8</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKQ</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820162829823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时序分析会先计算相关时钟的公共周期，然后再将时钟扩展到该公共周期。请注意，仅针对相关时钟（即在它们之间具有时序路径的时钟）去计算公共周期。CLKQ和CLKP之间数据路径的公共周期仅扩展为10ns的公共周期，CLKM和CLKQ之间数据路径的公共周期为40ns，而CLKM和CLKP之间数据路径的公共周期也为40ns。</p>
<p>​ 让我们考虑一条从CLKM时钟域到CLKP时钟域的数据路径，这种情况下时序分析的公共基本周期为40ns。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Expanding clock <span class="string">&#x27;CLKM&#x27;</span> <span class="keyword">to</span> base <span class="keyword">period</span> <span class="keyword">of</span> <span class="number">40.00</span> (<span class="keyword">old</span> <span class="keyword">period</span> was</span><br><span class="line"></span><br><span class="line"><span class="number">8.00</span>, added <span class="number">8</span> edges).</span><br><span class="line"></span><br><span class="line">Expanding clock <span class="string">&#x27;CLKP&#x27;</span> <span class="keyword">to</span> base <span class="keyword">period</span> <span class="keyword">of</span> <span class="number">40.00</span> (<span class="keyword">old</span> <span class="keyword">period</span> was</span><br><span class="line"></span><br><span class="line"><span class="number">5.00</span>, added <span class="number">14</span> edges).</span><br></pre></td></tr></table></figure>
<p>​ 建立时间检查在时钟发起沿和捕获沿之间的最短时间内进行。在我们从CLKM到CLKP的示例路径中，这就是24ns处的时钟CLKM发起沿以及25ns处的时钟CLKP捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820163649538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820163925412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告，最严格的保持时间检查是从0ns处的CLKM发起沿到0ns处的CLKP捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820163958956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820164030643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 现在，我们对从CLKP时钟域到CLKM时钟域的路径的建立时间进行检查。在这种情况下，最严格的建立时间检查是从15ns处的时钟CLKP发起沿到16ns处的时钟CLKM捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164157342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820164230477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告，同样，最严格的还是0ns处的检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164321225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2021082016435437.png" alt="img"></p>
<h3 id="相移phase-shifted">相移（Phase Shifted）</h3>
<p>​ 在以下示例中，两个时钟有90°的相移（phase shift）：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period <span class="number">2.0</span> -waveform &#123;<span class="number">0</span> <span class="number">1.0</span>&#125; <span class="selector-attr">[get_ports CKM]</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">2.0</span> -waveform &#123;<span class="number">0.5</span> <span class="number">1.5</span>&#125; <span class="selector-attr">[get_ports CKM90]</span></span><br></pre></td></tr></table></figure>
<p>​ 图8-36给出了使用这两个时钟的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164909372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查的路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164957665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820165025759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 0.5ns处的CKM90第一个上升沿是捕获沿，保持时间检查是在建立时间捕获沿之前一个周期的时钟沿处。对于2ns的发起沿，建立时间捕获沿为2.5ns，因此保持时间检查沿就在0.5ns处的前一个捕获沿。保持时间检查的路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820165204133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在第10章中还会介绍其它时序检查，例如数据到数据（data to data）检查和时钟门控（clock gating）检查。</p>
<h1 id="接口分析interface-analysis">接口分析（Interface Analysis）</h1>
<blockquote>
<p>​ 本章描述了各种类型的输入和输出路径的时序分析程序，以及几种常用的接口。还描述了特殊接口(如SDRM)的时序分析和源同步接口(如DDR sdram)的时序分析。</p>
</blockquote>
<h2 id="io-接口io-interfaces">IO 接口(IO Interfaces)</h2>
<p>​ 本节给出的示例说明了如何定义DUA（设计的芯片）的输入和输出接口的约束。后面的部分提供了SRAM和DDR SDRAM接口的时序约束示例。</p>
<h3 id="输入接口input-interface">输入接口（Input Interface）</h3>
<p>​ 大致有两种指定的输入时序的替代方法:</p>
<ul>
<li>作为 AC 约束的DUA 输入端的波形。</li>
<li>指定外部逻辑到输入的路径延迟。</li>
</ul>
<p><em>数字设备的约束分为两部分：DC - 恒定值（静态）和 AC - 变化的波形（动态）。</em></p>
<p><strong>输入波形约束（Waveform Specification at Inputs）</strong></p>
<p>​ 考虑图 9-1 所示的输入交流约束。约束是输入CIN在时钟CLKP上升沿前4.3ns稳定，值保持稳定直到时钟上升沿后2ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820174357228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 首先考虑 4.3ns 约束。给定 8ns 的时钟周期（如图 9-1 所示），此要求映射到从虚拟触发器（驱动此输入的触发器）到输入 CIN 的延迟。从虚拟触发器时钟到 CIN 的延迟必须最多为 3.7ns (= 8.0 - 4.3)，最大延迟为 3.7ns。这可确保输入 CIN 处的数据在上升沿之前 4.3ns 到达。因此，AC 约束的这一部分可以等效地指定为 3.7ns 的最大输入延迟。</p>
<p>​ AC 约束还指出，输入 CIN 在时钟上升沿后稳定 2ns。这个规范也可以映射到虚拟触发器的延迟，即虚拟触发器到输入CIN的延迟必须至少为2.0ns。因此最小输入延迟指定为 2.0ns。</p>
<p>​ 这里的输入约束为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> <span class="operator">-</span>period <span class="number">8</span> [get_ports <span class="type">CLKP</span>]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span>min <span class="number">2.0</span> <span class="operator">-</span>clock <span class="type">CLKP</span> [get_ports <span class="type">CIN</span>]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span>max <span class="number">3.7</span> <span class="operator">-</span>clock <span class="type">CLKP</span> [get_ports <span class="type">CIN</span>]</span><br></pre></td></tr></table></figure>
<p>​ 以下是这些输入条件下设计的路径报告。首先是建立时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082017485994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 指定的最大输入延迟 (3.7ns) 被添加到数据路径。建立时间检查可确保 DUA 内的延迟小于 4.3ns，并且可以锁存正确的数据。接下来是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820175219324.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820175252174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 最小输入延迟被添加到保持检查中的数据路径。该检查确保，时钟边沿后 2ns 处的最早数据变化不会覆盖触发器处的先前数据。</p>
<p><strong>输入路径延迟约束（Path Delay Specification to Inputs）</strong></p>
<p>​ 已知连接到输入的外部逻辑的路径延迟时，指定输入约束是一项简单的任务。添加外部逻辑路径到输入的任何延迟，并使用 <strong>set_input_delay</strong> 命令指定路径延迟。</p>
<p>​ 图9-2示例输入的外部逻辑路径。添加Tck2q和Tc1延迟以获得外部延迟。知道Tck2q和Tc1后，直接获得输入延迟作为Tck2q Tc1。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082018013184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 外部最大和最小路径延迟转换为以下输入约束。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name RCLK -period <span class="number">10</span> [get_ports RCLK]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">max</span> <span class="number">6.2</span> -<span class="built_in">clock</span> RCLK [get_ports INIT]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">min</span> <span class="number">3.0</span> -<span class="built_in">clock</span> RCLK [get_ports INIT]</span><br></pre></td></tr></table></figure>
<p>​ 它们的路径报告类似于第8.1节和第8.2节中的路径报告。</p>
<p>​ 注意，当计算设计内部触发器的数据引脚处的到达时间时，最大和最小输入延迟值被添加到数据路径延迟中，这取决于是执行最大路径检查（建立时间）还是最小路径检查（保持时间）。</p>
<h3 id="输出接口output-interface">输出接口（Output Interface）</h3>
<p>​ 与输入情况类似，指定输出时序要求大致有两种替代方法：</p>
<ul>
<li>作为AC约束的DUA输出端所需的波形。</li>
<li>指定外部逻辑的路径延迟。</li>
</ul>
<p><strong>输出波形约束（Output Waveform Specification）</strong></p>
<p>​ 考虑图9-3所示的输出AC约束，输出QOUT应该稳定在时钟CKP的上升沿之前的输出2ns。此外，输出应在时钟上升沿后1.5ns后才改变。这些约束通常从与QOUT接口的外部块的设置和保持要求中获得。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820185516273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是在输出上表达此需求的约束。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name CLKP <span class="operator">-</span>period <span class="number">6</span> <span class="operator">-</span>waveform <span class="punctuation">&#123;</span><span class="number">0</span> <span class="number">3</span><span class="punctuation">&#125;</span> <span class="punctuation">[</span>get_ports CLKP<span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup delay of virtual flip-flop:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock CLKP <span class="operator">-</span><span class="built_in">max</span> <span class="number">2.0</span> <span class="punctuation">[</span>get_ports QOUT<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hold time for virtual flip-flop:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock CLKP <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">1.5</span> <span class="punctuation">[</span>get_ports QOUT<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 输出的外部路径延迟最大输出路径延迟指定为2.0ns。这将确保数据QOUT在时钟边缘之前的2ns窗口之前发生变化。最小输出路径延迟-1.5ns从虚拟触发器的角度指定了要求，也就是说，为了确保在输出端口 QOUT的1.5ns的保持时间需求。1.5ns的保持时间要求就是<strong>set_output_delay</strong>中指定的最小值-1.5。</p>
<p>这里是建立时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820190115573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 从下一个时钟沿减去最大输出延迟，以确定到达 DUA 输出所需的时间。</p>
<p>​ 接下来是保持时间检查路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082019023821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 从捕获时钟边沿中减去最小输出延迟（-1.5ns），以确定满足保持时间要求的 DUA 输出的最早到达时间。负最小输出延迟要求很常见。</p>
<p><strong>输出的外部路径延迟（ External Path Delays for Output）</strong></p>
<p>​ 在这种情况下，明确指定了外部逻辑的路径延迟。请参见图 9-4 中的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082019054179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 让我们首先检查建立时间检查。从Tc2_max和Tsetup获得最大输出延迟（set_output_delay max）建立时间。为了检查DUA内部触发器（如UFF0）和虚拟触发器之间输出路径的建立时间要求，将最大输出延迟指定为Tc2_max + Tsetup。</p>
<p>​ 接下来，让我们检查保持时间检查。最小输出延迟（set_output_delay min）设置由Tc2_min和Thold获得。由于捕获触发器的保持时间被添加到捕获时钟路径，最小输出延迟被指定为（Tc2_min-Thold）。</p>
<p>​ 输出上的约束转化为以下内容：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name SCLK <span class="operator">-</span>period <span class="number">5</span> <span class="punctuation">[</span>get_ports SCLK<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup of the external logic (Tc2_max = 2.5,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tsetup = 0.6):</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">3.1</span> <span class="operator">-</span>clock SCLK <span class="punctuation">[</span>get_ports RDY<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hold of the external logic (Tc2_min=1.6, Thold=0.15):</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="number">1.45</span> <span class="operator">-</span>clock SCLK <span class="punctuation">[</span>get_ports RDY<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 它们的路径报告类似于第8.1节和第8.2节中的路径报告。</p>
<h3 id="窗口内的输出变化output-change-within-window">窗口内的输出变化（Output Change within Window）</h3>
<p>​ <strong>set_output_delay</strong> 命令可用于指定输出信号相对于时钟的最大和最小到达时间。本节考虑指定约束的特殊情况，以验证当输出只能在相对于时钟边沿的时序窗口内更改时的场景。在验证源同步接口的时序时，此要求经常出现。</p>
<p>​ 在源同步接口中，时钟也作为输出与数据一起出现。在这种情况下，通常需要时钟和数据之间的时序关系。例如，可能只需要在时钟上升沿附近的特定窗口内更改输出数据。</p>
<p>​ 图 9-5 显示了对源同步接口的示例要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820191516481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 要求是 DATAQ 的每一位只能在时钟上升沿前 2ns 和时钟上升沿后最多 1ns 的指定窗口内发生变化。这与前几节讨论的输出延迟约束完全不同，后者要求数据引脚在时钟上升沿附近的指定时序窗口中保持稳定。</p>
<p>​ 我们在主时钟为 CLKM 的 CLK_STROBE 上创建一个生成时钟。这是为了帮助指定与此接口要求相对应的时序约束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> <span class="operator">-</span>period <span class="number">6</span> [get_ports <span class="type">CLKM</span>&#125;</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">CLK_STROBE</span> <span class="operator">-</span>source <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>divide_by <span class="number">1</span> [get_ports <span class="type">CLK_STROBE</span>]</span><br></pre></td></tr></table></figure>
<p>​ 使用具有多周期路径约束的建立和保持时间检查的组合来指定窗口要求。时序要求映射到必须在单个上升沿（启动和捕获的同一沿）发生的建立时间检查。因此，我们为建立时间指定了一个多周期为 0。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path <span class="number">0</span> -setup -<span class="selector-tag">to</span> <span class="selector-attr">[get_ports DATAQ]</span></span><br></pre></td></tr></table></figure>
<p>​ 此外，保持时间检查必须发生在同一边上，因此我们需要为保持时间检查指定 -1（减一）的多周期。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path -<span class="number">1</span> -hold -<span class="selector-tag">to</span> <span class="selector-attr">[get_ports DATAQ]</span></span><br></pre></td></tr></table></figure>
<p>​ 现在指定关于时钟 CLK_STROBE 的输出时序约束。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_output_delay -<span class="built_in">max</span> <span class="number">-1.0</span> -<span class="built_in">clock</span> CLK_STROBE [get_ports DATAQ]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">min</span> +<span class="number">2.0</span> -<span class="built_in">clock</span> CLK_STROBE [get_ports DATAQ]</span><br></pre></td></tr></table></figure>
<p>​ 请注意，输出延迟约束指定的最小值大于最大值。之所以存在这种异常，是因为在这种情况下，输出延迟约束与实际逻辑块不对应。与典型输出接口的情况不同，输出延迟约束对应于输出端的逻辑块，源同步接口中的 <strong>set_output_delay</strong> 约束只是一种机制，用于验证输出是否被限制在了时钟有效沿附近的指定窗口内才能切换。因此，我们有最小输出延迟约束大于最大输出延迟约束的异常。</p>
<p>​ 这是指定约束的建立时间时序检查路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193033323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820193108653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，发射边沿和捕获边沿是相同的时钟边沿，即时间 0。报告显示 DATAQ 在 0.61ns 处发生变化，而 CLK_STROBE 在 0.09ns 处发生变化。由于 DATAQ 可以在 CLK_STROBE 的 1ns 内发生变化，因此在考虑 0.3ns 的时钟不确定性后有 0.18ns 的裕量。</p>
<p>​ 这是检查时钟另一侧边界的保持路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193300190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820193337452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通过最小路径分析，DATAQ 到达时间为0.48ns，而 CLK_STROBE 到达时间为 0.09ns。由于要求数据在 CLK_STROBE 之前最多可以更改 2ns 限制，因此在考虑 50ps 的时钟不确定性后，我们得到 2.35ns 的裕量。</p>
<p>​ 源同步接口的另一个示例如图 9-6 所示。在这种情况下，输出时钟是主时钟的 2 分频，并且是数据同步接口的一部分。 POUT 被限制在 QCLKOUT 之前不早于 2ns 且不晚于 QCLKOUT 之后的 1ns 切换。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193602967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是约束。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create_clock -<span class="keyword">name</span> CLKM -period <span class="number">6</span> [get_ports CLKM&#125;</span><br><span class="line"></span><br><span class="line">create_generated_clock -<span class="keyword">name</span> QCLKOUT -source CLKM -divide_by <span class="number">2</span> [get_ports QCLKOUT]</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">0</span> -setup -<span class="keyword">to</span> [get_ports POUT]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_multicycle_path -<span class="number">1</span> -hold -<span class="keyword">to</span> [get_ports POUT]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_output_delay -max -<span class="number">1.0</span> -clock QCLKOUT [get_ports POUT]</span><br><span class="line"></span><br><span class="line">set_output_delay -min +<span class="number">2.0</span> -clock QCLKOUT [get_ports POUT]</span><br></pre></td></tr></table></figure>
<p>​ 下面是建立时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193819667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820193910330.png" alt="img"></p>
<p>​ 请注意，多周期约束已将建立时间检查移回一个周期，以便在同一时钟沿执行检查。输出 POUT 在 0.61ns处 变化，而时钟 QCLKOUT 在 0.27ns处 变化。鉴于要求在 1ns 内改变，并考虑 0.30ns 的时钟不确定性，我们得到 0.36ns 的裕量。</p>
<p>​ 这是检查切换窗口上的其他约束的保持路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820194609756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820194811877.png" alt="img"></p>
<p>​ 路径报告显示，数据在 QCLKOUT 时钟边沿之前 2ns 的允许窗口内发生变化，并且存在 2.17ns 的裕量。</p>
<h2 id="sram-接口sram-interface">SRAM 接口（SRAM Interface）</h2>
<p>​ SRAM 接口中的所有数据传输仅在时钟的有效边沿发生。所有信号都由 SRAM 锁存或仅在有效时钟沿由 SRAM 启动。构成 SRAM 接口的信号包括命令、地址和控制输出总线 (CAC)、双向数据总线 (DQ) 和时钟。在写周期中，DUA 将数据写入 SRAM，数据和地址从 DUA 传输到 SRAM，并在有效时钟沿锁存在 SRAM 中。在读周期中，地址信号仍然从 DUA 到 SRAM，而从 SRAM 输出的数据信号到 DUA。因此地址和控制是单向的，从 DUA 到 SRAM，如图 9-7 所示。 <strong>DLL(delay-locked loop延迟锁定环 ）</strong>通常放置在时钟路径中。 DLL 允许延迟时钟（如有必要），以解决由于 PVT 和其他外部变化引起的跨接口的各种信号的延迟变化。通过考虑这些变化，对于往返 SRAM 的读周期和写周期的数据传输都有很好的时序余量。</p>
<p>​ 图 9-8 显示了典型 SRAM 接口的交流特性。请注意，图9-8中的数据输入和数据输出是指SRAM看到的方向。来自SRAM的Data out是DUA的输入，进入SRAM的Data in是DUA的输出。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082021031111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First define primary clock at the output of UPLL0:</span></span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name PLL_CLK <span class="operator">-</span>period <span class="number">5</span> <span class="punctuation">[</span>get_pins UPLL0<span class="operator">/</span>CLKOUT<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Next define a generated clock at clock output pin of DUA:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name SRAM_CLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source <span class="punctuation">[</span>get_pins UPLL0<span class="operator">/</span>CLKOUT<span class="punctuation">]</span> <span class="operator">-</span>divide_by <span class="number">1</span> <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports SRAM_CLK<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constrain the address and control:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">1.5</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports ADDR<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.5</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports ADDR<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Constrain the data going out of DUA:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">1.7</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.8</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constrain the data coming into the DUA:</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">3.2</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="built_in">min</span> <span class="number">1.7</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 这是地址引脚的代表性建立时间路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820211339616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查验证地址信号是否在 SRAM_CLK 边沿之前 1.5ns处（存储器地址引脚的设置时间）到达存储器。</p>
<p>​ 这是同一引脚的保持时间时序路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820211705190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间检查验证地址信号是否在时钟边沿后 0.5ns 内保持稳定。</p>
<h2 id="ddr-sdram-接口ddr-sdram-interface">DDR SDRAM 接口（DDR SDRAM Interface）</h2>
<p>​ DDR SDRAM 接口可以看作是上一节描述的 SRAM 接口的扩展。就像SRAM接口一样，有两条主要的总线。图 9-9 说明了 DUA 和 SDRAM 之间的总线连接和总线方向。第一个总线由命令、地址和控制引脚（通常称为 CAC）组成，使用标准方案在内存时钟的一个时钟沿（或每个时钟周期一次）发送信息。两条双向总线由数据总线 DQ 和数据选通 DQS 组成。 DDR 接口的主要区别在于双向数据选通 DQS。为一组数据信号提供 DQS 选通。这允许数据信号（每字节一个或每半字节一个）与选通信号具有紧密匹配的时序；如果时钟对于整个数据总线是通用的，那么这种紧密匹配对于时钟信号可能是不可行的。双向选通信号 DQS 用于读取和写入操作。选通用于在其两个边沿（下降沿和上升沿或双倍数据速率）上捕获数据。在SDRAM的读模式下，DQ总线源同步于数据选通DQS（而不是存储器时钟），即DQ和DQS从SDRAM发出时是对齐的。在另一个方向，即 DUA 发送数据时，DQS 相移 90 度。请注意，数据 DQ 和选通 DQS 边沿均源自 DUA 内的存储器时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820212024441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上所述，对于一组 DQ 信号（四位或八位）有一个数据选通 DQS。这样做是为了使 DQ 和 DQS 的所有位之间的偏斜平衡要求更容易。例如，一个字节一个DQS，一组9个信号（8个DQ和一个DQS）需要平衡，这比用时钟平衡72位数据总线要容易得多。</p>
<p>​ 上面的描述不是对 DDR SDRAM 接口的完整解释，尽管足以解释这种接口的时序要求。</p>
<p>​ 图 9-10 显示了典型 DDR SDRAM 接口的 CAC 总线（在 DUA 处）的交流特性。这些建立和保持要求映射到 CAC 总线的以下接口约束。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820212248862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DDRCLK is typically a generated clock of the PLL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clock internal to DUA:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name DDRCLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>source <span class="punctuation">[</span>get_pins UPLL0<span class="operator">/</span>CLKOUT<span class="punctuation">]</span><span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>divide_by <span class="number">1</span> <span class="punctuation">[</span>get_ports DDRCLK<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Set output constraints for each bit of CAC:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.75</span> <span class="operator">-</span>clock DDRCLK <span class="punctuation">[</span>get_ports CAC<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.75</span> <span class="operator">-</span>clock DDRCLK <span class="punctuation">[</span>get_ports CAC<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 在某些情况下，地址总线可能会驱动比时钟大得多的负载，尤其是在与无缓冲存储器模块接口时。在这种情况下，地址信号比时钟信号具有更大的存储器延迟，这种延迟差异可能导致与图 9-10 中描述的不同的 AC 约束。</p>
<p>​ DQS 和 DQ 的对齐对于读和写周期是不同的。这将在以下小节中进一步探讨。</p>
<h3 id="读取周期read-cycle">读取周期（Read Cycle）</h3>
<p>​ 在读周期中，存储器输出的数据与 DQS 边沿对齐。波形如图 9-11 所示；图中的 DQ 和 DQS 代表存储器引脚上的信号。数据 (DQ) 由存储器在 DQS 的每个边沿发出，并且 DQ 转换与 DQS 的下降沿和上升沿边沿对齐。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820213331438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于 DQS 选通信号和 DQ 数据信号名义上彼此对齐，因此 DUA 内的存储器控制器通常使用 DLL（或任何替代方法来实现四分之一周期延迟）来延迟 DQS，从而对齐延迟的DQS 边缘与数据有效窗口的中心。</p>
<p>​ 即使 DQ 和 DQS 名义上在内存中对齐，但 DQ 和 DQS 选通信号可能不再在 DUA 内的内存控制器上对齐。这可能是由于 IO 缓冲器之间的延迟差异以及 PCB 互连走线的差异等因素造成的。</p>
<p>​ 图9-12中为基本的数据读取原理图。上升沿触发的触发器在DQS_DLL的上升沿捕获数据DQ，而下降沿触发的触发器在DQS_DLL的下降沿捕获数据DQ。虽然图中的DQ路径上没有DLL，但某些设计可能在数据路径上也会放置一个DLL。这样可以用来延迟信号（以解决由于PVT或互连走线长度或其它差异引起的变化），以便可以在数据有效窗口的中间准确地采样数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820213548856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 为了约束控制器上的读取接口，在 DQS 上定义了一个时钟，并在与时钟相关的数据上指定了输入延迟。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_clock -period <span class="number">5</span> -name DQS <span class="selector-attr">[get_ports DQS]</span></span><br></pre></td></tr></table></figure>
<p>​ 这假设内存读取接口以 200 MHz 运行（相当于 400 Mbps，因为数据在两个时钟边沿传输），并且对应于每 2.5ns 采样一次的 DQ 信号。由于数据是在两条边上捕获的，因此需要为每条边明确指定输入约束。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For rising clock edge:</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">0.4</span> <span class="operator">-</span><span class="built_in">max</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="number">0.4</span> <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is with respect to clock rising edge (default).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similarly for falling edge:</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">0.35</span> <span class="operator">-</span><span class="built_in">max</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="number">0.35</span> <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The launch and capture are on the same edge:</span></span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">0</span> <span class="operator">-</span>setup <span class="operator">-</span>to UFF0<span class="operator">/</span>D</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">0</span> <span class="operator">-</span>setup <span class="operator">-</span>to UFF5<span class="operator">/</span>D</span><br></pre></td></tr></table></figure>
<p>​ 输入延迟命令指定了DUA引脚上DQ和DQS沿之间的延迟差，即使这两个信号通常是从存储器中同时输出的，但由于不同存储器的规格，在时序上仍会存在偏差。因此，DUA内的控制器设计应考虑到两个信号之间可能存在偏斜（skew）。以下是两个触发器建立时间检查的路径报告。假设捕获触发器的建立时间要求为0.05ns、保持时间要求为0.03ns，且DLL延迟设置为1.25ns，即四分之一周期 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820214821164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820214852999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820214916862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215011788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2021082021504258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="写周期write-cycle">写周期（Write Cycle）</h3>
<p>​ 在写周期中，DQS 边沿与来自 DUA 内的存储器控制器的 DQ 信号有四分之一周期的偏移，因此 DQS 选通可用于捕获存储器中的数据。</p>
<p>​ 图9-13显示了存储器引脚上所需的波形，在存储器引脚处，DQS信号必须与DQ数据窗口的中心对齐。请注意，仍然是由于IO缓冲器延迟不匹配或者PCB互连走线的变化，仅在存储控制器（DUA内部）中对齐DQ和DQS还不足以使这些信号在SDRAM存储器引脚处真正的对齐。因此，DUA通常在写周期中使用额外的DLL去进行控制，以实现DQS和DQ信号之间所需的四分之一周期偏移（offset）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215207808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 约束此模式的输出取决于在控制器中生成时钟的方式。我们考虑两种情况。</p>
<p><strong>情况 1：内部 2x 时钟（Case 1: Internal 2x Clock）</strong></p>
<p>​ 如果有两倍于 DDR 时钟频率的内部时钟可用，则输出逻辑可以类似于图 9-14 中所示的逻辑。 DLL 提供了一种机制，可在必要时偏移 DQS 时钟，以便满足存储器引脚上的建立和保持要求。在某些情况下，可能不使用 DLL - 而是使用负沿触发器来获得 90 度偏移。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215347243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于图 9-14 所示的场景，输出可以被约束为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 166MHz (333Mbps) DDR; 2x clock is at 333MHz:</span></span><br><span class="line"></span><br><span class="line">create_clock -period 3 [get_ports CLK2X]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a 1x generated clock at the output of flip-flop:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name pre_DQS -<span class="built_in">source</span> CLK2X \</span><br><span class="line"></span><br><span class="line">-divide_by 2 [get_pins UFF1/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the delayed version as DQS assuming 1.5ns DLL delay:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name DQS -<span class="built_in">source</span> UFF1/Q \</span><br><span class="line"></span><br><span class="line">-edges &#123;1 2 3&#125; -edge_shift &#123;1.5 1.5 1.5&#125; [get_ports DQS]</span><br></pre></td></tr></table></figure>
<p>​ DQ 输出引脚的时序必须相对于生成的时钟 DQS 进行约束。</p>
<p>​ 假设DDR SDRAM的DQ和DQS管脚之间的设置要求分别为DQ的上升沿和下降沿为0.25ns和0.4ns。同样，假设 DQ 引脚的上升沿和下降沿需要 0.15ns 和 0.2ns 的保持时间。 DQS 输出的 DLL 延迟已设置为四分之一周期，即 1.5ns。波形如图 9-15 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215528622.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.25</span> <span class="operator">-</span>rise <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default above is rising clock.</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.4</span> <span class="operator">-</span>fall <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If setup requirements are different for falling edge of DQS,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># that can be specified by using the -clock_fall option.</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.15</span> <span class="operator">-</span>rise DQ</span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.2</span> <span class="operator">-</span>fall DQ</span><br></pre></td></tr></table></figure>
<p>​ 这是通过输出 DQ 的建立时间报告。建立时间检查是从 0ns 时 CLK2X 的上升沿开始，在 1.5ns 时启动 DQ 到 DQS 的上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082021565414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，上述报告中的四分之一周期延迟出现在了时钟DQS上升沿的第一行中，而不是在DLL实例UDLL0的那行中。这是因为DLL延迟已被建模为了衍生时钟DQS定义的一部分，而不是DLL时序弧中的一部分。</p>
<p>​ 以下是通过输出DQ路径的保持时间检查报告。保持时间检查从3ns处发起DQ的时钟CLK2X上升沿到1.5ns处的DQS前一个上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082021572331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>情况 2：内部 1x 时钟（Case 2: Internal 1x Clock）</strong></p>
<p>​ 当只有内部 1x 时钟可用时，输出电路通常类似于图 9-16 中所示的电路。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820220343806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 有两个触发器用于生成 DQ 数据。第一个触发器NEGEDGE_REG由时钟CLK1X的负沿触发，第二个触发器POSEDGE_REG由时钟CLK1X的正沿触发。每个触发器锁存适当的边沿数据，然后使用 CLK1X 作为多路复用器选择多路复用输出该数据。当 CLK1X 为高电平时，触发器 NEGEDGE_REG 的输出被送到 DQ。当 CLK1X 为低电平时，触发器 POSEDGE_REG 的输出被送到 DQ。因此，数据在时钟 CLK1X 的两个边沿到达输出 DQ。请注意，每个触发器都有半个周期将数据传播到多路复用器的输入，以便输入数据在被 CLK1X 边沿选择之前在多路复用器处准备就绪。相关波形如图 9-17 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082022045226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create the 1x clock:</span></span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name CLK1X <span class="operator">-</span>period <span class="number">6</span> <span class="punctuation">[</span>get_ports CLK1X<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a generated clock at DQS. It is a divide-by-1 of</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CLK1X. Assume a quarter-cycle delay of 1.5ns on UDLL0:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name DQS <span class="operator">-</span>source CLK1X <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>edges <span class="punctuation">&#123;</span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span><span class="punctuation">&#125;</span> <span class="operator">-</span>edge_shift <span class="punctuation">&#123;</span><span class="number">1.5</span> <span class="number">1.5</span> <span class="number">1.5</span><span class="punctuation">&#125;</span> <span class="punctuation">[</span>get_ports DQS<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a setup check of 0.25 and 0.3 between DQ and DQS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pins on rising and falling edge of clock:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.25</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.3</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.2</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.27</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 建立和保持检查验证从多路复用器到输出的时序。设置检查之一是从多路复用器输入处的 CLK1X 上升沿（启动 NEGEDGE_REG 数据）到 DQS 的上升沿。另一个设置检查是从多路复用器输入（启动 POSEDGE_REG 数据）处的 CLK1X 下降沿到 DQS 的下降沿。类似地，保持检查是从相同的 CLK1X 边沿（如设置检查）到 DQS 的前一个下降沿或上升沿。</p>
<p>​ 这是通过端口 DQ 的建立时间检查报告。检查在选择 NEGEDGE_REG 输出的 CLK1X 的上升沿和 DQS 的上升沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221033546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820221110528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820221144131.png" alt="img"></p>
<p>​ 这是通过端口 DQ 的另一个设置时序检查报告。此设置检查在选择 POSEDGE_REG 输出的 CLK1X 下降沿和 DQS 下降沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221236695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是通过端口 DQ 的保持时间检查报告。检查在 CLK1X 的上升沿和 DQS 的前一个下降沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221347904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是通过端口 DQ 的另一个保持时序检查报告。该检查在 CLK1X 的下降沿和 DQS 的前一个上升沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221446443.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820221515820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 虽然上述接口时序分析忽略了任何负载对输出的影响，但可以指定额外的负载（使用 set_load）以获得更高的准确性。然而，STA 可以通过电路模拟来补充，以实现如下所述的稳健 DRAM 时序。</p>
<p>​ DDR 接口的 DQ 和 DQS 信号通常在读取和写入模式下使用 ODT（On-Die Termination），以减少由于 DRAM 和 DUA 的阻抗不匹配引起的任何反射。存在 ODT 终端时，用于 STA 的时序模型无法提供足够的精度。设计人员可以使用另一种机制，例如详细的电路级模拟来验证 DRAM 接口的信号完整性和时序。</p>
<h2 id="视频-dac-接口interface-to-a-video-dac">视频 DAC 接口（Interface to a Video DAC）</h2>
<p>​ 考虑图 9-18，它显示了一个典型的 DAC（Digital to Analog Converter）接口，其中高速时钟正在将数据传输到 DAC 的低速时钟接口。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221750364.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时钟 DAC_CLK 是时钟 XPLL_CLK 的 2 分频。 DAC 建立和保持检查与 DAC_CLK 的下降沿有关。</p>
<p>​ 在这种情况下，建立时间被视为单周期 (XPLL_CLK) 路径，即使从较快时钟域到较慢时钟域的接口可以在必要时指定为多周期路径。如图 9-18 所示，XPLL_CLK 的上升沿发射数据，DAC_CLK 的下降沿捕获数据。这是建立时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082022194144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，接口是从较快的时钟到较慢的时钟，因此如有必要，可以将其设置为双周期路径。</p>
<p>​ 这是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820222044800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间检查是在建立时间捕获沿之前一个周期完成的。在这种接口情况下，最关键的保持时间检查是在发起沿和捕获沿重合处执行的，这显示在保持时序报告中。</p>
<h1 id="稳健验证robust-verification">稳健验证（Robust Verification）</h1>
<blockquote>
<p>​ 本章描述了特殊的 STA 分析，例如时间借用（ time borrowing）、时钟门控（clock gating）和非顺序时序检查（non-sequential timing checks）。此外，还介绍了先进的 STA 概念，例如片上变化（on-chip variation）、统计时序（statistical timing analysis）以及功率与时序之间的权衡。</p>
</blockquote>
<h2 id="片上变化on-chip-variations">片上变化（On-Chip Variations）</h2>
<p>​ 通常，工艺和各环境参数在芯片的不同部分上可能不一致。由于工艺差异，芯片上不同部分的相同MOS晶体管可能没有相似的特性，这些差异是由于芯片内部的工艺差异引起的。请注意，多个制造批次中的工艺参数差异可能会覆盖慢工艺到快工艺（2.10节中所介绍）。在本节中，我们讨论的是对一个芯片上可能存在的工艺差异（称为<strong>局部工艺差异local process variations</strong>）的分析，该差异远小于多个制造批次之间的差异（称为<strong>全局工艺差异 global process variations</strong>）。</p>
<p>​ 除了工艺参数的变化，设计的不同部分也可能会遇到不同的电源电压和温度。因此，同一芯片的两个区域可能不处于相同的 PVT 条件。这些差异可能由许多因素引起，包括：</p>
<ul>
<li>会影响局部电源电压的沿芯片区域的IR压降变化</li>
<li>PMOS或NMOS器件的电压阈值变化</li>
<li>PMOS或NMOS器件的沟道长度变化</li>
<li>由于局部热点造成的温度变化</li>
<li>互连金属刻蚀或厚度变化会影响互连电阻或电容</li>
</ul>
<p>​ 上述 PVT 变化被称为片上变化 (<strong>On-Chip Variations，OCV</strong>)，这些变化会影响芯片不同部分的线延迟和单元延迟。如上所述，OCV 的建模并不是要对晶片与晶片之间可能的 PVT 变化的整个范围进行建模，而是要对单个管芯内局部可能的 PVT 变化进行建模。 OCV 效应通常在时钟路径上更明显，因为它们在芯片中行进的距离更长。考虑局部 PVT 变化的一种方法是在 STA 期间合并 OCV 分析。前几章中描述的静态时序分析是在特定<strong>时序角（timing corner）</strong>获得时序，而不是对沿芯片的变化进行建模。由于 OCV 对时钟和数据路径的影响可能不同，时序验证可以通过使发射和捕获路径的 PVT 条件略有不同来模拟 OCV 效应。 STA 可以通过<strong>降额（derate）</strong>特定路径的延迟来包含 OCV 效应，也就是说，通过使这些路径更快或更慢，然后使用这些变化来验证设计的行为。单元延迟或线延迟或两者都可以降额以模拟 OCV 的影响。</p>
<p>​ 我们现在检查 OCV 降额是如何进行建立时间检查的。考虑图 10-1 中所示的逻辑，其中 PVT 条件可以随芯片变化。当启动时钟路径和数据路径具有导致最大延迟的 OCV 条件，而捕获时钟路径具有导致最小延迟的 OCV 条件时，建立时间检查的最差条件发生。请注意，这里的最小和最大是由于裸片上的局部 PVT 变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820223333186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>对于此示例，以下是建立时间检查，注意此处还不包括任何用于降额延迟的OCV设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LaunchClockPath <span class="operator">+</span> MaxDataPath <span class="operator">&lt;=</span> ClockPeriod <span class="operator">+</span> CaptureClockPath <span class="operator">-</span> Tsetup_UFF1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">This implies that the minimum clock <span class="keyword">period</span> <span class="operator">=</span> </span><br><span class="line"></span><br><span class="line">        LaunchClockPath <span class="operator">+</span> MaxDataPath <span class="operator">-</span> CaptureClockPath <span class="operator">+</span> Tsetup_UFF1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">From</span> the figure,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LaunchClockPath <span class="operator">=</span> <span class="number">1.2</span> <span class="operator">+</span> <span class="number">0.8</span> <span class="operator">=</span> <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">MaxDataPath <span class="operator">=</span> <span class="number">5.2</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">CaptureClockPath <span class="operator">=</span> <span class="number">1.2</span> <span class="operator">+</span> <span class="number">0.86</span> <span class="operator">=</span> <span class="number">2.06</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Tsetup_UFF1 <span class="operator">=</span> <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">This results <span class="keyword">in</span> a minimum clock <span class="keyword">period</span> <span class="keyword">of</span>:</span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span> <span class="operator">+</span> <span class="number">5.2</span> – <span class="number">2.06</span> <span class="operator">+</span> <span class="number">0.35</span> <span class="operator">=</span> <span class="number">5.49</span>ns</span><br></pre></td></tr></table></figure>
<p>​ 上述路径延迟对应于没有任何 OCV 降额的延迟值。可以使用 set_timing_derate 规范来降低单元和网络延迟。例如，命令：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<p>​ 上述命令将最小/最短/最早路径的延迟降低了20％，并将最大/最长/最迟路径的延迟增加了10％。长路径的延迟（例如，用于建立时间检查的数据路径和发起时钟路径或用于保持时间检查的捕获时钟路径）将乘以使用<strong>-late</strong>选项指定的降额值，而短路径的延迟（例如，用于建立时间检查的捕获时钟路径或用于保持时间检查的数据路径和发起时钟路径）将乘以使用<strong>-early</strong>选项指定的降额值。如果未指定降额系数，则假定值为1.0。</p>
<p>​ 降额系数将统一应用于所有网络延迟和单元延迟，如果某个应用场景中需要保证单元和网络的降额系数不同，则可以在<strong>set_timing_derate</strong>命令中使用<strong>-cell_delay</strong>和<strong>-net_delay</strong>选项。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Derate only the cell delays - early paths by -10%, and</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no derate on the late paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -cell_delay -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -cell_delay -late <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Derate only the net delays - no derate on the early paths</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># and derate the late paths by +20%:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -net_delay -early <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -net_delay -late <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>​ 可以使用<strong>-cell_check</strong>选项来对单元检查（例如建立时间和保持时间）的延迟进行降额。使用此选项时，使用<strong>set_output_delay</strong>指定的任何输出延迟也将被降额，因为此约束也是输出建立时间要求的一部分。但是，对于使用<strong>set_input_delay</strong>指定的输入延迟，是不会被降额的。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Derate the cell timing check values:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.8</span> -cell_check</span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.1</span> -cell_check</span><br><span class="line"></span><br><span class="line"><span class="comment"># Derate the early clock paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.95</span> -clock</span><br><span class="line"></span><br><span class="line"><span class="comment"># Derate the late data paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.05</span> -data</span><br></pre></td></tr></table></figure>
<p>​ <strong>-clock</strong>选项仅将降额应用于时钟路径。同样，<strong>-data</strong>选项仅将降额应用于数据路径。</p>
<p>​ 我们现在将以下降额应用于图 10-1 的示例。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.1</span> -cell_check</span><br><span class="line">使用这些降额值，我们得到以下建立时间检查的结果：</span><br><span class="line"></span><br><span class="line">LaunchClockPath = <span class="number">2.0</span> * <span class="number">1.2</span> = <span class="number">2.4</span></span><br><span class="line"></span><br><span class="line">MaxDataPath = <span class="number">5.2</span> * <span class="number">1.2</span> = <span class="number">6.24</span></span><br><span class="line"></span><br><span class="line">CaptureClockPath = <span class="number">2.06</span> * <span class="number">0.9</span> = <span class="number">1.854</span></span><br><span class="line"></span><br><span class="line">Tsetup_UFF1 = <span class="number">0.35</span> * <span class="number">1.1</span> = <span class="number">0.385</span></span><br><span class="line"></span><br><span class="line">最小时钟周期为</span><br><span class="line"></span><br><span class="line"><span class="number">2.4</span> + <span class="number">6.24</span> – <span class="number">1.854</span> + <span class="number">0.385</span> = <span class="number">7.171</span>ns</span><br></pre></td></tr></table></figure>
<p>​ 在上面的建立时间检查中，存在差异，因为时钟树的公共时钟路径（图 10-1）具有 1.2ns 的延迟，对于启动时钟和捕获时钟的降额不同。时钟树的这一部分对启动时钟和捕获时钟都是通用的，不应以不同的方式降额。对启动和捕获时钟应用不同的降额过于悲观，因为实际上时钟树的这一部分将真正处于一个 PVT 条件下，要么作为最大路径，要么作为最小路径（或介于两者之间），但永远不会同时处于同时。对时钟树公共部分应用不同降额因子引起的悲观情绪称为<strong>公共路径悲观情绪（Common Path Pessimism，CPP）</strong>，在分析过程中应将其去除。 CPPR 代表 <strong>Common Path Pessimism Removal</strong>，通常在路径报告中作为单独的项目列出。它也被标记为<strong>时钟重新收敛悲观消除</strong>（ <strong>Clock Reconvergence Pessimism Removal，CRPR）</strong>。</p>
<p>​ CPPR 是在时序分析中去除启动时钟路径和捕获时钟路径之间人为引起的悲观情绪。如果相同的时钟同时驱动捕获和启动触发器，那么时钟树可能会在分支之前共享一个公共部分。由于启动和捕获时钟路径的降额不同，CPP 本身就是沿时钟树的这个公共部分的延迟差异。时钟信号在公共点的最小和最大到达时间之间的差值是 CPP。<strong>公共点（ common point）</strong>定义为时钟树公共部分中最后一个单元的输出引脚。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CPP</span> = <span class="title class_">LatestArrivalTime</span><span class="meta">@CommonPoint</span> – <span class="title class_">EarliestArrivalTime</span><span class="meta">@CommonPoint</span></span><br></pre></td></tr></table></figure>
<p>​ 上述分析中的“最晚时间”和“最早时间”是指在特定工艺角（Corner）下的OCV降额值，例如最坏情况下的慢速（Worst-Case-Slow）或最佳情况下的快速（Best-Case-Fast）。对于图10-1的示例：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LatestArrivalTime<span class="keyword">@CommonPoint</span> = <span class="number">1.2</span> * <span class="number">1.2</span> = <span class="number">1.44</span></span><br><span class="line"></span><br><span class="line">EarliestArrivalTime<span class="keyword">@CommonPoint</span> = <span class="number">1.2</span> * <span class="number">0.9</span> = <span class="number">1.08</span></span><br><span class="line"></span><br><span class="line">This implies a CPP <span class="attribute">of</span>: <span class="number">1.44</span> - <span class="number">1.08</span> = <span class="number">0.36</span>ns</span><br><span class="line"></span><br><span class="line">With the CPP correction, this results in a</span><br><span class="line"></span><br><span class="line">minimum clock period <span class="attribute">of</span>: <span class="number">7.171</span> - <span class="number">0.36</span> = <span class="number">6.811</span>ns</span><br></pre></td></tr></table></figure>
<p>​ 应用OCV降额将本示例设计的最小时钟周期从5.49ns增加到6.811ns。这说明，由这些降额系数模拟的OCV变化可降低设计的最大运行频率。</p>
<p><strong>在最坏 PVT 条件下使用 OCV 进行分析（Analysis with OCV at Worst PVT Condition）</strong></p>
<p>​ 如果在最坏的 PVT 条件下执行建立时序检查，则不需要对后期路径进行降额，因为它们已经是最差的。但是，可以通过使用特定的降额来使这些路径更快，例如，将早期路径加速 10%，从而将降额应用于早期路径。在最坏情况下慢速corner的降额约束可能类似于：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don’t derate the late paths as they are already the slowest,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># but derate the early paths to make these faster by 10%.</span></span><br></pre></td></tr></table></figure>
<p>​ 上述降额设置用于最坏情况慢速角的最大路径（或setup）检查；因此，后期路径 OCV 降额设置保持在 1.0，以免使其减速超过最坏情况的慢速转角。</p>
<p>​ 下面描述了在最坏情况下慢转角的setup时序检查示例。为以下捕获时钟路径指定了降额约束：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Derate the early clock paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.8</span> -clock</span><br></pre></td></tr></table></figure>
<p>​ 以下是在最坏情况下的慢角执行的setup时序检查路径报告。延迟路径使用的降额报告为Max Data Paths Derating Factor 和 Max Clock Paths Derating Factor。</p>
<p>​ 用于早期路径的降额报告为Min Clock Paths Derating Factor（最小时钟路径降额因子）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828114206571.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，捕获时钟路径降额了 20%。请参阅时序报告中的单元 UCKBUF0。在发射路径中，它具有 56ps 的延迟，而在捕获路径中具有 45ps 的降额延迟。单元 UCKBUF0 在公共时钟路径上，即在捕获时钟路径和启动时钟路径上。由于公共时钟路径不能有不同的降额，因此该公共路径的时序差异 56ps - 45ps = 11ps 将单独校正。这在报告中表现为线路clock reconvergence pessimism。总之，如果要比较这条路径的报告，有和没有降额，人们会注意到只有捕获时钟路径的单元和网络延迟被降额了。</p>
<p><strong>OCV 用于保持检查（OCV for Hold Checks）</strong></p>
<p>​ 我们现在检查如何进行降额以进行保持时序检查。考虑图 10-2 所示的逻辑。如果沿芯片的 PVT 条件不同，当启动时钟路径和数据路径具有导致最小延迟的 OCV 条件时，即当我们有最早的启动时钟时，保持检查的最坏条件发生，并且捕获时钟路径具有导致最大延迟的 OCV 条件，即具有最新的捕获时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828114915472.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对于此示例，在以下表达式中指定了保持时序检查 ：</p>
<p><embed src="https://latex.codecogs.com/gif.latex?LaunchClockPath%20+%20MinDataPath%20-CaptureClockPath%20-TholdUFF1%20%3E%3D%200"></p>
<p>​ 将图 10-2 中的延迟值应用于表达式，我们得到（不应用任何降额）：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?LaunchClockPath%20%3D%200.25%20+%200.6%20%3D%200.85"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?MinDataPath%20%3D%201.7"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?CaptureClockPath%20%3D%200.25%20+%200.75%20%3D%201.00"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?TholdUFF1%20%3D%201.25"></p>
<p>​ 这意味着条件是：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?0.85%20+%201.7%20-%201.00%20-%201.25%20%3D%200.3n%20%3E%3D0"></p>
<p>​ 这是真的，因此不存在保持违规。</p>
<p>​ 应用以下降额约束：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.95</span> -cell_check</span><br></pre></td></tr></table></figure>
<p>​ 可以得到</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LaunchClockPath = 0.85 <span class="emphasis">* 0.9 = 0.765</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">MinDataPath = 1.7 *</span> 0.9 = 1.53</span><br><span class="line"></span><br><span class="line">CaptureClockPath = 1.00 <span class="emphasis">* 1.2 = 1.2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Thold_UFF1 = 1.25 *</span> 0.95 = 1.1875</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Common clock path pessimism: 0.25 <span class="emphasis">* (1.2 - 0.9) = 0.075</span></span><br></pre></td></tr></table></figure>
<p>​ 通过对启动和捕获时钟路径的公共时钟树应用降额而产生的公共时钟路径悲观情绪也被移除以进行保持时序检查。然后保持检查条件变为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?0.765%20+%201.53%20-1.2%20-%201.1875%20+%200.075%20%3D%20-0.0175ns"></p>
<p>​ 它小于 0，因此表明存在违反保持的情况，将 OCV 降额因子应用于早期和晚期路径。</p>
<p>​ 通常，保持时序检查在最佳情况下的快速 PVT corner执行。在这种情况下，不需要对早期路径进行降容，因为这些路径已经是最早的可能。但是，可以通过将延迟路径降低特定的降额因子来对延迟路径应用降额，例如，将延迟路径减慢 20%。这个corner的降额约束将类似于：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don’t derate the early paths as they are already the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastest, but derate the late paths slower by 20%.</span></span><br></pre></td></tr></table></figure>
<p>​ 在图10-2例子中，</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LatestArrivalTime<span class="variable">@CommonPoint</span> = <span class="number">0.25</span> * <span class="number">1.2</span> = <span class="number">0.30</span></span><br><span class="line"></span><br><span class="line">EarliestArrivalTime<span class="variable">@CommonPoint</span> = <span class="number">0.25</span> * <span class="number">1.0</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>​ 这意味着一个共同的路径悲观性：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?0.30%20-%200.25%20%3D%200.05ns"></p>
<p>​ 以下是使用此降额的示例设计的保持时序检查路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828120250589.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，后期路径的额定值降低了 20%，而早期的路径并未降低额定值。请参阅单元格 UCKBUF0。它在发射路径上的延迟为 56ps，而在捕获路径上的延迟为 67ps - 降额了 20%。 UCKBUF0是公共时钟树上的单元，因此该公共时钟树上因不同降额引入的悲观情绪为，67ps - 56ps = 11ps，在线clock reconvergence pessimism中单独考虑。</p>
<h2 id="时间借用time-borrowing">时间借用（Time Borrowing）</h2>
<p>​ 时间借用（ <strong>time borrowing</strong>）技术，也称为<strong>cycle stealing</strong>，发生在锁存器上。在锁存器中，时钟的一个边沿使锁存器透明，也就是说，它打开锁存器，使锁存器的输出与数据输入相同；这个时钟边缘称为开启边沿（ <strong>opening edge</strong>）。时钟的第二个边沿关闭锁存器，即数据输入上的任何更改在锁存器的输出端不再可用；此时钟边沿称为闭合边沿（ <strong>closing edge</strong>）。</p>
<p>​ 通常，数据应该在时钟的有效边沿之前在锁存输入端准备就绪。然而，由于锁存器在时钟有效时是透明的，因此数据到达的时间可能晚于有效时钟边沿，也就是说，它可以从下一个周期借用时间。如果借用了这样的时间，则可用于下一阶段(锁存到另一顺序单元)的时间减少。</p>
<p>​ 图10-3显示了使用主动上升沿借用时间的示例。如果数据DIN在10 ns的CLK上升沿上的锁存器打开之前的时间A准备就绪，则数据在锁存器打开时流向锁存器的输出。如果数据如DIN(延迟)所示在时间B到达，则借用时间Tb。然而，这减少了从锁存器到下一个触发器UFF2的可用时间-而不是整个时钟周期，只有时间Ta可用。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828121452541.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 锁存器时序的第一条规则是，如果数据在锁存器的开启边缘之前到达，则行为建模与触发器完全相同。起始边沿捕获数据，相同的时钟边沿启动数据作为下一条路径的起始点。</p>
<p>​ 第二个规则适用于数据信号到达时，而锁存器是透明的(在开口和闭合边缘之间)。锁存器的输出，而不是时钟引脚，被用作下一级的启动点。在锁存器结束的路径借用的时间量决定了下一阶段的启动时间。</p>
<p>​ 在锁存器的闭合沿之后到达的数据信号是时序冲突。图10-4显示了positive slack, zero slack, 和negative slack (即发生违规时)的数据到达时序区域。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828121743872.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828121905272.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-5(A)显示了具有通向下一级触发器的半周期路径的锁存器的使用。图10-5(B)描述了借用时间场景的波形。时钟周期为10 ns。数据由UFF0在时间0启动，但数据路径需要7 ns。锁闩ULAT1以5 ns的速度打开。因此，从路径ULAT1到UFF1借用2 ns。ULAT1到UFF1路径的可用时间仅为3 ns(5 ns-2 ns)。</p>
<p>​ 接下来，我们将为图10-5(A)中的锁存示例描述三组时序报告，以说明从下一阶段借用的不同时间量。</p>
<p><strong>没有借用时间的示例（Example with No Time Borrowed）</strong></p>
<p>​ 以下是从触发器UFF0到锁存器ULAT1的数据路径延迟小于5 ns时的setup路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828122232374.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828122341479.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828122505588.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 在这种情况下，不需要借用，因为数据在锁存器打开之前及时到达锁存器ULAT1。</p>
<p><strong>有借用时间的示例（Example with Time Borrowed）</strong></p>
<p>​ 下面的路径报告显示了从触发器UFF0到锁存器ULAT1的数据路径延迟大于5 ns的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828123718576.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828123759594.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 在这种情况下，由于在锁存器透明的同时数据变为可用，因此从后续路径借用所需的1.81 ns的延迟，并且仍然满足定时。下面是后续路径的路径报告，显示前一路径已经借用了1.81 ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828124500967.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>有时序违规的示例（Example with Timing Violation）</strong></p>
<p>​ 在这种情况下，数据路径延迟要大得多，只有在锁存器关闭后数据才可用。这显然是timing violation</p>
<p><img src="https://img-blog.csdnimg.cn/20210828124940278.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828125407421.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828125449516.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="数据到数据检查data-to-data-checks">数据到数据检查（Data to Data Checks）</h2>
<p>​ setup和hold检查也可以在任意两个数据引脚之间应用，这两个引脚都不是时钟。一个管脚是约束管脚（ <strong>constrained pin</strong>），其作用类似于触发器的数据管脚，第二个管脚是相关管脚（<strong>related pin</strong>），其作用类似于触发器的时钟管脚。关于触发器的setup检查的一个重要区别在于，数据到数据setup检查在与启动边沿相同的边沿上执行(与触发器的正常setup检查不同，在触发器的正常setup检查中，捕获时钟边沿通常与启动时钟边沿相差一个周期)。因此，数据到数据setup检查也称为 <strong>zero-cycle checks</strong>或 <strong>same-cycle checks</strong>。</p>
<p>​ 使用 <strong>set_data_check</strong> 约束指定数据到数据检查。以下是 SDC 约束示例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_data_check -<span class="selector-tag">from</span> SDA -<span class="selector-tag">to</span> SCTRL -setup <span class="number">2.1</span></span><br><span class="line"></span><br><span class="line">set_data_check -<span class="selector-tag">from</span> SDA -<span class="selector-tag">to</span> SCTRL -hold <span class="number">1.5</span></span><br></pre></td></tr></table></figure>
<p>​ 参见图 10-6。 SDA 是<strong>related pin</strong>，SCTRL 是 <strong>constrained pin</strong>。setup数据检查意味着 SCTRL 应在相关引脚 SDA 的边缘之前至少 2.1ns 到达。否则它是数据到数据setup检查违规。hold数据检查指定 SCTRL 应在 SDA 之后至少 1.5ns 到达。如果约束信号早于此约束到达，则它是数据到数据hold检查违规。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828130442153.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这种检查在 custom-designed block 中很有用，在这种情况下，可能需要提供一个信号相对于另一个信号的特定到达时间。一种常见的情况是数据信号被使能信号门控，当数据信号到达时，需要保证使能信号稳定。</p>
<p>​ 考虑图 10-7 中所示的 and 单元格。我们假设要求是确保 PNA 在 PREAD 上升沿之前 1.8ns 到达，并且在 PREAD 上升沿之后的 1.0ns 内不应改变。在本例中，PNA 是 <strong>constrained pin</strong>，PREAD 是<strong>related pin</strong>。所需的波形如图 10-7 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828130725350.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 可以使用数据到数据建立和保持检查来指定这样的要求。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_data_check -<span class="selector-tag">from</span> UAND0/A1 -<span class="selector-tag">to</span> UAND0/A2 -setup <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">set_data_check -<span class="selector-tag">from</span> UAND0/A1 -<span class="selector-tag">to</span> UAND0/A2 -hold <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>​ 这是setup报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828131153755.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ setup时间在报告中指定为data check setup time。失败的报告表明 PREAD 需要至少延迟 1.72ns，以确保 PENA 在 PREAD 之前 1.8ns 到达——这是我们的要求</p>
<p>​ 数据到数据setup检查的一个重要方面是，启动<strong>constrained pin</strong>和<strong>related pin</strong>的时钟边沿来自相同的时钟周期（也称为same-cycle checks）。因此，请注意报告中捕获沿 (UDFF0/CK) 的开始时间为 0ns，而不是像setup报告中通常看到的那样晚一个周期。</p>
<p>​ zero-cycle setup check导致保持时序检查与其他保持检查报告不同 - 保持检查不再在同一时钟沿上。下面是用于保持路径报告的 CLKPLL 的时钟约束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKPLL</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKPLL</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210828132551788.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828132628336.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，用于启动<strong>related pin</strong>以进行保持检查的时钟沿比 <strong>constrained pin</strong>的启动沿早一个周期。这是因为根据定义，保持检查通常在建立捕获沿之前的一个周期执行。由于<strong>constrained pin</strong>和<strong>related pin</strong>的时钟沿对于数据到数据setup检查是相同的，因此保持检查在启动沿前一个周期完成。</p>
<p>​ 在某些情况下，设计人员可能需要在同一时钟周期内执行数据到数据保持检查。相同的周期保持要求意味着将用于<strong>related pin</strong>的时钟沿移回受<strong>constrained pin</strong>的时钟沿所在的位置。这可以通过指定 -1 的多周期来实现。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_multicycle_path -<span class="number">1</span> -hold -<span class="keyword">to</span> UAND0/A2</span><br></pre></td></tr></table></figure>
<p>​ 以下是具有此多周期约束的上述示例的保持时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828133043530.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828133122590.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 现在，对constrained pin 和 the related pin使用相同的时钟沿执行保持检查。在同一周期中执行数据到数据保持检查的另一种方法是将其指定为反向引脚之间的数据到数据setup检查。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_data_check -<span class="selector-tag">from</span> UAND0/A2 -<span class="selector-tag">to</span> UAND0/A1 -setup <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>​ 数据到数据检查在定义<strong>no-change data check</strong>时也很有用。这是通过在上升沿指定setup检查和在下降沿指定保持检查来完成的，以便有效定义不变窗口。如图 10-8 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828133421644.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 以下是此方案的约束：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_data_check -rise_from D2 -<span class="keyword">to</span> D1 -setup <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">set_data_check -fall_from D2 -<span class="keyword">to</span> D1 -hold <span class="number">0.8</span></span><br></pre></td></tr></table></figure>
<h2 id="非顺序检查non-sequential-checks">非顺序检查（Non-Sequential Checks）</h2>
<p>​ 单元或宏的（cell 和 macro）库文件可以将时序弧指定为非顺序检查（non-sequential check），例如两个数据引脚之间的时序弧。非顺序检查是两个引脚之间的检查，这两个引脚都不是时钟。一个引脚是constrained pin，其作用类似于数据，而第二个引脚是related pin，其作用类似于时钟。该检查指定在related pin上发生变化之前和之后，constrained pin上的数据必须保持稳定多长时间。</p>
<p>​ 请注意，此检查被指定为单元库约束的一部分，并且不需要显式数据到数据检查约束。以下是这样的时间弧如何出现在单元库中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pin (WEN) &#123;</span><br><span class="line"></span><br><span class="line">    timing () &#123;</span><br><span class="line"></span><br><span class="line">    timing_type: non_seq_setup_rising;</span><br><span class="line"></span><br><span class="line">    intrinsic_rise: <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">    intrinsic_fall:<span class="number">1.15</span>;</span><br><span class="line"></span><br><span class="line">    related_pin: “D0”;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timing () &#123;</span><br><span class="line"></span><br><span class="line">    timing_type: non_seq_hold_rising;</span><br><span class="line"></span><br><span class="line">    intrinsic_rise: <span class="number">0.6</span>;</span><br><span class="line"></span><br><span class="line">    intrinsic_fall:<span class="number">0.65</span>;</span><br><span class="line"></span><br><span class="line">    related_pin: “D0”;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ setup_rising 是指相关管脚的上升沿。固有上升和下降值是指受限引脚的上升和下降设置时间。可以为hold_rising、setup_falling 和hold_falling 定义类似的时序弧。</p>
<p>​ 非顺序检查（non-sequential check）类似于第10.3节中描述的数据对数据检查，但是它们有两个主要区别。在非顺序检查中，建立和保持值从标准单元库中获得，其中建立和保持时序模型可以使用NLDM表格模型或其他高级时序模型来描述。在数据到数据检查中，只能为数据到数据建立或保持检查指定一个值。第二个区别是，非顺序检查只能应用于单元的pin，而数据对数据检查可以应用于设计中的任意两个pin。</p>
<p>​ <strong>非顺序建立检查（non-sequential setup check）</strong>指定相对于related pin，受约束信号必须多早到达。如图10-9所示。单元库包含建立时序弧D0-&gt;WEN，该弧被指定为非顺序弧。如果WEN信号出现在建立窗口内，则非顺序建立检查失败。</p>
<p>​ <strong>非顺序保持检查（non-sequential hold check）</strong>指定相对于related pin，受约束信号必须到达多晚。见图10-9。如果WEN在保持窗口内发生变化，则保持检查失败。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830101407282.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="时钟门控检查clock-gating-checks">时钟门控检查（Clock Gating Checks）</h2>
<p>​ 当<strong>门控信号（gating signal）</strong>可以控制逻辑单元处的<strong>时钟信号（clock signal）</strong>的路径时，发生时钟门控检查。如图10-10示例。连接到时钟的逻辑单元的引脚称为<strong>时钟引脚（clock pin）</strong>，连接门控信号的引脚称为<strong>门控引脚（gating pin）</strong>。发生时钟门控的逻辑单元也称为<strong>门控单元（gating cell）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083012393322.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 时钟门控检查的一个条件是通过单元的时钟必须用作<strong>下游时钟（clock downstream）</strong>。下游时钟使用既可以作为触发器时钟，也可以扇出到输出端口，或者作为生成时钟，将门控单元的输出称为其主时钟。如果时钟不用作门控单元之后的时钟，则不会推断时钟门控检查。</p>
<p>​ 时钟门控检查的另一个条件适用于门控信号。检查的门控引脚上的信号不应是时钟，或者如果是时钟，则不应用作下游时钟（本节后面将包含作为门控信号的时钟示例）。</p>
<p>​ 在一般情况下，时钟信号和门控信号不需要连接到单个逻辑单元，例如and、或or，而是可以是任意逻辑块的输入。在这种情况下，要推断时钟门控检查，检查的时钟引脚和检查的门控引脚必须扇出到公共输出引脚。</p>
<p>​ 推断出两种类型的时钟门控检查：</p>
<ul>
<li>高电平有效时钟门控检查（Active-high clock gating check）：当门控单元具有and 或 nand功能时发生。</li>
<li>低电平有效时钟门控检查（ Active-low clock gating check）：当门控单元具有 or或 nor功能时发生。</li>
</ul>
<p>​ 高电平有效和低电平有效是指门控信号的逻辑状态，它激活门控单元输出端的时钟信号。如果门控单元是门控关系不明显的复杂功能，例如多路复用器或异或单元，则 STA 输出通常会提供警告，指出未推断出时钟门控检查。然而，这可以通过使用命令 set_clock_gating_check 明确指定门控单元的时钟门控关系来改变。在这种情况下， 如果set_clock_gating_check 约束与门控单元的功能不一致，STA 通常会提供警告。我们将在本节后面介绍此类命令的示例。</p>
<p>​ 如前所述，只有当时钟不用作下游时钟时，它才能成为门控信号。考虑图 10-11 中的示例。由于 CLKA 的生成时钟的定义，CLKB 不用作下游时钟 - CLKB 的路径被生成的时钟定义阻塞。因此，为and单元推断时钟 CLKA 的时钟门控检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830125722393.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>高电平有效时钟门控（Active-High Clock Gating）</strong></p>
<p>​ 我们现在检查高电平有效时钟门控检查的时序关系。这发生在一个and或一个 nand 单元上；使用and的示例如图 10-12 所示。门控单元的引脚 B 是时钟信号，门控单元的引脚 A 是门控信号。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830125923262.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 让我们假设时钟 CLKA 和 CLKB 具有相同的波形 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKA</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKA</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKB</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKB</span>]</span><br></pre></td></tr></table></figure>
<p>​ 因为它是一个and单元，门控信号 UAND0/A 上的高电平打开门控单元并允许时钟通过。时钟门控检查旨在验证门控引脚转换不会为扇出时钟创建有效边沿。对于正边沿触发逻辑，这意味着门控信号的上升沿发生在时钟的非活动周期（低电平时）。类似地，对于负沿触发逻辑，门控信号的下降沿应仅在时钟为低电平时出现。请注意，如果时钟同时驱动正边沿和负边沿触发的触发器，则门控信号（上升沿或下降沿）的任何转换都必须仅在时钟为低电平时发生。图 10-13 显示了需要延迟以通过时钟门控检查的活动边沿期间门控信号转换的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083013173523.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 高电平有效时钟门控建立检查要求门控信号在时钟变高之前发生变化。这是建立路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830131901143.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830131938470.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> 请注意，端点指示它是时钟门控检查。此外，该路径位于 Path Group中指定的clock_gating_default 路径组中。该检查验证门控信号在 10ns 时钟 CLKB 的下一个上升沿之前发生变化。</p>
<p>​ 高电平有效时钟门控保持检查要求门控信号仅在时钟下降沿之后发生变化。这是保持路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830132409531.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 保持门控检查失败，因为门控信号在 5ns 处的 CLKB 下降沿之前变化太快。如果在 UDFF0/Q 和 UAND0/A1 引脚之间添加 5ns 延迟，则建立和保持门控检查都将通过验证门控信号仅在指定window中发生变化。</p>
<p>​ 可以看出，保持时间要求相当大。这是因为门控信号的意义和被门控的触发器是相同的。这可以通过使用不同类型的启动触发器来解决，例如，一个负边沿触发的触发器来生成门控信号。这样的例子如下所示。</p>
<p>​ 在图 10-14 中，触发器 UFF0 由时钟 CLKA 的负沿控制。安全时钟门控意味着触发器 UFF0 的输出必须在门控时钟的非活动部分（5ns 到 10ns 之间）发生变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830173538597.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对应于图 10-14 中原理图的信号波形如图 10-15 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830174143777.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控建立报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830174323459.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830174358708.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830174433665.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控保持报告。请注意，新设计更容易满足保持时间检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830174519796.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 由于启动门控信号的时钟沿（负沿）与被门控的时钟（高电平有效）相反，建立和保持要求非常容易满足。这是门控时钟最常用的结构。</p>
<p><strong>低电平有效时钟门控（Active-Low Clock Gating）</strong></p>
<p>​ 图 10-16 显示了低电平有效时钟门控检查的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830181603890.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock -name MCLK -period <span class="number">8</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_ports MCLK]</span></span><br><span class="line"></span><br><span class="line">create_clock -name SCLK -period <span class="number">8</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_ports SCLK]</span></span><br></pre></td></tr></table></figure>
<p>​ 低电平有效时钟门控检查验证门控信号的上升沿是否到达正沿触发逻辑的时钟的有效部分（当它为高电平时）。如前所述，关键是门控信号不应导致输出门控时钟的有效边沿。当门控信号为高电平时，时钟无法通过。因此，只有当时钟为高电平时，门控信号才应切换，如图 10-17 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830185148249.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是低电平有效时钟门控建立时序报告。此检查可确保门控信号在时钟边沿变为无效之前到达，在本例中为 4ns。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083018523843.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830185304979.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控保持时序报告。此检查确保门控信号仅在时钟信号的上升沿之后发生变化，在本例中为 0ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830190607857.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>带多路复用器的时钟门控（Clock Gating with a Multiplexer）</strong></p>
<p>​ 图10-18显示了使用多路复用器单元的时钟门控示例。多路复用器输入端的时钟门控检查确保多路复用器选择信号在正确的时间到达，以便在MCLK和TCLK之间干净地切换。对于本例，我们感兴趣的是在MCLK之间切换，并假设在选择信号切换时TCLK较低。这意味着多路复用器的选择信号应仅在MCLK低时切换。这类似于高电平有效时钟门控检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192230279.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图 10-19 显示了时序关系。多路复用器的选择信号必须在 MCLK 为低电平时到达。此外，假设选择更改时 TCLK 将为低。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192339475.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 由于门控单元是一个多路复用器，因此不会自动推断时钟门控检查，如 STA 期间报告的此消息所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083019243746.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 但是，可以通过提供 set_clock_gating_check 明确强制进行时钟门控检查。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_clock_gating_check -high [get_cells UMUX0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -high option indicates an active-high check.</span></span><br><span class="line"></span><br><span class="line">set_disable_clock_gating_check UMUX0/I1</span><br></pre></td></tr></table></figure>
<p>​ 禁用检查（disable check）关闭特定引脚上的时钟门控检查，因为我们不关心该引脚。多路复用器上的时钟门控检查已指定为高电平有效时钟门控检查。这是建立时序路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192632656.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830192706977.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 接下来是时钟门控保持时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192800398.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830192831749.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>具有时钟反转的时钟门控（Clock Gating with Clock Inversion）</strong></p>
<p>​ 图10-20显示了另一个时钟门控示例，其中触发器的时钟反转，触发器的输出为门控信号。由于门控单元是and单元，因此只有当and单元的时钟信号较低时，门控信号才必须切换。这定义了建立和保持时钟门控检查。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083019310096.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控建立时序报告 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830195034612.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830195110873.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830195144823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，建立检查会验证数据是否在时间 15ns 的 MCLK 边沿之前发生更改。这是时钟门控保持时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830195249157.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 保持检查验证数据（门控信号）是否在时间 10ns 的 MCLK 下降沿之前发生变化。</p>
<p>​ 如果门控单元是复杂单元并且建立和保持检查不明显，则可以使用 set_clock_gating_check 命令指定对时钟信号进行门控的门控信号的建立和保持检查。建立检查验证门控信号在时钟信号的有效边沿之前是否稳定。建立失败会导致门控单元输出出现故障。保持检查验证门控信号在时钟信号的非活动边沿是否稳定。以下是 set_clock_gating_check 约束的一些示例。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set_clock_gating_check -setup <span class="number">2.4</span> -hold <span class="number">0.8</span> \</span><br><span class="line"></span><br><span class="line">[get_cells U0/UXOR1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the setup and hold time for the clock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gating check at the specified cell.</span></span><br><span class="line"></span><br><span class="line">set_clock_gating_check -high [get_cells UMUX5]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check is performed on high level of clock. Alternately, the</span></span><br><span class="line"></span><br><span class="line">-low option can be used <span class="keyword">for</span> an active-low clock gating check.</span><br></pre></td></tr></table></figure>
<h2 id="功耗管理power-management">功耗管理（Power Management）</h2>
<p>​ 管理功率是任何设计及其实现方式的一个重要方面。在设计实施期间，设计人员通常需要评估不同的方法，以在设计的速度、功耗和面积之间进行权衡。</p>
<p>​ 如第 3 章所述，设计逻辑部分的功耗由泄漏功率（leakage power）和有功功率（active power）组成。此外，模拟宏和 IO 缓冲器（尤其是那些具有有源端接的）可以消耗与活动无关且不泄漏的功率。在本节中，我们关注设计逻辑部分功耗的权衡。</p>
<p>​ 一般来说，管理由标准单元和内存宏组成的数字逻辑的功率贡献有两个考虑事项:</p>
<ul>
<li>最小化设计的总有功功率：设计人员将确保总功耗保持在可用功率限制范围内。设计的不同操作模式可能有不同的限制。此外，设计中使用的不同电源也可能有不同的限制。</li>
<li>将设计在待机模式下的功耗降至最低：对于电池供电的设备（例如手机）来说，这是一个重要的考虑因素，其目标是将待机模式下的功耗降至最低。待机模式下的功耗是泄漏功耗加上待机模式下活动逻辑的任何功耗。如上所述，可能有其他模式，例如睡眠模式，对功率有不同的限制。</li>
</ul>
<p>​ 本节介绍功率管理的各种方法。这些方法中的每一种都有其优点和缺点，本文将对其进行描述。</p>
<h3 id="时钟门控clock-gating">时钟门控（Clock Gating）</h3>
<p>​ 如第 3 章所述，触发器的时钟活动占总功耗的重要组成部分。即使触发器输出不切换，触发器也会由于时钟切换而耗散功率。考虑图 10-21(a) 中的示例，其中触发器仅在使能信号 EN 有效时才接收新数据，否则保持先前状态。在 EN 信号无效期间，触发器的时钟<strong>翻转（toggle）</strong>不会引起任何输出变化，尽管时钟活动仍会导致触发器内部的功率耗散。时钟门控的目的是，通过在触发器输入无效的clock cycles期间消除触发器的时钟活动来最小化这种贡献。通过时钟门控进行的逻辑重组在触发器引脚处引入了时钟门控。图 10-21 说明了时钟门控引起的转换示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830210553168.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 因此，时钟门控确保触发器的时钟引脚仅在其数据输入端有新数据时才触发。</p>
<h3 id="电源门控power-gating">电源门控（Power Gating）</h3>
<p>​ 电源门控涉及关闭电源，以便可以关闭非活动块的电源。此过程如图 10-22 所示，其中添加了一个与电源串联的footer（或header）MOS 器件。配置控制信号 SLEEP ，使得在块的正常操作期间footer（或header）MOS 器件处于开启状态。由于电源门控 MOS 器件（footer or header）在正常操作期间处于开启状态，因此该模块已通电并在正常功能模式下运行。在模块的非活动（或睡眠）模式期间，门控 MOS 器件（footer or header）被关闭，从而消除了逻辑模块中的任何活动功耗。footer是在实际的地与模块的地网络之间的大型NMOS器件，可通过电源门控对其进行控制。header是实际电源和模块的电源网络之间的大型 PMOS 器件，通过电源门控进行控制。在睡眠模式期间，块中唯一耗散的功率是通过footer（或header）设备的泄漏功率。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830212647360.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ footer or header通常使用多个电源门控单元来实现，这些电源门控单元对应于多个并联的 MOS 器件。footer or header设备向电源引入了串联电阻。如果导通电阻值不小，通过门控 MOS 器件的 IR 压降会影响逻辑块中单元的时序。虽然关于门控器件尺寸的主要标准是确保导通电阻值较小，但由于电源门控 MOS 器件决定了非活动或睡眠模式下的泄漏功率，因此需要进行权衡。</p>
<p>​ 总之，应该有足够数量的电源门控单元并联，以确保在有源模式下串联电阻的 IR 降最小。然而，处于非活动或睡眠模式的门控单元的泄漏功率也是选择并联电源门控单元数量的一个标准。</p>
<h3 id="多电压阈值单元multi-vt-cells">多电压阈值单元（Multi Vt Cells）</h3>
<p>​ 如第3章（第3.8节）所述，多<strong>电压阈值（Vt）</strong>单元用于权衡速度和泄露功率。高Vt单元具有较少的泄露功率，尽管其速度比标准Vt单元慢，标准Vt单元速度更快，但具有较高的泄露功率。类似地，低Vt单元比标准Vt单元快，但泄露功率也相应地更高。</p>
<p>​ 在大多数设计中，目标是在达到所需操作速度的同时将总功率降至最低。尽管泄露功率可能是总功率的重要组成部分，但实现仅使用高Vt单元来减少泄露功率的设计可以增加总功率，即使泄露功率贡献可能会降低。这是因为最终的设计实现可能需要更多(或更高强度)的高Vt单元来实现所需的性能。与使用高Vt单元导致的泄漏功率的降低相比，等效gate数目的增加可以更多地增加有功功率。然而，在某些情况下，泄漏功率是总功率的主要组成部分；在这种情况下，采用高Vt单元的设计可能会导致总功率降低。需要适当地利用具有不同Vt的单元之间在其速度和泄露功率方面的上述权衡，因为它取决于设计及其开关活动曲线。下面说明了高性能块的两个场景，其中实现方法可以根据块是非常活跃的还是具有低切换活动而不同。</p>
<p><strong>具有高活性的高性能块（High Performance Block with High Activity）</strong></p>
<p>​ 这种情况是具有高开关活动的高性能块，并且功率由有功功率支配。对于此类块，仅关注降低泄漏功率会导致总功率增加，即使泄漏功率贡献可被最小化。在这种情况下，初始设计实现应使用标准 Vt（或低 Vt）单元以满足所需的性能。在达到所需的时序后，沿着具有正时序裕量的路径的单元可以更改为高 Vt 单元，从而在仍然满足时序要求的同时减少泄漏贡献。因此，在最终实现中，标准 Vt（或低 Vt）单元仅用于关键或难以实现的时序路径，而沿非关键时序路径的单元可以是高 Vt 单元。</p>
<p><strong>具有低活性的高性能块（High Performance Block with Low Activity）</strong></p>
<p>​ 这种情况是具有非常低开关活动的高性能模块，因此泄漏功率是总功率的重要组成部分。由于模块的活动性较低，因此有功功率不是设计总功率的主要组成部分。对于此类模块，初始实现尝试仅在组合逻辑和触发器中使用高 Vt 单元。一个例外是时钟树，它始终处于活动状态，因此使用标准 Vt（或低 Vt）单元构建。在仅使用高 Vt 单元进行初始实施后，可能存在一些无法实现所需时序的时序路径。然后将沿这些路径的单元替换为标准 Vt（或低 Vt）单元，以实现所需的时序性能。</p>
<h3 id="阱偏置well-bias">阱偏置（Well Bias）</h3>
<p>​ <strong>阱偏置（well bias）</strong>是指在分别用于 NMOS 和 PMOS 器件的 P-well 或 N-well 上添加一个小的电压偏置。图 2-1 所示 NMOS 器件的衬底（或 P 阱）连接通常接地。同样，图 2-1 所示 PMOS 器件的衬底（或 N 阱）连接通常连接到电源 (Vdd) 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809140101587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果阱连接具有轻微的负偏压，可以显著降低泄漏功率。这意味着 NMOS 器件的 P 阱连接到一个小的负电压（例如 -0.5V）。同样，PMOS 器件的 Nwell 连接连接到高于电源的电压（例如 Vdd +0.5V）。通过添加阱偏置，单元的速度受到影响；然而，泄漏功率大大减少。单元库中的时序是通过将阱偏置考虑在内而生成的。</p>
<p>​ 使用阱偏置的缺点是P阱和N阱连接需要额外的供电电源（例如-0.5V和Vdd + 0.5V）。</p>
<h2 id="反标backannotation">反标（Backannotation）</h2>
<h3 id="spef">SPEF</h3>
<p>​ STA 如何知道设计的寄生参数是什么？通常，该信息是通过使用寄生提取工具提取的，并且该数据由 STA 工具以 SPEF 的形式读取。附录 C 中描述了 SPEF 的详细信息和格式。</p>
<p>​ 物理设计布局工具内的 STA 引擎的行为也类似，不同之处在于提取信息写入内部数据库。</p>
<h3 id="sdf">SDF</h3>
<p>​ 在某些情况下，单元和互连的延迟由另一个工具计算，并通过 SDF 为 STA 读取。使用 SDF 的优点是不再需要计算单元延迟和互连延迟——因为它们直接来自 SDF，因此 STA 可以专注于时序检查。但是，这种延迟注释的缺点是由于缺少寄生信息，STA 无法执行串扰计算。 SDF 是通常用于将延迟信息传递给模拟器的机制。</p>
<p>​ SDF 的详细信息和格式在附录 B 中描述。</p>
<h2 id="sign-off方法sign-off-methodology">sign off方法（Sign-off Methodology）</h2>
<p>​ STA 可以针对许多不同的场景运行。决定场景的三个主要变量是：</p>
<ul>
<li>寄生角（Parasitics corners）（RC 互连角和用于寄生提取的操作条件）</li>
<li>操作模式 （Operating mode）</li>
<li>PVT 角（PVT corner）</li>
</ul>
<p><strong>互连寄生角（Parasitic Interconnect Corners）</strong></p>
<p>​ 可以在许多corner提取寄生参数。这些主要取决于制造过程中金属宽度和金属蚀刻的变化。其中一些是：</p>
<ul>
<li>Typical：这是指互连电阻和电容的标称值。</li>
<li>Max C：这是指导致最大电容的互连角。互连电阻比 typical corner小。该角会导致短网路径的最大延迟，可用于最大路径分析。</li>
<li>Min C：这是指导致最小电容的互连角。互连电阻比 typical corner大。该角导致具有短网络的路径的最小延迟并可用于最小路径分析。</li>
<li>Max RC：这是指使互连RC 乘积最大化的互连角。这通常对应于减小走线宽度的较大蚀刻。这导致最大电阻但对应于小于Typical电容。总体而言，对于具有长互连的路径，该角具有最大延迟，可用于最大路径分析。</li>
<li>Min RC：这是指使互连RC 乘积最小的互连角。这通常对应于增加走线宽度的较小蚀刻。这导致最小的电阻，但对应于大于Typical电容。总体而言，对于具有长互连的路径，该角具有最小的路径延迟，可用于最小路径分析。</li>
</ul>
<p>​ 基于上述各个角的互连电阻和电容，具有较大电容的互连角会导致电阻较小，具有较小电容的互连角会导致电阻较大。因此，电阻在一定程度上补偿了各个互连角下的电容。这意味着对于所有类型网络的延迟，没有一个角会真正对应极限情况（最差情况或最佳情况）。使用Cworst / Cbest角下的路径延迟仅对于较短网络是极限情况，而RCworst / RCbest角仅对于较长网络是极限情况，而对于平均长度的网络，Typical互连角通常在路径延迟方面是极限的。因此，设计人员经常会在上述各个互连角下都去验证设计的时序。但是，即使在每个角处都进行了验证也可能无法涵盖所有可能的情况，因为不同的金属层实际上可以独立地处于不同互连角下，例如：METAL2在Max C角下而METAL1在Max RC角下。10.9节中介绍的统计（statistical）时序分析将提出一种静态时序分析的机制，其中不同的金属层可以处于不同的互连角下。</p>
<p><strong>操作模式（Operating Modes）</strong></p>
<ul>
<li>功能模式1（工作在高速时钟下）</li>
<li>功能模式2（工作在低速时钟下）</li>
<li>功能模式3（睡眠模式）</li>
<li>功能模式4（调试模式）</li>
<li>测试模式1（scan capture）</li>
<li>测试模式2（scan shift）</li>
<li>测试模式3（bist）</li>
<li>测试模式4（jtag）</li>
</ul>
<p><strong>PVT corner</strong></p>
<p>​ PVT corner指示在什么条件下进行STA分析。最常见的PVT corner是：</p>
<ul>
<li>WCS(慢工艺，低电源，高温)</li>
<li>BCF(快工艺，高电源，低温)</li>
<li>Typical(典型工艺，额定电源，额定温度)</li>
<li>WCL(冷慢工艺，低电源，低温)</li>
<li>或PVT domin中的任何其他点</li>
</ul>
<p>​ 任何情况下都可以执行STA分析。这里的场景指的是上述互连角、操作模式和PVT corner的组合。</p>
<p><strong>多模式多角分析（Multi-Mode Multi-Corner Analysis）</strong></p>
<p>​ <strong>多模式多角(Multi-mode multi-corner ，MMMC)</strong>分析是指同时对多个工作模式、PVT角和寄生互连角进行STA分析。例如，假设DUA有四种工作模式(Normal, Sleep, Scan shift, Jtag)，并在三个PVT角(WCS、BCF、WCL)和三个寄生互连角(Typical、Min C、Min RC)进行分析，如表10-23所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830222133808.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 总共有 36 种可能的场景，在这些场景中可以执行所有时序检查，例如建立、保持、转换和时钟门控检查。根据设计的规模，同时为所有 36 个场景运行 STA 在运行时间方面可能会令人望而却步。一个场景可能不需要，因为它可能包含在另一个场景中，或者一个场景可能不需要。例如，设计者可以确定场景 4、6、7 和 9 不相关，因此不需要。此外，可能没有必要在一个corner运行所有模式，例如场景 5 中可能不需要 Scan shift 或 Jtag 模式。 如果多模式多角功能是可用的，则可以在单个场景或多个场景中同时运行 STA可用的。</p>
<p>​ 运行多模式多角 STA 的优点是节省了运行时间和设置分析脚本的复杂性。 MMMC 场景中的额外节省是设计和寄生参数只需加载一次或两次，而不是为每个mode或corner单独加载多次。这样的工作也更适合在 LSF 场上运行它们。多模式多角在优化流程中具有更大的优势，其中优化在所有场景中完成，以便在一个场景中修复时序违规不会在另一个场景中引入时序违规。</p>
<p>​ 对于 IO 约束，-add_delay 选项可以与多个时钟源一起使用，以在一次运行中分析不同的模式，例如扫描或双模式，或对应于不同速度的 PHY（物理层接口 IP 块，例如 10G PHY）中的不同操作模式。通常，每种模式都在单独的运行中进行分析，但并非总是如此。</p>
<p>​ 发现具有大量时钟的设计需要数十次独立运行才能覆盖最大和最小corner的每个模式，并且包括串扰和噪声的影响，这并不罕见。</p>
<h2 id="统计静态时序分析statistical-static-timing-analysis">统计静态时序分析（Statistical Static Timing Analysis）</h2>
<p>​ 到目前为止描述的静态时序分析技术是确定性的，因为该分析基于设计中所有时序弧的固定延迟。根据操作条件以及工艺和互连模型计算每个电弧的延迟。虽然可能存在多个mode和多个corner，但是可以确定性地获得给定场景的时序路径延迟。</p>
<p>​ 实际上，执行STA时通常使用的工艺和工作条件的最差情况（WCS）或最佳情况（BCF）对应于极端的3σ角（这里的σ指的是统计建模的自变量的标准差）。时序库基于的是代工厂提供的带有工作条件的工艺角模型，这些条件对应于单元时序值的不同角。例如，使用快速工艺模型、最高电源和最低温度来表征最佳情况的快速时序库。</p>
<h3 id="工艺和互连变化process-and-interconnect-variations">工艺和互连变化（Process and Interconnect Variations）</h3>
<p><strong>全局工艺变化（Global Process Variations）</strong></p>
<p>​ 全局工艺变化（global process variations）（也称为芯片间器件变化inter-die device variations），指的是影响芯片(或晶片)上所有器件的工艺参数的变化。参见图10-24。这描述了芯片上的所有设备都受到这些工艺变化的类似影响-芯片上的每个设备都将变slow或变fast，或者介于两者之间的任何位置。因此，由全局工艺参数建模的变化旨在捕捉不同模具之间的变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830223058608.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-25显示了全局参数值(例如g_par1)的变化。例如，参数g_par1可以对应于标准（<em>这里的标准设备是指长度和宽度固定的设备。</em>）NMOS器件的IDSsat(器件饱和电流)。由于这是一个全局参数，因此芯片上所有单元实例中的所有NMOS器件将对应于相同的g_par1值。可以有如下选择：所有单元实例的g_par1的变化是完全相关的，或者芯片上g_par1的变化相互影响。注意，可能还存在其它全局参数（g_par2，...），其可能可以对PMOS器件饱和电流和其它相关变量建模。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830223509267.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 不同的全局参数(g_par1、g_par2、.。。。)。是不相关的。不同全局参数中的变化不会相互影响，这意味着g_par1和g_par2参数彼此独立变化；在芯片中，g_par1可能处于最大值，而g_par2可能处于最小值。</p>
<p>​ 在确定性（即非统计性）分析中，慢速工艺模型可能对应于芯片间变化的+ 3σ角的条件。类似地，快速工艺模型可能对应于芯片间变化的-3σ角的条件。</p>
<p><strong>局部工艺变化（Local Process Variations）</strong></p>
<p>​ 局部工艺变化(也称为<strong>芯片内器件变化intra-die device variations</strong>)指的是工艺参数中的变化，这些变化可能以不同方式影响给定芯片上的器件。参见图10-26。这意味着并排放置的芯片上的相同器件在同一芯片上可能具有不同的行为。由局部工艺变化建模的变化旨在捕捉模具内的随机工艺变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830231808425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-27显示了局部工艺参数的变化。芯片上的局部参数变化不会相互影响，并且它们从一个单元实例到另一个单元实例的变化是不相关的。这意味着对于同一芯片上的不同器件，局部参数可能具有不同的值。例如，芯片上的不同NAND2单元实例可能会看到不同的局部工艺参数值。这会导致同一NAND2单元的不同实例具有不同的延迟值，即使其他参数(例如输入转换和输出负载)是相同的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830232146765.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-28显示了由全局和局部变化引起的NAND2信元延迟的变化。该图说明了全局参数变化比局部参数变化引起的时延变化更大。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830232319120.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 局部工艺变化是打算在使用 OCV 建模的分析中捕获的变化之一，如第 10.1 节所述。由于统计时序模型通常包括局部工艺变化，使用统计时序模型的 OCV 分析不应包括 OCV 设置中的局部工艺变化。</p>
<p><strong>互连变化（Interconnect Variations）</strong></p>
<p>​ 如第 10.8 节所述，有各种互连角代表影响互连电阻和电容值的每个金属层的参数变化。这些参数变化通常是金属和电介质的厚度，以及影响各种金属层中金属走线的宽度和间距的金属蚀刻。通常，影响金属的参数会影响该金属层中所有走线的寄生效应，但对其他金属层中走线的寄生效应影响很小或没有影响。</p>
<p>​ 第 10.8 节中描述的互连角对互连变化进行建模，以便所有金属层映射到相同的互连角。对互连走线变化进行统计建模时，每个金属层都可以独立地变化。</p>
<p>​ 统计方法对互连空间中所有可能的变化组合进行建模，从而对仅通过在指定的互连角处分析无法捕捉到的变化进行建模。例如，时钟树的启动路径可能在 METAL2 中，而时钟树的捕获路径在 METAL3 中。传统互连corner处的时序分析考虑了所有金属一起变化的各个corner，因此无法模拟 METAL2 位于导致最大延迟的corner而 METAL3 位于导致最小延迟的corner的情况。这种组合对应于设置路径的最坏情况，只能通过对互连变化进行统计建模来捕获。</p>
<h3 id="统计分析statistical-analysis">统计分析（Statistical Analysis）</h3>
<p><strong>什么是 SSTA？</strong></p>
<p>​ 如果对单元时序模型和互连寄生进行统计建模，则上述变化的建模是可行的。除了延迟之外，单元输入端的引脚电容值也被统计建模。这意味着时序模型是根据工艺参数（全局和局部）的平均值和标准偏差来描述的。互连电阻和电容是根据互连参数的平均值和标准偏差来描述的。延迟计算程序（在第 5 章中描述）获得每个时序弧（单元以及互连）的延迟，然后用关于各种参数的平均值和标准偏差表示。因此，每个延迟都由平均值和 N 个标准偏差表示（其中 N 是统计建模的独立过程和互连参数的数量）。</p>
<p>​ 由于通过各个时序弧的延迟是用统计形式表示的，因此统计静态时序分析SSTA（Statistical Static Timing Analysis）过程中会结合时序弧的延迟以获得路径延迟，该路径延迟同样会以统计形式表示（具有均值和标准差）。SSTA会根据独立的工艺和互连参数的标准差，来获得路径延迟的总体标准差。例如，考虑由两个时序弧组成的路径延迟，如图10-29所示。由于每个延迟分量都有其变化，因此根据变化是相关的还是不相关的，将对变化进行不同的组合。如果变化来自同一来源（例如，由相互影响的g_par1参数引起），则路径延迟的σ仅等于（σ1 + σ2）。但是，如果变化是不相关的（例如由于l_par1参数），那么路径延迟的σ等于<embed src="https://latex.codecogs.com/gif.latex?%5Csqrt%7B%5Csigma%201%5E%7B2%7D+%5Csigma%202%5E%7B2%7D%7D"> ，该值小于（σ1 + σ2）。当对局部（不相关的）工艺变化建模时，路径延迟σ较小的现象也称为各个延迟变化的<strong>统计抵消（statistical cancellation）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830233527671.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对于实际设计，相关和不相关的变化都被建模，因此需要适当组合这两种类型的变化的贡献。</p>
<p>​ 发起和捕获时钟的时钟路径延迟也以相同的统计形式表示。基于数据和时钟路径延迟，可以将裕量（slack）作为具有标准值和标准差的统计量。</p>
<p>​ 假设使用正态分布，可以获得对应于（平均值mean +/- 3σ）的有效最小值和最大值。 （平均值mean -/ + 3σ）对应于图10-30中所示正态分布的0.135％和99.865％的分位数。0.135％的分位数意味着仅0.135％的结果分布小于此值（平均值mean-3σ）；同样，99.865％的分位数表示99.865％的结果小于此值，或仅0.135％（100％-99.865％）的结果大于此值（平均值mean+3σ）。有效的下限和上限在SSTA报告中称为<strong>分位数（quantile）</strong>，设计人员可以选择分析中使用的分位数，例如0.5％或99.5％，对应于（平均值mean -/ + 2.576σ）。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083023382033.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对于噪声和串扰分析（第 6 章），所使用的路径延迟和时序窗口是根据各种参数的平均值和标准偏差进行统计建模的。</p>
<p>​ 根据路径裕量分布，SSTA会报告每个路径裕量的平均值、标准差和分位数，从而可以根据所需的统计置信度（confidence）来判断时序是通过还是违例。</p>
<p><strong>统计时序库（Statistical Timing Libraries）</strong></p>
<p>​ 在 SSTA 方法中，标准单元库（以及设计中使用的其他宏的库）提供各种环境条件下的时序模型。例如，在最小 Vdd 和高温corner处的分析利用在此条件下表征的库，但对工艺参数进行统计建模。库包括标称参数值以及参数变化的时序模型。对于 N 个工艺参数，在 0.9V 和 125C 电源下表征的统计时序库可能包括以下内容：</p>
<ul>
<li>具有标准工艺参数的时序模型，<em>加上以下关于每个工艺参数的信息</em>。</li>
<li>参数i为（标准值+1σ）的时序模型，其他参数保持为标准值</li>
<li>参数i为（标准值-1σ）的时序模型，其他参数保持为标准值</li>
</ul>
<p>​ 对于具有两个独立工艺参数的简化示例场景，时序模型的特征在于标称参数值以及参数值的变化，如图 10-31 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830234408681.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>统计互连变化（Statistical Interconnect Variations）</strong></p>
<p>​ 每个金属层有三个独立的参数：</p>
<ul>
<li>金属刻蚀（ Metal etch）：这可以控制金属宽度以及与相邻导体的间距。金属层中的大刻蚀减小了宽度（这增加了电阻）并增加了到相邻走线的间距（这减小了到相邻走线的耦合电容）。该参数表示为导体宽度的变化。</li>
<li>金属厚度（ Metal thickness）：较厚的金属意味着与下面各层的电容更大。该参数表示为导体厚度的变化。</li>
<li>IMD厚度（金属间介电层厚度，Inter Metal Dielectric thickness）：较大的IMD厚度会减少与下面各层的耦合。该参数表示为IMD厚度的变化。</li>
</ul>
<p><strong>SSTA 结果（SSTA Results）</strong></p>
<p>​ 统计分析中输出的结果将根据平均值和角的有效值来提供路径的裕量。以下是用于建立时间检查（最大路径分析）的SSTA报告示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210830234749790.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830234818841.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 上面的报告显示，尽管时序路径的均值满足要求，但0.135％的分位数却有0.43ns的时序违例，时序路径裕量的分位数为-0.43ns。时序路径裕量的平均值为+ 0.86ns，标准差为0.43ns，这意味着+/- 2σ的分布结果满足要求。由于95.5％的分布落在2σ的变化范围内，这意味着只有2.275％的路径会出现时序违例（其余的2.275％分布具有较大的正裕量）。因此，把分位数设置为2.275％后可以使得裕量为0或没有时序违例。到达时间和路径裕量分布如下图10-32所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210830234912288.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，以上报告是针对建立时间检查的，因此分位数那一列提供的是分位数上限（例如，路径延迟的+ 3σ值），保持时间检查时则会指定为分位数下限（例如-3σ值）。报告中的“sensitiv”列是指敏感度，即标准差与平均值的比值（表示为百分比）。就裕量而言，需要较小的灵敏度，这意味着即使平均值发生变化，以平均值通过的路径也会继续通过。“incr”列中指定了报告中该行的增量标准差。</p>
<p>​ 使用单元和互连走线的统计模型，统计时序方法可以分析各种角条件下的设计，并分析由于工艺和互连参数变化而导致的情况。例如，在最差VT（电压和温度）情况下进行统计分析将分析整个全局工艺和互连走线空间。在最佳VT（电压和温度）情况下的另一种统计分析也将分析整个工艺和互连走线空间。这些分析可以与在最差PVT情况或最佳PVT情况下进行的传统分析进行对比，传统分析仅探讨工艺和互连空间中的单个点。</p>
<h2 id="路径失败时序paths-failing-timing">路径失败时序？（Paths Failing Timing?）</h2>
<p>​ 在本节中，我们将提供一些示例，突出显示设计者在调试STA结果期间需要关注的关键方面。这些例子中有几个只包含STA报告的相关摘录 。</p>
<h3 id="未找到路径no-path-found">未找到路径（No Path Found）</h3>
<p>​ 如果用户尝试获取路径报告，而STA报告找不到路径，或者它提供了路径报告但slack时间是无限的，该怎么办？在这两种情况下，出现这种情况可能是因为：</p>
<ul>
<li>时序路径已断开</li>
<li>该路径不存在</li>
<li>这是一条false path</li>
</ul>
<p>​ 在上述每种情况下，都需要仔细调试约束以确定是什么约束导致路径被阻塞。一种强力选项是删除所有错误的路径设置和时序中断，然后查看该路径是否可以进行时序分析。(时序中断是从STA中移除时序弧，通过使用<strong>set_disable_timing</strong>现，如第7.10节所述。)</p>
<h3 id="时钟交叉域clock-crossing-domain">时钟交叉域（Clock Crossing Domain）</h3>
<p>​ 这是路径报告的头部。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830235839772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830235908791.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 首先要注意的是，该路径从输入端口（ input port）开始，在触发器的clear pin结束，并且正在验证clear pin上的恢复检查（参见库恢复时间library recovery time）。接下来要注意的是，路径跨越两个不同的时钟域，SYS_IN_CLK，启动输入的时钟，和 PX9_CLK，触发器的时钟，正在检查其恢复时序。尽管从时序报告中看不出来，但从设计知识来看，可以检查两个时钟是否完全异步以及这两个时钟域之间的任何路径是否应该被视为错误。</p>
<p>​ lesson：验证启动时钟和捕获时钟以及两者之间的路径是否有效。</p>
<h3 id="反向生成时钟inverted-generated-clocks">反向生成时钟（Inverted Generated Clocks）</h3>
<p>​ 创建生成时钟时，需要谨慎使用 -invert 选项。如果使用 -invert 选项指定生成的时钟，则 STA 假定指定点的生成时钟属于指定类型。但是根据逻辑，设计中可能不会出现这样的波形。 STA 通常会提供错误或警告消息，指示生成的时钟无法实现，但它会继续分析并报告时序路径。</p>
<p>​ 考虑图 10-33。让我们在单元 UCKBUF0 的输出上定义一个带有 -invert 的生成时钟。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">CLKGEN</span> <span class="operator">-</span>divide_by <span class="number">1</span> <span class="operator">-</span>invert \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source [get_ports <span class="type">CLKM</span>] [get_pins <span class="type">UCKBUF0</span><span class="operator">/</span><span class="type">C</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210831000333661.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是基于上述约束的建立时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831000435921.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2021083100051170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，STA 假设单元 UCKBUF0 输出的波形是时钟 CLKM 的反相时钟。因此，上升沿为 5ns，捕获设置时钟沿为 15ns。除了时钟的上升沿在 5ns 而不是 0ns 的事实之外，从时序报告中看不出有什么问题。应该注意的是，由于错误位于启动和捕获时钟路径的公共部分，因此建立和保持时序检查确实正确执行。 STA产生的警告和错误需要仔细分析和理解。</p>
<p>​ 需要注意的重要一点是，无论是否可实现，STA 都会按照指定的方式创建生成的时钟。</p>
<p>​ 现在让我们尝试使用 -invert 选项将生成的时钟移动到单元 UCKBUF1 的输出，看看会发生什么。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">CLKGEN</span> <span class="operator">-</span>divide_by <span class="number">1</span> <span class="operator">-</span>invert \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source [get_ports <span class="type">CLKM</span>] [get_pins <span class="type">UCKBUF1</span><span class="operator">/</span><span class="type">C</span>]</span><br></pre></td></tr></table></figure>
<p>​ 这是setup报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831000724466.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831000758651.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 该路径看起来像半周期路径，但这是不正确的，因为在实际逻辑中时钟路径上没有反转。 STA 再次假设 UCKBUF1/C 引脚上的时钟是 create_generated_clock 命令中指定的时钟。因此上升沿发生在 5ns。捕获时钟边沿正在运行时钟 CLKM，其下一个上升沿发生在 10ns。下面的保持路径报告也包含与建立路径类似的差异。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831000911937.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831001005109.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 通常，STA 输出将包括错误或警告，指示生成的时钟不可实现。调试此类不正确路径的最佳方法是实际绘制捕获触发器和启动触发器处的时钟波形，并尝试了解所显示的边沿是否确实有效。</p>
<p>​ lesson：检查捕获和启动时钟的边沿，看看它们是否确实是它们应该的样子。</p>
<h3 id="缺少虚拟时钟延迟missing-virtual-clock-latency">缺少虚拟时钟延迟（Missing Virtual Clock Latency）</h3>
<p>​ 考虑以下路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831001250883.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831001324170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 它是从输入引脚开始的路径。请注意，起始到达时间列为 0。这表明时钟 VCLKM 上没有指定延迟 - 该时钟用于定义输入引脚 RESET_L 上的输入到达时间；这很可能是一个虚拟时钟，这就是缺少到达时间的原因。</p>
<p>​ lesson：使用虚拟时钟时，请确保在 set_input_delay 和 set_output_delay 约束中指定或考虑了虚拟时钟的延迟。</p>
<h3 id="大-io-延迟large-io-delays">大 I/O 延迟（Large I/O Delays）</h3>
<p>​ 当输入或输出路径有时序违例时，首先要检查的是时钟延迟，该延迟用作指定输入到达时间或输出所需时间的参考。这同样适用于前面所讲的例子。</p>
<p>​ 要检查的第二件事是输入或输出延迟，即输入路径上的输入到达时间或输出路径上的输出所需时间。我们可能会发现这些数值对于目标频率是不现实的。输入到达时间通常是时序报告中数据路径的第一个值，而输出所需时间通常是时序报告中数据路径的最后一个值。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831001604440.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 在输入失败路径的这个数据路径中，注意输入到达时间为 14ns。在这种特殊情况下，输入到达时间规范存在错误，因为它太大。</p>
<p>​ lesson：在检查输入或输出路径时，检查指定的外部延迟是否合理。</p>
<h3 id="错误的-io-缓冲区延迟incorrect-io-buffer-delay">错误的 I/O 缓冲区延迟（Incorrect I/O Buffer Delay）</h3>
<p>​ 当路径经过输入缓冲器或输出缓冲器时，约束不正确可能会导致输入或输出缓冲器延迟值较大。在如下所示的情况中，请注意18ns这个较大的输出缓冲器延迟值，这是由于输出引脚上指定的负载值较大导致的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831001732524.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831001801107.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> lesson：注意由不正确的负载规范引起的缓冲区的大延迟。</p>
<h3 id="延迟值不正确incorrect-latency-numbers">延迟值不正确（Incorrect Latency Numbers）</h3>
<p>​ 当时序路径出现故障时，需要检查的一件事是启动时钟和捕获时钟的延迟是否合理，即确保这些时钟之间的偏差在可接受的范围内。时钟构建期间不正确的延迟规范或不正确的时钟平衡都可能导致启动和捕获时钟路径中的大偏差，从而导致时序违规。</p>
<p>​ lesson：检查时钟偏差是否在合理范围内。</p>
<h3 id="半周期路径half-cycle-path">半周期路径（Half-cycle Path）</h3>
<p>​ 如前面的示例所述，设计人员需要检查违例路径的时钟域。随之而来的是，设计人员可能需要检查发起和捕获触发器的时钟沿。在某些情况下，可能会发现一个半周期路径（上升沿至下降沿路径或下降沿至上升沿路径）并且可能无法满足半周期路径的时序要求，又或者这些半周期路径不是真实存在的 。</p>
<p>​ lesson：确保数据路径有足够的时间进行传播。</p>
<h3 id="大延迟和转换时间large-delays-and-transition-times">大延迟和转换时间（Large Delays and Transition Times）</h3>
<p>​ 一项关键项目是检查沿数据路径的延迟或转换时间的异常大的数值。其中一些可能是由于：</p>
<ul>
<li>高扇出网络（High-fanout nets）：未适当缓冲（buffered）的网络。</li>
<li>较长网络（ Long nets）：需要在中间插入缓冲器的网络。</li>
<li>低强度单元（Low strength cells）：由于在设计中标有“don't touch”，因此未被更换的单元。</li>
<li>存储器路径（Memory paths）：这些路径通常会由于存储器输入上的建立时间较长以及存储器输出上的输出延迟较大而导致时序违规。</li>
</ul>
<h3 id="缺少多周期保持missing-multicycle-hold">缺少多周期保持（Missing Multicycle Hold）</h3>
<p>​ 对于多周期 N 设置规范，通常会看到缺少相应的多周期 N-1 保持规范。因此，这会导致在工具修复保持违规时插入大量不必要的延迟单元。</p>
<p>​ lesson：在修复之前始终审核保留违规，以确保正在修复的保留违规是真实的。</p>
<h3 id="路径未优化path-not-optimized">路径未优化（Path Not Optimized）</h3>
<p>​ STA违例也可能出现在尚未优化的路径上，可以通过检查数据路径来确定这种情况。是否存在延迟较大的单元？可以手动改善数据路径的时序吗？也许数据路径需要进一步优化，工具可能正在其它违例路径上工作。</p>
<h3 id="路径仍然不满足时序path-still-not-meeting-timing">路径仍然不满足时序（Path Still Not Meeting Timing）</h3>
<p>​ 如果数据路径具有强驱动能力的单元，而该路径仍然时序违例，则需要检查布线延迟和线负载较高的引脚。这可能是下一个改进方法：也许可以将单元移动得更近一些，从而可以减少线负载和布线延迟。</p>
<h3 id="如果仍然无法满足时序怎么办what-if-timing-still-cannot-be-met">如果仍然无法满足时序怎么办（What if Timing Still Cannot be Met）*</h3>
<p>​ 可以利用有用偏斜（useful skew）来帮助时序收敛。有用偏斜是指故意使时钟树失衡的地方，尤其是时序违例路径的发起时钟和捕获时钟路径，从而使时序在该路径上收敛。通常，这意味着可以延迟捕获时钟，以使捕获触发器的时钟在数据准备就绪稍后到达。当然，这假定了后续数据路径（即下一级触发器到触发器的数据路径）上有足够的裕量。</p>
<p>​ 也可以尝试相反的操作，也就是说，可以使发起时钟路径更短，以便更早地发起来自发起触发器的数据，从而帮助满足建立时间要求。同样，只有在前一级触发器到触发器路径具有多余的裕量时，才能做到这一点。</p>
<p>​ 有用偏斜技术不仅可用于修复建立时间违例，还可用于修复保持时间违例。此技术的一个缺点是，如果设计具有多种操作模式，则有用偏斜可能会在另一种模式下引起问题。</p>
<h2 id="验证时序约束validating-timing-constraints">验证时序约束（Validating Timing Constraints）</h2>
<p>​ 随着芯片尺寸的增长，将越来越依赖静态时序分析所交付的时序。仅依赖STA的风险在于STA取决于时序约束的合理与否。因此，时序约束的验证成为重要的考虑因素。</p>
<h3 id="检查路径例外checking-path-exceptions">检查路径例外（Checking Path Exceptions）</h3>
<p>​ 有一些工具可以根据设计的结构（网表）检查伪路径和多周期路径的有效性，这些工具会检查指定的伪路径或多周期路径约束是否有效。此外，这些工具还可能可以根据设计的结构生成缺少的伪路径和多周期路径约束。但是，这些工具生成的某些路径例外（path exception）也可能是无效的。这是因为这些工具通常使用形式验证技术（formal verification techniques）通过逻辑结构来确定伪路径或多周期路径，而设计人员对设计的功能行为有更深入的了解。因此，在接受并在STA中使用它们之前，设计人员需要检查工具生成的路径例外。可能还存在其它基于设计语义行为的路径例外，如果工具无法提取此类路径例外，设计者必须手动定义这些路径例外。</p>
<p>​ 时序约束中最大的风险就是路径例外。因此，应在仔细分析设计后确定出伪路径和多周期路径。通常，相比于伪路径，最好使用多周期路径，这确保了该路径至少受到一定程度的约束。如果在已知或可预期的时间会对信号进行采样，则无论信号离时钟沿有多远，都应使用多周期路径，这样静态时序分析至少可以知道一些时序约束的信息。伪路径可能会导致时序优化工具完全忽略这些路径，而实际上，它们确实可能在经过大量时钟周期后才被采样。</p>
<h3 id="检查时钟域交叉checking-clock-domain-crossing">检查时钟域交叉（Checking Clock Domain Crossing）</h3>
<p>​ 可用工具来确保设计中所有的跨时钟域均有效，这些工具还可以自动生成必要的伪路径约束。这样的工具也可能可以识别出非法（illegal）的跨时钟域，即数据在没有任何时钟同步逻辑的情况下跨越了两个不同时钟域。在这种情况下，这些工具可以提供在需要时自动插入合适的时钟同步逻辑的功能。请注意，并非所有跨异步时钟域都需要时钟同步器，应该取决于数据性质以及是否需要在下一个周期或几个周期后捕获数据。</p>
<p>​ 使用STA检查跨异步时钟域的另一种方法是设置一个很大的时钟不确定度（uncertainty），该不确定度等于采样时钟的周期。这样可以确保至少存在一些时序违例行为，根据这些时序违例行为，可以确定适当的路径例外，或者将时钟同步逻辑添加到设计中。</p>
<h3 id="验证-io-和时钟约束validating-io-and-clock-constraints">验证 IO 和时钟约束（Validating IO and Clock Constraints）</h3>
<p>​ 验证IO和时钟约束仍然是一个挑战，设计人员会经常进行时序仿真以检查设计中所有时钟的有效性。可以进行系统级时序仿真来验证IO时序，以确保芯片可以与其外围设备通信且没有任何时序问题。</p>
<h1 id="附录asdc">附录A:SDC</h1>
<blockquote>
<p>本附录将介绍1.7版本的SDC格式，此格式主要用于指定设计的时序约束。它不包含任何特定工具的命令，例如链接（link）和编译（compile）。它是一个文本文件，可以手写或由程序创建，并由程序读取。某些SDC命令仅适用于实现（implementation）或综合（synthesis），但是本附录会列出所有SDC命令。</p>
</blockquote>
<p>SDC语法是基于TCL的格式，即所有命令都遵循TCL语法。一个SDC文件会在文件开头包含SDC版本号，其次是设计约束，注释（注释以字符＃开始，并在行尾处结束）在SDC文件中可以散布在设计约束中。设计约束中较长的命令行可以使用反斜杠（）字符分成多行。</p>
<h2 id="a.1-基本命令">A.1 基本命令</h2>
<p>以下是SDC中的基本命令：</p>
<p>● <strong>current_instance</strong> [instance_pathname]</p>
<p>上述命令设置了设计的当前实例，这允许其它命令从该实例中设置或获取属性（attribute）。如果未提供任何参数，则当前实例将成为顶层（top-level）。</p>
<p>例子：</p>
<p>● <strong>current_instance</strong> /core/U2/UPLL</p>
<p>● <strong>current_instance</strong> .. （向上一层）</p>
<p>● <strong>current_instance</strong> （设为顶层）</p>
<p>● <strong>expr</strong> arg1 arg2 ... argn</p>
<p>● <strong>list</strong> arg1 arg2 ... argn</p>
<p>● <strong>set</strong> variable_name value</p>
<p>● <strong>set_hierarchy_separator</strong> separator</p>
<p>上述命令指定了SDC文件中使用的默认层次结构分隔符。在允许的情况下，可以通过在各个SDC命令中使用<strong>-hsc</strong>选项来覆盖此设置。</p>
<p>例子：</p>
<p>● <strong>set_hierarchy_separator</strong> /</p>
<p>● <strong>set_hierarchy_separator</strong> .</p>
<p>● <strong>set_units</strong> [<strong>-capacitance</strong> cap_unit] [<strong>-resistance</strong> res_units] [<strong>-time</strong> time_unit] [<strong>-voltage</strong> voltage_unit] [<strong>-current</strong> current_unit] [<strong>-power</strong> power_unit]</p>
<p>上述命令指定了SDC文件中使用的单位。</p>
<p>例子：</p>
<p>● <strong>set_units</strong> <strong>-capacitance</strong> pf <strong>-time</strong> ps</p>
<h2 id="a.2-对象访问命令">A.2 对象访问命令</h2>
<p>以下命令指定了如何访问设计实例中的对象。</p>
<p><strong>all_clocks</strong>命令会返回一个所有时钟的集合：</p>
<p>● <strong>foreach_in_collection</strong> clkvar [<strong>all_clocks</strong>]</p>
<p>● <strong>set_clock_transition</strong> 0.150 [<strong>all_clocks</strong>]</p>
<p><strong>all_inputs</strong> [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-clock</strong> clock_name] 命令会返回一个设计中所有输入端口的集合：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VCLK 0.6 <strong>-min</strong> [<strong>all_inputs</strong>]</p>
<p><strong>all_outputs</strong> [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-clock</strong> clock_name] 命令会返回一个设计中所有输出端口的集合：</p>
<p>● <strong>set_load</strong> 0.5 [<strong>all_outputs</strong>]</p>
<p><strong>all_registers</strong> [<strong>-no_hierarchy</strong>] [<strong>-clock</strong> clock_name] [<strong>-rise_clock</strong> clock_name] [<strong>-fall_clock</strong> clock_name] [<strong>-cells</strong>] [<strong>-data_pins</strong>] [<strong>-clock_pins</strong>] [<strong>-slave_clock_pins</strong>] [<strong>-async_pins</strong>] [<strong>-output_pins</strong>] [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-master_slave</strong>] 命令会返回一个具有指定属性的寄存器的集合：</p>
<p>● <strong>all_registers</strong> <strong>-clock</strong> DAC_CLK</p>
<p>上述这个命令返回的集合中为所有由时钟DAC_CLK触发的寄存器。</p>
<p><strong>current_design</strong> [design name] 命令会返回当前设计的名称。如果使用参数指定，则将会设置当前设计为指定的名称：</p>
<p>● <strong>current_design</strong> FADD</p>
<p>● <strong>current_design</strong></p>
<p><strong>get_cells</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个设计中与指定模型（pattern）匹配的单元的集合，通配符可用于匹配多个单元：</p>
<p>● <strong>get_cells</strong> RegEdge*</p>
<p>● <strong>foreach_in_collection</strong> cvar [<strong>get_cells</strong> <strong>-hierarchical</strong> *]</p>
<p><strong>get_clocks</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个设计中与指定模型匹配的时钟的集合。当在<strong>-from</strong>或<strong>-to</strong>等上下文中使用时，它将返回一个由指定时钟驱动的所有触发器的集合：</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_clocks</strong> SYS_CLK]</p>
<p>● <strong>set_multicycle_path</strong> <strong>-to</strong> [<strong>get_clocks</strong> jtag*]</p>
<p><strong>get_lib_cells</strong> [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会创建一个当前正在加载的库中并且与指定模型匹配的库单元的集合：</p>
<p>● <strong>get_lib_cells</strong> cmos131v/AOI3*</p>
<p><strong>get_lib_pins</strong> [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个与指定模型匹配的库单元引脚的集合。</p>
<p><strong>get_libs</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个设计中当前加载的库的集合。</p>
<p><strong>get_nets</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个与指定模型匹配的网络的集合：</p>
<p>● <strong>get_nets</strong> <strong>-hierarchical</strong> *</p>
<p>● <strong>get_nets</strong> FIFO_patt*</p>
<p><strong>get_pins</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个与指定模型匹配的引脚名称的集合：</p>
<p>● <strong>get_pins</strong> *</p>
<p>● <strong>get_pins</strong> U1/U2/U3/UAND/Z</p>
<p><strong>get_ports</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个与指定模型匹配的设计（输入和输出）端口名称的集合：</p>
<p>● <strong>foreach_in_collection</strong> port_name [<strong>get_ports</strong> clk*]</p>
<p>可以在不“获取”对象的情况下引用诸如端口（port）之类的对象吗？当设计中只有一个具有该名称的对象时，实际上没有任何区别。但是，当多个对象具有相同的名称时，使用<strong>get_ *</strong> 命令将变得更加重要，它可以避免在引用哪种类型对象方面所带来的任何可能的混淆。假设有一个名为BIST_N1的网络和一个名为BIST_N1的端口，考虑以下SDC命令：</p>
<p>● <strong>set_load</strong> 0.05 BIST_N1</p>
<p>问题是要引用哪个BIST_N1？网络还是端口？在大多数情况下，最好明确表明对象的类型，例如：</p>
<p>● <strong>set_load</strong> 0.05 [<strong>get_nets</strong> BIST_N1]</p>
<p>现在再假设有一个时钟MCLK和另一个也称为MCLK的端口，考虑以下SDC命令：</p>
<p>● <strong>set_propagated_clock</strong> MCLK</p>
<p>该对象是引用名为MCLK的端口还是引用称为MCLK的时钟？在此特定情况下，它指的是时钟，因为这是<strong>set_propagated_clock</strong>命令的优先级所选择的。但是，要明确一点，最好明确表明对象类型，如下所示：</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_clocks</strong> MCLK]</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_ports</strong> MCLK]</p>
<p>有了这种明确的条件申明，就不必依赖优先级规则了，并且SDC命令会非常清楚。</p>
<h2 id="a.3-时序约束">A.3 时序约束</h2>
<p>本节将介绍与时序约束有关的SDC命令。</p>
<p><strong>create_clock</strong> <strong>-period</strong> period_value [<strong>-name</strong> clock_name] [<strong>-waveform</strong> edge_list] [<strong>-add</strong>] [source_objects] 命令可用于定义时钟。如果未指定clock_name，则时钟名称将是第一个源对象的名称。<strong>-period</strong>选项指定时钟周期，<strong>-add</strong>选项用于在已经具有时钟定义的引脚上创建时钟。否则，如果不使用此选项，则此时钟定义将覆盖该节点上任何其它现有的时钟定义。<strong>-waveform</strong>选项指定时钟的上升沿和下降沿（占空比），默认值为（0，period / 2）。如果时钟定义的节点位于另一个时钟之后的路径上，则它将阻塞该点之前一个时钟。</p>
<p>例子：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 20 <strong>-waveform</strong> {0 6} <strong>-name</strong> SYS_CLK [<strong>get_ports</strong> SYS_CLK]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CPU_CLK <strong>-period</strong> 2.33 <strong>-add</strong> [<strong>get_ports</strong> CPU_CLK]</p>
<p><strong>create_generated_clock</strong> [<strong>-name</strong> clock_name] [<strong>-source</strong> master_pin] [<strong>-edges</strong> edge_list] [<strong>-divide_by</strong> factor] [<strong>-multiply_by</strong> factor] [<strong>-duty_cycle</strong> percent] [<strong>-invert</strong>] [<strong>-edge_shift</strong> shift_list] [<strong>-add</strong>] [<strong>-master_clock</strong> clock] [<strong>-combinational</strong>] [source_objects] 命令可用于定义内部的衍生时钟。如果未指定<strong>-name</strong>，则时钟名称为第一个源对象的名称。<strong>-source</strong>指定衍生时钟的源是设计中的引脚或端口。如果有多个时钟输入源节点，必须使用<strong>-master_clock</strong>选项指定将这些时钟中的哪一个用作衍生时钟的源。<strong>-divide_by</strong>选项用于指定时钟的分频系数，与<strong>-multiply_by</strong>类似。<strong>-duty_cycle</strong>可以用于指定时钟的占空比。如果时钟的相位已反转，则可以指定<strong>-invert</strong>选项。除了使用时钟倍频或分频，还可以使用<strong>-edges</strong>和<strong>-edge_shift</strong>选项指定衍生时钟。<strong>-edges</strong>选项指定一个由三个数字组成的列表，该列表指定用于第一个上升沿、下一个下降沿和下一个上升沿的主时钟边沿。例如，可以将时钟分频器指定为<strong>-divide_by</strong> 2或<strong>-edges</strong> {1 3 5}。<strong>-edge_shift</strong>选项可以与<strong>-edges</strong>选项一起使用，以指定三个边沿中每个边沿的偏移量。</p>
<p>例子：</p>
<p>● <strong>create_generated_clock</strong> <strong>-divide_by</strong> 2 <strong>-source</strong> [<strong>get_ports</strong> sys_clk] <strong>-name</strong> gen_sys_clk [<strong>get_pins</strong> UFF/Q]</p>
<p>● <strong>create_generated_clock</strong> <strong>-add</strong> <strong>-invert</strong> <strong>-edges</strong> {1 2 8} <strong>-source</strong> [<strong>get_ports</strong> mclk] <strong>-name</strong> gen_clk_div</p>
<p>● <strong>create_generated_clock</strong> <strong>-multiply_by</strong> 3 <strong>-source</strong> [<strong>get_ports</strong> ref_clk] <strong>-master_clock</strong> clk10MHz [<strong>get_pins</strong> UPLL/CLKOUT] <strong>-name</strong> gen_pll_clk</p>
<p><strong>group_path</strong> [<strong>-name</strong> group_name] [<strong>-default</strong>] [<strong>-weight</strong> weight_value] [<strong>-from</strong> from_list] [<strong>-rise_from</strong> from_list] [<strong>-fall_from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-rise_to</strong> to_list] [<strong>-fall_to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_through</strong> through_list] [<strong>-fall_through</strong> through_list] 命令可以为指定的路径组命名。</p>
<p><strong>set_clock_gating_check</strong> [<strong>-setup</strong> setup_value] [<strong>-hold</strong> hold_value] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-high</strong>] [<strong>-low</strong>] [object_list] 命令可以提供对任何对象指定时钟门控检查的功能。时钟门控检查仅在具有时钟信号的逻辑门处执行，默认情况下建立时间和保持时间值为0。</p>
<p>例子：</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-setup</strong> 0.15 <strong>-hold</strong> 0.05 [<strong>get_clocks</strong> ck20m]</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-hold</strong> 0.3 [<strong>get_cells</strong> U0/clk_divider/UAND1]</p>
<p><strong>set_clock_groups</strong> [<strong>-name</strong> name] [<strong>-logically_exclusive</strong>] [<strong>-physically_exclusive</strong>] [<strong>-asynchronous</strong>] [<strong>-allow_paths</strong>] <strong>-group</strong> clock_list 命令指定了一组具有特定属性的时钟，并为该组分配了一个名称。</p>
<p><strong>set_clock_latency</strong> [<strong>-rayise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-source</strong>] [<strong>-late</strong>] [<strong>-early</strong>] [<strong>-clock</strong> clock_list] delay object_list 命令指定给定时钟的时钟延迟。有两种类型的延迟：网络延迟和源延迟。源延迟是时钟定义引脚与其源之间的时钟网络延迟，而网络延迟是时钟定义引脚与触发器时钟引脚之间的时钟网络延迟。</p>
<p>例子：</p>
<p>● <strong>set_clock_latency</strong> 1.86 [<strong>get_clocks</strong> clk250]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-late</strong> <strong>-rise</strong> 2.5 [<strong>get_clocks</strong> MCLK]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-late</strong> <strong>-fall</strong> 2.3 [<strong>get_clocks</strong> MCLK]</p>
<p><strong>set_clock_sense</strong> [<strong>-positive</strong>] [<strong>-negative</strong>] [<strong>-pulse</strong> pulse] [<strong>-stop_propagation</strong>] [<strong>-clock</strong> clock_list] pin_list 命令在引脚上设置时钟属性。</p>
<p><strong>set_clock_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] transition_clock_list 命令指定时钟定义点处的时钟过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_clock_transition</strong> <strong>-min</strong> 0.5 [<strong>get_clocks</strong> SERDES_CLK]</p>
<p>● <strong>set_clock_transition</strong> <strong>-max</strong> 1.5 [<strong>get_clocks</strong> SERDES_CLK]</p>
<p><strong>set_clock_uncertainty</strong> [<strong>-from</strong> from_clock] [<strong>-rise_from</strong> rise_from_clock] [<strong>-fall_from</strong> fall_from_clock] [<strong>-to</strong> to_clock] [<strong>-rise_to</strong> rise_to_clock] [<strong>-fall_to</strong> fall_to_clock] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-setup</strong>] [<strong>-hold</strong>] uncertainty [object_list] 命令指定了时钟或时钟到时钟传输的时钟不确定度。STA将从路径的数据需要到达时间中减去建立时间不确定度，并将保持时间不确定度增加到路径的数据需要到达时间中。</p>
<p>例子：</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-setup</strong> <strong>-rise</strong> <strong>-fall</strong> 0.2 [<strong>get_clocks</strong> CLK2]</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> [<strong>get_clocks</strong> HSCLK] <strong>-to</strong> [<strong>get_clocks</strong> SYSCLK] <strong>-hold</strong> 0.35</p>
<p><strong>set_data_check</strong> [<strong>-from</strong> from_object] [<strong>-to</strong> to_object] [<strong>-rise_from</strong> from_object] [<strong>-fall_from</strong> from_object] [<strong>-rise_to</strong> to_object] [<strong>-fall_to</strong> to_object] [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-clock</strong> clock_object] value 命令在两个数据引脚之间执行指定的检查。</p>
<p>例子：</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> [<strong>get_pins</strong> UBLK/EN] <strong>-to</strong> [<strong>get_pins</strong> UBLK/D] <strong>-setup</strong> 0.2</p>
<p><strong>set_disable_timing</strong> [<strong>-from</strong> from_pin_name] [<strong>-to</strong> to_pin_name] cell_pin_list 命令中断了指定单元内的时序弧。</p>
<p>例子：</p>
<p>● <strong>set_disable_timing</strong> <strong>-from</strong> A <strong>-to</strong> ZN [<strong>get_cells</strong> U1]</p>
<p><strong>set_false_path</strong> [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] 命令指定了STA不需要考虑的路径例外。</p>
<p>● <strong>set_false_path</strong> <strong>-from</strong> [<strong>get_clocks</strong> jtag_clk] <strong>-to</strong> [<strong>get_clocks</strong> sys_clk]</p>
<p>● <strong>set_false_path</strong> <strong>-through</strong> U1/A <strong>-through</strong> U4/ZN</p>
<p><strong>set_ideal_latency</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] delay object_list 命令用于为特定对象设置理想的延迟。</p>
<p><strong>set_ideal_network</strong> [<strong>-no_propagate</strong>] object_list 命令将指定设计中理想网络的源节点。</p>
<p><strong>set_ideal_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] transition_time object_list 命令将指定理想网络的过渡时间。</p>
<p><strong>set_input_delay</strong> [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-max</strong>] [<strong>-min</strong>] [<strong>-add_delay</strong>] [<strong>-network_latency_included</strong>] [<strong>-source_latency_included</strong>] delay_value port_pin_list 命令将指定相对于指定时钟的输入端口数据到达时间，默认为时钟的上升沿。<strong>-add_delay</strong>选项允许向该引脚或端口添加多个约束，可以使用此<strong>-add_delay</strong>选项将时钟设置为不同的时钟。默认情况下，会将发起时钟的时钟源延迟添加到输入延迟值中，但是当指定了<strong>-source_latency_included</strong>选项时，由于假设已将源网络延迟添加到了输入延迟值中，因此不再添加源网络延迟。<strong>-max</strong>选项指定的延迟用于建立时间和恢复时间检查，而<strong>-min</strong>选项指定的延迟用于保持时间和撤销时间检查。如果仅指定<strong>-min</strong>或<strong>-max</strong>或两者均未指定，则两者将使用相同的值。</p>
<p>例子：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> SYSCLK 1.1 [<strong>get_ports</strong> MDIO*]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> virtual_mclk 2.5 [<strong>all_inputs</strong>]</p>
<p><strong>set_max_delay</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] delay_value 命令用于设置指定路径上的最大延迟。这个命令用于指定两个任意引脚之间的延迟，而不是从一个触发器到另一个触发器的延迟。</p>
<p>例子：</p>
<p>● <strong>set_max_delay</strong> <strong>-from</strong> [<strong>get_clocks</strong> FIFOCLK] <strong>-to</strong> [<strong>get_clocks</strong> MAINCLK] 3.5</p>
<p>● <strong>set_max_delay</strong> <strong>-from</strong> [<strong>all_inputs</strong>] <strong>-to</strong> [<strong>get_cells</strong> UCKDIV/UFF1/D] 2.66</p>
<p><strong>set_max_time_borrow</strong> delay_value object_list 命令可用于设置在分析锁存器路径时可以借用的最长时间。</p>
<p>例子：</p>
<p>● <strong>set_max_time_borrow</strong> 0.6 [<strong>get_pins</strong> CORE/CNT_LATCH/D]</p>
<p><strong>set_min_delay</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] delay_value 命令用于设置指定路径上的最小延迟，该延迟可以在任意两个引脚之间。</p>
<p>例子：</p>
<p>● <strong>set_min_delay</strong> <strong>-from</strong> U1/S <strong>-to</strong> U2/A 0.6</p>
<p>● <strong>set_min_delay</strong> <strong>-from</strong> [<strong>get_clocks</strong> PCLK] <strong>-to</strong> [<strong>get_pins</strong> UFF/*/S]</p>
<p><strong>set_multicycle_path</strong> [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-start</strong>] [<strong>-end</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] path_multiplier 命令将路径指定为多周期路径，可以使用多个<strong>-through</strong>选项。如果多周期路径仅用于建立时间检查，请使用<strong>-setup</strong>选项，而如果多周期路径用于保持时间检查，请使用<strong>-hold</strong>选项。如果<strong>-setup</strong>或<strong>-hold</strong>均未指定，则默认为<strong>-setup</strong>且默认的保持时间周期为0。<strong>-start</strong>选项指定了时钟周期数使用的是发起时钟的 ，而<strong>-end</strong>选项指定使用的是捕获时钟的，默认值为<strong>-start</strong>。<strong>-hold</strong>选项指定的时钟周期数表示需要偏离默认多周期保持时间值0的时钟沿数。</p>
<p>例子：</p>
<p>● <strong>set_multicycle_path</strong> <strong>-start</strong> <strong>-setup</strong> <strong>-from</strong> [<strong>get_clocks</strong> PCLK] <strong>-to</strong> [<strong>get_clocks</strong> MCLK] 4</p>
<p>● <strong>set_multicycle_path</strong> <strong>-hold</strong> <strong>-from</strong> UFF1/Q <strong>-to</strong> UCNTFF/D 2</p>
<p>● <strong>set_multicycle_path</strong> <strong>-setup</strong> <strong>-to</strong> [<strong>get_pins</strong> UEDGEFF*] 4</p>
<p><strong>set_output_delay</strong> [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] [<strong>-level_sensitive</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-max</strong>] [<strong>-min</strong>] [<strong>-add_delay</strong>] [<strong>-network_delay_included</strong>] [<strong>-source_latency_included</strong>] delay_value port_pin_list 命令可以指定相对于时钟的输出所需时间，默认是上升沿。默认情况下，时钟源延迟会添加到输出延迟值中，但是当指定<strong>-source_latency_included</strong>选项时，不会添加时钟延迟值，因为会假定它已包含在输出延迟值中。<strong>-add_delay</strong>选项可用于在一个引脚/端口上指定多个<strong>set_output_delay</strong>。</p>
<p><strong>set_propagated_clock</strong> object_list 命令指定时钟延迟需要计算，即不是理想的。</p>
<p>● <strong>set_propagated_clock</strong> [<strong>all_clocks</strong>]</p>
<h2 id="a.4-环境命令">A.4 环境命令</h2>
<p>本节介绍了用于设置待分析设计环境的命令。</p>
<p><strong>set_case_analysis</strong> value port_or_pin_list 命令用于指定被设置为常数的端口或引脚。</p>
<p>例子：</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_pins</strong> UDFT/MODE_SEL]</p>
<p>● <strong>set_case_analysis</strong> 1 [<strong>get_ports</strong> SCAN_ENABLE]</p>
<p><strong>set_drive</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] resistance port_list 命令用于指定输入端口的驱动强度，它指定端口的外部驱动电阻，值为0表示驱动强度是最高的。</p>
<p>例子：</p>
<p>● <strong>set_drive</strong> 0 {CLK RST}</p>
<p><strong>set_driving_cell</strong> [<strong>-lib_cell</strong> lib_cell_name] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-library</strong> lib_name] [<strong>-pin</strong> pin_name] [<strong>-from_pin</strong> from_pin_name] [<strong>-multiply_by</strong> factor] [<strong>-dont_scale</strong>] [<strong>-no_design_rule</strong>] [<strong>-input_transition_rise</strong> rise_time] [<strong>-input_transition_fall</strong> fall_time] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] port_list 命令用于模拟驱动输入端口的单元的驱动电阻。</p>
<p>例子：</p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> BUFX4 <strong>-pin</strong> ZN [<strong>all_inputs</strong>]</p>
<p><strong>set_fanout_load</strong> value port_list 命令在输出端口上设置指定的扇出负载。</p>
<p>例子：</p>
<p>● <strong>set_fanout_load</strong> 5 [<strong>all_outputs</strong>]</p>
<p><strong>set_input_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] transition port_list 命令指定了输入端口上的过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_input_transition</strong> 0.2 [<strong>get_ports</strong> SD_DIN*]</p>
<p>● <strong>set_input_transition</strong> <strong>-rise</strong> 0.5 [<strong>get_ports</strong> GPIO*]</p>
<p><strong>set_load</strong> [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-subtract_pin_load</strong>] [<strong>-pin_load</strong>] [<strong>-wire_load</strong>] value objects 命令用于指定在设计中引脚或网络上的电容性负载的值。<strong>-subtract_pin_load</strong>选项表示从指定负载中减去引脚电容。</p>
<p>例子：</p>
<p>● <strong>set_load</strong> 50 [<strong>all_outputs</strong>]</p>
<p>● <strong>set_load</strong> 0.1 [<strong>get_pins</strong> UFF0/Q]</p>
<p>● <strong>set_load</strong> <strong>-subtract_pin_load</strong> 0.025 [<strong>get_nets</strong> UCNT0/NET5]</p>
<p><strong>set_logic_dc</strong> port_list 命令、<strong>set_logic_one</strong> port_list 命令以及<strong>set_logic_zero</strong> port_list 命令将指定的端口设置为不关心（don't care）、逻辑1或逻辑0。</p>
<p>例子：</p>
<p>● <strong>set_logic_dc</strong> SE</p>
<p>● <strong>set_logic_one</strong> TEST</p>
<p>● <strong>set_logic_zero</strong> [<strong>get_pins</strong> USB0/USYNC_FF1/Q]</p>
<p><strong>set_max_area</strong> area_value 命令指定了当前设计的最大面积限制。</p>
<p>例子：</p>
<p>● <strong>set_max_area</strong> 20000.0</p>
<p><strong>set_max_capacitance</strong> value object_list 命令指定了端口或设计中的最大电容。如果是设计，则指定了设计中所有引脚的最大电容。</p>
<p>● <strong>set_max_capacitance</strong> 0.2 [<strong>current_design</strong>]</p>
<p>● <strong>set_max_capacitance</strong> 1 [<strong>all_outputs</strong>]</p>
<p><strong>set_max_fanout</strong> value object_list 命令指定了端口或设计中的最大扇出值。如果是设计，则指定了设计中所有输出引脚的最大扇出值。</p>
<p>● <strong>set_max_fanout</strong> 16 [<strong>get_pins</strong> UDFT0/JTAG/ZN]</p>
<p>● <strong>set_max_fanout</strong> 50 [<strong>current_design</strong>]</p>
<p><strong>set_max_transition</strong> [<strong>-clock_path</strong>] [<strong>-data_path</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] value object_list 命令指定了端口或设计中的最大过渡时间。如果是设计，则指定了设计中所有引脚上的最大过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_max_transition</strong> 0.2 UCLKDIV0/QN</p>
<p><strong>set_min_capacitance</strong> value object_list 命令指定了设计中端口或引脚上的最小电容值。</p>
<p>例子：</p>
<p>● <strong>set_min_capacitance</strong> 0.05 UPHY0/UCNTR/B1</p>
<p><strong>set_operating_conditions</strong> [<strong>-library</strong> lib_name] [<strong>-analysis_type</strong> type] [<strong>-max</strong> max_condition] [<strong>-min</strong> min_condition] [<strong>-max_library</strong> max_lib] [<strong>-min_library</strong> min_lib] [<strong>-object_list</strong> objects] [condition] 命令可以设置用于时序分析的工作条件。分析类型可以是single（单个情况），bc_wc（最佳情况/最差情况）或者on_chip_variation（片上变化）。可以使用<strong>operating_conditions</strong>命令在库中定义工作条件。</p>
<p>例子：</p>
<p>● <strong>set_operating_conditions</strong> <strong>-analysis_type</strong> bc_wc</p>
<p>● <strong>set_operating_conditions</strong> WCCOM</p>
<p>● <strong>set_operating_conditions</strong> <strong>-analysis_type</strong> on_chip_variation</p>
<p><strong>set_port_fanout_number</strong> value port_list 命令可用于设置端口的最大扇出数。</p>
<p>例子：</p>
<p>● <strong>set_port_fanout_number</strong> 10 [<strong>get_ports</strong> GPIO*]</p>
<p><strong>set_resistance</strong> [<strong>-min</strong>] [<strong>-max</strong>] value list_of_nets 命令可用于设置指定网络上的电阻。</p>
<p>例子：</p>
<p>● <strong>set_resistance</strong> 10 <strong>-min</strong> U0/U1/NETA</p>
<p>● <strong>set_resistance</strong> 50 <strong>-max</strong> U0/U1/NETA</p>
<p><strong>set_timing_derate</strong> [<strong>-cell_delay</strong>] [<strong>-cell_check</strong>] [<strong>-net_delay</strong>] [<strong>-data</strong>] [<strong>-clock</strong>] [<strong>-early</strong>] [<strong>-late</strong>] derate_value [object_list] 命令指定了降额系数。</p>
<p><strong>set_wire_load_min_block_size</strong> size 命令指定了将线负载模型设置为“enclosed”时使用的最小的块大小。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_min_block_size</strong> 5000</p>
<p><strong>set_wire_load_mode</strong> mode_name 命令定义了如何对分层设计（hierarchical design）中的网络使用线负载模型的机制。mode_name可以是top，enclosure或segmented。top模式规定在顶层定义的线负载模型将用于所有较低级别上。enclosure模式规定完全封闭在模块中的网络的线负载模型用于该网络。segmented模式规定模块中的网络段使用该模块的线负载模型。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_mode</strong> enclosed</p>
<p><strong>set_wire_load_model</strong> <strong>-name</strong> model_name [<strong>-library</strong> lib_name] [<strong>-min</strong>] [<strong>-max</strong>] [object_list] 命令定义了用于当前设计或指定网络的线负载模型。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_model</strong> <strong>-name</strong> "eSiliconLightWLM"</p>
<p><strong>set_wire_load_selection_group</strong> [<strong>-library</strong> lib_name] [<strong>-min</strong>] [<strong>-max</strong>] group_name [object_list] 命令会在根据块的单元面积确定线负载模型时，为设计设置线负载选择组，该选择组通常在技术库中定义。</p>
<h2 id="a.5-多电压命令">A.5 多电压命令</h2>
<p>当设计中存在多电压岛（multi-voltage islands）时，以下命令适用。</p>
<p><strong>create_voltage_area</strong> <strong>-name</strong> name [<strong>-coordinate</strong> coordinate_list] [<strong>-guard_band_x</strong> float] [<strong>-guard_band_y</strong> float] cell_list</p>
<p><strong>set_level_shifter_strategy</strong> [<strong>-rule</strong> rule_type]</p>
<p><strong>set_level_shifter_threshold</strong> [<strong>-voltage</strong> float] [<strong>-percent</strong> float]</p>
<p><strong>set_max_dynamic_power</strong> power [unit] 命令指定了最大动态功率。</p>
<p>例子：</p>
<p>● <strong>set_max_dynamic_power</strong> 0 mw</p>
<p><strong>set_max_leakage_power</strong> power [unit] 命令指定了最大漏电功率。</p>
<p>例子：</p>
<p>● <strong>set_max_leakage_power</strong> 12 mw</p>
<h1 id="附录bsdf">附录B:SDF</h1>
<blockquote>
<p>本附录将介绍标准延迟标注格式，并说明了如何在仿真中执行反标。</p>
</blockquote>
<p>延迟格式描述了设计网表的单元延迟和互连走线延迟，无论设计是用两种主要硬件描述语言（VHDL或Verilog HDL）中的哪一种所描述的。</p>
<p>本章还会介绍仿真的反标（backannotation），STA的反标其实是一个简单直接的过程，其中DUA中的时序弧将由SDF所指定的延迟进行标注。</p>
<h2 id="b.1-什么是sdf">B.1 什么是SDF？</h2>
<p>SDF是指标准延迟格式（Standard Delay Format）。它是一个IEEE标准——IEEE Std1497，它是ASCII文本文件，它描述了时序信息和约束，其目的是用作各种工具之间的文本类型的时序信息交换媒介，它也可以用来描述需要它的工具的时序数据。由于它是IEEE标准，因此由一个工具生成的时序信息可以被支持该标准的许多其它工具所使用。SDF中的数据与工具和语言都无关，且包括了互连走线延迟、器件延迟以及时序检查的规范。</p>
<p>由于SDF是ASCII文件，因此它易于阅读，尽管对于实际设计而言，这些文件往往很大。但是，它是作为工具之间的交换媒介。经常在进行信息交换时，一个工具可能会在生成SDF文件时产生一个问题，而另一个读取SDF的工具可能无法正确读取SDF。读取SDF的工具可能会在读取SDF时产生一个错误或警告，或者它可能会错误地解释SDF中的值。在这种情况下，设计人员可能必须查看SDF文件，看看出了什么问题。本章介绍了SDF文件的基础知识，并提供了必要和足够的信息，以帮助理解和调试任何标注问题。</p>
<p>图B-1显示了如何使用SDF文件的典型流程。时序计算工具通常会生成时序信息存储在SDF文件中。然后，通过读取SDF的工具将该信息反标到设计中。请注意，完整的设计信息不会都存储到SDF文件中，而只会存储延迟值。例如，实例名称和实例的引脚名称将被存储到SDF文件中，因为它们对于指定实例相关或引脚相关的延迟是必需的。因此，必须为SDF生成工具和SDF读取工具提供相同的设计。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ecd6657bd53a0b42922cf29e0791ce96_720w.jpg" alt="图B-1"></p>
<p>一个设计可以具有多个与之关联的SDF文件。可以为一个设计创建一个SDF文件，在分层设计中，也可以为分层中的每个块创建多个SDF文件。在标注期间，每个SDF都将应用于适当的分层实例中，如图B-2所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e94cf2f197e57648d209e2e296787f33_720w.jpg" alt="图B-2"></p>
<p>SDF文件包含了用于反标和标注的时序数据。更具体地说，它包含：</p>
<p>● 单元延迟（Cell delays）</p>
<p>● 脉冲传播（Pulse propagation）</p>
<p>● 时序检查（Timing checks）</p>
<p>● 互连走线延迟（Interconnect delays）</p>
<p>● 时序环境（Timing environment）</p>
<p>引脚到引脚的延迟（pin-to-pin delay）和分布式延迟（distributed delay）都可以针对单元延迟进行建模。引脚到引脚的延迟使用<strong>IOPATH</strong>结构（construct）表示，这些结构定义了每个单元输入到输出的路径延迟。<strong>COND</strong>结构还可以用于额外指定有条件的引脚到引脚延迟。状态相关（state-dependent）的路径延迟也可以使用<strong>COND</strong>结构来指定，分布式延迟的建模是使用<strong>DEVICE</strong>结构指定的。</p>
<p>脉冲传播结构——<strong>PATHPULSE</strong>和<strong>PATHPULSEPERCENT</strong>可用于指定使用引脚到引脚延迟模型时允许传播到单元输出端口的毛刺大小。</p>
<p>可以在SDF中指定的时序检查包括：</p>
<p>● 建立时间：SETUP，SETUPHOLD</p>
<p>● 保持时间：HOLD，SETUPHOLD</p>
<p>● 恢复时间：RECOVERY，RECREM</p>
<p>● 撤销时间：REMOVAL，RECREM</p>
<p>● 最大偏斜：SKEW，BIDIRECTSKEW</p>
<p>● 最小脉冲宽度：WIDTH</p>
<p>● 最小周期：PERIOD</p>
<p>● 不变化：NOCHANGE</p>
<p>时序检查中的信号可能存在某些条件。在时序检查中允许使用负值，不支持负值的工具可以选择将其替换为零。</p>
<p>SDF描述中支持三种类型的互连走线建模。<strong>INTERCONNECT</strong>结构是最通用且最常用的，可用于指定点对点延迟（从源端到接收端），因此单个网络可以具有多个<strong>INTERCONNECT</strong>结构。<strong>PORT</strong>结构可用于指定负载端口处的网络延迟，假定网络只有一个源端驱动。<strong>NETDELAY</strong>结构可用于指定整个网络的延迟，而无需考虑其源端或接收端，因此是指定网络上延迟的最不具体的方法。</p>
<p>时序环境提供了设计在工作时所依据的信息，这些信息包括<strong>ARRIVAL</strong>，<strong>DEPARTURE</strong>，<strong>SLACK</strong>和<strong>WAVEFORM</strong>结构。这些结构主要用于标注，例如可用于综合。</p>
<h2 id="b.2-sdf格式">B.2 SDF格式</h2>
<p>SDF文件包含一个首部（header section），后跟一个或多个单元。每个单元代表设计中的一个区域或范围，它可以是库原语（primitive）或用户自定义的黑盒。</p>
<p><img src="https://pic1.zhimg.com/80/v2-32c338d91631d725594577be36353fe0_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1b4881894fc3ec6ff1263e2e99283d98_720w.png"></p>
<p>首部包含一般信息，除了层次结构分隔符、时间刻度（timescale）和SDF版本号外，都不会影响SDF文件的语义。默认情况下，层次结构分隔符<strong>DIVIDER</strong>是点字符（“.”）。通过以下方法，可以将其替换为“/”字符：</p>
<p>● （<strong>DIVIDER</strong> /）</p>
<p>如果首部中没有时间刻度信息，则默认值为1ns。否则，可以使用以下命令明确指定时间刻度<strong>TIMESCALE</strong>：</p>
<p>● （<strong>TIMESCALE</strong> 10ps）</p>
<p>也就是说，将SDF文件中指定的所有延迟值乘以10ps。</p>
<p>SDF版本号<strong>SDFVERSION</strong>是必需的，SDF文件的使用者会根据它来确保文件符合指定的SDF版本。首部中可能存在的其它信息（属于常规信息类别）包括日期、程序名称、版本和工作条件。</p>
<p><img src="https://pic3.zhimg.com/80/v2-577b099dcdbd269c15847aca12e30a66_720w.jpg"></p>
<p>首部之后是一个或多个单元的描述，每个单元在设计中代表一个或多个实例（使用通配符），单元可以是库原语或分层块（hierarchical block）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fe6bfaad0613dedb373ad17b1277fe91_720w.jpg"></p>
<p>单元的顺序很重要，因为数据是从上到下进行处理的。后面的单元描述可以覆盖前面的单元描述所指定的时序信息（通常，两次定义同一单元实例的时序信息并不常见）。另外，可以将时序信息标注为绝对值或增量的形式。如果时序信息使用增量的形式，它将会把新值添加到现有值中。而如果时序信息是绝对值，它将覆盖任何先前指定的时序信息。</p>
<p>单元实例可以是分层实例名称。用于层次结构分隔的分隔符必须符合首部中指定的分隔符。单元实例名称可以选择为“ * ”字符，即通配符，这表示指定类型的所有单元实例。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fc80b331cfbceb028f05ba6436b635a5_720w.jpg"></p>
<p>单元中可以描述四种类型的时序规范：</p>
<p>● <strong>DELAY</strong>：用于描述延迟</p>
<p>● <strong>TIMINGCHECK</strong>：用于描述时序检查</p>
<p>● <strong>TIMINGENV</strong>：用于描述时序环境</p>
<p>● <strong>LABEL</strong>：声明可用于描述延迟的时序模型变量。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-71e1306389fda36a3736c4355c3e6a5e_720w.jpg"></p>
<p><strong>DELAY</strong>时序规范有四种类型：</p>
<p>● <strong>ABSOLUTE</strong>：在反标期间替换单元实例的现有延迟值。</p>
<p>● <strong>INCREMETN</strong>：将新的延迟数据添加到单元实例的任何现有延迟值。</p>
<p>● <strong>PATHPULSE</strong>：指定设计输入和输出之间的脉冲传播极限。此极限值用于决定是将出现在输入上的脉冲传播到输出，还是将其标记为“ X ”，或者将其滤除。</p>
<p>● <strong>PATHPULSEPERCENT</strong>：除了值以百分比表示外，这与<strong>PATHPULSE</strong>完全相同。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-dd3ec3554236c12e4fa6fc701cd4b44c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8bc0512afe629aec62d694de4a60fec5_720w.png"></p>
<p>RN和Q是单元的输入端口和输出端口。第一个值3是脉冲抑制极限（pulse rejection limit），称为r-limit，它定义了可以出现在输出上的最窄脉冲。窄于此的任何脉冲都会被拒绝通过，也就是说，它将不会出现在输出上。第二个值7（如果存在）是错误极限（error limit），也称为e-limit。任何小于e-limit的脉冲都会导致输出为“ X ”。e-limit必须大于r-limit，如图B-3所示。 当出现小于3（r-limit）的脉冲时，该脉冲不会传播到输出；当脉冲宽度在3（r-limit）和7（e-limit）之间时，输出为X ；当脉冲宽度大于7（e-limit）时，脉冲会传播到输出且没有任何滤除（unfiltered）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7a44bc7feaf5240b72fc659a73e49b0d_720w.jpg" alt="图B-3"></p>
<p>可以使用<strong>ABSOLUTE</strong>或<strong>INCREMENT</strong>描述八种延迟定义：</p>
<p>● <strong>IOPATH</strong>：输入到输出路径的延迟。</p>
<p>● <strong>RETAIN</strong>：保留时间定义，可以用于指定输出端口在其相关输入端口改变后应保留其先前值的时间。</p>
<p>● <strong>COND</strong>：条件路径延迟，可以用于指定状态相关的输入到输出路径延迟。</p>
<p>● <strong>CONDELSE</strong>：默认路径延迟，可以用于指定条件路径的默认值。</p>
<p>● <strong>PORT</strong>：端口延迟，可以用于指定互连走线延迟，该延迟被建模为输入端口的延迟。</p>
<p>● <strong>INTERCONNECT</strong>：互连走线延迟，可以用于指定从其源端到接收端的整个网络的传播延迟。</p>
<p>● <strong>NETDELAY</strong>：网络延迟，可以用于指定从一个网络的所有源端到所有接收端的传播延迟。</p>
<p>● <strong>DEVICE</strong>：器件延迟，主要用于描述分布式时序模型，可以用于指定通过单元到输出端口的所有路径的传播延迟。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-26486eadc451e8cf4b3ba11d9a90c44d_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-000889b7625a146ea8cd833cbdd586d0_720w.jpg"></p>
<p>输入A上的值发生更改后，Y将保留其先前值50ps（低电平为40ps）。50ps是保持高电平的值，40ps是保持低电平的值，101ps是传播上升沿延迟，90ps是传播下降沿延迟，如图B-4所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8f5362a1813e5826d56cf53189078208_720w.jpg" alt="图B-4"></p>
<p><img src="https://pic3.zhimg.com/80/v2-064e1ab89c1059a05fa4327a5c3601f2_720w.jpg"></p>
<h3 id="延迟">延迟</h3>
<p>到目前为止，我们已经看过了许多不同形式的延迟，其实延迟规范还有其它形式。通常，可以将延迟指定为一个、两个、三个、六个或十二个令牌（token）的集合，这些令牌可用于描述以下过渡的延迟：0-&gt; 1、1-&gt; 0、0-&gt; Z，Z-&gt; 1，1-&gt; Z，Z-&gt; 0，0-&gt; X，X-&gt; 1,1-&gt; X，X-&gt; 0，X-&gt; Z，Z-&gt; X。下表展示了如何使用少于十二个延迟令牌来表示十二种过渡情况。</p>
<p><img src="https://pic3.zhimg.com/80/v2-418bcbad04cfac55e68b987108dd126a_720w.jpg"></p>
<p>以下是这些延迟的一些示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2411c1a4d95992b3c3cb7ad538f77938_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0efbda04e3b93496dae44e52e7d662ea_720w.jpg"></p>
<p>每个延迟令牌可以依次写为一个、两个或三个值，如以下示例所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a25316d9a9dc68a981aed38dd574ed02_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d7cdbec2a0e38c883521a18500fd5ece_720w.jpg"></p>
<p>一个SDF文件中的延迟值可以使用有符号的实数或以下形式的三元数组来编写：</p>
<p>● （ 8.0：3.6：9.8 ）</p>
<p>为了表示出设计在三个工艺工作条件下的最小、典型以及最大延迟，注释器通常会根据用户提供的选项来决定去选择哪个值。三元数组形式中的值是可选的，但是至少应有一个。例如，以下形式是规范的：</p>
<p>● （ ： ： 0.22）</p>
<p>● （ 1.001 ： ： 0.998 ）</p>
<p>未指定的值就不会去标注。</p>
<h3 id="时序检查">时序检查</h3>
<p>在以<strong>TIMINGCHECK</strong>关键字开头的部分中指定了时序检查的极限。在任何这些检查中，可以使用<strong>COND</strong>结构指定有条件的时序检查。在某些情况下，可以指定两个额外的条件检查<strong>SCOND</strong>和<strong>CCOND</strong>，它们与<strong>stamp event</strong>和<strong>check event</strong>关联。</p>
<p>以下是一组检查：</p>
<p>● <strong>SETUP</strong>：建立时间检查</p>
<p>● <strong>HOLD</strong>：保持时间检查</p>
<p>● <strong>SETUPHOLD</strong>：建立时间和保持时间检查</p>
<p>● <strong>RECOVERY</strong>：恢复时间检查</p>
<p>● <strong>REMOVAL</strong>：撤销时间检查</p>
<p>● <strong>RECREM</strong>：恢复时间和撤销时间检查</p>
<p>● <strong>SKEW</strong>：单向偏斜时序检查</p>
<p>● <strong>BIDIRECTSKEW</strong>：双向偏斜时序检查</p>
<p>● <strong>WIDTH</strong>：脉宽时序检查</p>
<p>● <strong>PERIOD</strong>：周期时序检查</p>
<p>● <strong>NOCHANGE</strong>：不变化时序检查</p>
<p>以下是一些例子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-5c5d7204f65836158e1103e50124ac1a_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-027858b082c45fdd460dbdd0967c8b01_720w.jpg"></p>
<h3 id="标签">标签</h3>
<p>标签可用于指定VHDL泛型（generics）或Verilog HDL参数的值。</p>
<p><img src="https://pic3.zhimg.com/80/v2-8cdfc771fcd6b908f0a9399b1cb84d12_720w.jpg"></p>
<h3 id="时序环境">时序环境</h3>
<p>有许多结构可用于描述设计的时序环境。但是，这些结构可用于标注，而不是用于反标，例如在逻辑综合工具中。这些未在本文中描述。</p>
<h2 id="b.2.1-例子">B.2.1 例子</h2>
<p>接下去，我们将为两个设计提供完整的SDF文件。</p>
<h3 id="全加器">全加器</h3>
<p>这是用于全加器（full-adder）电路的Verilog HDL网表（netlist）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0e7bc900139da441a2767d8fad090c30_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-caf8d96c333133e47484f32cf01fe8b8_720w.jpg"></p>
<p>以下是时序分析工具生成的完整SDF文件：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d23fbfd72155d7886d89e1b2f4e5476b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-77685b34c4fbbe8ace061a710aed5df5_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e12b065955a4de070114fddadcfbce8c_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e6a30e472c3bdae01ffa43bd9910ccb7_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-01c6fc556821612d5dbfe35a9cf647cc_720w.jpg"></p>
<p><strong>INTERCONNECT</strong>中的所有延迟均为0，因为这是布局前的数据，因此建模的是理想互连走线模型。</p>
<h3 id="十进制计数器">十进制计数器</h3>
<p>这是十进制计数器的Verilog HDL模型：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0748cd5cfa0dd22a9d106a3384bbe087_720w.jpg"></p>
<p>对应的完整SDF文件如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b21c8a0a1b09a6245240c95006952694_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4901921680558a65934ef446e58216cf_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3b63a6d8348af47f5bbda97888ac5391_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-7138bb34c6a3100db8aab1f592a929a6_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-03e59a8edcf0e9bd228bb44e0a2fa6c7_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d1e8d9de8ae1f68138500f12648c8969_720w.jpg"></p>
<h2 id="b.3-标注过程">B.3 标注过程</h2>
<p>在本节中，我们将介绍如何在HDL描述中进行SDF的标注（annotation）。SDF的标注可以通过多种工具执行，例如逻辑综合工具、仿真工具和静态时序分析工具。SDF标注器（annotator）是这些工具的组件，可用于读取SDF、解释并向设计中标注时序值。假定会使用与HDL模型一致的信息创建SDF文件，并且在反标期间使用相同的HDL模型。此外，SDF标注器还需要负责正确解释SDF中的时序值。</p>
<p>SDF标注器标注了反标时序的泛型和参数。如果在语法或映射（mapping）过程中不符合该标准，它将给出错误报告。如果一个SDF标注器不支持某些SDF结构，则不会产生任何错误，标注器将忽略这些错误。</p>
<p>如果SDF标注器未能修改反标时序的泛型，则在反标过程中不会修改泛型的值，即保持不变。</p>
<p>在仿真工具中，反标通常发生在规划（elaboration）阶段之后，紧接在负约束延迟计算之前。</p>
<h2 id="b.3.1-verilog-hdl">B.3.1 Verilog HDL</h2>
<p>在Verilog HDL中，标注的主要机制是指定块（specify block），指定块可以指定路径延迟和时序检查。实际延迟值和时序检查极限值是通过SDF文件指定的，映射是一种行业标准，在IEEE Std 1364中定义。</p>
<p>从SDF文件中获得并在Verilog HDL模块的指定块中标注的信息包括指定路径的延迟、参数值、时序检查约束极限值和互连走线延迟。向一个Verilog HDL模型进行标注时，将忽略SDF文件中的其它结构。SDF中的<strong>LABEL</strong>部分定义了参数值。通过将SDF结构与相应的Verilog HDL声明进行匹配，然后将现有的时序值替换为SDF文件中的时序值，即可完成反标。</p>
<p>下表显示了SDF延迟值如何映射到Verilog HDL延迟值：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9f1f317462c2611034a9a4b53741e0de_720w.jpg"></p>
<p>下表描述了SDF结构到Verilog HDL结构的映射：</p>
<p><img src="https://pic2.zhimg.com/80/v2-313db78cf9a45f6c105d3d1440348085_720w.jpg"></p>
<p>有关示例，请参见后面部分。</p>
<h2 id="b.3.2-vhdl">B.3.2 VHDL</h2>
<p>SDF到VHDL的标注是一个行业标准，它在VITAL ASIC建模规范的IEEE标准IEEE Std 1076.4中定义，该标准的其中一部分描述了SDF延迟到ASIC库的标注。在这里，我们仅介绍与SDF映射有关的VITAL标准的相关部分。</p>
<p>SDF可用于直接在符合VITAL的模型中修改反标时序泛型，只能使用SDF为符合VITAL的模型指定时序数据。有两种方法可以将时序数据传递到VHDL模型中：通过配置，或直接传递到仿真中去。SDF标注过程包括在仿真期间在符合VITAL的模型中映射SDF结构和相应的泛型。</p>
<p>在符合VITAL的模型中，存在着有关如何命名和声明泛型的规则，以确保可以在模型的时序泛型和相应的SDF时序信息之间建立映射。</p>
<p>时序泛型由泛型名称及其类型组成，名称指定时序信息的种类，类型指定时序值的种类。如果泛型名称不符合VITAL标准，则它不是时序泛型，也不会被标注。</p>
<p>下表显示了SDF延迟值如何映射到VHDL延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-866c35b13ece5c6ea2823a6dc2b7369a_720w.jpg"></p>
<p>在VHDL中，时序信息是通过泛型进行反标的。泛型名称遵循一定的规则，以便保持一致或从SDF结构中获取。利用每个时序泛型名称，可以指定条件边沿的可选后缀。边沿可以指定一个与时序信息相关联的边沿。</p>
<p>下表列出了各种时序泛型名称：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a44e7be49c593fa926151c78211ea37e_720w.jpg"></p>
<h2 id="b.4-映射示例">B.4 映射示例</h2>
<p>以下是将SDF结构映射到VHDL泛型（generic）和Verilog HDL声明（declaration）的示例。</p>
<h3 id="传播延迟">传播延迟</h3>
<p>● 从输入端口A到输出端口Y的传播延迟：上升时间为0.406，下降时间为0.339：</p>
<p><img src="https://pic3.zhimg.com/80/v2-ce8817f40cbe6944cae4e876a1141952_720w.jpg"></p>
<p>● 从输入端口OE到输出端口Y的传播延迟：上升时间为0.441，下降时间为0.409。最小、标准和最大延迟是相同的：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5ba1ce30b7681eeb36521d1b4fdb0149_720w.jpg"></p>
<p>● 从输入端口S0到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4520723ba1cbe4d6efeded2cc18fcc8b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-941b803367be3f8b623e9441c672e74e_720w.jpg"></p>
<p>● 从输入端口A到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic1.zhimg.com/80/v2-5910a4199d9cf0ccbde48394fb8c4fe4_720w.jpg"></p>
<p>● 从输入端口CK到输出端口Q的传播延迟：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0088f98f6ea741e7591f39e6fae58c8_720w.jpg"></p>
<p>● 从输入端口A到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0906839b82ae3746a30f2fbab837ae52_720w.jpg"></p>
<p>● 从输入端口CK到输出端口ECK的传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-958bf0a11aad37027a21df522b30032f_720w.jpg"></p>
<p>● 从输入端口CI到输出端口S的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-57e351f67f6ccce1466b610c8a1adf3e_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-16d981773c8041d428f2be9a89d1c7ff_720w.jpg"></p>
<p>● 从输入端口CS到输出端口S的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e31479125e64ea6a9f64df5d464553d6_720w.jpg"></p>
<p>● 从输入端口A到输出端口ICO的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-54d7a6401167320d44fac2bee4b25213_720w.jpg"></p>
<p>● 从输入端口A到输出端口CO的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-32182414760afe7846ba1e1ce8812077_720w.jpg"></p>
<p>● 从CK的上升沿到Q的延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-99e2051f91bb85807bf213162372cae9_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0e460d79ac68db88328a50ec20a72ba7_720w.jpg"></p>
<h3 id="输入建立时间">输入建立时间</h3>
<p>● D的上升沿与CK的上升沿之间的建立时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-74df5beb66d1ae66e712eb57ce3c325b_720w.jpg"></p>
<p>● D的下降沿与CK的上升沿之间的建立时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-cfc7c24f1b23b829bc2380713acddef2_720w.jpg"></p>
<p>● 输入端口E的上升沿与参考CK的上升沿之间的建立时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-be5f8683b8362378df8607312a4ce0f0_720w.jpg"></p>
<p>● 输入端口E的下降沿和参考CK的上升沿之间的建立时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-35d38d491de9b443e26b8a28d8c36356_720w.jpg"></p>
<p>● SE和CK之间的条件建立时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-69ee9e630b83697eb0fd27cd4ed80e6b_720w.jpg"></p>
<h3 id="输入保持时间">输入保持时间</h3>
<p>● D的上升沿与CK的上升沿之间的保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-747b90fc0b8da319d271419f537bc6c5_720w.jpg"></p>
<p>● RN与SN之间的保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e4046cfa14bff3712bcd1fc7d3080e0d_720w.jpg"></p>
<p>● 输入端口SI与参考端口CK之间的保持时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4e7ac1d79cc26faa847d30c9fe8cd02a_720w.jpg"></p>
<p>● E和CK上升沿之间的条件保持时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-a3437becbae9757ee567c0263df8c750_720w.jpg"></p>
<h3 id="输入建立和保持时间">输入建立和保持时间</h3>
<p>● 在D和CLK之间的建立时间与保持时间检查。这是一个有条件的检查，第一个延迟值是建立时间，第二个延迟值是保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-dd937a75ad7ee6c5db2dd4db88cc676d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-40c51c521d6435c7b62a5a430ca34902_720w.jpg"></p>
<h3 id="输入恢复时间">输入恢复时间</h3>
<p>● CLKA和CLKB之间的恢复时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-16f2fefab421960b02616ee979f19ec0_720w.jpg"></p>
<p>● CLKA上升沿与CLKB上升沿之间的条件恢复时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c83e876cd023698a3a33fa12f0d1773a_720w.jpg"></p>
<p>● SE与CK之间的恢复时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-efeb18f572104d6bfdef3af51d68903b_720w.jpg"></p>
<p>● RN与CK之间的恢复时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5ca9075bc61d1632d53c41a5a8196221_720w.jpg"></p>
<h3 id="输入撤销时间">输入撤销时间</h3>
<p>● E的上升沿与CK的下降沿之间的撤销时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b3caa9abbff61864a418a14693fd9ac5_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-699caacc53dd183477ea55a704c1b9ae_720w.png"></p>
<p>● CK的上升沿和SN之间的条件撤销时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3126ac8ac932e519a5e4df7905f0ba5b_720w.jpg"></p>
<h3 id="周期">周期</h3>
<p>● 输入CLKB的周期：</p>
<p><img src="https://pic1.zhimg.com/80/v2-020a171b7bb267280a44a3b0fa6c2fcc_720w.jpg"></p>
<p>● 输入端口EN的周期：</p>
<p><img src="https://pic3.zhimg.com/80/v2-25504e21962dff3d9b6769b8847b75de_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-05a0d9f7bf016ed54f14e5b0b30341b4_720w.jpg"></p>
<p>● 输入端口TCK的周期：</p>
<p><img src="https://pic1.zhimg.com/80/v2-24f6b097b58e8bc2565b7216f4f15e50_720w.jpg"></p>
<h3 id="脉宽">脉宽</h3>
<p>● CK上高脉冲的脉冲宽度：</p>
<p><img src="https://pic1.zhimg.com/80/v2-870910d6bcedcc59f797c11e7b6ece90_720w.jpg"></p>
<p>● CK上低脉冲的脉冲宽度：</p>
<p><img src="https://pic1.zhimg.com/80/v2-929c85b83c12d25707c2ae3c04d96528_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9e4066425d9adc9cdd95bec6a11b9c74_720w.jpg"></p>
<p>● RN上高脉冲的脉冲宽度：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d9cfe0e3981d15668e6b11cf0e5a4d37_720w.jpg"></p>
<h3 id="输入偏斜时间">输入偏斜时间</h3>
<p>● CK与TCK之间的偏斜：</p>
<p><img src="https://pic3.zhimg.com/80/v2-8a49393d63450f5c7aa992c55e2ea7aa_720w.jpg"></p>
<p>● SE和CK下降沿之间的偏斜：</p>
<p><img src="https://pic2.zhimg.com/80/v2-53cda8ce114c00c5586cfda867410581_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-16f953ab76a39bb1e7585312ebc8b9ca_720w.jpg"></p>
<h3 id="无变化的建立时间">无变化的建立时间</h3>
<p>SDF文件中的NOCHANGE结构将同时映射到VHDL中的tncsetup和tnchold泛型。</p>
<p>● D和CK下降沿之间无变化的建立时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35501310e16ec371aba334d7d748ec31_720w.jpg"></p>
<h3 id="无变化的保持时间">无变化的保持时间</h3>
<p>SDF文件中的NOCHANGE结构将同时映射到VHDL中的tncsetup和tnchold泛型。</p>
<p>● E和CLKA之间无变化的条件保持时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-17346e072ebd78d7d4c7ff1519bae456_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9251364fb786f794df968c1821e6dbf8_720w.jpg"></p>
<h3 id="端口延迟">端口延迟</h3>
<p>● 端口OE的延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-ca3ed5652ebb3b601eb1f6bcb62350b5_720w.jpg"></p>
<p>● 端口RN的延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d1def2fb828ac302521caf6a83c86fc3_720w.jpg"></p>
<h3 id="网络延迟">网络延迟</h3>
<p>● 连接到端口CKA的网络延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-bb573f4548409fcd60d58457b5fee1e6_720w.jpg"></p>
<h3 id="互连路径延迟">互连路径延迟</h3>
<p>● 从端口Y到端口D的互连路径延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-92c911cbd368a44d8fdc8b5d70840a25_720w.jpg"></p>
<h3 id="器件延迟">器件延迟</h3>
<p>● 实例uP的输出SM的器件延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-594d97d08b6dd15cd5a7fac8ae779262_720w.jpg"></p>
<h2 id="b.5-完整语法">B.5 完整语法</h2>
<p>以下是使用BNF格式显示的SDF的完整语法。终端（terminal）名称是大写的，关键字是粗体的，但是不区分大小写。起始的终端是delay_file：</p>
<p><img src="https://pic4.zhimg.com/80/v2-778ef72b2a25569041fc038d59b6b6c3_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-25318d1ed0e04a456481502b0b78d402_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-c4a97a21948d8413effe48b3f4b98fb2_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3712a766a742f058308daeb4733f8d73_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-72f6af6a036ef6a4345a84ec5d8717db_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-de80ee340df3748c82680bcb38abc0ee_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-8fc1c5592b3caeb7953e1a2f72f909ba_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c7df5901bd83557b3e0226bae3b859d3_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ce2cf75964e4d40841dc4aa72646215d_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-958c19cddf02f96d902b58b7a92fcd29_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-39f72aafdf5ecdb580cbb2482e05dfc0_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f12d07ad8763294f144ca9291f67c13b_720w.jpg"></p>
<h1 id="附录cspef">附录C:SPEF</h1>
<blockquote>
<p>本附录将介绍标准寄生参数提取格式（SPEF），它是IEEE Std 1481标准的一部分。</p>
</blockquote>
<h2 id="c.1-基础">C.1 基础</h2>
<p>SPEF允许以ASCII交换格式描述设计的寄生信息（R，L和C）。用户可以读取和检查SPEF文件中的值，尽管用户永远不会手动创建此文件。它主要用于将寄生信息从一个工具传递到另一个工具。图C-1显示了SPEF可以由诸如布局布线工具或寄生参数提取工具之类的工具生成，然后交由时序分析工具用于电路仿真或执行串扰分析。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d66bfe17d0657c476a9db91bc10399d7_720w.jpg" alt="图C-1"></p>
<p>寄生参数可以在许多不同的层次上表示。SPEF支持分布式（distributed）网络模型、（reduced）简化网络模型和（lumped）集总电容模型。在分布式网络模型（D_NET）中，网络走线的每段都有其自己的R和C。在简化网络模型（R_NET）中，在网络的负载引脚上考虑一个简化的R和C，而在网络的驱动引脚上考虑一个π模型（C-R-C）。在集总电容模型中，仅为整个网络指定一个电容。图C-2显示了物理网络走线的一个示例，图C-3显示了分布式网络模型，图C-4显示了简化的网络模型，图C-5显示了集总电容模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0826235775bf5a106ea18e42a61d1b82_720w.jpg" alt="图C-2"></p>
<p><img src="https://pic2.zhimg.com/80/v2-072247589e9f878fade00feb0c1ffb61_720w.jpg" alt="图C-3"></p>
<p><img src="https://pic4.zhimg.com/80/v2-60166c6d849bcaa4f16f21e8ff44fd73_720w.jpg" alt="图C-4"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ee7be67b2c83c0739da7df72acf5fa2a_720w.jpg" alt="图C-5"></p>
<p>互连寄生效应取决于工艺，SPEF支持最佳（best-case）、典型（typical）和最差（worst-case）三种情况。允许R、L和C值、端口压摆和负载使用此三种不同情况下的值。</p>
<p>通过提供一个包含网络名称和实例名称映射到索引的一个名称映射（name map），可以有效地减小SPEF文件的大小，更重要的是，所有较长名称仅出现在一个位置。</p>
<p>设计的SPEF文件可以拆分为多个文件，也可以分层。</p>
<h2 id="c.2-格式">C.2 格式</h2>
<p>SPEF文件的格式如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e1eb8bc8e1d1dc3c659322158db3aa0b_720w.jpg"></p>
<p><strong>header_definition</strong>包含了基本信息，例如SPEF版本号、设计名称以及R，L和C的单位。<strong>name_map</strong>指定了网络名称和实例名称到索引的映射。<strong>power_definition</strong>声明了电源网络和地网络。<strong>external_definition</strong>定义了设计的端口。<strong>define_definition</strong>中指出了SPEF还在其它文件中进行了描述的那些实例。<strong>internal_definition</strong>包含的是文件的核心——设计的寄生参数。</p>
<p>图C-6显示了<strong>header_definition</strong>的示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-484aac79a1305cbe5e8b710781ecd170_720w.jpg" alt="图C-6"></p>
<p><strong>SPEF</strong> name 指定了SPEF的版本号；</p>
<p><strong>DESIGN</strong> name 指定了设计的名称；</p>
<p><strong>DATE</strong> string 指定了创建文件时的时间戳；</p>
<p><strong>VENDOR</strong> string 指定了用于创建SPEF的供应商工具；</p>
<p><strong>PROGRAM</strong> string 指定了用于生成SPEF的程序；</p>
<p><strong>VERSION</strong> string 指定了用于创建SPEF的程序的版本号；</p>
<p><strong>DESIGN_FLOW</strong> string string string . . . 指定了在什么阶段创建SPEF文件。它描述了有关SPEF文件的信息，这些信息无法通过读取文件来获得。</p>
<p>预定义的字符串值为：</p>
<p>● <strong>EXTERNAL_LOADS：</strong>外部载荷在SPEF文件中完全指定。</p>
<p>● <strong>EXTERNAL_SLEWS：</strong>外部压摆在SPEF文件中完全指定。</p>
<p>● <strong>FULL_CONNECTIVITY：</strong>SPEF中存在逻辑网表连接。</p>
<p>● <strong>MISSING_NETS：</strong>SPEF文件中可能缺少某些逻辑网络。</p>
<p>● <strong>NETLIST_TYPE_VERILOG：</strong>使用Verilog HDL类型命名约定。</p>
<p>● <strong>NETLIST_TYPE_VHDL87：</strong>使用VHDL87命名约定。</p>
<p>● <strong>NETLIST_TYPE_VHDL93：</strong>使用VHDL93网表命名约定。</p>
<p>● <strong>NETLIST_TYPE_EDIF：</strong>使用EDIF类型命名约定。</p>
<p>● <strong>ROUTING_CONFIDENCE：</strong>（正整数）所有网络的默认走线置信度，基本上是寄生精度的水平。</p>
<p>● <strong>ROUTING_CONFIDENCE_ENTRY：</strong>补充走线置信度值。</p>
<p>● <strong>NAME_SCOPE_LOCAL | FLAT：</strong>指定了SPEF文件中的路径是相对于文件还是相对于设计顶层。</p>
<p>● <strong>SLEW_THRESHOLDS：</strong>（low_input_threshold_percent，high_input_threshold_percent）指定了设计的默认输入转换阈值。</p>
<p>● <strong>PIN_CAP NONE | INPUT_OUTPUT | INPUT_ONLY：</strong>指定了作为总电容一部分的引脚电容类型，默认值为INPUT_OUTPUT。</p>
<p><strong>DIVIDER /</strong> 指定了层次结构分隔符。可以使用的其它字符是" . " , " : "和" / "。</p>
<p><strong>DELIMITER ：</strong>指定了实例与其引脚之间的分隔符。可以使用的其它可能字符是" . " , " / " , " : " 或者 "|"。</p>
<p><strong>BUS_DELIMITER [ ]</strong> 指定了用于标识总线位的前缀和后缀。可以用于前缀和后缀的其他可能字符是" { " , " ( " , " &lt; " , " : "，" ."和" } " , " ) ", " &gt; "。</p>
<p><strong>T_UNIT</strong> 正整数 <strong>NS | PS</strong> 指定了时间单位。</p>
<p><strong>C_UNIT</strong> 正整数 <strong>PF | FF</strong> 指定了电容单位。</p>
<p><strong>R_UNIT</strong> 正整数 <strong>OHM| KOHM</strong> 指定了电阻单位。</p>
<p><strong>L_UNIT</strong> 正整数 <strong>HENRY | MH | UH</strong> 指定了电感单位。</p>
<p>SPEF文件中的注释可以两种形式出现：</p>
<p><img src="https://pic2.zhimg.com/80/v2-cd8ab4c3d088f43622badae784fe8745_720w.jpg"></p>
<p>图C-7显示了一个名称映射的示例。 它的形式为：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d58b398fa18b250b4bf1720d0d9831d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-830b7f416c518cc6939b4c2a2a344e0a_720w.jpg" alt="图C-7"></p>
<p>名称映射将指定名称到唯一整数值（它们的索引）的映射。名称映射有助于通过索引来对名称进行引用从而减小文件的大小，名称可以是网络名称或实例名称。考虑图C-7中的名称映射，以后可以使用它们的索引在SPEF文件中引用这些名称，例如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-aa1fd2b77bc88b929311c8607fde5a47_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d7541e59caead48893974062b457c9b8_720w.png"></p>
<p>因此，名称映射会通过使用其唯一的整数表示来避免重复长名称及其路径。</p>
<p><strong>power definition</strong>部分定义了电源和接地网络：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9e013a5dc7f8b677915b38c98830968d_720w.png"></p>
<p>以下是一些例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0bf96246e2c1639894272b3cacf6374_720w.png"></p>
<p><strong>external_definition</strong>包含了设计的逻辑和物理端口的定义。图C-8显示了逻辑端口的示例，逻辑端口可以以下形式描述：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4d9ee95769630326723c2f28d2e07d0c_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c5b9b4c86664f72d1053abbf0ecd5c55_720w.jpg" alt="图C-8"></p>
<p>其中<strong>port_name</strong>可以是形式为*正整数的端口索引。方向为I表示输入，O表示输出，B表示双向。连接属性（conn_attribute）是可选的，可以是以下属性：</p>
<p>● *<strong>C</strong> number number：端口的坐标。</p>
<p>● *<strong>L</strong> par_value：端口的电容负载。</p>
<p>● *<strong>S</strong> par_value par_value：定义端口上的波形。</p>
<p>● *<strong>D</strong> cell_type：定义端口的驱动单元。</p>
<p>可以使用以下命令定义SPEF文件中的物理端口：</p>
<p><img src="https://pic3.zhimg.com/80/v2-46131891dca3b3ae809ea9cc5c461a1a_720w.jpg"></p>
<p><strong>define definition</strong>部分定义了当前SPEF文件中引用的实例，但其寄生参数在其它SPEF文件中进行了描述：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4a4ace48312c1977d659dd31a8be32fe_720w.png"></p>
<p>当实例是物理分区（而不是逻辑层次结构）时，将使用*<strong>PDEFINE</strong>。以下有些例子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fc8d4ae3a1ab2e5d586321cd2cfd774d_720w.png"></p>
<p>这意味着将存在另一个带有*<strong>DESIGN</strong>值ddrphy的SPEF文件，该文件将包含设计ddrphy的寄生参数，其可能具有物理和逻辑层次结构。跨越层次边界的任何网络都必须描述为分布式网络（D_NET）。</p>
<p><strong>internal definition</strong>部分包含了SPEF文件的核心，即设计中网络的寄生参数。基本上有两种形式：分布式网络D_NET和简化网络R_NET。图C-9中为一个分布式网络定义的示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-283e7c120b5c5437c4781a02a3835ead_720w.jpg" alt="图C-9"></p>
<p>第一行中的*5426是网络的索引号（网络名称请参见名称映射），0.899466是网络上的总电容值。电容值是网络上所有电容的总和，其中包括假定为接地的交叉耦合电容，还包括负载电容。它可能包含也可能不包含引脚电容，具体取决于<strong>DESIGN_FLOW</strong>定义中的<strong>PIN_CAP</strong>设置。</p>
<p><strong>connectivity section</strong>描述了网络的驱动和负载引脚：</p>
<p><img src="https://pic2.zhimg.com/80/v2-682dad147f6f48ad51d7e59d10b1f675_720w.png"></p>
<p><em>I表示内部引脚（ </em> P表示端口），<em>14212：D表示实例</em>14212的D引脚，14212是一个索引号（有关实际名称需参见名称映射）。“ I”表示网络上的负载（输入引脚），“ O”表示网络上的驱动（输出引脚）。<em>C和 </em>D如先前在<strong>connection attributes</strong>中所定义的那样，<em>C定义了引脚的坐标，</em>D定义了引脚的驱动单元。</p>
<p><strong>capacitance section</strong>描述了分布式网络的电容，电容单位在之前已用* C_UNIT指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d2b4601149c0f392d43cba3646d01c3d_720w.jpg"></p>
<p>第一个数字是电容标识符。电容规范有两种形式： 第一种到第四种一种形式，第五种是另一种形式。第一种形式（第一至第四种）指定两个网络之间的交叉耦合电容，而第二种形式（id为5）指定接地电容。因此，在电容id1中，网络<em>5426和</em>5290之间的交叉耦合电容为0.217446；在电容id5中，接地电容为0.529736。请注意，第一个节点名称必须是所描述的D_NET的网络名称。网络索引后面的正整数（<em>5426：10278中的10278）指定内部节点或连接点。因此，电容id4表示在内部节点10278的网络</em>5426和内部节点9922的网络*5116之间存在耦合电容，该耦合电容的值为0.113918。</p>
<p><strong>resistance section</strong>描述了分布式网络的电阻，电阻单位在之前已用* R_UNIT指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-43c952ff95fe9602d9db81ec6a033e5d_720w.png"></p>
<p>第一个字段是电阻标识符。因此，该网络具有三个电阻部分。第一个在内部节点<em>5426：10278与</em>14212上的D引脚之间，电阻值为0.34。使用图C-10中所示的RC网络可以更好地理解电容和电阻部分。</p>
<p><img src="https://pic2.zhimg.com/80/v2-54692812f54dc062e6e3d425c15c9061_720w.jpg" alt="图C-10"></p>
<p>图C-11显示了分布式网络的另一个示例。该网络具有一个驱动和两个负载，网络上的总电容为2.69358。图C-12显示了与分布式网络相对应的RC网络。</p>
<p><img src="https://pic4.zhimg.com/80/v2-938002ad4792085b1bb900c3a4fab8ff_720w.jpg" alt="图C-11"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5e55c1dad59c315a8f334a8073ac1e67_720w.jpg" alt="图C-12"></p>
<p>通常，内部定义（internal definition）可以包含以下规范：</p>
<p>● <strong>D_NET</strong>：逻辑网络的分布式RC网络形式。</p>
<p>● <strong>R_NET</strong>：逻辑网络的简化RC网络形式。</p>
<p>● <strong>D_PNET</strong>：物理网络的分布式形式。</p>
<p>● <strong>R_PNET</strong>：物理网络的简化形式。</p>
<p>语法如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4fe6519e2a6a66d0ae1226635a95a8c8_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5cb28904839a93a2349824681e125ce4_720w.jpg"></p>
<p><strong>inductance section</strong>用于指定电感，其格式类似于电阻部分。 * V用于指定网络寄生参数的准确性。这些可以单独使用网络指定，也可以使用带有<strong>ROUTING_CONFIDENCE</strong>值的*** DESIGN_FLOW**语句进行全局指定，例如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-811c988ccd8701a6c6f2b9354a72beff_720w.png"></p>
<p>它指定了寄生参数是在最终单元布局和最终布线之后提取得到的，并且使用了3d提取。走线置信度的其它可能值为：</p>
<p>● 10：统计线负载模型</p>
<p>● 20：物理线负载模型</p>
<p>● 30：具有位置但没有单元布局的物理分区</p>
<p>● 40：使用基于斯坦纳树（steiner tree）的走线估计的单元位置</p>
<p>● 50：使用全局走线估计的单元位置</p>
<p>● 60：使用斯坦纳走线进行的最终单元布局</p>
<p>● 70：使用全局走线进行的最终单元布局</p>
<p>● 80：最终单元布局，最终走线，2d提取</p>
<p>● 90：最终单元布局，最终走线，2.5d提取</p>
<p>● 100：最终单元布局，最终走线，3d提取</p>
<p><strong>reduced net</strong>是从分布式网络形式简化而来的网络。网络上每个驱动都有一个驱动精简部分（driver reduction section）。驱动精简部分的形式为：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aeb44e379a12069929a4d96c43c79b10_720w.jpg"></p>
<p><em>C2_R1_C1表示在网络的驱动引脚上使用π模型的寄生参数。 </em> RC结构中的rc_value是指Elmore延迟（R * C）。 图C-13显示了简化后的网络的SPEF示例，图C-14以图形方式显示了RC网络。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2890bf55cf5daca5bf05c97e259f22b4_720w.jpg" alt="图C-13"></p>
<p><img src="https://pic1.zhimg.com/80/v2-3947f51106a7373e73b6fc25466226ec_720w.jpg" alt="图C-14"></p>
<p>可使用<em><strong>D_NET</strong>或</em><strong>R_NET</strong>结构描述集总电容模型（lumped capacitance model），该结构仅具有总电容而没有其它信息。以下是集总电容声明的示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ee64afd594898f8c63a77fbab14f1923_720w.jpg"></p>
<p>SPEF文件中的值可以采用三元数组的形式来表示工艺变化，例如：</p>
<p>● 0.243 ： 0.269 ： 0.300</p>
<p>最佳情况下值为0.243，典型情况下值为0.269，最差情况下值为0.300。</p>
<h2 id="c.3-完整语法">C.3 完整语法</h2>
<p>本节描述了SPEF文件的完整语法。</p>
<p>可以在字符前面加上反斜杠（）来对其进行转义。注释有两种形式：//开始注释直到行尾，而/ * . . . * /是多行注释。</p>
<p>在以下语法中，粗体字符如（，[是语法的一部分。所有结构均按字母顺序排列，起始符号为SPEF_file：</p>
<p><img src="https://pic3.zhimg.com/80/v2-07d727acd214247bedf57d671232a11e_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c8fb4e366e5154843f123975f1b02ffd_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0456819806173f4d5cfe1f07e3c1b856_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-95fcf79c19ee60fdf418eb1489b36fe3_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8e456c68bf7b3d4d80c8ec56a4a1d5e1_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-75d9df40768e4a338ec16bb3fb7e3770_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-4f8ba11df9dce8065baac3a18032fa70_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-947377e805d31cfbc32aadbab331ffbe_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a6c00e091dc1ae58f09bb13dd7128649_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-389fd37ea782a79b658f16808aa55c05_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e0da9791e613e059a2c949f966382c2f_720w.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.narutozxp.top">桐桐花</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.narutozxp.top/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v2/">https://www.narutozxp.top/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.narutozxp.top" target="_blank">narutozxp</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STA/">STA</a></div><div class="post_share"><div class="social-share" data-image="/img/19.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v1/"><img class="prev-cover" src="/img/6.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Static Timing Analysis for Nanometer Designs:A Practical Approach(v1)</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/05/ML-Theory-Summary/"><img class="next-cover" src="/img/15.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ML Theory Summary</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v1/" title="Static Timing Analysis for Nanometer Designs:A Practical Approach(v1)"><img class="cover" src="/img/6.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-13</div><div class="title">Static Timing Analysis for Nanometer Designs:A Practical Approach(v1)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B3%E7%B1%B3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">纳米设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">什么是静态时序分析？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">为什么使用静态时序分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%89%B0%E5%92%8C%E5%99%AA%E5%A3%B0crosstalk-and-noise"><span class="toc-number">1.3.1.</span> <span class="toc-text">串扰和噪声（Crosstalk and Noise）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">设计流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cmos%E6%95%B0%E5%AD%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text">CMOS数字设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fpga%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">FPGA设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.3.</span> <span class="toc-text">异步设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E7%9A%84sta"><span class="toc-number">1.5.</span> <span class="toc-text">不同设计阶段的STA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">静态时序分析的局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E7%8E%87%E8%80%83%E8%99%91"><span class="toc-number">1.7.</span> <span class="toc-text">功率考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-number">1.8.</span> <span class="toc-text">可靠性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E7%9A%84%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.9.</span> <span class="toc-text">书的大纲</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#sta%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">STA概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cmos-%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">CMOS 逻辑设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mos%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">MOS基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmos-%E9%80%BB%E8%BE%91%E9%97%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">CMOS 逻辑门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8D%95%E5%85%83"><span class="toc-number">2.1.3.</span> <span class="toc-text">标准单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmos-%E5%8D%95%E5%85%83%E7%9A%84%E5%BB%BA%E6%A8%A1"><span class="toc-number">2.2.</span> <span class="toc-text">CMOS 单元的建模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%85%B3%E6%B3%A2%E5%BD%A2"><span class="toc-number">2.3.</span> <span class="toc-text">开关波形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E5%BB%B6%E8%BF%9Fpropagation-delay"><span class="toc-number">2.4.</span> <span class="toc-text">传播延迟（Propagation Delay）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A2%E5%BD%A2%E8%BD%AC%E6%8D%A2slew-of-a-waveform"><span class="toc-number">2.5.</span> <span class="toc-text">波形转换（Slew of a Waveform）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B9%8B%E9%97%B4%E7%9A%84%E5%81%8F%E5%B7%AEskew-between-signals"><span class="toc-number">2.6.</span> <span class="toc-text">信号之间的偏差（Skew between Signals）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%BC%A7timing-arcs-and-unateness"><span class="toc-number">2.7.</span> <span class="toc-text">时序弧（Timing Arcs and Unateness）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E6%97%B6%E5%BA%8F%E8%B7%AF%E5%BE%84min-and-max-timing-paths"><span class="toc-number">2.8.</span> <span class="toc-text">最小和最大时序路径（Min and Max Timing Paths）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%9F%9Fclock-domains"><span class="toc-number">2.9.</span> <span class="toc-text">时钟域（Clock Domains）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%9D%A1%E4%BB%B6operating-conditions"><span class="toc-number">2.10.</span> <span class="toc-text">操作条件（Operating Conditions）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8D%95%E5%85%83%E5%BA%93standard-cell-library"><span class="toc-number">3.</span> <span class="toc-text">标准单元库（Standard Cell Library）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%84%9A%E7%94%B5%E5%AE%B9pin-capacitance"><span class="toc-number">3.1.</span> <span class="toc-text">引脚电容（Pin Capacitance）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%BB%BA%E6%A8%A1timing-modeling"><span class="toc-number">3.2.</span> <span class="toc-text">时序建模（Timing Modeling）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E5%BA%8F%E6%A8%A1%E5%9E%8Blinear-timing-model"><span class="toc-number">3.2.1.</span> <span class="toc-text">线性时序模型（Linear Timing Model）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%BB%B6%E8%BF%9F%E6%A8%A1%E5%9E%8Bnon-linear-delay-model"><span class="toc-number">3.2.2.</span> <span class="toc-text">非线性延迟模型（Non-Linear Delay Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%BB%B6%E8%BF%9F%E6%A8%A1%E5%9E%8B%E6%9F%A5%E6%89%BE%E7%A4%BA%E4%BE%8Bexample-of-non-linear-delay-model-lookup"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">非线性延迟模型查找示例（Example of Non-Linear Delay Model Lookup）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E8%A7%84%E6%A0%BC%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4%E9%99%8D%E9%A2%9Dthreshold-specifications-and-slew-derating"><span class="toc-number">3.2.3.</span> <span class="toc-text">阈值规格和转换时间降额（Threshold Specifications and Slew Derating）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E6%A8%A1%E5%9E%8B%E7%BB%84%E5%90%88%E5%8D%95%E5%85%83timing-models---combinational-cells"><span class="toc-number">3.3.</span> <span class="toc-text">时序模型——组合单元（Timing Models - Combinational Cells）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9E%8Bdelay-and-slew-models"><span class="toc-number">3.3.1.</span> <span class="toc-text">延迟和转换模型（Delay and Slew Models）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%9D%97general-combinational-block"><span class="toc-number">3.3.2.</span> <span class="toc-text">通用组合块（General Combinational Block）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E6%A8%A1%E5%9E%8B%E9%A1%BA%E5%BA%8F%E5%8D%95%E5%85%83timing-models---sequential-cells"><span class="toc-number">3.4.</span> <span class="toc-text">时序模型——顺序单元（Timing Models - Sequential Cells）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A3%80%E6%9F%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BF%9D%E6%8C%81synchronous-checks-setup-and-hold"><span class="toc-number">3.4.1.</span> <span class="toc-text">同步检查：建立和保持（Synchronous Checks: Setup and Hold）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A3%80%E6%9F%A5asynchronous-checks"><span class="toc-number">3.4.2.</span> <span class="toc-text">异步检查（Asynchronous Checks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E5%BB%B6%E8%BF%9Fpropagation-delay-1"><span class="toc-number">3.4.3.</span> <span class="toc-text">传播延迟（Propagation Delay）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9E%8Bstate-dependent-models"><span class="toc-number">3.5.</span> <span class="toc-text">状态相关模型（State-Dependent Models）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E5%8C%A3%E5%AD%90%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6%E5%BA%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">黑匣子的接口时序模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%97%B6%E5%BA%8F%E5%BB%BA%E6%A8%A1advanced-timing-modeling"><span class="toc-number">3.7.</span> <span class="toc-text">高级时序建模（Advanced Timing Modeling）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%99%A8%E5%BC%95%E8%84%9A%E7%94%B5%E5%AE%B9receiver-pin-capacitance"><span class="toc-number">3.7.1.</span> <span class="toc-text">接收器引脚电容（Receiver Pin Capacitance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%94%B5%E6%B5%81"><span class="toc-number">3.7.2.</span> <span class="toc-text">输出电流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E4%B8%B2%E6%89%B0%E5%99%AA%E5%A3%B0%E5%88%86%E6%9E%90models-for-crosstalk-noise-analysis"><span class="toc-number">3.7.3.</span> <span class="toc-text">模型串扰噪声分析（Models for Crosstalk Noise Analysis）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.4.</span> <span class="toc-text">其他噪声模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%80%97%E5%BB%BA%E6%A8%A1power-dissipation-modeling"><span class="toc-number">3.8.</span> <span class="toc-text">功耗建模（Power Dissipation Modeling）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%8A%9F%E5%8A%9F%E7%8E%87active-power"><span class="toc-number">3.8.1.</span> <span class="toc-text">有功功率（Active Power）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E5%8A%9F%E7%8E%87leakage-power"><span class="toc-number">3.8.2.</span> <span class="toc-text">泄露功率（Leakage Power）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E5%BA%93%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7other-attributes-in-cell-library"><span class="toc-number">3.9.</span> <span class="toc-text">单元库其他属性（Other Attributes in Cell Library）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%BE%81%E5%92%8C%E6%93%8D%E4%BD%9C%E6%9D%A1%E4%BB%B6characterization-and-operating-conditions"><span class="toc-number">3.10.</span> <span class="toc-text">表征和操作条件（Characterization and Operating Conditions）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8k%E5%9B%A0%E5%AD%90%E9%99%8D%E9%A2%9D"><span class="toc-number">3.10.1.</span> <span class="toc-text">使用K因子降额</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%8D%95%E5%85%83library-units"><span class="toc-number">3.10.2.</span> <span class="toc-text">库单元（Library Units）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%92%E8%BF%9E%E5%AF%84%E7%94%9Finterconnect-parasitics"><span class="toc-number">4.</span> <span class="toc-text">互连寄生（Interconnect Parasitics）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%BF%9Erlcrlc-for-interconnect"><span class="toc-number">4.1.</span> <span class="toc-text">互连RLC（RLC for Interconnect ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#t--model"><span class="toc-number">4.1.1.</span> <span class="toc-text">T -model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pi--model"><span class="toc-number">4.1.2.</span> <span class="toc-text">Pi -model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E8%BD%BD%E6%A8%A1%E5%9E%8Bwireload-models"><span class="toc-number">4.2.</span> <span class="toc-text">线载模型（Wireload Models）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E8%BF%9E%E6%A0%91interconnect-trees"><span class="toc-number">4.2.1.</span> <span class="toc-text">互连树（Interconnect Trees）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%BA%BF%E8%BD%BD%E6%A8%A1%E5%9E%8Bspecifying-wireload-models"><span class="toc-number">4.2.2.</span> <span class="toc-text">指定线载模型（Specifying Wireload Models）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%AF%84%E7%94%9F%E5%8F%82%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BArepresentation-of-extracted-parasitics"><span class="toc-number">4.3.</span> <span class="toc-text">提取寄生参数的表示（Representation of Extracted Parasitics）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%A0%87%E5%87%86%E5%AF%84%E7%94%9F%E6%A0%BC%E5%BC%8Fdetailed-standard-parasitic-format"><span class="toc-number">4.3.1.</span> <span class="toc-text">详细标准寄生格式（Detailed Standard Parasitic Format）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%AE%80%E6%A0%87%E5%87%86%E5%AF%84%E7%94%9F%E6%A0%BC%E5%BC%8Freduced-standard-parasitic-format"><span class="toc-number">4.3.2.</span> <span class="toc-text">精简标准寄生格式（Reduced Standard Parasitic Format）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AF%84%E7%94%9F%E4%BA%A4%E6%8D%A2%E6%A0%BC%E5%BC%8Fstandard-parasitic-extraction-format"><span class="toc-number">4.3.3.</span> <span class="toc-text">标准寄生交换格式（Standard Parasitic Extraction Format）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E8%80%A6%E5%90%88%E7%94%B5%E5%AE%B9representing-coupling-capacitances"><span class="toc-number">4.4.</span> <span class="toc-text">表示耦合电容（Representing Coupling Capacitances）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95hierarchical-methodology"><span class="toc-number">4.5.</span> <span class="toc-text">分层方法（Hierarchical Methodology）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E5%A4%8D%E5%88%B6%E5%9D%97block-replicated-in-layout"><span class="toc-number">4.5.1.</span> <span class="toc-text">在布局中复制块（Block Replicated in Layout）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%85%B3%E9%94%AE%E7%BD%91%E7%BB%9C%E5%AF%84%E7%94%9F%E6%95%88%E5%BA%94reducing-parasitics-for-critical-nets"><span class="toc-number">4.6.</span> <span class="toc-text">减少关键网络寄生效应（Reducing Parasitics for Critical Nets）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E4%BA%92%E8%BF%9E%E7%94%B5%E9%98%BBreducing-interconnect-resistance"><span class="toc-number">4.6.1.</span> <span class="toc-text">降低互连电阻（Reducing Interconnect Resistance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E7%BA%BF%E8%B7%9Dincreasing-wire-spacing"><span class="toc-number">4.6.2.</span> <span class="toc-text">增加线距（Increasing Wire Spacing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AF%84%E7%94%9F%E5%8F%82%E6%95%B0parasitics-for-correlated-nets"><span class="toc-number">4.6.3.</span> <span class="toc-text">相关网络的寄生参数（Parasitics for Correlated Nets）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97delay-calculation"><span class="toc-number">5.</span> <span class="toc-text">延迟计算（Delay Calculation）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0overview"><span class="toc-number">5.1.</span> <span class="toc-text">概述（Overview）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80delay-calculation-basics"><span class="toc-number">5.1.1.</span> <span class="toc-text">延迟计算基础（Delay Calculation Basics）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E8%BF%9E%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97delay-calculation-with-interconnect"><span class="toc-number">5.1.2.</span> <span class="toc-text">互连延迟计算（Delay Calculation with Interconnect）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%95%88%E7%94%B5%E5%AE%B9%E7%9A%84%E5%8D%95%E5%85%83%E5%BB%B6%E8%BF%9Fcell-delay-using-effective-capacitance"><span class="toc-number">5.2.</span> <span class="toc-text">使用有效电容的单元延迟（Cell Delay using Effective Capacitance）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%BF%9E%E5%BB%B6%E8%BF%9Finterconnect-delay"><span class="toc-number">5.3.</span> <span class="toc-text">互连延迟（Interconnect Delay）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#elmore%E5%BB%B6%E8%BF%9F"><span class="toc-number">5.3.1.</span> <span class="toc-text">Elmore延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E4%BA%92%E8%BF%9E%E5%BB%B6%E8%BF%9F%E4%BC%B0%E8%AE%A1higher-order-interconnect-delay-estimation"><span class="toc-number">5.3.2.</span> <span class="toc-text">高阶互连延迟估计（Higher Order Interconnect Delay Estimation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E8%8A%AF%E7%89%87%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97full-chip-delay-calculation"><span class="toc-number">5.3.3.</span> <span class="toc-text">全芯片延迟计算（Full Chip Delay Calculation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%90%88%E5%B9%B6slew-merging"><span class="toc-number">5.4.</span> <span class="toc-text">转换合并（Slew Merging）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%98%88%E5%80%BCdifferent-slew-thresholds"><span class="toc-number">5.5.</span> <span class="toc-text">不同的转换阈值（Different Slew Thresholds）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E5%90%8C%E7%9A%84%E7%94%B5%E5%8E%8B%E5%9F%9Fdifferent-voltage-domains"><span class="toc-number">5.6.</span> <span class="toc-text">个同的电压域（Different Voltage Domains）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97path-delay-calculation"><span class="toc-number">5.7.</span> <span class="toc-text">路径延迟计算（Path Delay Calculation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E8%B7%AF%E5%BE%84%E5%BB%B6%E8%BF%9Fcombinational-path-delay"><span class="toc-number">5.7.1.</span> <span class="toc-text">组合路径延迟（Combinational Path Delay）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E8%B7%AF%E5%BE%84path-to-a-flip-flop"><span class="toc-number">5.7.2.</span> <span class="toc-text">触发器的路径（Path to a Flip-flop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BE%84multiple-paths"><span class="toc-number">5.7.3.</span> <span class="toc-text">多路径（Multiple Paths）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%95%E9%87%8F%E8%AE%A1%E7%AE%97slack-calculation"><span class="toc-number">5.8.</span> <span class="toc-text">裕量计算（Slack Calculation）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2%E6%89%B0%E5%92%8C%E5%99%AA%E5%A3%B0crosstalk-and-noise-1"><span class="toc-number">6.</span> <span class="toc-text">串扰和噪声（Crosstalk and Noise）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0overview-1"><span class="toc-number">6.1.</span> <span class="toc-text">概述（Overview）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E6%89%B0%E6%AF%9B%E5%88%BA%E5%88%86%E6%9E%90crosstalk-glitch-analysis"><span class="toc-number">6.2.</span> <span class="toc-text">串扰毛刺分析（Crosstalk Glitch Analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86basics"><span class="toc-number">6.2.1.</span> <span class="toc-text">基础知识（Basics）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%9B%E5%88%BA%E7%B1%BB%E5%9E%8Btypes-of-glitches"><span class="toc-number">6.2.2.</span> <span class="toc-text">毛刺类型（Types of Glitches）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%9B%E5%88%BA%E9%98%88%E5%80%BC%E5%92%8C%E4%BC%A0%E6%92%ADglitch-thresholds-and-propagation"><span class="toc-number">6.2.3.</span> <span class="toc-text">毛刺阈值和传播（Glitch Thresholds and Propagation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%B9%B2%E6%89%B0%E6%BA%90%E7%9A%84%E5%99%AA%E5%A3%B0%E7%B4%AF%E7%A7%AFnoise-accumulation-with-multiple-aggressors"><span class="toc-number">6.2.4.</span> <span class="toc-text">多个干扰源的噪声累积（Noise Accumulation with Multiple Aggressors）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B2%E6%89%B0%E6%BA%90%E6%97%B6%E5%BA%8F%E7%9B%B8%E5%85%B3%E6%80%A7aggressor-timing-correlation"><span class="toc-number">6.2.5.</span> <span class="toc-text">干扰源时序相关性（Aggressor Timing Correlation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B2%E6%89%B0%E6%BA%90%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%85%B3%E6%80%A7aggressor-functional-correlation"><span class="toc-number">6.2.6.</span> <span class="toc-text">干扰源功能相关性（Aggressor Functional Correlation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E6%89%B0%E5%BB%B6%E8%BF%9F%E5%88%86%E6%9E%90crosstalk-delay-analysis"><span class="toc-number">6.3.</span> <span class="toc-text">串扰延迟分析（Crosstalk Delay Analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86basics-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">基础知识（Basics）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E8%B4%9F%E4%B8%B2%E6%89%B0positive-and-negative-crosstalk"><span class="toc-number">6.3.2.</span> <span class="toc-text">正负串扰（Positive and Negative Crosstalk）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%B9%B2%E6%89%B0%E6%BA%90%E7%9A%84%E7%B4%AF%E7%A7%AFaccumulation-with-multiple-aggressors"><span class="toc-number">6.3.3.</span> <span class="toc-text">多个干扰源的累积（Accumulation with Multiple Aggressors）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E8%80%85-%E5%8F%97%E5%AE%B3%E8%80%85%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E6%80%A7aggressor-victim-timing-correlation"><span class="toc-number">6.3.4.</span> <span class="toc-text">攻击者-受害者时间相关性（Aggressor Victim Timing Correlation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E8%80%85-%E5%8F%97%E5%AE%B3%E8%80%85%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%85%B3%E6%80%A7aggressor-victim-functional-correlation"><span class="toc-number">6.3.5.</span> <span class="toc-text">攻击者-受害者功能相关性（Aggressor Victim Functional Correlation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%B2%E6%89%B0%E5%BB%B6%E8%BF%9F%E8%BF%9B%E8%A1%8C%E6%97%B6%E5%BA%8F%E9%AA%8C%E8%AF%81timing-verification-using-crosstalk-delay"><span class="toc-number">6.4.</span> <span class="toc-text">使用串扰延迟进行时序验证（Timing Verification Using Crosstalk Delay）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90setup-analysis"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1建立时间分析（Setup Analysis）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90hold-analysis"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2保持时间分析（Hold Analysis）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7computational-complexity"><span class="toc-number">6.5.</span> <span class="toc-text">计算复杂性（Computational Complexity）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%99%AA%E5%A3%B0%E9%81%BF%E5%85%8D%E6%8A%80%E6%9C%AFnoise-avoidance-techniques"><span class="toc-number">6.6.</span> <span class="toc-text">噪声避免技术（Noise Avoidance Techniques）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-sta-%E7%8E%AF%E5%A2%83configuring-the-sta-environment"><span class="toc-number">7.</span> <span class="toc-text">配置 STA 环境（Configuring the STA Environment）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFsta%E7%8E%AF%E5%A2%83what-is-the-sta-environment"><span class="toc-number">7.1.</span> <span class="toc-text">什么是STA环境？（What is the STA Environment?）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%97%B6%E9%92%9Fspecifying-clocks"><span class="toc-number">7.2.</span> <span class="toc-text">指定时钟（Specifying Clocks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7clock-uncertainty"><span class="toc-number">7.2.1.</span> <span class="toc-text">时钟不确定性（Clock Uncertainty）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%BB%B6%E8%BF%9Fclock-latency"><span class="toc-number">7.2.2.</span> <span class="toc-text">时钟延迟（Clock Latency）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%97%B6%E9%92%9Fgenerated-clocks"><span class="toc-number">7.3.</span> <span class="toc-text">生成时钟（Generated Clocks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E8%BE%93%E5%85%A5%E8%B7%AF%E5%BE%84constraining-input-paths"><span class="toc-number">7.4.</span> <span class="toc-text">约束输入路径（Constraining Input Paths）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84constraining-output-paths"><span class="toc-number">7.5.</span> <span class="toc-text">约束输出路径（Constraining Output Paths）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E8%B7%AF%E5%BE%84%E7%BB%84timing-path-groups"><span class="toc-number">7.6.</span> <span class="toc-text">时序路径组（Timing Path Groups）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%B1%9E%E6%80%A7%E5%BB%BA%E6%A8%A1modeling-of-external-attributes"><span class="toc-number">7.7.</span> <span class="toc-text">外部属性建模（Modeling of External Attributes）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%BC%BA%E5%BA%A6%E5%BB%BA%E6%A8%A1modeling-drive-strengths"><span class="toc-number">7.7.1.</span> <span class="toc-text">驱动强度建模（Modeling Drive Strengths）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%99%E6%A3%80%E6%9F%A5design-rule-checks"><span class="toc-number">7.8.</span> <span class="toc-text">设计规则检查（Design Rule Checks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%97%B6%E9%92%9Fvirtual-clocks"><span class="toc-number">7.9.</span> <span class="toc-text">虚拟时钟（Virtual Clocks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90refining-the-timing-analysis"><span class="toc-number">7.10.</span> <span class="toc-text">完善时序分析（Refining the Timing Analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%9D%9E%E6%B4%BB%E5%8A%A8%E4%BF%A1%E5%8F%B7specifying-inactive-signals"><span class="toc-number">7.10.1.</span> <span class="toc-text">指定非活动信号（Specifying Inactive Signals）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8D%95%E5%85%83%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E5%BC%A7breaking-timing-arcs-in-cells"><span class="toc-number">7.10.2.</span> <span class="toc-text">打破单元格中的时序弧（Breaking Timing Arcs in Cells）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E8%A7%84%E8%8C%83point-to-point-specification"><span class="toc-number">7.11.</span> <span class="toc-text">点对点规范（Point-to-Point Specification）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%88%86%E5%89%B2path-segmentation"><span class="toc-number">7.12.</span> <span class="toc-text">路径分割（Path Segmentation）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%AA%8C%E8%AF%81timing-verification"><span class="toc-number">8.</span> <span class="toc-text">时序验证（Timing Verification）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4%E6%97%B6%E5%BA%8F%E6%A3%80%E6%9F%A5setup-timing-check"><span class="toc-number">8.1.</span> <span class="toc-text">建立时间时序检查（Setup Timing Check）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%B0%E8%A7%A6%E5%8F%91%E5%99%A8%E8%B7%AF%E5%BE%84flip-flop-to-flip-flop-path"><span class="toc-number">8.1.1.</span> <span class="toc-text">触发器到触发器路径（Flip-flop to Flip-flop Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E8%B7%AF%E5%BE%84%E7%9A%84%E8%BE%93%E5%85%A5input-to-flip-flop-path"><span class="toc-number">8.1.2.</span> <span class="toc-text">触发器路径的输入（Input to Flip-flop Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%B0%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84flip-flop-to-output-path"><span class="toc-number">8.1.3.</span> <span class="toc-text">触发器到输出路径（Flip-flop to Output Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%88%B0%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84input-to-output-path"><span class="toc-number">8.1.4.</span> <span class="toc-text">输入到输出路径（Input to Output Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%91%E7%8E%87%E7%9B%B4%E6%96%B9%E5%9B%BEfrequency-histogram"><span class="toc-number">8.1.5.</span> <span class="toc-text">频率直方图（Frequency Histogram）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4%E6%A3%80%E6%9F%A5hold-timing-check"><span class="toc-number">8.2.</span> <span class="toc-text">保持时间检查（Hold Timing Check）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%B0%E8%A7%A6%E5%8F%91%E5%99%A8%E8%B7%AF%E5%BE%84flip-flop-to-flip-flop-path-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">触发器到触发器路径（Flip-flop to Flip-flop Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E8%B7%AF%E5%BE%84%E7%9A%84%E8%BE%93%E5%85%A5input-to-flip-flop-path-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">触发器路径的输入（Input to Flip-flop Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%B0%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84flip-flop-to-output-path-1"><span class="toc-number">8.2.3.</span> <span class="toc-text">触发器到输出路径（Flip-flop to Output Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%88%B0%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84input-to-output-path-1"><span class="toc-number">8.2.4.</span> <span class="toc-text">输入到输出路径（Input to Output Path）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E8%B7%AF%E5%BE%84multicycle-paths"><span class="toc-number">8.3.</span> <span class="toc-text">多周期路径（Multicycle Paths）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E8%B7%AF%E5%BE%84false-paths"><span class="toc-number">8.4.</span> <span class="toc-text">伪路径（False Paths）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%91%A8%E6%9C%9F%E8%B7%AF%E5%BE%84half-cycle-paths"><span class="toc-number">8.5.</span> <span class="toc-text">半周期路径（Half-Cycle Paths）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%97%B6%E9%97%B4%E6%A3%80%E6%9F%A5removal-timing-check"><span class="toc-number">8.6.</span> <span class="toc-text">移除时间检查（Removal Timing Check）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E6%97%B6%E9%97%B4%E6%A3%80%E6%9F%A5recovery-timing-check"><span class="toc-number">8.7.</span> <span class="toc-text">恢复时间检查（Recovery Timing Check）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E7%9A%84%E6%97%B6%E5%BA%8Ftiming-across-clock-domains"><span class="toc-number">8.8.</span> <span class="toc-text">跨时钟域的时序（Timing across Clock Domains）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%88%B0%E5%BF%AB%E6%97%B6%E9%92%9F%E5%9F%9Fslow-to-fast-clock-domains"><span class="toc-number">8.8.1.</span> <span class="toc-text">慢到快时钟域（Slow to Fast Clock Domains）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E5%88%B0%E6%85%A2%E6%97%B6%E9%92%9F%E5%9F%9Ffast-to-slow-clock-domains"><span class="toc-number">8.8.2.</span> <span class="toc-text">快到慢时钟域（Fast to Slow Clock Domains）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">8.9.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%80%8D%E6%97%B6%E9%92%9Fmultiple-clocks"><span class="toc-number">8.10.</span> <span class="toc-text">多倍时钟（Multiple Clocks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%80%8D%E6%95%B0integer-multiples"><span class="toc-number">8.10.1.</span> <span class="toc-text">整数倍数（Integer Multiples）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%95%B4%E6%95%B0%E5%80%8D%E6%95%B0non-integer-multiples"><span class="toc-number">8.10.2.</span> <span class="toc-text">非整数倍数（Non-Integer Multiples）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%A7%BBphase-shifted"><span class="toc-number">8.10.3.</span> <span class="toc-text">相移（Phase Shifted）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90interface-analysis"><span class="toc-number">9.</span> <span class="toc-text">接口分析（Interface Analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#io-%E6%8E%A5%E5%8F%A3io-interfaces"><span class="toc-number">9.1.</span> <span class="toc-text">IO 接口(IO Interfaces)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8E%A5%E5%8F%A3input-interface"><span class="toc-number">9.1.1.</span> <span class="toc-text">输入接口（Input Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3output-interface"><span class="toc-number">9.1.2.</span> <span class="toc-text">输出接口（Output Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%86%85%E7%9A%84%E8%BE%93%E5%87%BA%E5%8F%98%E5%8C%96output-change-within-window"><span class="toc-number">9.1.3.</span> <span class="toc-text">窗口内的输出变化（Output Change within Window）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sram-%E6%8E%A5%E5%8F%A3sram-interface"><span class="toc-number">9.2.</span> <span class="toc-text">SRAM 接口（SRAM Interface）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ddr-sdram-%E6%8E%A5%E5%8F%A3ddr-sdram-interface"><span class="toc-number">9.3.</span> <span class="toc-text">DDR SDRAM 接口（DDR SDRAM Interface）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%91%A8%E6%9C%9Fread-cycle"><span class="toc-number">9.3.1.</span> <span class="toc-text">读取周期（Read Cycle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%91%A8%E6%9C%9Fwrite-cycle"><span class="toc-number">9.3.2.</span> <span class="toc-text">写周期（Write Cycle）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91-dac-%E6%8E%A5%E5%8F%A3interface-to-a-video-dac"><span class="toc-number">9.4.</span> <span class="toc-text">视频 DAC 接口（Interface to a Video DAC）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%B3%E5%81%A5%E9%AA%8C%E8%AF%81robust-verification"><span class="toc-number">10.</span> <span class="toc-text">稳健验证（Robust Verification）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%87%E4%B8%8A%E5%8F%98%E5%8C%96on-chip-variations"><span class="toc-number">10.1.</span> <span class="toc-text">片上变化（On-Chip Variations）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%80%9F%E7%94%A8time-borrowing"><span class="toc-number">10.2.</span> <span class="toc-text">时间借用（Time Borrowing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5data-to-data-checks"><span class="toc-number">10.3.</span> <span class="toc-text">数据到数据检查（Data to Data Checks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%A1%BA%E5%BA%8F%E6%A3%80%E6%9F%A5non-sequential-checks"><span class="toc-number">10.4.</span> <span class="toc-text">非顺序检查（Non-Sequential Checks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%97%A8%E6%8E%A7%E6%A3%80%E6%9F%A5clock-gating-checks"><span class="toc-number">10.5.</span> <span class="toc-text">时钟门控检查（Clock Gating Checks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%80%97%E7%AE%A1%E7%90%86power-management"><span class="toc-number">10.6.</span> <span class="toc-text">功耗管理（Power Management）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%97%A8%E6%8E%A7clock-gating"><span class="toc-number">10.6.1.</span> <span class="toc-text">时钟门控（Clock Gating）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E9%97%A8%E6%8E%A7power-gating"><span class="toc-number">10.6.2.</span> <span class="toc-text">电源门控（Power Gating）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%B5%E5%8E%8B%E9%98%88%E5%80%BC%E5%8D%95%E5%85%83multi-vt-cells"><span class="toc-number">10.6.3.</span> <span class="toc-text">多电压阈值单元（Multi Vt Cells）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B1%E5%81%8F%E7%BD%AEwell-bias"><span class="toc-number">10.6.4.</span> <span class="toc-text">阱偏置（Well Bias）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E6%A0%87backannotation"><span class="toc-number">10.7.</span> <span class="toc-text">反标（Backannotation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spef"><span class="toc-number">10.7.1.</span> <span class="toc-text">SPEF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sdf"><span class="toc-number">10.7.2.</span> <span class="toc-text">SDF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sign-off%E6%96%B9%E6%B3%95sign-off-methodology"><span class="toc-number">10.8.</span> <span class="toc-text">sign off方法（Sign-off Methodology）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90statistical-static-timing-analysis"><span class="toc-number">10.9.</span> <span class="toc-text">统计静态时序分析（Statistical Static Timing Analysis）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E8%89%BA%E5%92%8C%E4%BA%92%E8%BF%9E%E5%8F%98%E5%8C%96process-and-interconnect-variations"><span class="toc-number">10.9.1.</span> <span class="toc-text">工艺和互连变化（Process and Interconnect Variations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90statistical-analysis"><span class="toc-number">10.9.2.</span> <span class="toc-text">统计分析（Statistical Analysis）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%A4%B1%E8%B4%A5%E6%97%B6%E5%BA%8Fpaths-failing-timing"><span class="toc-number">10.10.</span> <span class="toc-text">路径失败时序？（Paths Failing Timing?）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E6%89%BE%E5%88%B0%E8%B7%AF%E5%BE%84no-path-found"><span class="toc-number">10.10.1.</span> <span class="toc-text">未找到路径（No Path Found）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%BA%A4%E5%8F%89%E5%9F%9Fclock-crossing-domain"><span class="toc-number">10.10.2.</span> <span class="toc-text">时钟交叉域（Clock Crossing Domain）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E7%94%9F%E6%88%90%E6%97%B6%E9%92%9Finverted-generated-clocks"><span class="toc-number">10.10.3.</span> <span class="toc-text">反向生成时钟（Inverted Generated Clocks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E5%B0%91%E8%99%9A%E6%8B%9F%E6%97%B6%E9%92%9F%E5%BB%B6%E8%BF%9Fmissing-virtual-clock-latency"><span class="toc-number">10.10.4.</span> <span class="toc-text">缺少虚拟时钟延迟（Missing Virtual Clock Latency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7-io-%E5%BB%B6%E8%BF%9Flarge-io-delays"><span class="toc-number">10.10.5.</span> <span class="toc-text">大 I&#x2F;O 延迟（Large I&#x2F;O Delays）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84-io-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%BB%B6%E8%BF%9Fincorrect-io-buffer-delay"><span class="toc-number">10.10.6.</span> <span class="toc-text">错误的 I&#x2F;O 缓冲区延迟（Incorrect I&#x2F;O Buffer Delay）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AEincorrect-latency-numbers"><span class="toc-number">10.10.7.</span> <span class="toc-text">延迟值不正确（Incorrect Latency Numbers）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%91%A8%E6%9C%9F%E8%B7%AF%E5%BE%84half-cycle-path"><span class="toc-number">10.10.8.</span> <span class="toc-text">半周期路径（Half-cycle Path）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%BB%B6%E8%BF%9F%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4large-delays-and-transition-times"><span class="toc-number">10.10.9.</span> <span class="toc-text">大延迟和转换时间（Large Delays and Transition Times）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E5%B0%91%E5%A4%9A%E5%91%A8%E6%9C%9F%E4%BF%9D%E6%8C%81missing-multicycle-hold"><span class="toc-number">10.10.10.</span> <span class="toc-text">缺少多周期保持（Missing Multicycle Hold）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%9C%AA%E4%BC%98%E5%8C%96path-not-optimized"><span class="toc-number">10.10.11.</span> <span class="toc-text">路径未优化（Path Not Optimized）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E4%BB%8D%E7%84%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3%E6%97%B6%E5%BA%8Fpath-still-not-meeting-timing"><span class="toc-number">10.10.12.</span> <span class="toc-text">路径仍然不满足时序（Path Still Not Meeting Timing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BB%8D%E7%84%B6%E6%97%A0%E6%B3%95%E6%BB%A1%E8%B6%B3%E6%97%B6%E5%BA%8F%E6%80%8E%E4%B9%88%E5%8A%9Ewhat-if-timing-still-cannot-be-met"><span class="toc-number">10.10.13.</span> <span class="toc-text">如果仍然无法满足时序怎么办（What if Timing Still Cannot be Met）*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9Fvalidating-timing-constraints"><span class="toc-number">10.11.</span> <span class="toc-text">验证时序约束（Validating Timing Constraints）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%B7%AF%E5%BE%84%E4%BE%8B%E5%A4%96checking-path-exceptions"><span class="toc-number">10.11.1.</span> <span class="toc-text">检查路径例外（Checking Path Exceptions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%97%B6%E9%92%9F%E5%9F%9F%E4%BA%A4%E5%8F%89checking-clock-domain-crossing"><span class="toc-number">10.11.2.</span> <span class="toc-text">检查时钟域交叉（Checking Clock Domain Crossing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-io-%E5%92%8C%E6%97%B6%E9%92%9F%E7%BA%A6%E6%9D%9Fvalidating-io-and-clock-constraints"><span class="toc-number">10.11.3.</span> <span class="toc-text">验证 IO 和时钟约束（Validating IO and Clock Constraints）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95asdc"><span class="toc-number">11.</span> <span class="toc-text">附录A:SDC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#a.1-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">11.1.</span> <span class="toc-text">A.1 基本命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.2-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">11.2.</span> <span class="toc-text">A.2 对象访问命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.3-%E6%97%B6%E5%BA%8F%E7%BA%A6%E6%9D%9F"><span class="toc-number">11.3.</span> <span class="toc-text">A.3 时序约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.4-%E7%8E%AF%E5%A2%83%E5%91%BD%E4%BB%A4"><span class="toc-number">11.4.</span> <span class="toc-text">A.4 环境命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a.5-%E5%A4%9A%E7%94%B5%E5%8E%8B%E5%91%BD%E4%BB%A4"><span class="toc-number">11.5.</span> <span class="toc-text">A.5 多电压命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95bsdf"><span class="toc-number">12.</span> <span class="toc-text">附录B:SDF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#b.1-%E4%BB%80%E4%B9%88%E6%98%AFsdf"><span class="toc-number">12.1.</span> <span class="toc-text">B.1 什么是SDF？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.2-sdf%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text">B.2 SDF格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.2.1.</span> <span class="toc-text">延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E6%A3%80%E6%9F%A5"><span class="toc-number">12.2.2.</span> <span class="toc-text">时序检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">12.2.3.</span> <span class="toc-text">标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E7%8E%AF%E5%A2%83"><span class="toc-number">12.2.4.</span> <span class="toc-text">时序环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.2.1-%E4%BE%8B%E5%AD%90"><span class="toc-number">12.3.</span> <span class="toc-text">B.2.1 例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%8A%A0%E5%99%A8"><span class="toc-number">12.3.1.</span> <span class="toc-text">全加器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">12.3.2.</span> <span class="toc-text">十进制计数器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.3-%E6%A0%87%E6%B3%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">12.4.</span> <span class="toc-text">B.3 标注过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.3.1-verilog-hdl"><span class="toc-number">12.5.</span> <span class="toc-text">B.3.1 Verilog HDL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.3.2-vhdl"><span class="toc-number">12.6.</span> <span class="toc-text">B.3.2 VHDL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.4-%E6%98%A0%E5%B0%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.7.</span> <span class="toc-text">B.4 映射示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.7.1.</span> <span class="toc-text">传播延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.2.</span> <span class="toc-text">输入建立时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.3.</span> <span class="toc-text">输入保持时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.4.</span> <span class="toc-text">输入建立和保持时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%81%A2%E5%A4%8D%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.5.</span> <span class="toc-text">输入恢复时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%92%A4%E9%94%80%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.6.</span> <span class="toc-text">输入撤销时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F"><span class="toc-number">12.7.7.</span> <span class="toc-text">周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%89%E5%AE%BD"><span class="toc-number">12.7.8.</span> <span class="toc-text">脉宽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%81%8F%E6%96%9C%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.9.</span> <span class="toc-text">输入偏斜时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%98%E5%8C%96%E7%9A%84%E5%BB%BA%E7%AB%8B%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.10.</span> <span class="toc-text">无变化的建立时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%8F%98%E5%8C%96%E7%9A%84%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4"><span class="toc-number">12.7.11.</span> <span class="toc-text">无变化的保持时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.7.12.</span> <span class="toc-text">端口延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.7.13.</span> <span class="toc-text">网络延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E8%BF%9E%E8%B7%AF%E5%BE%84%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.7.14.</span> <span class="toc-text">互连路径延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%99%A8%E4%BB%B6%E5%BB%B6%E8%BF%9F"><span class="toc-number">12.7.15.</span> <span class="toc-text">器件延迟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b.5-%E5%AE%8C%E6%95%B4%E8%AF%AD%E6%B3%95"><span class="toc-number">12.8.</span> <span class="toc-text">B.5 完整语法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95cspef"><span class="toc-number">13.</span> <span class="toc-text">附录C:SPEF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c.1-%E5%9F%BA%E7%A1%80"><span class="toc-number">13.1.</span> <span class="toc-text">C.1 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.2-%E6%A0%BC%E5%BC%8F"><span class="toc-number">13.2.</span> <span class="toc-text">C.2 格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c.3-%E5%AE%8C%E6%95%B4%E8%AF%AD%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">C.3 完整语法</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1/dist/fancybox/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@11.12.1/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script><script src="/js/twikoo_emotion_biger.js"></script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.narutozxp.top',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.narutozxp.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo@1/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.jsdelivr.net/gh/narutozxp/live2d-widget@latest/autoload.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>