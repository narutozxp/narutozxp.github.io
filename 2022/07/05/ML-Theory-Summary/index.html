<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ML Theory Summary | narutozxp</title><meta name="keywords" content="ML Theory"><meta name="author" content="narutozxp"><meta name="copyright" content="narutozxp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="description test">
<meta property="og:type" content="article">
<meta property="og:title" content="ML Theory Summary">
<meta property="og:url" content="https://www.narutozxp.top/2022/07/05/ML-Theory-Summary/index.html">
<meta property="og:site_name" content="narutozxp">
<meta property="og:description" content="description test">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.narutozxp.top/img/23.jpg">
<meta property="article:published_time" content="2022-07-05T09:43:53.000Z">
<meta property="article:modified_time" content="2023-06-27T04:10:52.000Z">
<meta property="article:author" content="narutozxp">
<meta property="article:tag" content="ML Theory">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.narutozxp.top/img/23.jpg"><link rel="shortcut icon" href="/img/myself.jpg"><link rel="canonical" href="https://www.narutozxp.top/2022/07/05/ML-Theory-Summary/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Great%20Vibes" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ML Theory Summary',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-27 04:10:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script> <link rel="stylesheet" href="/css/custom.css"> <link rel="stylesheet" href="/css/font.css"> <script data-pjax src="https://wavedrom.com/wavedrom.min.js" type="text/javascript"></script> <script data-pjax src="https://wavedrom.com/skins/default.js" type="text/javascript"></script> <script data-pjax src="https://wavedrom.com/skins/dark.js" type="text/javascript"></script> <script data-pjax src="https://wavedrom.com/skins/narrow.js" type="text/javascript"></script> <script data-pjax src="https://wavedrom.com/skins/lowkey.js" type="text/javascript"></script> <script data-pjax src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js" type="text/javascript"></script> <script data-pjax src="https://cdn.jsdelivr.net/npm/echarts-gl/dist/echarts-gl.min.js" type="text/javascript"></script> <script data-pjax src="https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.js" type="text/javascript"></script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/abcjs/abcjs-audio.css"/> <script defer data-pjax src="https://cn.vercount.one/js" type="text/javascript"></script>
<script data-pjax type="text/javascript"> document.addEventListener('pjax:complete', WaveDrom.ProcessAll); document.addEventListener('pjax:complete', mermaid.init); </script> <script data-pjax type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.5.0/style.css" /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"> <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script> <meting-js id="2217718183" server="netease" type="playlist" autoplay = "false" api = "https://v.iarc.top/?server=:server&type=:type&id=:id&r=:r" mini = "true" fixed = "true" loop = "all" order = 'random' list-folded = "true"> </meting-js><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/myself.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/23.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">narutozxp</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ML Theory Summary</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-05T09:43:53.000Z" title="发表于 2022-07-05 09:43:53">2022-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-27T04:10:52.000Z" title="更新于 2023-06-27 04:10:52">2023-06-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ML/">ML</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">37.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>164分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ML Theory Summary"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="introduction">Introduction</h1>
<p>对概率的诠释有两大学派，一种是频率派另一种是贝叶斯派。后面我们对观测集采用下面记号：<br>
<span class="math display">\[
X_{N\times p}=(x_{1},x_{2},\cdots,x_{N})^{T},x_{i}=(x_{i1},x_{i2},\cdots,x_{ip})^{T}
\]</span><br>
这个记号表示有 <span class="math inline">\(N\)</span> 个样本，每个样本都是 <span class="math inline">\(p\)</span> 维向量。其中每个观测都是由 <span class="math inline">\(p(x|\theta)\)</span> 生成的。</p>
<h2 id="频率派的观点">频率派的观点</h2>
<p><span class="math inline">\(p(x|\theta)\)</span>中的 <span class="math inline">\(\theta\)</span> 是一个常量。对于 <span class="math inline">\(N\)</span> 个观测来说观测集的概率为 <span class="math inline">\(p(X|\theta)\mathop{=}\limits _{iid}\prod\limits _{i=1}^{N}p(x_{i}|\theta))\)</span> 。为了求 <span class="math inline">\(\theta\)</span> 的大小，我们采用最大对数似然MLE的方法：</p>
<p><span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span></p>
<h2 id="贝叶斯派的观点">贝叶斯派的观点</h2>
<p>贝叶斯派认为 <span class="math inline">\(p(x|\theta)\)</span> 中的 <span class="math inline">\(\theta\)</span> 不是一个常量。这个 <span class="math inline">\(\theta\)</span> 满足一个预设的先验的分布 <span class="math inline">\(\theta\sim p(\theta)\)</span> 。于是根据贝叶斯定理依赖观测集参数的后验可以写成：</p>
<p><span class="math display">\[
p(\theta|X)=\frac{p(X|\theta)\cdot p(\theta)}{p(X)}=\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}
\]</span><br>
为了求 <span class="math inline">\(\theta\)</span> 的值，我们要最大化这个参数后验MAP：</p>
<p><span class="math display">\[
\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)
\]</span><br>
其中第二个等号是由于分母和 <span class="math inline">\(\theta\)</span> 没有关系。求解这个 <span class="math inline">\(\theta\)</span> 值后计算<span class="math inline">\(\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}\)</span> ，就得到了参数的后验概率。其中 <span class="math inline">\(p(X|\theta)\)</span> 叫似然，是我们的模型分布。得到了参数的后验分布后，我们可以将这个分布用于预测贝叶斯预测：<br>
<span class="math display">\[
p(x_{new}|X)=\int\limits _{\theta}p(x_{new}|\theta)\cdot p(\theta|X)d\theta
\]</span><br>
其中积分中的被乘数是模型，乘数是后验分布。</p>
<h2 id="小结">小结</h2>
<p>频率派和贝叶斯派分别给出了一系列的机器学习算法。频率派的观点导出了一系列的统计机器学习算法而贝叶斯派导出了概率图理论。在应用频率派的 MLE 方法时最优化理论占有重要地位。而贝叶斯派的算法无论是后验概率的建模还是应用这个后验进行推断时积分占有重要地位。因此采样积分方法如 MCMC 有很多应用。</p>
<h1 id="mathbasics">MathBasics</h1>
<h2 id="高斯分布">高斯分布</h2>
<h3 id="一维情况-mle">一维情况 MLE</h3>
<p>高斯分布在机器学习中占有举足轻重的作用。在 MLE 方法中：</p>
<p><span class="math display">\[
\theta=(\mu,\Sigma)=(\mu,\sigma^{2}),\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span><br>
一般地，高斯分布的概率密度函数PDF写为：</p>
<p><span class="math display">\[
p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}
\]</span><br>
带入 MLE 中我们考虑一维的情况</p>
<p><span class="math display">\[
\log p(X|\theta)=\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)=\sum\limits _{i=1}^{N}\log\frac{1}{\sqrt{2\pi}\sigma}\exp(-(x_{i}-\mu)^{2}/2\sigma^{2})
\]</span><br>
首先对 <span class="math inline">\(\mu\)</span> 的极值可以得到 ：<br>
<span class="math display">\[
\mu_{MLE}=\mathop{argmax}\limits _{\mu}\log p(X|\theta)=\mathop{argmax}\limits _{\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial}{\partial\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}=0\longrightarrow\mu_{MLE}=\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}
\]</span><br>
其次对 <span class="math inline">\(\theta\)</span> 中的另一个参数 <span class="math inline">\(\sigma\)</span> ，有：<br>
<span class="math display">\[
\begin{align*}
\sigma_{MLE}=\mathop{argmax}\limits _{\sigma}\log p(X|\theta)&amp;=\mathop{argmax}\limits _{\sigma}\sum\limits _{i=1}^{N}[-\log\sigma-\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]\\
&amp;=\mathop{argmin}\limits _{\sigma}\sum\limits _{i=1}^{N}[\log\sigma+\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]
\end{align*}
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial}{\partial\sigma}\sum\limits _{i=1}^{N}[\log\sigma+\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]=0\longrightarrow\sigma_{MLE}^{2}=\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span><br>
值得注意的是，上面的推导中，首先对 <span class="math inline">\(\mu\)</span> 求 MLE， 然后利用这个结果求 <span class="math inline">\(\sigma_{MLE}\)</span> ，因此可以预期的是对数据集求期望时 <span class="math inline">\(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}]\)</span> 是无偏差的：<br>
<span class="math display">\[
\mathbb{E}_{\mathcal{D}}[\mu_{MLE}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\frac{1}{N}\sum\limits _{i=1}^{N}\mathbb{E}_{\mathcal{D}}[x_{i}]=\mu
\]</span><br>
但是当对 <span class="math inline">\(\sigma_{MLE}\)</span> 求 期望的时候由于使用了单个数据集的 <span class="math inline">\(\mu_{MLE}\)</span>，因此对所有数据集求期望的时候我们会发现 <span class="math inline">\(\sigma_{MLE}\)</span> 是 有偏的：</p>
<p><span class="math display">\[
\begin{align*}
\mathbb{E}_{\mathcal{D}}[\sigma_{MLE}^{2}]&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu_{MLE})^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}^{2}-2x_{i}\mu_{MLE}+\mu_{MLE}^{2})
\\&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu_{MLE}^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}+\mu^{2}-\mu_{MLE}^{2}]\\
&amp;= \mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}]-\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}-\mu^{2}]=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mu^{2})r\\&amp;=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mathbb{E}_{\mathcal{D}}^{2}[\mu_{MLE}])=\sigma^{2}-Var[\mu_{MLE}]\\&amp;=\sigma^{2}-Var[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\sigma^{2}-\frac{1}{N^{2}}\sum\limits _{i=1}^{N}Var[x_{i}]=\frac{N-1}{N}\sigma^{2}
\end{align*}
\]</span><br>
所以：<br>
<span class="math display">\[
\hat{\sigma}^{2}=\frac{1}{N-1}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span></p>
<h3 id="多维情况">多维情况</h3>
<p>多维高斯分布表达式为：<br>
<span class="math display">\[
p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}
\]</span><br>
其中 <span class="math inline">\(x,\mu\in\mathbb{R}^{p},\Sigma\in\mathbb{R}^{p\times p}\)</span> ，<span class="math inline">\(\Sigma\)</span> 为协方差矩阵，一般而言也是半正定矩阵。这里我们只考虑正定矩阵。首先我们处理指数上的数字，指数上的数字可以记为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\mu\)</span> 之间的马氏距离。对于对称的协方差矩阵可进行特征值分解，<span class="math inline">\(\Sigma=U\Lambda U^{T}=(u_{1},u_{2},\cdots,u_{p})diag(\lambda_{i})(u_{1},u_{2},\cdots,u_{p})^{T}=\sum\limits _{i=1}^{p}u_{i}\lambda_{i}u_{i}^{T}\)</span> ，于是：</p>
<p><span class="math display">\[
\Sigma^{-1}=\sum\limits _{i=1}^{p}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}
\]</span></p>
<p><span class="math display">\[
\Delta=(x-\mu)^{T}\Sigma^{-1}(x-\mu)=\sum\limits _{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu)=\sum\limits _{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}}
\]</span></p>
<p>我们注意到 <span class="math inline">\(y_{i}\)</span> 是 <span class="math inline">\(x-\mu\)</span> 在特征向量 <span class="math inline">\(u_{i}\)</span> 上的投影长度，因此上式子就是 <span class="math inline">\(\Delta\)</span> 取不同值时的同心椭圆。</p>
<p>下面我们看多维高斯模型在实际应用时的两个问题</p>
<ol type="1">
<li><p>参数 <span class="math inline">\(\Sigma,\mu\)</span> 的自由度为 <span class="math inline">\(O(p^{2})\)</span> 对于维度很高的数据其自由度太高。解决方案：高自由度的来源是 <span class="math inline">\(\Sigma\)</span> 有 <span class="math inline">\(\frac{p(p+1)}{2}\)</span> 个自由参数，可以假设其是对角矩阵，甚至在各向同性假设中假设其对角线上的元素都相同。前一种的算法有 Factor Analysis，后一种有概率 PCA(p-PCA) 。</p></li>
<li><p>第二个问题是单个高斯分布是单峰的，对有多个峰的数据分布不能得到好的结果。解决方案：高斯混合GMM 模型。</p></li>
</ol>
<p>下面对多维高斯分布的常用定理进行介绍。</p>
<p>我们记 <span class="math inline">\(x=(x_1, x_2,\cdots,x_p)^T=(x_{a,m\times 1}, x_{b,n\times1})^T,\mu=(\mu_{a,m\times1}, \mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)</span>，已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma)\)</span>。</p>
<p>首先是一个高斯分布的定理：</p>
<blockquote>
<p>定理：已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma), y\sim Ax+b\)</span>，那么 <span class="math inline">\(y\sim\mathcal{N}(A\mu+b, A\Sigma A^T)\)</span>。</p>
<p>证明：<span class="math inline">\(\mathbb{E}[y]=\mathbb{E}[Ax+b]=A\mathbb{E}[x]+b=A\mu+b\)</span>，<span class="math inline">\(Var[y]=Var[Ax+b]=Var[Ax]=A\cdot Var[x]\cdot A^T\)</span>。</p>
</blockquote>
<p>下面利用这个定理得到 <span class="math inline">\(p(x_a),p(x_b),p(x_a|x_b),p(x_b|x_a)\)</span> 这四个量。</p>
<ol type="1">
<li><p><span class="math inline">\(x_a=\begin{pmatrix}\mathbb{I}_{m\times m}&amp;\mathbb{O}_{m\times n})\end{pmatrix}\begin{pmatrix}x_a\\x_b\end{pmatrix}\)</span>，代入定理中得到：<br>
<span class="math display">\[
\mathbb{E}[x_a]=\begin{pmatrix}\mathbb{I}&amp;\mathbb{O}\end{pmatrix}\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix}=\mu_a\\
Var[x_a]=\begin{pmatrix}\mathbb{I}&amp;\mathbb{O}\end{pmatrix}\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\begin{pmatrix}\mathbb{I}\\\mathbb{O}\end{pmatrix}=\Sigma_{aa}
\]</span><br>
所以 <span class="math inline">\(x_a\sim\mathcal{N}(\mu_a,\Sigma_{aa})\)</span>。</p></li>
<li><p>同样的，<span class="math inline">\(x_b\sim\mathcal{N}(\mu_b,\Sigma_{bb})\)</span>。</p></li>
<li><p>对于两个条件概率，我们引入三个量：<br>
<span class="math display">\[
\begin{gather*}
x_{b\cdot a}=x_b-\Sigma_{ba}\Sigma_{aa}^{-1}x_a\\
\mu_{b\cdot a}=\mu_b-\Sigma_{ba}\Sigma_{aa}^{-1}\mu_a\\
\Sigma_{bb\cdot a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{gather*}
\]</span><br>
特别的，最后一个式子叫做 <span class="math inline">\(\Sigma_{bb}\)</span> 的 Schur Complementary。可以看到：<br>
<span class="math display">\[
x_{b\cdot a}=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}x_a\\x_b\end{pmatrix}
\]</span><br>
所以：<br>
<span class="math display">\[
\begin{gather*}
\mathbb{E}[x_{b\cdot a}]=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix}=\mu_{b\cdot a}\\
Var[x_{b\cdot a}]=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\begin{pmatrix}-\Sigma_{aa}^{-1}\Sigma_{ba}^T\\\mathbb{I}_{n\times n}\end{pmatrix}=\Sigma_{bb\cdot a}
\end{gather*}
\]</span><br>
利用这三个量可以得到 <span class="math inline">\(x_b=x_{b\cdot a}+\Sigma_{ba}\Sigma_{aa}^{-1}x_a\)</span>。因此：<br>
<span class="math display">\[
\begin{gather*}
\mathbb{E}[x_b|x_a]=\mu_{b\cdot a}+\Sigma_{ba}\Sigma_{aa}^{-1}x_a\\
Var[x_b|x_a]=\Sigma_{bb\cdot a}
\end{gather*}
\]</span></p>
<p>这里同样用到了定理。</p></li>
<li><p>同样：<br>
<span class="math display">\[
\begin{gather*}
x_{a\cdot b}=x_a-\Sigma_{ab}\Sigma_{bb}^{-1}x_b\\
\mu_{a\cdot b}=\mu_a-\Sigma_{ab}\Sigma_{bb}^{-1}\mu_b\\
\Sigma_{aa\cdot b}=\Sigma_{aa}-\Sigma_{ab}\Sigma_{bb}^{-1}\Sigma_{ba}
\end{gather*}
\]</span><br>
所以：<br>
<span class="math display">\[
\mathbb{E}[x_a|x_b]=\mu_{a\cdot b}+\Sigma_{ab}\Sigma_{bb}^{-1}x_b
\]</span></p>
<p><span class="math display">\[
Var[x_a|x_b]=\Sigma_{aa\cdot b}
\]</span></p></li>
</ol>
<p>下面利用上边四个量，求解线性模型：</p>
<blockquote>
<p>已知：<span class="math inline">\(p(x)=\mathcal{N}(\mu,\Lambda^{-1}),p(y|x)=\mathcal{N}(Ax+b,L^{-1})\)</span>，求解：<span class="math inline">\(p(y),p(x|y)\)</span>。</p>
<p>解：令 <span class="math inline">\(y=Ax+b+\epsilon,\epsilon\sim\mathcal{N}(0,L^{-1})\)</span>，所以 <span class="math inline">\(\mathbb{E}[y]=\mathbb{E}[Ax+b+\epsilon]=A\mu+b\)</span>，<span class="math inline">\(Var[y]=A \Lambda^{-1}A^T+L^{-1}\)</span>，因此：<br>
<span class="math display">\[
  p(y)=\mathcal{N}(A\mu+b,L^{-1}+A\Lambda^{-1}A^T)
  \]</span><br>
引入 <span class="math inline">\(z=\begin{pmatrix}x\\y\end{pmatrix}\)</span>，我们可以得到 <span class="math inline">\(Cov[x,y]=\mathbb{E}[(x-\mathbb{E}[x])(y-\mathbb{E}[y])^T]\)</span>。对于这个协方差可以直接计算：<br>
<span class="math display">\[
  \begin{align*}
  Cov(x,y)&amp;=\mathbb{E}[(x-\mu)(Ax-A\mu+\epsilon)^T]=\mathbb{E}[(x-\mu)(x-\mu)^TA^T]=Var[x]A^T=\Lambda^{-1}A^T
  \end{align*}
  \]</span><br>
注意到协方差矩阵的对称性，所以 <span class="math inline">\(p(z)=\mathcal{N}\begin{pmatrix}\mu\\A\mu+b\end{pmatrix},\begin{pmatrix}\Lambda^{-1}&amp;\Lambda^{-1}A^T\\A\Lambda^{-1}&amp;L^{-1}+A\Lambda^{-1}A^T\end{pmatrix})\)</span>。根据之前的公式，我们可以得到：<br>
<span class="math display">\[
  \mathbb{E}[x|y]=\mu+\Lambda^{-1}A^T(L^{-1}+A\Lambda^{-1}A^T)^{-1}(y-A\mu-b)
  \]</span></p>
<p><span class="math display">\[
  Var[x|y]=\Lambda^{-1}-\Lambda^{-1}A^T(L^{-1}+A\Lambda^{-1}A^T)^{-1}A\Lambda^{-1}
  \]</span></p>
</blockquote>
<h1 id="线性回归">线性回归</h1>
<p>假设数据集为：<br>
<span class="math display">\[
\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}
\]</span><br>
后面我们记：<br>
<span class="math display">\[
X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T
\]</span><br>
线性回归假设：<br>
<span class="math display">\[
f(w)=w^Tx
\]</span></p>
<h2 id="最小二乘法">最小二乘法</h2>
<p>对这个问题，采用二范数定义的平方误差来定义损失函数：<br>
<span class="math display">\[
L(w)=\sum\limits_{i=1}^N||w^Tx_i-y_i||^2_2
\]</span><br>
展开得到：<br>
<span class="math display">\[
\begin{align*}
L(w)&amp;=(w^Tx_1-y_1,\cdots,w^Tx_N-y_N)\cdot (w^Tx_1-y_1,\cdots,w^Tx_N-y_N)^T\\
&amp;=(w^TX^T-Y^T)\cdot (Xw-Y)=w^TX^TXw-Y^TXw-w^TX^TY+Y^TY\\
&amp;=w^TX^TXw-2w^TX^TY+Y^TY
\end{align*}
\]</span><br>
最小化这个值的 $ $ ：<br>
<span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmin}\limits_wL(w)&amp;\longrightarrow\frac{\partial}{\partial w}L(w)=0\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY=0\\
&amp;\longrightarrow \hat{w}=(X^TX)^{-1}X^TY=X^+Y
\end{align*}
\]</span><br>
这个式子中 <span class="math inline">\((X^TX)^{-1}X^T\)</span> 又被称为伪逆。对于行满秩或者列满秩的 <span class="math inline">\(X\)</span>，可以直接求解，但是对于非满秩的样本集合，需要使用奇异值分解（SVD）的方法，对 <span class="math inline">\(X\)</span> 求奇异值分解，得到<br>
<span class="math display">\[
X=U\Sigma V^T
\]</span><br>
于是：<br>
<span class="math display">\[
X^+=V\Sigma^{-1}U^T
\]</span><br>
在几何上，最小二乘法相当于模型（这里就是直线）和试验值的距离的平方求和，假设我们的试验样本张成一个 <span class="math inline">\(p\)</span> 维空间（满秩的情况）：<span class="math inline">\(X=Span(x_1,\cdots,x_N)\)</span>，而模型可以写成 <span class="math inline">\(f(w)=X\beta\)</span>，也就是 <span class="math inline">\(x_1,\cdots,x_N\)</span> 的某种组合，而最小二乘法就是说希望 <span class="math inline">\(Y\)</span> 和这个模型距离越小越好，于是它们的差应该与这个张成的空间垂直：<br>
<span class="math display">\[
X^T\cdot(Y-X\beta)=0\longrightarrow\beta=(X^TX)^{-1}X^TY
\]</span></p>
<h2 id="噪声为高斯分布的-mle">噪声为高斯分布的 MLE</h2>
<p>对于一维的情况，记 <span class="math inline">\(y=w^Tx+\epsilon,\epsilon\sim\mathcal{N}(0,\sigma^2)\)</span>，那么 <span class="math inline">\(y\sim\mathcal{N}(w^Tx,\sigma^2)\)</span>。代入极大似然估计中：<br>
<span class="math display">\[
\begin{align*}
L(w)=\log p(Y|X,w)&amp;=\log\prod\limits_{i=1}^Np(y_i|x_i,w)\\
&amp;=\sum\limits_{i=1}^N\log(\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(y_i-w^Tx_i)^2}{2\sigma^2}})\\
\mathop{argmax}\limits_wL(w)&amp;=\mathop{argmin}\limits_w\sum\limits_{i=1^N}(y_i-w^Tx_i)^2
\end{align*}
\]</span><br>
这个表达式和最小二乘估计得到的结果一样。</p>
<h2 id="权重先验也为高斯分布的-map">权重先验也为高斯分布的 MAP</h2>
<p>取先验分布 <span class="math inline">\(w\sim\mathcal{N}(0,\sigma_0^2)\)</span>。于是： <br>
<span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmax}\limits_wp(w|Y)&amp;=\mathop{argmax}\limits_wp(Y|w)p(w)\\
&amp;=\mathop{argmax}\limits_w\log p(Y|w)p(w)\\
&amp;=\mathop{argmax}\limits_w(\log p(Y|w)+\log p(w))\\
&amp;=\mathop{argmin}\limits_w[(y-w^Tx)^2+\frac{\sigma^2}{\sigma_0^2}w^Tw]
\end{align*}
\]</span><br>
这里省略了 <span class="math inline">\(X\)</span>，<span class="math inline">\(p(Y)\)</span>和 <span class="math inline">\(w\)</span> 没有关系，同时也利用了上面高斯分布的 MLE的结果。</p>
<p>我们将会看到，超参数 <span class="math inline">\(\sigma_0\)</span>的存在和下面会介绍的 Ridge 正则项可以对应，同样的如果将先验分布取为 Laplace 分布，那么就会得到和 L1 正则类似的结果。</p>
<h2 id="正则化">正则化</h2>
<p>在实际应用时，如果样本容量不远远大于样本的特征维度，很可能造成过拟合，对这种情况，我们有下面三个解决方式：</p>
<ol type="1">
<li>加数据</li>
<li>特征选择（降低特征维度）如 PCA 算法。</li>
<li>正则化</li>
</ol>
<p>正则化一般是在损失函数（如上面介绍的最小二乘损失）上加入正则化项（表示模型的复杂度对模型的惩罚），下面我们介绍一般情况下的两种正则化框架。<br>
<span class="math display">\[
\begin{align*}
L1&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||_1,\lambda\gt0\\
L2&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||^2_2,\lambda \gt 0
\end{align*}
\]</span><br>
下面对最小二乘误差分别分析这两者的区别。</p>
<h3 id="l1-lasso">L1 Lasso</h3>
<p>L1正则化可以引起稀疏解。</p>
<p>从最小化损失的角度看，由于 L1 项求导在0附近的左右导数都不是0，因此更容易取到0解。</p>
<p>从另一个方面看，L1 正则化相当于：<br>
<span class="math display">\[
\begin{gather*}
\mathop{argmin}\limits_wL(w)\\
s.t. ||w||_1\lt C
\end{gather*}
\]</span><br>
我们已经看到平方误差损失函数在 <span class="math inline">\(w\)</span> 空间是一个椭球，因此上式求解就是椭球和 <span class="math inline">\(||w||_1=C\)</span>的切点，因此更容易相切在坐标轴上。</p>
<h3 id="l2-ridge">L2 Ridge</h3>
<p><span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmin}\limits_wL(w)+\lambda w^Tw&amp;\longrightarrow\frac{\partial}{\partial w}L(w)+2\lambda w=0\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY+2\lambda \hat w=0\\
&amp;\longrightarrow \hat{w}=(X^TX+\lambda \mathbb{I})^{-1}X^TY
\end{align*}
\]</span></p>
<p>可以看到，这个正则化参数和前面的 MAP 结果不谋而合。利用2范数进行正则化不仅可以是模型选择 <span class="math inline">\(w\)</span> 较小的参数，同时也避免 $ X^TX$不可逆的问题。</p>
<h2 id="小结-1">小结</h2>
<p>线性回归模型是最简单的模型，但是麻雀虽小，五脏俱全，在这里，我们利用最小二乘误差得到了闭式解。同时也发现，在噪声为高斯分布的时候，MLE 的解等价于最小二乘误差，而增加了正则项后，最小二乘误差加上 L2 正则项等价于高斯噪声先验下的 MAP解，加上 L1 正则项后，等价于 Laplace 噪声先验。</p>
<p>传统的机器学习方法或多或少都有线性回归模型的影子：</p>
<ol type="1">
<li>线性模型往往不能很好地拟合数据，因此有三种方案克服这一劣势：
<ol type="1">
<li>对特征的维数进行变换，例如多项式回归模型就是在线性特征的基础上加入高次项。</li>
<li>在线性方程后面加入一个非线性变换，即引入一个非线性的激活函数，典型的有线性分类模型如感知机。</li>
<li>对于一致的线性系数，我们进行多次变换，这样同一个特征不仅仅被单个系数影响，例如多层感知机（深度前馈网络）。</li>
</ol></li>
<li>线性回归在整个样本空间都是线性的，我们修改这个限制，在不同区域引入不同的线性或非线性，例如线性样条回归和决策树模型。</li>
<li>线性回归中使用了所有的样本，但是对数据预先进行加工学习的效果可能更好（所谓的维数灾难，高维度数据更难学习），例如 PCA 算法和流形学习。</li>
</ol>
<h1 id="线性分类">线性分类</h1>
<p>对于分类任务，线性回归模型就无能为力了，但是我们可以在线性模型的函数进行后再加入一层激活函数，这个函数是非线性的，激活函数的反函数叫做链接函数。我们有两种线性分类的方式：</p>
<ol type="1">
<li>硬分类，我们直接需要输出观测对应的分类。这类模型的代表为：
<ol type="1">
<li>线性判别分析（Fisher 判别）</li>
<li>感知机</li>
</ol></li>
<li>软分类，产生不同类别的概率，这类算法根据概率方法的不同分为两种
<ol type="1">
<li>生成式（根据贝叶斯定理先计算参数后验，再进行推断）：高斯判别分析（GDA）和朴素贝叶斯等为代表
<ol type="1">
<li>GDA</li>
<li>Naive Bayes</li>
</ol></li>
<li>判别式（直接对条件概率进行建模）：Logistic 回归</li>
</ol></li>
</ol>
<h2 id="两分类-硬分类-感知机算法">两分类-硬分类-感知机算法</h2>
<p>我们选取激活函数为：<br>
<span class="math display">\[
sign(a)=\left\{\begin{matrix}+1,a\ge0\\-1,a\lt0\end{matrix}\right.
\]</span><br>
这样就可以将线性回归的结果映射到两分类的结果上了。</p>
<p>定义损失函数为错误分类的数目，比较直观的方式是使用指示函数，但是指示函数不可导，因此可以定义：<br>
<span class="math display">\[
L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i
\]</span><br>
其中，<span class="math inline">\(\mathcal{D}_{wrong}\)</span>是错误分类集合，实际在每一次训练的时候，我们采用梯度下降的算法。损失函数对 <span class="math inline">\(w\)</span> 的偏导为：<br>
<span class="math display">\[
\frac{\partial}{\partial w}L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_ix_i
\]</span><br>
但是如果样本非常多的情况下，计算复杂度较高，但是，实际上我们并不需要绝对的损失函数下降的方向，我们只需要损失函数的期望值下降，但是计算期望需要知道真实的概率分布，我们实际只能根据训练数据抽样来估算这个概率分布（经验风险）：<br>
<span class="math display">\[
\mathbb{E}_{\mathcal D}[\mathbb{E}_\hat{p}[\nabla_wL(w)]]=\mathbb{E}_{\mathcal D}[\frac{1}{N}\sum\limits_{i=1}^N\nabla_wL(w)]
\]</span><br>
我们知道， <span class="math inline">\(N\)</span> 越大，样本近似真实分布越准确，但是对于一个标准差为 <span class="math inline">\(\sigma\)</span> 的数据，可以确定的标准差仅和 <span class="math inline">\(\sqrt{N}\)</span> 成反比，而计算速度却和 <span class="math inline">\(N\)</span> 成正比。因此可以每次使用较少样本，则在数学期望的意义上损失降低的同时，有可以提高计算速度，如果每次只使用一个错误样本，我们有下面的更新策略（根据泰勒公式，在负方向）：<br>
<span class="math display">\[
w^{t+1}\leftarrow w^{t}+\lambda y_ix_i
\]</span><br>
是可以收敛的，同时使用单个观测更新也可以在一定程度上增加不确定度，从而减轻陷入局部最小的可能。在更大规模的数据上，常用的是小批量随机梯度下降法。</p>
<h2 id="两分类-硬分类-线性判别分析-lda">两分类-硬分类-线性判别分析 LDA</h2>
<p>在 LDA 中，我们的基本想法是选定一个方向，将试验样本顺着这个方向投影，投影后的数据需要满足两个条件，从而可以更好地分类：</p>
<ol type="1">
<li>相同类内部的试验样本距离接近。</li>
<li>不同类别之间的距离较大。</li>
</ol>
<p>首先是投影，我们假定原来的数据是向量 <span class="math inline">\(x\)</span>，那么顺着 $ w$ 方向的投影就是标量：<br>
<span class="math display">\[
z=w^T\cdot x(=|w|\cdot|x|\cos\theta)
\]</span><br>
对第一点，相同类内部的样本更为接近，我们假设属于两类的试验样本数量分别是 <span class="math inline">\(N_1\)</span>和 <span class="math inline">\(N_2\)</span>，那么我们采用方差矩阵来表征每一个类内的总体分布，这里我们使用了协方差的定义，用 <span class="math inline">\(S\)</span> 表示原数据的协方差：<br>
<span class="math display">\[
\begin{align*}
C_1:Var_z[C_1]&amp;=\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(z_i-\overline{z_{c1}})(z_i-\overline{z_{c1}})^T\\
&amp;=\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(w^Tx_i-\frac{1}{N_1}\sum\limits_{j=1}^{N_1}w^Tx_j)(w^Tx_i-\frac{1}{N_1}\sum\limits_{j=1}^{N_1}w^Tx_j)^T\\
&amp;=w^T\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(x_i-\overline{x_{c1}})(x_i-\overline{x_{c1}})^Tw\\
&amp;=w^TS_1w\\
C_2:Var_z[C_2]&amp;=\frac{1}{N_2}\sum\limits_{i=1}^{N_2}(z_i-\overline{z_{c2}})(z_i-\overline{z_{c2}})^T\\
&amp;=w^TS_2w
\end{align*}
\]</span><br>
所以类内距离可以记为：<br>
<span class="math display">\[
\begin{align*}
Var_z[C_1]+Var_z[C_2]=w^T(S_1+S_2)w
\end{align*}
\]</span><br>
对于第二点，我们可以用两类的均值表示这个距离：<br>
<span class="math display">\[
\begin{align*}
(\overline{z_{c1}}-\overline{z_{c2}})^2&amp;=(\frac{1}{N_1}\sum\limits_{i=1}^{N_1}w^Tx_i-\frac{1}{N_2}\sum\limits_{i=1}^{N_2}w^Tx_i)^2\\
&amp;=(w^T(\overline{x_{c1}}-\overline{x_{c2}}))^2\\
&amp;=w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw
\end{align*}
\]</span><br>
综合这两点，由于协方差是一个矩阵，于是我们用将这两个值相除来得到我们的损失函数，并最大化这个值：<br>
<span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmax}\limits_wJ(w)&amp;=\mathop{argmax}\limits_w\frac{(\overline{z_{c1}}-\overline{z_{c2}})^2}{Var_z[C_1]+Var_z[C_2]}\\
&amp;=\mathop{argmax}\limits_w\frac{w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw}{w^T(S_1+S_2)w}\\
&amp;=\mathop{argmax}\limits_w\frac{w^TS_bw}{w^TS_ww}
\end{align*}
\]</span><br>
这样，我们就把损失函数和原数据集以及参数结合起来了。下面对这个损失函数求偏导，注意我们其实对 <span class="math inline">\(w\)</span> 的绝对值没有任何要求，只对方向有要求，因此只要一个方程就可以求解了：<br>
<span class="math display">\[
\begin{gather*}
\frac{\partial}{\partial w}J(w)=2S_bw(w^TS_ww)^{-1}-2w^TS_bw(w^TS_ww)^{-2}S_ww=0\\
\Longrightarrow S_bw(w^TS_ww)=(w^TS_bw)S_ww\\
\Longrightarrow w\propto S_w^{-1}S_bw=S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw\propto S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})
\end{gather*}
\]</span><br>
于是 $ S_w^{-1}(-)$ 就是我们需要寻找的方向。最后可以归一化求得单位的 <span class="math inline">\(w\)</span> 值。</p>
<h2 id="两分类-软分类-概率判别模型-logistic-回归">两分类-软分类-概率判别模型-Logistic 回归</h2>
<p>有时候我们只要得到一个类别的概率，那么我们需要一种能输出 <span class="math inline">\([0,1]\)</span> 区间的值的函数。考虑两分类模型，我们利用判别模型，希望对 <span class="math inline">\(p(C|x)\)</span> 建模，利用贝叶斯定理：<br>
<span class="math display">\[
p(C_1|x)=\frac{p(x|C_1)p(C_1)}{p(x|C_1)p(C_1)+p(x|C_2)p(C_2)}
\]</span><br>
取 <span class="math inline">\(a=\ln\frac{p(x|C_1)p(C_1)}{p(x|C_2)p(C_2)}\)</span>，于是：<br>
<span class="math display">\[
p(C_1|x)=\frac{1}{1+\exp(-a)}
\]</span><br>
上面的式子叫 Logistic Sigmoid 函数，其参数表示了两类联合概率比值的对数。在判别式中，不关心这个参数的具体值，模型假设直接对 <span class="math inline">\(a\)</span> 进行。</p>
<p>Logistic 回归的模型假设是：<br>
<span class="math display">\[
a=w^Tx
\]</span><br>
于是，通过寻找 $  w$ 的最佳值可以得到在这个模型假设下的最佳模型。概率判别模型常用最大似然估计的方式来确定参数。</p>
<p>对于一次观测，获得分类 <span class="math inline">\(y\)</span> 的概率为（假定<span class="math inline">\(C_1=1,C_2=0\)</span>）：<br>
<span class="math display">\[
p(y|x)=p_1^yp_0^{1-y}
\]</span></p>
<p>那么对于 <span class="math inline">\(N\)</span> 次独立全同的观测 MLE为：<br>
<span class="math display">\[
\hat{w}=\mathop{argmax}_wJ(w)=\mathop{argmax}_w\sum\limits_{i=1}^N(y_i\log p_1+(1-y_i)\log p_0)
\]</span><br>
注意到，这个表达式是交叉熵表达式的相反数乘 <span class="math inline">\(N\)</span>，MLE 中的对数也保证了可以和指数函数相匹配，从而在大的区间汇总获取稳定的梯度。</p>
<p>对这个函数求导数，注意到：<br>
<span class="math display">\[
p_1&#39;=(\frac{1}{1+\exp(-a)})&#39;=p_1(1-p_1)
\]</span><br>
则：<br>
<span class="math display">\[
J&#39;(w)=\sum\limits_{i=1}^Ny_i(1-p_1)x_i-p_1x_i+y_ip_1x_i=\sum\limits_{i=1}^N(y_i-p_1)x_i
\]</span><br>
由于概率值的非线性，放在求和符号中时，这个式子无法直接求解。于是在实际训练的时候，和感知机类似，也可以使用不同大小的批量随机梯度上升（对于最小化就是梯度下降）来获得这个函数的极大值。</p>
<h2 id="两分类-软分类-概率生成模型-高斯判别分析-gda">两分类-软分类-概率生成模型-高斯判别分析 GDA</h2>
<p>生成模型中，我们对联合概率分布进行建模，然后采用 MAP 来获得参数的最佳值。两分类的情况，我们采用的假设：</p>
<ol type="1">
<li><span class="math inline">\(y\sim Bernoulli(\phi)\)</span></li>
<li><span class="math inline">\(x|y=1\sim\mathcal{N}(\mu_1,\Sigma)\)</span></li>
<li><span class="math inline">\(x|y=0\sim\mathcal{N}(\mu_0,\Sigma)\)</span></li>
</ol>
<p>那么独立全同的数据集最大后验概率可以表示为：<br>
<span class="math display">\[
\begin{align*}
\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N (\log p(x_i|y_i)+\log p(y_i))\\
=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log \mathcal{N}(\mu_1,\Sigma)+y_i\log\phi+(1-y_i)\log(1-\phi))
\end{align*}
\]</span></p>
<ul>
<li><p>首先对 <span class="math inline">\(\phi\)</span> 进行求解，将式子对 <span class="math inline">\(\phi\)</span> 求偏导：<br>
<span class="math display">\[
\begin{align*}\sum\limits_{i=1}^N\frac{y_i}{\phi}+\frac{y_i-1}{1-\phi}=0\\
\Longrightarrow\phi=\frac{\sum\limits_{i=1}^Ny_i}{N}=\frac{N_1}{N}
\end{align*}
\]</span></p></li>
<li><p>然后求解 <span class="math inline">\(\mu_1\)</span>：<br>
<span class="math display">\[
\begin{align*}\hat{\mu_1}&amp;=\mathop{argmax}_{\mu_1}\sum\limits_{i=1}^Ny_i\log\mathcal{N}(\mu_1,\Sigma)\\
&amp;=\mathop{argmin}_{\mu_1}\sum\limits_{i=1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)
\end{align*}
\]</span><br>
由于：<br>
<span class="math display">\[
\sum\limits_{i=1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)=\sum\limits_{i=1}^Ny_ix_i^T\Sigma^{-1}x_i-2y_i\mu_1^T\Sigma^{-1}x_i+y_i\mu_1^T\Sigma^{-1}\mu_1
\]</span></p>
<p>求微分左边乘以 <span class="math inline">\(\Sigma\)</span> 可以得到：<br>
<span class="math display">\[
\begin{align*}\sum\limits_{i=1}^N-2y_i\Sigma^{-1}x_i+2y_i\Sigma^{-1}\mu_1=0\\
\Longrightarrow\mu_1=\frac{\sum\limits_{i=1}^Ny_ix_i}{\sum\limits_{i=1}^Ny_i}=\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1}
\end{align*}
\]</span></p></li>
<li><p>求解 <span class="math inline">\(\mu_0\)</span>，由于正反例是对称的，所以：<br>
<span class="math display">\[
\mu_0=\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0}
\]</span></p></li>
<li><p>最为困难的是求解 <span class="math inline">\(\Sigma\)</span>，我们的模型假设对正反例采用相同的协方差矩阵，当然从上面的求解中我们可以看到，即使采用不同的矩阵也不会影响之前的三个参数。首先我们有：<br>
<span class="math display">\[
\begin{align*}
\sum\limits_{i=1}^N\log\mathcal{N}(\mu,\Sigma)&amp;=\sum\limits_{i=1}^N\log(\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}})+(-\frac{1}{2}(x_i-\mu)^T\Sigma^{-1}(x_i-\mu))\\
&amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}Trace((x_i-\mu)^T\Sigma^{-1}(x_i-\mu))\\
&amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}Trace((x_i-\mu)(x_i-\mu)^T\Sigma^{-1})\\
&amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}NTrace(S\Sigma^{-1})
\end{align*}
\]</span><br>
在这个表达式中，我们在标量上加入迹从而可以交换矩阵的顺序，对于包含绝对值和迹的表达式的导数，我们有：<br>
<span class="math display">\[
\begin{align*}
\frac{\partial}{\partial A}(|A|)&amp;=|A|A^{-1}\\
\frac{\partial}{\partial A}Trace(AB)&amp;=B^T
\end{align*}
\]</span><br>
因此：<br>
<span class="math display">\[
\begin{align*}[\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log \mathcal{N}(\mu_1,\Sigma)]&#39;
\\=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}N_1Trace(S_1\Sigma^{-1})-\frac{1}{2}N_2Trace(S_2\Sigma^{-1})
\end{align*}
\]</span><br>
其中，<span class="math inline">\(S_1,S_2\)</span> 分别为两个类数据内部的协方差矩阵，于是：<br>
<span class="math display">\[
\begin{align*}N\Sigma^{-1}-N_1S_1^T\Sigma^{-2}-N_2S_2^T\Sigma^{-2}=0
\\\Longrightarrow\Sigma=\frac{N_1S_1+N_2S_2}{N}
\end{align*}
\]</span><br>
这里应用了类协方差矩阵的对称性。</p></li>
</ul>
<p>于是我们就利用最大后验的方法求得了我们模型假设里面的所有参数，根据模型，可以得到联合分布，也就可以得到用于推断的条件分布了。</p>
<h2 id="两分类-软分类-概率生成模型-朴素贝叶斯">两分类-软分类-概率生成模型-朴素贝叶斯</h2>
<p>上面的高斯判别分析的是对数据集的分布作出了高斯分布的假设，同时引入伯努利分布作为类先验，从而利用最大后验求得这些假设中的参数。</p>
<p>朴素贝叶斯队数据的属性之间的关系作出了假设，一般地，我们有需要得到 <span class="math inline">\(p(x|y)\)</span> 这个概率值，由于 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(p\)</span> 个维度，因此需要对这么多的维度的联合概率进行采样，但是我们知道这么高维度的空间中采样需要的样本数量非常大才能获得较为准确的概率近似。</p>
<p>在一般的有向概率图模型中，对各个属性维度之间的条件独立关系作出了不同的假设，其中最为简单的一个假设就是在朴素贝叶斯模型描述中的条件独立性假设。<br>
<span class="math display">\[
p(x|y)=\prod\limits_{i=1}^pp(x_i|y)
\]</span><br>
即：<br>
<span class="math display">\[
x_i\perp x_j|y,\forall\  i\ne j
\]</span><br>
于是利用贝叶斯定理，对于单次观测：<br>
<span class="math display">\[
p(y|x)=\frac{p(x|y)p(y)}{p(x)}=\frac{\prod\limits_{i=1}^pp(x_i|y)p(y)}{p(x)}
\]</span><br>
对于单个维度的条件概率以及类先验作出进一步的假设：</p>
<ol type="1">
<li><span class="math inline">\(x_i\)</span> 为连续变量：<span class="math inline">\(p(x_i|y)=\mathcal{N}(\mu_i,\sigma_i^2)\)</span></li>
<li><span class="math inline">\(x_i\)</span> 为离散变量：类别分布（Categorical）：<span class="math inline">\(p(x_i=i|y)=\theta_i,\sum\limits_{i=1}^K\theta_i=1\)</span></li>
<li><span class="math inline">\(p(y)=\phi^y(1-\phi)^{1-y}\)</span></li>
</ol>
<p>对这些参数的估计，常用 MLE 的方法直接在数据集上估计，由于不需要知道各个维度之间的关系，因此，所需数据量大大减少了。估算完这些参数，再代入贝叶斯定理中得到类别的后验分布。</p>
<h2 id="小结-2">小结</h2>
<p>分类任务分为两类，对于需要直接输出类别的任务，感知机算法中我们在线性模型的基础上加入符号函数作为激活函数，那么就能得到这个类别，但是符号函数不光滑，于是我们采用错误驱动的方式，引入 <span class="math inline">\(\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i\)</span> 作为损失函数，然后最小化这个误差，采用批量随机梯度下降的方法来获取最佳的参数值。而在线性判别分析中，我们将线性模型看作是数据点在某一个方向的投影，采用类内小，类间大的思路来定义损失函数，其中类内小定义为两类数据的方差之和，类间大定义为两类数据中心点的间距，对损失函数求导得到参数的方向，这个方向就是 <span class="math inline">\(S_w^{-1}(\overline x_{c1}-\overline x_{c2})\)</span>，其中 <span class="math inline">\(S_w\)</span> 为原数据集两类的方差之和。</p>
<p>另一种任务是输出分类的概率，对于概率模型，我们有两种方案，第一种是判别模型，也就是直接对类别的条件概率建模，将线性模型套入 Logistic 函数中，我们就得到了 Logistic 回归模型，这里的概率解释是两类的联合概率比值的对数是线性的，我们定义的损失函数是交叉熵（等价于 MLE），对这个函数求导得到 <span class="math inline">\(\frac{1}{N}\sum\limits_{i=1}^N(y_i-p_1)x_i\)</span>，同样利用批量随机梯度（上升）的方法进行优化。第二种是生成模型，生成模型引入了类别的先验，在高斯判别分析中，我们对数据集的数据分布作出了假设，其中类先验是二项分布，而每一类的似然是高斯分布，对这个联合分布的对数似然进行最大化就得到了参数， <span class="math inline">\(\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1},\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0},\frac{N_1S_1+N_2S_2}{N},\frac{N_1}{N}\)</span>。在朴素贝叶斯中，我们进一步对属性的各个维度之间的依赖关系作出假设，条件独立性假设大大减少了数据量的需求。</p>
<h1 id="降维">降维</h1>
<p>我们知道，解决过拟合的问题除了正则化和添加数据之外，降维就是最好的方法。降维的思路来源于维度灾难的问题，我们知道 <span class="math inline">\(n\)</span> 维球的体积为：<br>
<span class="math display">\[
CR^n
\]</span><br>
那么在球体积与边长为 <span class="math inline">\(2R\)</span> 的超立方体比值为：<br>
<span class="math display">\[
\lim\limits_{n\rightarrow0}\frac{CR^n}{2^nR^n}=0
\]</span></p>
<p>这就是所谓的维度灾难，在高维数据中，主要样本都分布在立方体的边缘，所以数据集更加稀疏。</p>
<p>降维的算法分为：</p>
<ol type="1">
<li>直接降维，特征选择</li>
<li>线性降维，PCA，MDS等</li>
<li>分线性，流形包括 Isomap，LLE 等</li>
</ol>
<p>为了方便，我们首先将协方差矩阵（数据集）写成中心化的形式：<br>
<span class="math display">\[
\begin{align*}S&amp;=\frac{1}{N}\sum\limits_{i=1}^N(x_i-\overline{x})(x_i-\overline{x})^T\\
&amp;=\frac{1}{N}(x_1-\overline{x},x_2-\overline{x},\cdots,x_N-\overline{x})(x_1-\overline{x},x_2-\overline{x},\cdots,x_N-\overline{x})^T\\
&amp;=\frac{1}{N}(X^T-\frac{1}{N}X^T\mathbb{I}_{N1}\mathbb{I}_{N1}^T)(X^T-\frac{1}{N}X^T\mathbb{I}_{N1}\mathbb{I}_{N1}^T)^T\\
&amp;=\frac{1}{N}X^T(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})^TX\\
&amp;=\frac{1}{N}X^TH_NH_N^TX\\
&amp;=\frac{1}{N}X^TH_NH_NX=\frac{1}{N}X^THX
\end{align*}
\]</span><br>
这个式子利用了中心矩阵 $ H$的对称性，这也是一个投影矩阵。</p>
<h2 id="线性降维-主成分分析-pca">线性降维-主成分分析 PCA</h2>
<h3 id="损失函数">损失函数</h3>
<p>主成分分析中，我们的基本想法是将所有数据投影到一个字空间中，从而达到降维的目标，为了寻找这个子空间，我们基本想法是：</p>
<ol type="1">
<li>所有数据在子空间中更为分散</li>
<li>损失的信息最小，即：在补空间的分量少</li>
</ol>
<p>原来的数据很有可能各个维度之间是相关的，于是我们希望找到一组 <span class="math inline">\(p\)</span> 个新的线性无关的单位基 <span class="math inline">\(u_i\)</span>，降维就是取其中的 <span class="math inline">\(q\)</span> 个基。于是对于一个样本 <span class="math inline">\(x_i\)</span>，经过这个坐标变换后：<br>
<span class="math display">\[
\hat{x_i}=\sum\limits_{i=1}^p(u_i^Tx_i)u_i=\sum\limits_{i=1}^q(u_i^Tx_i)u_i+\sum\limits_{i=q+1}^p(u_i^Tx_i)u_i
\]</span><br>
对于数据集来说，我们首先将其中心化然后再去上面的式子的第一项，并使用其系数的平方平均作为损失函数并最大化：<br>
<span class="math display">\[
\begin{align*}J&amp;=\frac{1}{N}\sum\limits_{i=1}^N\sum\limits_{j=1}^q((x_i-\overline{x})^Tu_j)^2\\
&amp;=\sum\limits_{j=1}^qu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align*}
\]</span><br>
由于每个基都是线性无关的，于是每一个 <span class="math inline">\(u_j\)</span> 的求解可以分别进行，使用拉格朗日乘子法：<br>
<span class="math display">\[
\mathop{argmax}_{u_j}L(u_j,\lambda)=\mathop{argmax}_{u_j}u_j^TSu_j+\lambda(1-u_j^Tu_j)
\]</span><br>
于是：<br>
<span class="math display">\[
Su_j=\lambda u_j
\]</span><br>
可见，我们需要的基就是协方差矩阵的本征矢。损失函数最大取在本征值前 <span class="math inline">\(q\)</span> 个最大值。</p>
<p>下面看其损失的信息最少这个条件，同样适用系数的平方平均作为损失函数，并最小化：<br>
<span class="math display">\[
\begin{align*}J&amp;=\frac{1}{N}\sum\limits_{i=1}^N\sum\limits_{j=q+1}^p((x_i-\overline{x})^Tu_j)^2\\
&amp;=\sum\limits_{j=q+1}^pu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align*}
\]</span><br>
同样的：<br>
<span class="math display">\[
\mathop{argmin}_{u_j}L(u_j,\lambda)=\mathop{argmin}_{u_j}u_j^TSu_j+\lambda(1-u_j^Tu_j)
\]</span><br>
损失函数最小取在本征值剩下的个最小的几个值。数据集的协方差矩阵可以写成 <span class="math inline">\(S=U\Lambda U^T\)</span>，直接对这个表达式当然可以得到本征矢。</p>
<h3 id="svd-与-pcoa">SVD 与 PCoA</h3>
<p>下面使用实际训练时常常使用的 SVD 直接求得这个 <span class="math inline">\(q\)</span> 个本征矢。</p>
<p>对中心化后的数据集进行奇异值分解：<br>
<span class="math display">\[
HX=U\Sigma V^T,U^TU=E_N,V^TV=E_p,\Sigma:N\times p
\]</span></p>
<p>于是：<br>
<span class="math display">\[
S=\frac{1}{N}X^THX=\frac{1}{N}X^TH^THX=\frac{1}{N}V\Sigma^T\Sigma V^T
\]</span><br>
因此，我们直接对中心化后的数据集进行 SVD，就可以得到特征值和特征向量 <span class="math inline">\(V\)</span>，在新坐标系中的坐标就是：<br>
<span class="math display">\[
HX\cdot V
\]</span><br>
由上面的推导，我们也可以得到另一种方法 PCoA 主坐标分析，定义并进行特征值分解：<br>
<span class="math display">\[
T=HXX^TH=U\Sigma\Sigma^TU^T
\]</span><br>
由于：<br>
<span class="math display">\[
TU\Sigma=U\Sigma(\Sigma^T\Sigma)
\]</span><br>
于是可以直接得到坐标。这两种方法都可以得到主成分，但是由于方差矩阵是 <span class="math inline">\(p\times p\)</span> 的，而 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(N\times N\)</span> 的，所以对样本量较少的时候可以采用 PCoA的方法。</p>
<h3 id="p-pca">p-PCA</h3>
<p>下面从概率的角度对 PCA 进行分析，概率方法也叫 p-PCA。我们使用线性模型，类似之前 LDA，我们选定一个方向，对原数据 <span class="math inline">\(x\in\mathbb{R}^p\)</span> ，降维后的数据为 <span class="math inline">\(z\in\mathbb{R}^q,q&lt;p\)</span>。降维通过一个矩阵变换（投影）进行：<br>
<span class="math display">\[
\begin{align*}
z&amp;\sim\mathcal{N}(\mathbb{O}_{q1},\mathbb{I}_{qq})\\
x&amp;=Wz+\mu+\varepsilon\\
\varepsilon&amp;\sim\mathcal{N}(0,\sigma^2\mathbb{I}_{pp})
\end{align*}
\]</span><br>
对于这个模型，我么可以使用期望-最大（EM）的算法进行学习，在进行推断的时候需要求得 <span class="math inline">\(p(z|x)\)</span>，推断的求解过程和线性高斯模型类似。<br>
<span class="math display">\[
\begin{align*}
&amp;p(z|x)=\frac{p(x|z)p(z)}{p(x)}\\
&amp;\mathbb{E}[x]=\mathbb{E}[Wz+\mu+\varepsilon]=\mu\\
&amp;Var[x]=WW^T+\sigma^2\mathbb{I}_{pp}\\
\Longrightarrow p(z|x)=\mathcal{N}(W^T(WW^T+&amp;\sigma^2\mathbb{I})^{-1}(x-\mu),\mathbb{I}-W^T(WW^T+\sigma^2\mathbb{I})^{-1}W)
\end{align*}
\]</span></p>
<h2 id="小结-3">小结</h2>
<p>降维是解决维度灾难和过拟合的重要方法，除了直接的特征选择外，我们还可以采用算法的途径对特征进行筛选，线性的降维方法以 PCA 为代表，在 PCA 中，我们只要直接对数据矩阵进行中心化然后求奇异值分解或者对数据的协方差矩阵进行分解就可以得到其主要维度。非线性学习的方法如流形学习将投影面从平面改为超曲面。</p>
<h1 id="支撑向量机">支撑向量机</h1>
<p>支撑向量机（SVM）算法在分类问题中有着重要地位，其主要思想是最大化两类之间的间隔。按照数据集的特点：</p>
<ol type="1">
<li>线性可分问题，如之前的感知机算法处理的问题</li>
<li>线性可分，只有一点点错误点，如感知机算法发展出来的 Pocket 算法处理的问题</li>
<li>非线性问题，完全不可分，如在感知机问题发展出来的多层感知机和深度学习</li>
</ol>
<p>这三种情况对于 SVM 分别有下面三种处理手段：</p>
<ol type="1">
<li>hard-margin SVM</li>
<li>soft-margin SVM</li>
<li>kernel Method</li>
</ol>
<p>SVM 的求解中，大量用到了 Lagrange 乘子法，首先对这种方法进行介绍。</p>
<h2 id="约束优化问题">约束优化问题</h2>
<p>一般地，约束优化问题（原问题）可以写成：</p>
<p><span class="math display">\[
\begin{align*}
&amp;\min_{x\in\mathbb{R^p}}f(x)\\
&amp;s.t.\ m_i(x)\le0,i=1,2,\cdots,M\\
&amp;\ \ \ \ \ \ \ \ n_j(x)=0,j=1,2,\cdots,N
\end{align*}
\]</span></p>
<p>定义 Lagrange 函数：</p>
<p><span class="math display">\[
L(x,\lambda,\eta)=f(x)+\sum\limits_{i=1}^M\lambda_im_i(x)+\sum\limits_{i=1}^N\eta_in_i(x)
\]</span></p>
<p>那么原问题可以等价于无约束形式：</p>
<p><span class="math display">\[
\min_{x\in\mathbb{R}^p}\max_{\lambda,\eta}L(x,\lambda,\eta)\ s.t.\ \lambda_i\ge0
\]</span></p>
<p>这是由于，当满足原问题的不等式约束的时候，<span class="math inline">\(\lambda_i=0\)</span> 才能取得最大值，直接等价于原问题，如果不满足原问题的不等式约束，那么最大值就为 <span class="math inline">\(+\infty\)</span> ，由于需要取最小值，于是不会取到这个情况。</p>
<p>这个问题的对偶形式：</p>
<p><span class="math display">\[
\max_{\lambda,\eta}\min_{x\in\mathbb{R}^p}L(x,\lambda,\eta)\ s.t.\ \lambda_i\ge0
\]</span></p>
<p>对偶问题是关于 $ , $ 的最大化问题。</p>
<p>由于：<br>
<span class="math display">\[
\max_{\lambda_i,\eta_j}\min_{x}L(x,\lambda_i,\eta_j)\le\min_{x}\max_{\lambda_i,\eta_j}L(x,\lambda_i,\eta_j)
\]</span></p>
<blockquote>
<p>证明：显然有 <span class="math inline">\(\min\limits_{x}L\le L\le\max\limits_{\lambda,\eta}L\)</span>，于是显然有 <span class="math inline">\(\max\limits_{\lambda,\eta}\min\limits_{x}L\le L\)</span>，且 <span class="math inline">\(\min\limits_{x}\max\limits_{\lambda,\eta}L\ge L\)</span>。</p>
</blockquote>
<p>对偶问题的解小于原问题，有两种情况：</p>
<ol type="1">
<li>强对偶：可以取等于号</li>
<li>弱对偶：不可以取等于号</li>
</ol>
<p>其实这一点也可以通过一张图来说明：</p>
<p><img src="/2022/07/05/ML-Theory-Summary/originVSdual.jpg" alt="originVsdual"></p>
<p>对于一个凸优化问题，有如下定理：</p>
<blockquote>
<p>如果凸优化问题满足某些条件如 Slater 条件，那么它和其对偶问题满足强对偶关系。记问题的定义域为：<span class="math inline">\(\mathcal{D}=domf(x)\cap dom m_i(x)\cap domn_j(x)\)</span>。于是 Slater 条件为：<br>
<span class="math display">\[
  \exists \hat{x}\in Relint\mathcal{D}\ s.t.\ \forall i=1,2,\cdots,M,m_i(x)\lt0
  \]</span><br>
其中 Relint 表示相对内部（不包含边界的内部）。</p>
</blockquote>
<ol type="1">
<li>对于大多数凸优化问题，Slater 条件成立。</li>
<li>松弛 Slater 条件，如果 M 个不等式约束中，有 K 个函数为仿射函数，那么只要其余的函数满足 Slater 条件即可。</li>
</ol>
<p>上面介绍了原问题和对偶问题的对偶关系，但是实际还需要对参数进行求解，求解方法使用 KKT 条件进行：</p>
<blockquote>
<p>KKT 条件和强对偶关系是等价关系。KKT 条件对最优解的条件为：</p>
<ol type="1">
<li><p>可行域：<br>
<span class="math display">\[
\begin{align*}
m_i(x^*)\le0\\
n_j(x^*)=0\\
\lambda^*\ge0
\end{align*}
\]</span></p></li>
<li><p>互补松弛 <span class="math inline">\(\lambda^*m_i(x^*)=0,\forall m_i\)</span>，对偶问题的最佳值为 <span class="math inline">\(d^*\)</span>，原问题为 <span class="math inline">\(p^*\)</span><br>
<span class="math display">\[
\begin{align*}
d^*&amp;=\max_{\lambda,\eta}g(\lambda,\eta)=g(\lambda^*,\eta^*)\\
&amp;=\min_{x}L(x,\lambda^*,\eta^*)\\
&amp;\le L(x^*,\lambda^*,\eta^*)\\
&amp;=f(x^*)+\sum\limits_{i=1}^M\lambda^*m_i(x^*)\\
&amp;\le f(x^*)=p^*
\end{align*}
\]</span><br>
为了满足相等，两个不等式必须成立，于是，对于第一个不等于号，需要有梯度为0条件，对于第二个不等于号需要满足互补松弛条件。</p></li>
<li><p>梯度为0：<span class="math inline">\(\frac{\partial L(x,\lambda^*,\eta^*)}{\partial x}|_{x=x^*}=0\)</span></p></li>
</ol>
</blockquote>
<h2 id="hard-margin-svm">Hard-margin SVM</h2>
<p>支撑向量机也是一种硬分类模型，在之前的感知机模型中，我们在线性模型的基础上叠加了符号函数，在几何直观上，可以看到，如果两类分的很开的话，那么其实会存在无穷多条线可以将两类分开。在 SVM 中，我们引入最大化间隔这个概念，间隔指的是数据和直线的距离的最小值，因此最大化这个值反映了我们的模型倾向。</p>
<p>分割的超平面可以写为：<br>
<span class="math display">\[
0=w^Tx+b
\]</span><br>
那么最大化间隔（约束为分类任务的要求）：<br>
<span class="math display">\[
\begin{align*}
\mathop{argmax}_{w,b}[\min_i\frac{|w^Tx_i+b|}{||w||}]\ s.t.\ y_i(w^Tx_i+b)&gt;0\\
\Longrightarrow\mathop{argmax}_{w,b}[\min_i\frac{y_i(w^Tx_i+b)}{||w||}]\ s.t.\ y_i(w^Tx_i+b)&gt;0
\end{align*}
\]</span><br>
对于这个约束 <span class="math inline">\(y_i(w^Tx_i+b)&gt;0\)</span>，不妨固定 <span class="math inline">\(\min y_i(w^Tx_i+b)=1&gt;0\)</span>，这是由于分开两类的超平面的系数经过比例放缩不会改变这个平面，这也相当于给超平面的系数作出了约束。化简后的式子可以表示为：</p>
<p><span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw \ s.t.\ \min_iy_i(w^Tx_i+b)=1 
\]</span><br>
<span class="math display">\[
\Rightarrow\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\ y_i(w^Tx_i+b)\ge1,i=1,2,\cdots,N
\]</span></p>
<p>这就是一个包含 <span class="math inline">\(N\)</span> 个约束的凸优化问题，有很多求解这种问题的软件。</p>
<p>但是，如果样本数量或维度非常高，直接求解困难甚至不可解，于是需要对这个问题进一步处理。引入 Lagrange 函数：<br>
<span class="math display">\[
L(w,b,\lambda)=\frac{1}{2}w^Tw+\sum\limits_{i=1}^N\lambda_i(1-y_i(w^Tx_i+b))
\]</span><br>
我们有原问题就等价于：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\max_{\lambda}L(w,b,\lambda_i)\ s.t.\ \lambda_i\ge0
\]</span><br>
我们交换最小和最大值的符号得到对偶问题：<br>
<span class="math display">\[
\max_{\lambda_i}\min_{w,b}L(w,b,\lambda_i)\ s.t.\ \lambda_i\ge0
\]</span><br>
由于不等式约束是仿射函数，对偶问题和原问题等价：</p>
<ul>
<li><p><span class="math inline">\(b\)</span>：<span class="math inline">\(\frac{\partial}{\partial b}L=0\Rightarrow\sum\limits_{i=1}^N\lambda_iy_i=0\)</span></p></li>
<li><p><span class="math inline">\(w\)</span>：首先将 <span class="math inline">\(b\)</span> 代入：<br>
<span class="math display">\[
L(w,b,\lambda_i)=\frac{1}{2}w^Tw+\sum\limits_{i=1}^N\lambda_i(1-y_iw^Tx_i-y_ib)=\frac{1}{2}w^Tw+\sum\limits_{i=1}^N\lambda_i-\sum\limits_{i=1}^N\lambda_iy_iw^Tx_i
\]</span><br>
所以：<br>
<span class="math display">\[
\frac{\partial}{\partial w}L=0\Rightarrow w=\sum\limits_{i=1}^N\lambda_iy_ix_i
\]</span></p></li>
<li><p>将上面两个参数代入：<br>
<span class="math display">\[
L(w,b,\lambda_i)=-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i
\]</span></p></li>
</ul>
<p>因此，对偶问题就是：<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span><br>
从 KKT 条件得到超平面的参数：</p>
<blockquote>
<p>原问题和对偶问题满足强对偶关系的充要条件为其满足 KKT 条件：<br>
<span class="math display">\[
  \begin{align*}
  &amp;\frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0
  \\&amp;\lambda_k(1-y_k(w^Tx_k+b))=0(slackness\ complementary)\\
  &amp;\lambda_i\ge0\\
  &amp;1-y_i(w^Tx_i+b)\le0
  \end{align*}
  \]</span></p>
</blockquote>
<p>根据这个条件就得到了对应的最佳参数：<br>
<span class="math display">\[
\begin{gather*}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)=0
\end{gather*}
\]</span><br>
于是这个超平面的参数 <span class="math inline">\(w\)</span> 就是数据点的线性组合，最终的参数值就是部分满足 <span class="math inline">\(y_i(w^Tx_i+b)=1\)</span>向量的线性组合（互补松弛条件给出），这些向量也叫支撑向量。</p>
<h2 id="soft-margin-svm">Soft-margin SVM</h2>
<p>Hard-margin 的 SVM 只对可分数据可解，如果不可分的情况，我们的基本想法是在损失函数中加入错误分类的可能性。错误分类的个数可以写成：<br>
<span class="math display">\[
error=\sum\limits_{i=1}^N\mathbb{I}\{y_i(w^Tx_i+b)\lt1\}
\]</span><br>
这个函数不连续，可以将其改写为：<br>
<span class="math display">\[
error=\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}
\]</span><br>
求和符号中的式子又叫做 Hinge Function。</p>
<p>将这个错误加入 Hard-margin SVM 中，于是：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,i=1,2,\cdots,N
\]</span><br>
这个式子中，常数 <span class="math inline">\(C\)</span> 可以看作允许的错误水平，同时上式为了进一步消除 <span class="math inline">\(\max\)</span> 符号，对数据集中的每一个观测，我们可以认为其大部分满足约束，但是其中部分违反约束，因此这部分约束变成 <span class="math inline">\(y_i(w^Tx+b)\ge1-\xi_i\)</span>，其中 <span class="math inline">\(\xi_i=1-y_i(w^Tx_i+b)\)</span>，进一步的化简：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\]</span></p>
<h2 id="kernel-method">Kernel Method</h2>
<p>核方法可以应用在很多问题上，在分类问题中，对于严格不可分问题，我们引入一个特征转换函数将原来的不可分的数据集变为可分的数据集，然后再来应用已有的模型。往往将低维空间的数据集变为高维空间的数据集后，数据会变得可分（数据变得更为稀疏）：</p>
<blockquote>
<p>Cover TH：高维空间比低维空间更易线性可分。</p>
</blockquote>
<p>应用在 SVM 中时，观察上面的 SVM 对偶问题：<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span><br>
在求解的时候需要求得内积，于是不可分数据在通过特征变换后，需要求得变换后的内积。我们常常很难求得变换函数的内积。于是直接引入内积的变换函数：<br>
<span class="math display">\[
\forall x,x&#39;\in\mathcal{X},\exists\phi\in\mathcal{H}:x\rightarrow z\ s.t.\ k(x,x&#39;)=\phi(x)^T\phi(x)
\]</span><br>
称 <span class="math inline">\(k(x,x&#39;)\)</span> 为一个正定核函数，其中<span class="math inline">\(\mathcal{H}\)</span> 是 Hilbert 空间（完备的线性内积空间），如果去掉内积这个条件我们简单地称为核函数。</p>
<blockquote>
<p><span class="math inline">\(k(x,x&#39;)=\exp(-\frac{(x-x&#39;)^2}{2\sigma^2})\)</span> 是一个核函数。</p>
<p>证明：<br>
<span class="math display">\[
  \begin{align*}
  \exp(-\frac{(x-x&#39;)^2}{2\sigma^2})&amp;=\exp(-\frac{x^2}{2\sigma^2})\exp(\frac{xx&#39;}{\sigma^2})\exp(-\frac{x&#39;^2}{2\sigma^2})\\
  &amp;=\exp(-\frac{x^2}{2\sigma^2})\sum\limits_{n=0}^{+\infty}\frac{x^nx&#39;^n}{\sigma^{2n}n!}\exp(-\frac{x&#39;^2}{2\sigma^2})\\
  &amp;=\exp(-\frac{x^2}{2\sigma^2})\varphi(x)\varphi(x&#39;)\exp(-\frac{x&#39;^2}{2\sigma^2})\\
  &amp;=\phi(x)\phi(x&#39;)
  \end{align*}
  \]</span></p>
</blockquote>
<p>正定核函数有下面的等价定义：</p>
<blockquote>
<p>如果核函数满足：</p>
<ol type="1">
<li>对称性</li>
<li>正定性</li>
</ol>
<p>那么这个核函数时正定核函数。</p>
<p>证明：</p>
<ol type="1">
<li>对称性 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(k(x,z)=k(z,x)\)</span>，显然满足内积的定义</li>
<li>正定性 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall N,x_1,x_2,\cdots,x_N\in\mathcal{X}\)</span>，对应的 Gram Matrix <span class="math inline">\(K=[k(x_i,x_j)]\)</span> 是半正定的。</li>
</ol>
<p>要证：<span class="math inline">\(k(x,z)=\phi(x)^T\phi(z)\Leftrightarrow K\)</span> 半正定+对称性。</p>
<ol type="1">
<li><p><span class="math inline">\(\Rightarrow\)</span>：首先，对称性是显然的，对于正定性：<br>
<span class="math display">\[
K=\begin{pmatrix}k(x_1,x_2)&amp;\cdots&amp;k(x_1,x_N)\\\vdots&amp;\vdots&amp;\vdots\\k(x_N,x_1)&amp;\cdots&amp;k(x_N,x_N)\end{pmatrix}
\]</span><br>
任意取 <span class="math inline">\(\alpha\in\mathbb{R}^N\)</span>，即需要证明 <span class="math inline">\(\alpha^TK\alpha\ge0\)</span>：<br>
<span class="math display">\[
\alpha^TK\alpha=\sum\limits_{i,j}\alpha_i\alpha_jK_{ij}=\sum\limits_{i,j}\alpha_i\phi^T(x_i)\phi(x_j)\alpha_j=\sum\limits_{i}\alpha_i\phi^T(x_i)\sum\limits_{j}\alpha_j\phi(x_j)
\]</span><br>
这个式子就是内积的形式，Hilbert 空间满足线性性，于是正定性的证。</p></li>
<li><p><span class="math inline">\(\Leftarrow\)</span>：对于 <span class="math inline">\(K\)</span> 进行分解，对于对称矩阵 <span class="math inline">\(K=V\Lambda V^T\)</span>，那么令 <span class="math inline">\(\phi(x_i)=\sqrt{\lambda_i}V_i\)</span>，其中 <span class="math inline">\(V_i\)</span>是特征向量，于是就构造了 <span class="math inline">\(k(x,z)=\sqrt{\lambda_i\lambda_j}V_i^TV_j\)</span></p></li>
</ol>
</blockquote>
<h2 id="小结-4">小结</h2>
<p>分类问题在很长一段时间都依赖 SVM，对于严格可分的数据集，Hard-margin SVM 选定一个超平面，保证所有数据到这个超平面的距离最大，对这个平面施加约束，固定 <span class="math inline">\(y_i(w^Tx_i+b)=1\)</span>，得到了一个凸优化问题并且所有的约束条件都是仿射函数，于是满足 Slater 条件，将这个问题变换成为对偶的问题，可以得到等价的解，并求出约束参数：<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span><br>
对需要的超平面参数的求解采用强对偶问题的 KKT 条件进行。<br>
<span class="math display">\[
\begin{align*}
&amp;\frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0
\\&amp;\lambda_k(1-y_k(w^Tx_k+b))=0(slackness\ complementary)\\
&amp;\lambda_i\ge0\\
&amp;1-y_i(w^Tx_i+b)\le0
\end{align*}
\]</span><br>
解就是：<br>
<span class="math display">\[
\begin{gather*}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)=0
\end{gather*}
\]</span><br>
当允许一点错误的时候，可以在 Hard-margin SVM 中加入错误项。用 Hinge Function 表示错误项的大小，得到：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\]</span><br>
对于完全不可分的问题，我们采用特征转换的方式，在 SVM 中，我们引入正定核函数来直接对内积进行变换，只要这个变换满足对称性和正定性，那么就可以用做核函数。</p>
<h1 id="指数族分布">指数族分布</h1>
<p>指数族是一类分布，包括高斯分布、伯努利分布、二项分布、泊松分布、Beta 分布、Dirichlet 分布、Gamma 分布等一系列分布。指数族分布可以写为统一的形式：<br>
<span class="math display">\[
p(x|\eta)=h(x)\exp(\eta^T\phi(x)-A(\eta))=\frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))
\]</span><br>
其中，<span class="math inline">\(\eta\)</span> 是参数向量，<span class="math inline">\(A(\eta)\)</span> 是对数配分函数（归一化因子）。</p>
<p>在这个式子中，$ (x)$ 叫做充分统计量，包含样本集合所有的信息，例如高斯分布中的均值和方差。充分统计量在在线学习中有应用，对于一个数据集，只需要记录样本的充分统计量即可。</p>
<p>对于一个模型分布假设（似然），那么我们在求解中，常常需要寻找一个共轭先验，使得先验与后验的形式相同，例如选取似然是二项分布，可取先验是 Beta 分布，那么后验也是 Beta 分布。指数族分布常常具有共轭的性质，于是我们在模型选择以及推断具有很大的便利。</p>
<p>共轭先验的性质便于计算，同时，指数族分布满足最大熵的思想（无信息先验），也就是说对于经验分布利用最大熵原理导出的分布就是指数族分布。</p>
<p>观察到指数族分布的表达式类似线性模型，事实上，指数族分布很自然地导出广义线性模型：<br>
<span class="math display">\[
\begin{gather*}
y=f(w^Tx)\\
y|x\sim Exp Family
\end{gather*}
\]</span><br>
在更复杂的概率图模型中，例如在无向图模型中如受限玻尔兹曼机中，指数族分布也扮演着重要作用。</p>
<p>在推断的算法中，例如变分推断中，指数族分布也会大大简化计算。</p>
<h2 id="一维高斯分布">一维高斯分布</h2>
<p>一维高斯分布可以写成：<br>
<span class="math display">\[
p(x|\theta)=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2\sigma^2})
\]</span><br>
将这个式子改写：<br>
<span class="math display">\[
\begin{gather*}
\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{1}{2\sigma^2}(x^2-2\mu x+\mu^2))\\
=\exp(\log(2\pi\sigma^2)^{-1/2})\exp(-\frac{1}{2\sigma^2}\begin{pmatrix}-2\mu&amp;1\end{pmatrix}\begin{pmatrix}x\\x^2\end{pmatrix}-\frac{\mu^2}{2\sigma^2})
\end{gather*}
\]</span><br>
所以：<br>
<span class="math display">\[
\eta=\begin{pmatrix}\frac{\mu}{\sigma^2}\\-\frac{1}{2\sigma^2}\end{pmatrix}=\begin{pmatrix}\eta_1\\\eta_2\end{pmatrix}
\]</span><br>
于是 <span class="math inline">\(A(\eta)\)</span>：<br>
<span class="math display">\[
A(\eta)=-\frac{\eta_1^2}{4\eta_2}+\frac{1}{2}\log(-\frac{\pi}{\eta_2})
\]</span></p>
<h2 id="充分统计量和对数配分函数的关系">充分统计量和对数配分函数的关系</h2>
<p>对概率密度函数求积分：<br>
<span class="math display">\[
\begin{align*}
\exp(A(\eta))&amp;=\int h(x)\exp(\eta^T\phi(x))dx
\end{align*}
\]</span><br>
两边对参数求导：<br>
<span class="math display">\[
\exp(A(\eta))A&#39;(\eta)=\int h(x)\exp(\eta^T\phi(x))\phi(x)dx\\
\Longrightarrow A&#39;(\eta)=\mathbb{E}_{p(x|\eta)}[\phi(x)]
\]</span><br>
类似的：<br>
<span class="math display">\[
A&#39;&#39;(\eta)=Var_{p(x|\eta)}[\phi(x)]
\]</span><br>
由于方差为正，于是 <span class="math inline">\(A(\eta)\)</span> 一定是凸函数。</p>
<h2 id="充分统计量和极大似然估计">充分统计量和极大似然估计</h2>
<p>对于独立全同采样得到的数据集 <span class="math inline">\(\mathcal{D}=\{x_1,x_2,\cdots,x_N\}\)</span>。<br>
<span class="math display">\[
\begin{align*}
\eta_{MLE}&amp;=\mathop{argmax}_\eta\sum\limits_{i=1}^N\log p(x_i|\eta)\\
&amp;=\mathop{argmax}_\eta\sum\limits_{i=1}^N(\eta^T\phi(x_i)-A(\eta))\\
&amp;\Longrightarrow A&#39;(\eta_{MLE})=\frac{1}{N}\sum\limits_{i=1}^N\phi(x_i)
\end{align*}
\]</span><br>
由此可以看到，为了估算参数，只需要知道充分统计量就可以了。</p>
<h2 id="最大熵">最大熵</h2>
<p>信息熵记为：<br>
<span class="math display">\[
Entropy=\int-p(x)\log(p(x))dx
\]</span></p>
<blockquote>
<p>一般地，对于完全随机的变量（等可能），信息熵最大。</p>
<p>我们的假设为最大熵原则，假设数据是离散分布的，<span class="math inline">\(k\)</span> 个特征的概率分别为 <span class="math inline">\(p_k\)</span>，最大熵原理可以表述为：<br>
<span class="math display">\[
   \max\{H(p)\}=\min\{\sum\limits_{k=1}^Kp_k\log p_k\}\ s.t.\ \sum\limits_{k=1}^Kp_k=1
   \]</span><br>
利用 Lagrange 乘子法：<br>
<span class="math display">\[
   L(p,\lambda)=\sum\limits_{k=1}^Kp_k\log p_k+\lambda(1-\sum\limits_{k=1}^Kp_k)
   \]</span><br>
于是可得：<br>
<span class="math display">\[
   p_1=p_2=\cdots=p_K=\frac{1}{K}
   \]</span><br>
因此等可能的情况熵最大。</p>
</blockquote>
<p>一个数据集 <span class="math inline">\(\mathcal{D}\)</span>，在这个数据集上的经验分布为 <span class="math inline">\(\hat{p}(x)=\frac{Count(x)}{N}\)</span>，实际不可能满足所有的经验概率相同，于是在上面的最大熵原理中还需要加入这个经验分布的约束。</p>
<p>对任意一个函数，经验分布的经验期望可以求得为：<br>
<span class="math display">\[
\mathbb{E}_{\hat{p}}[f(x)]=\Delta
\]</span><br>
于是：<br>
<span class="math display">\[
\max\{H(p)\}=\min\{\sum\limits_{k=1}^Np_k\log p_k\}\ s.t.\ \sum\limits_{k=1}^Np_k=1,\mathbb{E}_p[f(x)]=\Delta
\]</span><br>
Lagrange 函数为：<br>
<span class="math display">\[
L(p,\lambda_0,\lambda)=\sum\limits_{k=1}^Np_k\log p_k+\lambda_0(1-\sum\limits_{k=1}^Np_k)+\lambda^T(\Delta-\mathbb{E}_p[f(x)])
\]</span><br>
求导得到：<br>
<span class="math display">\[
\begin{gather*}
\frac{\partial}{\partial p(x)}L=\sum\limits_{k=1}^N(\log p(x)+1)-\sum\limits_{k=1}^N\lambda_0-\sum\limits_{k=1}^N\lambda^Tf(x)\\
\Longrightarrow\sum\limits_{k=1}^N\log p(x)+1-\lambda_0-\lambda^Tf(x)=0
\end{gather*}
\]</span><br>
由于数据集是任意的，对数据集求和也意味着求和项里面的每一项都是0：<br>
<span class="math display">\[
p(x)=\exp(\lambda^Tf(x)+\lambda_0-1)
\]</span><br>
这就是指数族分布。</p>
<h1 id="概率图模型">概率图模型</h1>
<p>概率图模型使用图的方式表示概率分布。为了在图中添加各种概率，首先总结一下随机变量分布的一些规则：<br>
<span class="math display">\[
\begin{align*}
&amp;Sum\ Rule:p(x_1)=\int p(x_1,x_2)dx_2\\
&amp;Product\ Rule:p(x_1,x_2)=p(x_1|x_2)p(x_2)\\
&amp;Chain\ Rule:p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{i+1,x_{i+2} \cdots}x_p)\\
&amp;Bayesian\ Rule:p(x_1|x_2)=\frac{p(x_2|x_1)p(x_1)}{p(x_2)}
\end{align*}
\]</span><br>
可以看到，在链式法则中，如果数据维度特别高，那么的采样和计算非常困难，我们需要在一定程度上作出简化，在朴素贝叶斯中，作出了条件独立性假设。在 Markov 假设中，给定数据的维度是以时间顺序出现的，给定当前时间的维度，那么下一个维度与之前的维度独立。在 HMM 中，采用了齐次 Markov 假设。在 Markov 假设之上，更一般的，加入条件独立性假设，对维度划分集合 <span class="math inline">\(A,B,C\)</span>，使得 <span class="math inline">\(X_A\perp X_B|X_C\)</span>。</p>
<p>概率图模型采用图的特点表示上述的条件独立性假设，节点表示随机变量，边表示条件概率。概率图模型可以分为三大理论部分：</p>
<ol type="1">
<li>表示：
<ol type="1">
<li>有向图（离散）：贝叶斯网络</li>
<li>高斯图（连续）：高斯贝叶斯和高斯马尔可夫网路</li>
<li>无向图（离散）：马尔可夫网络</li>
</ol></li>
<li>推断
<ol type="1">
<li>精确推断</li>
<li>近似推断
<ol type="1">
<li>确定性近似（如变分推断）</li>
<li>随机近似（如 MCMC）</li>
</ol></li>
</ol></li>
<li>学习
<ol type="1">
<li>参数学习
<ol type="1">
<li>完备数据</li>
<li>隐变量：E-M 算法</li>
</ol></li>
<li>结构学习</li>
</ol></li>
</ol>
<h2 id="有向图-贝叶斯网络">有向图-贝叶斯网络</h2>
<p>已知联合分布中，各个随机变量之间的依赖关系，那么可以通过拓扑排序（根据依赖关系）可以获得一个有向图。而如果已知一个图，也可以直接得到联合概率分布的因子分解：<br>
<span class="math display">\[
p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{parent(i)})
\]</span><br>
那么实际的图中条件独立性是如何体现的呢？在局部任何三个节点，可以有三种结构：</p>
<ol type="1">
<li></li>
</ol>
<p><pre class="mermaid"> graph TB;<br>
A((A))--&gt;B((B));<br>
B--&gt;C((C));</pre></p>
<p><span class="math display">\[
   \begin{gather*}
   p(A,B,C)=p(A)p(B|A)p(C|B)=p(A)p(B|A)p(C|B,A)\\
   \Longrightarrow p(C|B)=p(C|B,A)\\
   \Leftrightarrow p(C|B)p(A|B)=p(C|A,B)p(A|B)=p(C,A|B)\\
   \Longrightarrow C\perp A|B
   \end{gather*}
   \]</span></p>
<ol start="2" type="1">
<li></li>
</ol>
<p><pre class="mermaid"> graph TB;<br>
B((B))--&gt;A((A));<br>
B--&gt;C((C));</pre></p>
<p><span class="math display">\[
   \begin{gather*}
   p(A,B,C)=p(A|B)p(B)p(C|B)=p(B)p(A|B)p(C|A,B)\\
   \Longrightarrow p(C|B)=p(C|B,A)\\
   \Leftrightarrow p(C|B)p(A|B)=p(C|A,B)p(A|B)=p(C,A|B)\\
   \Longrightarrow C\perp A|B
   \end{gather*}
   \]</span></p>
<ol start="3" type="1">
<li></li>
</ol>
<p><pre class="mermaid"> graph TB;<br>
A((A))--&gt;B((B));<br>
C((C))--&gt;B</pre></p>
<p><span class="math display">\[
   \begin{gather*}
   p(A,B,C)=p(A)p(C)p(B|C,A)=p(A)p(C|A)p(B|C,A)\\
   \Longrightarrow p(C)=p(C|A)\\
   \Leftrightarrow C\perp A\\
   \end{gather*}
   \]</span></p>
<p>对这种结构，<span class="math inline">\(A,C\)</span> 不与 <span class="math inline">\(B\)</span> 条件独立。</p>
<p>从整体的图来看，可以引入 D 划分的概念。对于类似上面图 1和图 2的关系，引入集合A，B，那么满足 <span class="math inline">\(A\perp B|C\)</span> 的 <span class="math inline">\(C\)</span> 集合中的点与 <span class="math inline">\(A,B\)</span> 中的点的关系都满足图 1，2，满足图3 关系的点都不在 <span class="math inline">\(C\)</span> 中。D 划分应用在贝叶斯定理中：<br>
<span class="math display">\[
p(x_i|x_{-i})=\frac{p(x)}{\int p(x)dx_{i}}=\frac{\prod\limits_{j=1}^pp(x_j|x_{parents(j)})}{\int\prod\limits_{j=1}^pp(x_j|x_{parents(j)})dx_i}
\]</span><br>
可以发现，上下部分可以分为两部分，一部分是和 <span class="math inline">\(x_i\)</span> 相关的，另一部分是和 <span class="math inline">\(x_i\)</span> 无关的，而这个无关的部分可以相互约掉。于是计算只涉及和 <span class="math inline">\(x_i\)</span> 相关的部分。</p>
<p>与 <span class="math inline">\(x_i\)</span> 相关的部分可以写成：<br>
<span class="math display">\[
p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)
\]</span><br>
这些相关的部分又叫做 Markov 毯。</p>
<p>实际应用的模型中，对这些条件独立性作出了假设，从单一到混合，从有限到无限（时间，空间）可以分为：</p>
<ol type="1">
<li>朴素贝叶斯，单一的条件独立性假设 <span class="math inline">\(p(x|y)=\prod\limits_{i=1}^pp(x_i|y)\)</span>，在 D 划分后，所有条件依赖的集合就是单个元素。</li>
<li>高斯混合模型：混合的条件独立。引入多类别的隐变量 <span class="math inline">\(z_1, z_2,\cdots,z_k\)</span>， <span class="math inline">\(p(x|z)=\mathcal{N}(\mu,\Sigma)\)</span>，条件依赖集合为多个元素。</li>
<li>与时间相关的条件依赖
<ol type="1">
<li>Markov 链</li>
<li>高斯过程（无限维高斯分布）</li>
</ol></li>
<li>连续：高斯贝叶斯网络</li>
<li>组合上面的分类
<ul>
<li>GMM 与时序结合：动态模型
<ul>
<li>HMM（离散）</li>
<li>线性动态系统 LDS（Kalman 滤波）</li>
<li>粒子滤波（非高斯，非线性）</li>
</ul></li>
</ul></li>
</ol>
<h2 id="无向图-马尔可夫网络马尔可夫随机场">无向图-马尔可夫网络（马尔可夫随机场）</h2>
<p>无向图没有了类似有向图的局部不同结构，在马尔可夫网络中，也存在 D 划分的概念。直接将条件独立的集合 <span class="math inline">\(x_A\perp x_B|x_C\)</span> 划分为三个集合。这个也叫全局 Markov。对局部的节点，<span class="math inline">\(x\perp (X-Neighbour(\mathcal{x}))|Neighbour(x)\)</span>。这也叫局部 Markov。对于成对的节点：<span class="math inline">\(x_i\perp x_j|x_{-i-j}\)</span>，其中 <span class="math inline">\(i,j\)</span> 不能相邻。这也叫成对 Markov。事实上上面三个点局部全局成对是相互等价的。</p>
<p>有了这个条件独立性的划分，还需要因子分解来实际计算。引入团的概念：</p>
<blockquote>
<p>团，最大团：图中节点的集合，集合中的节点之间相互都是连接的叫做团，如果不能再添加节点，那么叫最大团。</p>
</blockquote>
<p>利用这个定义进行的 <span class="math inline">\(x\)</span> 所有维度的联合概率分布的因子分解为，假设有 <span class="math inline">\(K\)</span> 个团，<span class="math inline">\(Z\)</span> 就是对所有可能取值求和：<br>
<span class="math display">\[
\begin{align*}p(x)=\frac{1}{Z}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
Z=\sum\limits_{x\in\mathcal{X}}\prod\limits_{i=1}^{K}\phi(x_{ci})
\end{align*}
\]</span><br>
其中 <span class="math inline">\(\phi(x_{ci})\)</span> 叫做势函数，它必须是一个正值，可以记为：<br>
<span class="math display">\[
\phi(x_{ci})=\exp(-E(x_{ci}))
\]</span><br>
这个分布叫做 Gibbs 分布（玻尔兹曼分布）。于是也可以记为：<span class="math inline">\(p(x)=\frac{1}{Z}\exp(-\sum\limits_{i=1}^KE(x_{ci}))\)</span>。这个分解和条件独立性等价（Hammesley-Clifford 定理），这个分布的形式也和指数族分布形式上相同，于是满足最大熵原理。</p>
<h2 id="两种图的转换-道德图">两种图的转换-道德图</h2>
<p>我们常常想将有向图转为无向图，从而应用更一般的表达式。</p>
<ol type="1">
<li><p>链式：</p>
<pre class="mermaid">   graph TB;
 A((A))-->B((B));
 B-->C((C));</pre>
<p>直接去掉箭头，<span class="math inline">\(p(a,b,c)=p(a)p(b|a)p(c|b)=\phi(a,b)\phi(b,c)\)</span>：</p>
<pre class="mermaid">   graph TB;
 A((A))---B((B));
 B---C((C));</pre></li>
<li><p>V 形：</p>
<pre class="mermaid">   graph TB;
 B((B))-->A((A));
 B-->C((C));</pre>
<p>由于 <span class="math inline">\(p(a,b,c)=p(b)p(a|b)p(c|b)=\phi(a,b)\phi(b,c)\)</span>，直接去掉箭头：</p>
<pre class="mermaid">   graph TB;
 B((B))---A((A));
 B---C((C));</pre></li>
<li><p>倒 V 形：</p>
<pre class="mermaid">   graph TB;
 A((A))-->B((B));
 C((C))-->B</pre>
<p>由于 <span class="math inline">\(p(a,b,c)=p(a)p(c)p(b|a,c)=\phi(a,b,c)\)</span>，于是在 <span class="math inline">\(a,c\)</span> 之间添加线：</p>
<pre class="mermaid">   graph TD;
 a((a))---b((b));
 b---c((c));
 a---c;</pre>
<p>观察着三种情况可以概括为：</p>
<ol type="1">
<li>将每个节点的父节点两两相连</li>
<li>将有向边替换为无向边</li>
</ol></li>
</ol>
<h2 id="更精细的分解-因子图">更精细的分解-因子图</h2>
<p>对于一个有向图，可以通过引入环的方式，可以将其转换为无向图（Tree-like graph），这个图就叫做道德图。但是我们上面的 BP 算法只对无环图有效，通过因子图可以变为无环图。</p>
<p>考虑一个无向图：</p>
<pre class="mermaid">graph TD;
    a((a))---b((b));
    b---c((c));
    a---c;</pre>
<p>可以将其转为：</p>
<pre class="mermaid">graph TD;
    a((a))---f;
    f---b((b));
    f---c((c))</pre>
<p>其中 <span class="math inline">\(f=f(a,b,c)\)</span>。因子图不是唯一的，这是由于因式分解本身就对应一个特殊的因子图，将因式分解：<span class="math inline">\(p(x)=\prod\limits_{s}f_s(x_s)\)</span> 可以进一步分解得到因子图。</p>
<h2 id="推断">推断</h2>
<p>推断的主要目的是求各种概率分布，包括边缘概率，条件概率，以及使用 MAP 来求得参数。通常推断可以分为：</p>
<ol type="1">
<li>精确推断
<ol type="1">
<li>Variable Elimination(VE)</li>
<li>Belief Propagation(BP, Sum-Product Algo)，从 VE 发展而来</li>
<li>Junction Tree，上面两种在树结构上应用，Junction Tree 在图结构上应用</li>
</ol></li>
<li>近似推断
<ol type="1">
<li>Loop Belief Propagation（针对有环图）</li>
<li>Mente Carlo Interference：例如 Importance Sampling，MCMC</li>
<li>Variational Inference</li>
</ol></li>
</ol>
<h3 id="推断-变量消除ve">推断-变量消除（VE）</h3>
<p>变量消除的方法是在求解概率分布的时候，将相关的条件概率先行求和或积分，从而一步步地消除变量，例如在马尔可夫链中：</p>
<pre class="mermaid">graph LR;
    a((a))-->b((b));
    b-->c((c));
    c-->d((d))</pre>
<p><span class="math display">\[
p(d)=\sum\limits_{a,b,c}p(a,b,c,d)=\sum\limits_cp(d|c)\sum\limits_bp(c|b)\sum\limits_ap(b|a)p(a)
\]</span></p>
<p>变量消除的缺点很明显：</p>
<ol type="1">
<li>计算步骤无法存储</li>
<li>消除的最优次序是一个 NP-hard 问题</li>
</ol>
<h3 id="推断-信念传播bp">推断-信念传播（BP）</h3>
<p>为了克服 VE 的第一个缺陷-计算步骤无法存储。我们进一步地对上面的马尔可夫链进行观察：</p>
<pre class="mermaid">graph LR;
    a((a))-->b((b));
    b-->c((c));
    c-->d((d));
    d-->e((e));</pre>
<p>要求 <span class="math inline">\(p(e)\)</span>，当然使用 VE，从 <span class="math inline">\(a\)</span> 一直消除到 <span class="math inline">\(d\)</span>，记 <span class="math inline">\(\sum\limits_ap(a)p(b|a)=m_{a\to b(b)}\)</span>，表示这是消除 <span class="math inline">\(a\)</span> 后的关于 <span class="math inline">\(b\)</span> 的概率，类似地，记 <span class="math inline">\(\sum\limits_bp(c|b)m_{a\to b}(b)=m_{b\to c}(c)\)</span>。于是 <span class="math inline">\(p(e)=\sum\limits_dp(e|d)m_{b\to c}(c)\)</span>。进一步观察，对 <span class="math inline">\(p(c)\)</span>：<br>
<span class="math display">\[
p(c)=[\sum\limits_bp(c|b)\sum\limits_ap(b|a)p(a)]\cdot[\sum\limits_dp(d|c)\sum\limits_ep(e)p(e|d)]
\]</span><br>
我们发现了和上面计算 <span class="math inline">\(p(e)\)</span> 类似的结构，这个式子可以分成两个部分，一部分是从 <span class="math inline">\(a\)</span> 传播过来的概率，第二部分是从 $ e$ 传播过来的概率。</p>
<p>一般地，对于图（只对树形状的图）：</p>
<pre class="mermaid">graph TD;
    a((a))---b((b));
    b---c((c));
    b---d((d));</pre>
<p>这四个团（对于无向图是团，对于有向图就是概率为除了根的节点为1），有四个节点，三个边：<br>
<span class="math display">\[
p(a,b,c,d)=\frac{1}{Z}\phi_a(a)\phi_b(b)\phi_c(c)\phi_d(d)\cdot\phi_{ab}(a,b)\phi_{bc}(c,b)\phi_{bd}(d,b)
\]</span><br>
套用上面关于有向图的观察，如果求解边缘概率 <span class="math inline">\(p(a)\)</span>，定义 <span class="math inline">\(m_{c\to b}(b)=\sum\limits_c\phi_c(c)\phi_{bc}(bc)\)</span>，<span class="math inline">\(m_{d\to b}(b)=\sum\limits_d\phi_d(d)\phi_{bd}(bd)\)</span>，<span class="math inline">\(m_{b\to a}(a)=\sum\limits_b\phi_{ba}(ba)\phi_b(b)m_{c\to b}(b)_{d\to b}m(b)\)</span>，这样概率就一步步地传播到了 <span class="math inline">\(a\)</span>：<br>
<span class="math display">\[
p(a)=\phi_a(a)m_{b\to a}(a)
\]</span><br>
写成一般的形式，对于相邻节点 <span class="math inline">\(i,j\)</span>：<br>
<span class="math display">\[
m_{j\to i}(i)=\sum\limits_j\phi_j(j)\phi_{ij}(ij)\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}(j)
\]</span><br>
这个表达式，就可以保存计算过程了，只要对每条边的传播分别计算，对于一个无向树形图可以递归并行实现：</p>
<ol type="1">
<li>任取一个节点 <span class="math inline">\(a\)</span> 作为根节点</li>
<li>对这个根节点的邻居中的每一个节点，收集信息（计算入信息）</li>
<li>对根节点的邻居，分发信息（计算出信息）</li>
</ol>
<h3 id="推断-max-product-算法">推断-Max-Product 算法</h3>
<p>在推断任务中，MAP 也是常常需要的，MAP 的目的是寻找最佳参数：<br>
<span class="math display">\[
(\hat{a},\hat{b},\hat{c},\hat{d})=\mathop{argmax}_{a,b,c,d}p(a,b,c,d|E)
\]</span><br>
类似 BP，我们采用信息传递的方式来求得最优参数，不同的是，我们在所有信息传递中，传递的是最大化参数的概率，而不是将所有可能求和：<br>
<span class="math display">\[
m_{j\to i}=\max\limits_{j}\phi_j\phi_{ij}\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}
\]</span><br>
于是对于上面的图：<br>
<span class="math display">\[
\max_a p(a,b,c,d)=\max_a\phi_a\phi_{ab}m_{c\to b}m_{d\to b}
\]</span><br>
这个算法是 Sum-Product 算法的改进，也是在 HMM 中应用给的 Viterbi 算法的推广。</p>
<h1 id="期望最大">期望最大</h1>
<p>期望最大算法的目的是解决具有隐变量的混合模型的参数估计（极大似然估计）。MLE 对 <span class="math inline">\(p(x|\theta)\)</span> 参数的估计记为：<span class="math inline">\(\theta_{MLE}=\mathop{argmax}\limits_\theta\log p(x|\theta)\)</span>。EM 算法对这个问题的解决方法是采用迭代的方法：<br>
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz=\mathbb{E}_{z|x,\theta^t}[\log p(x,z|\theta)]
\]</span><br>
这个公式包含了迭代的两步：</p>
<ol type="1">
<li>E step：计算 <span class="math inline">\(\log p(x,z|\theta)\)</span> 在概率分布 <span class="math inline">\(p(z|x,\theta^t)\)</span> 下的期望</li>
<li>M step：计算使这个期望最大化的参数得到下一个 EM 步骤的输入</li>
</ol>
<blockquote>
<p>求证：<span class="math inline">\(\log p(x|\theta^t)\le\log p(x|\theta^{t+1})\)</span></p>
<p>证明：<span class="math inline">\(\log p(x|\theta)=\log p(z,x|\theta)-\log p(z|x,\theta)\)</span>，对左右两边求积分：<br>
<span class="math display">\[
  Left:\int_zp(z|x,\theta^t)\log p(x|\theta)dz=\log p(x|\theta)
  \]</span></p>
<p><span class="math display">\[
  Right:\int_zp(z|x,\theta^t)\log p(x,z|\theta)dz-\int_zp(z|x,\theta^t)\log p(z|x,\theta)dz=Q(\theta,\theta^t)-H(\theta,\theta^t)
  \]</span></p>
<p>所以：<br>
<span class="math display">\[
  \log p(x|\theta)=Q(\theta,\theta^t)-H(\theta,\theta^t)
  \]</span><br>
由于 <span class="math inline">\(Q(\theta,\theta^t)=\int_zp(z|x,\theta^t)\log p(x,z|\theta)dz\)</span>，而 <span class="math inline">\(\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz\)</span>，所以 <span class="math inline">\(Q(\theta^{t+1},\theta^t)\ge Q(\theta^t,\theta^t)\)</span>。要证 <span class="math inline">\(\log p(x|\theta^t)\le\log p(x|\theta^{t+1})\)</span>，需证：<span class="math inline">\(H(\theta^t,\theta^t)\ge H(\theta^{t+1},\theta^t)\)</span>：<br>
<span class="math display">\[
  \begin{align*}H(\theta^{t+1},\theta^t)-H(\theta^{t},\theta^t)&amp;=\int_zp(z|x,\theta^{t})\log p(z|x,\theta^{t+1})dz-\int_zp(z|x,\theta^t)\log p(z|x,\theta^{t})dz\\
  &amp;=\int_zp(z|x,\theta^t)\log\frac{p(z|x,\theta^{t+1})}{p(z|x,\theta^t)}=-KL(p(z|x,\theta^t),p(z|x,\theta^{t+1}))\le0
  \end{align*}
  \]</span><br>
综合上面的结果：<br>
<span class="math display">\[
  \log p(x|\theta^t)\le\log p(x|\theta^{t+1})
  \]</span></p>
</blockquote>
<p>根据上面的证明，我们看到，似然函数在每一步都会增大。进一步的，我们看 EM 迭代过程中的式子是怎么来的：<br>
<span class="math display">\[
\log p(x|\theta)=\log p(z,x|\theta)-\log p(z|x,\theta)=\log \frac{p(z,x|\theta)}{q(z)}-\log \frac{p(z|x,\theta)}{q(z)}
\]</span><br>
分别对两边求期望 <span class="math inline">\(\mathbb{E}_{q(z)}\)</span>：<br>
<span class="math display">\[
\begin{align*}
&amp;Left:\int_zq(z)\log p(x|\theta)dz=\log p(x|\theta)\\
&amp;Right:\int_zq(z)\log \frac{p(z,x|\theta)}{q(z)}dz-\int_zq(z)\log \frac{p(z|x,\theta)}{q(z)}dz=ELBO+KL(q(z),p(z|x,\theta))
\end{align*}
\]</span><br>
上式中，Evidence Lower Bound(ELBO)，是一个下界，所以 <span class="math inline">\(\log p(x|\theta)\ge ELBO\)</span>，等于号取在 KL 散度为0是，即：<span class="math inline">\(q(z)=p(z|x,\theta)\)</span>，EM 算法的目的是将 ELBO 最大化，根据上面的证明过程，在每一步 EM 后，求得了最大的ELBO，并根据这个使 ELBO 最大的参数代入下一步中：<br>
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_{\theta}ELBO=\mathop{argmax}_\theta\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz
\]</span><br>
由于 $ q(z)=p(z|x,^t)$ 的时候，这一步的最大值才能取等号，所以：<br>
<span class="math display">\[
\begin{gather*}
\hat{\theta}=\mathop{argmax}_{\theta}ELBO=\mathop{argmax}_\theta\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz=\mathop{argmax}_\theta\int_zp(z|x,\theta^t)\log\frac{p(x,z|\theta)}{p(z|x,\theta^t)}d z\\
=\mathop{argmax}_\theta\int_z p(z|x,\theta^t)\log p(x,z|\theta)
\end{gather*}
\]</span><br>
这个式子就是上面 EM 迭代过程中的式子。</p>
<p>从 Jensen 不等式出发，也可以导出这个式子：<br>
<span class="math display">\[
\begin{gather*}
\log p(x|\theta)=\log\int_zp(x,z|\theta)dz=\log\int_z\frac{p(x,z|\theta)q(z)}{q(z)}dz\\
=\log \mathbb{E}_{q(z)}[\frac{p(x,z|\theta)}{q(z)}]\ge \mathbb{E}_{q(z)}[\log\frac{p(x,z|\theta)}{q(z)}]
\end{gather*}
\]</span><br>
其中，右边的式子就是 ELBO，等号在 $ p(x,z|)=Cq(z)$ 时成立。于是：<br>
<span class="math display">\[
\begin{gather*}
\int_zq(z)dz=\frac{1}{C}\int_zp(x,z|\theta)dz=\frac{1}{C}p(x|\theta)=1\\
\Rightarrow q(z)=\frac{1}{p(x|\theta)}p(x,z|\theta)=p(z|x,\theta)
\end{gather*}
\]</span><br>
我们发现，这个过程就是上面的最大值取等号的条件。</p>
<h2 id="广义-em">广义 EM</h2>
<p>EM 模型解决了概率生成模型的参数估计的问题，通过引入隐变量 <span class="math inline">\(z\)</span>，来学习 <span class="math inline">\(\theta\)</span>，具体的模型对 <span class="math inline">\(z\)</span> 有不同的假设。对学习任务 <span class="math inline">\(p(x|\theta)\)</span>，就是学习任务 <span class="math inline">\(\frac{p(x,z|\theta)}{p(z|x,\theta)}\)</span>。在这个式子中，我们假定了在 E 步骤中，<span class="math inline">\(q(z)=p(z|x,\theta)\)</span>，但是这个<span class="math inline">\(p(z|x,\theta)\)</span> 如果无法求解，那么必须使用采样（MCMC）或者变分推断等方法来近似推断这个后验。我们观察 KL 散度的表达式，为了最大化 ELBO，在固定的 <span class="math inline">\(\theta\)</span> 时，我们需要最小化 KL 散度，于是：<br>
<span class="math display">\[
\hat{q}(z)=\mathop{argmin}_qKL(p,q)=\mathop{argmax}_qELBO
\]</span><br>
这就是广义 EM 的基本思路：</p>
<ol type="1">
<li><p>E step：<br>
<span class="math display">\[
\hat{q}^{t+1}(z)=\mathop{argmax}_q\int_zq^t(z)\log\frac{p(x,z|\theta)}{q^t(z)}dz,fixed\ \theta
\]</span></p></li>
<li><p>M step：<br>
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_\theta \int_zq^{t+1}(z)\log\frac{p(x,z|\theta)}{q^{t+1}(z)}dz,fixed\ \hat{q}
\]</span></p></li>
</ol>
<p>对于上面的积分：<br>
<span class="math display">\[
ELBO=\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz=\mathbb{E}_{q(z)}[p(x,z|\theta)]+Entropy(q(z))
\]</span><br>
因此，我们看到，广义 EM 相当于在原来的式子中加入熵这一项。</p>
<h2 id="em-的推广">EM 的推广</h2>
<p>EM 算法类似于坐标上升法，固定部分坐标，优化其他坐标，再一遍一遍的迭代。如果在 EM 框架中，无法求解 <span class="math inline">\(z\)</span> 后验概率，那么需要采用一些变种的 EM 来估算这个后验。</p>
<ol type="1">
<li>基于平均场的变分推断，VBEM/VEM</li>
<li>基于蒙特卡洛的EM，MCEM</li>
</ol>
<h1 id="高斯混合模型">高斯混合模型</h1>
<p>为了解决高斯模型的单峰性的问题，我们引入多个高斯模型的加权平均来拟合多峰数据：<br>
<span class="math display">\[
p(x)=\sum\limits_{k=1}^K\alpha_k\mathcal{N}(\mu_k,\Sigma_k)
\]</span><br>
引入隐变量 <span class="math inline">\(z\)</span>，这个变量表示对应的样本 <span class="math inline">\(x\)</span> 属于哪一个高斯分布，这个变量是一个离散的随机变量：<br>
<span class="math display">\[
p(z=i)=p_i,\sum\limits_{i=1}^kp(z=i)=1
\]</span><br>
作为一个生成式模型，高斯混合模型通过隐变量 <span class="math inline">\(z\)</span> 的分布来生成样本。用概率图来表示：</p>
<pre class="mermaid">graph LR;
    z((z))-->x((x))</pre>
<p>其中，节点 <span class="math inline">\(z\)</span> 就是上面的概率，<span class="math inline">\(x\)</span> 就是生成的高斯分布。于是对 <span class="math inline">\(p(x)\)</span>：<br>
<span class="math display">\[
p(x)=\sum\limits_zp(x,z)=\sum\limits_{k=1}^Kp(x,z=k)=\sum\limits_{k=1}^Kp(z=k)p(x|z=k)
\]</span><br>
因此：<br>
<span class="math display">\[
p(x)=\sum\limits_{k=1}^Kp_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span></p>
<h2 id="极大似然估计">极大似然估计</h2>
<p>样本为 <span class="math inline">\(X=(x_1,x_2,\cdots,x_N)\)</span>，$ (X,Z)$ 为完全参数，参数为 <span class="math inline">\(\theta=\{p_1,p_2,\cdots,p_K,\mu_1,\mu_2,\cdots,\mu_K\Sigma_1,\Sigma_2,\cdots,\Sigma_K\}\)</span>。我们通过极大似然估计得到 <span class="math inline">\(\theta\)</span> 的值：<br>
<span class="math display">\[
\begin{align*}\theta_{MLE}&amp;=\mathop{argmax}\limits_{\theta}\log p(X)=\mathop{argmax}_{\theta}\sum\limits_{i=1}^N\log p(x_i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log \sum\limits_{k=1}^Kp_k\mathcal{N}(x_i|\mu_k,\Sigma_k)
\end{align*}
\]</span><br>
这个表达式直接通过求导，由于连加号的存在，无法得到解析解。因此需要使用 EM 算法。</p>
<h2 id="em-求解-gmm">EM 求解 GMM</h2>
<p>EM 算法的基本表达式为：<span class="math inline">\(\theta^{t+1}=\mathop{argmax}\limits_{\theta}\mathbb{E}_{z|x,\theta_t}[p(x,z|\theta)]\)</span>。套用 GMM 的表达式，对数据集来说：<br>
<span class="math display">\[
\begin{align*}Q(\theta,\theta^t)&amp;=\sum\limits_z[\log\prod\limits_{i=1}^Np(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_z[\sum\limits_{i=1}^N\log p(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)
\end{align*}
\]</span><br>
对于中间的那个求和号，展开，第一项为：<br>
<span class="math display">\[
\begin{align*}
\sum\limits_z\log p(x_1,z_1|\theta)\prod\limits_{i=1}^Np(z_i|x_i,\theta^t)&amp;=\sum\limits_z\log p(x_1,z_1|\theta)p(z_1|x_1,\theta^t)\prod\limits_{i=2}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{z_1}\log p(x_1,z_1|\theta)
p(z_1|x_1,\theta^t)\sum\limits_{z_2,\cdots,z_K}\prod\limits_{i=2}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{z_1}\log p(x_1,z_1|\theta)p(z_1|x_1,\theta^t)\end{align*}
\]</span><br>
类似地，<span class="math inline">\(Q\)</span> 可以写为：<br>
<span class="math display">\[
Q(\theta,\theta^t)=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p(x_i,z_i|\theta)p(z_i|x_i,\theta^t)
\]</span><br>
对于 <span class="math inline">\(p(x,z|\theta)\)</span>：<br>
<span class="math display">\[
p(x,z|\theta)=p(z|\theta)p(x|z,\theta)=p_z\mathcal{N}(x|\mu_z,\Sigma_z)
\]</span><br>
对 <span class="math inline">\(p(z|x,\theta^t)\)</span>：<br>
<span class="math display">\[
p(z|x,\theta^t)=\frac{p(x,z|\theta^t)}{p(x|\theta^t)}=\frac{p_z^t\mathcal{N}(x|\mu_z^t,\Sigma_z^t)}{\sum\limits_kp_k^t\mathcal{N}(x|\mu_k^t,\Sigma_k^t)}
\]</span><br>
代入 <span class="math inline">\(Q\)</span>：<br>
<span class="math display">\[
Q=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p_{z_i}\mathcal{N(x_i|\mu_{z_i},\Sigma_{z_i})}\frac{p_{z_i}^t\mathcal{N}(x_i|\mu_{z_i}^t,\Sigma_{z_i}^t)}{\sum\limits_kp_k^t\mathcal{N}(x_i|\mu_k^t,\Sigma_k^t)}
\]</span><br>
下面需要对 <span class="math inline">\(Q\)</span> 值求最大值：<br>
<span class="math display">\[
Q=\sum\limits_{k=1}^K\sum\limits_{i=1}^N[\log p_k+\log \mathcal{N}(x_i|\mu_k,\Sigma_k)]p(z_i=k|x_i,\theta^t)
\]</span></p>
<ol type="1">
<li><p><span class="math inline">\(p_k^{t+1}\)</span>：<br>
<span class="math display">\[
p_k^{t+1}=\mathop{argmax}_{p_k}\sum\limits_{k=1}^K\sum\limits_{i=1}^N[\log p_k+\log \mathcal{N}(x_i|\mu_k,\Sigma_k)]p(z_i=k|x_i,\theta^t)\ s.t.\ \sum\limits_{k=1}^Kp_k=1
\]</span><br>
即：<br>
<span class="math display">\[
p_k^{t+1}=\mathop{argmax}_{p_k}\sum\limits_{k=1}^K\sum\limits_{i=1}^N\log p_kp(z_i=k|x_i,\theta^t)\ s.t.\ \sum\limits_{k=1}^Kp_k=1
\]</span><br>
引入 Lagrange 乘子：<span class="math inline">\(L(p_k,\lambda)=\sum\limits_{k=1}^K\sum\limits_{i=1}^N\log p_kp(z_i=k|x_i,\theta^t)-\lambda(1-\sum\limits_{k=1}^Kp_k)\)</span>。所以：<br>
<span class="math display">\[
\begin{gather*}
\frac{\partial}{\partial p_k}L=\sum\limits_{i=1}^N\frac{1}{p_k}p(z_i=k|x_i,\theta^t)+\lambda=0\\
\Rightarrow \sum\limits_k\sum\limits_{i=1}^N\frac{1}{p_k}p(z_i=k|x_i,\theta^t)+\lambda\sum\limits_kp_k=0\\
\Rightarrow\lambda=-N
\end{gather*}
\]</span></p>
<p>于是有：<br>
<span class="math display">\[
p_k^{t+1}=\frac{1}{N}\sum\limits_{i=1}^Np(z_i=k|x_i,\theta^t)
\]</span></p></li>
<li><p><span class="math inline">\(\mu_k,\Sigma_k\)</span>，这两个参数是无约束的，直接求导即可。</p></li>
</ol>
<h1 id="变分推断">变分推断</h1>
<p>我们已经知道概率模型可以分为，频率派的优化问题和贝叶斯派的积分问题。从贝叶斯角度来看推断，对于 <span class="math inline">\(\hat{x}\)</span> 这样的新样本，需要得到：<br>
<span class="math display">\[
p(\hat{x}|X)=\int_\theta p(\hat{x},\theta|X)d\theta=\int_\theta p(\theta|X)p(\hat{x}|\theta,X)d\theta
\]</span><br>
如果新样本和数据集独立，那么推断就是概率分布依参数后验分布的期望。</p>
<p>我们看到，推断问题的中心是参数后验分布的求解，推断分为：</p>
<ol type="1">
<li>精确推断</li>
<li>近似推断-参数空间无法精确求解
<ol type="1">
<li>确定性近似-如变分推断</li>
<li>随机近似-如 MCMC，MH，Gibbs</li>
</ol></li>
</ol>
<h2 id="基于平均场假设的变分推断">基于平均场假设的变分推断</h2>
<p>我们记 <span class="math inline">\(Z\)</span> 为隐变量和参数的集合，<span class="math inline">\(Z_i\)</span> 为第 <span class="math inline">\(i\)</span> 维的参数，于是，回顾一下 EM 中的推导：<br>
<span class="math display">\[
\log p(X)=\log p(X,Z)-\log p(Z|X)=\log\frac{p(X,Z)}{q(Z)}-\log\frac{p(Z|X)}{q(Z)}
\]</span><br>
左右两边分别积分：<br>
<span class="math display">\[
\begin{gather*}
Left:\int_Zq(Z)\log p(X)dZ=\log p(X)\\
Right:\int_Z[\log \frac{p(X,Z)}{q(Z)}-\log \frac{p(Z|X)}{q(Z)}]q(Z)dZ=ELBO+KL(q,p)
\end{gather*}
\]</span><br>
第二个式子可以写为变分和 KL 散度的和：<br>
<span class="math display">\[
L(q)+KL(q,p)
\]</span><br>
由于这个式子是常数，于是寻找 <span class="math inline">\(q\simeq p\)</span> 就相当于对 <span class="math inline">\(L(q)\)</span> 最大值。<br>
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span><br>
假设 <span class="math inline">\(q(Z)\)</span> 可以划分为 <span class="math inline">\(M\)</span> 个组（平均场近似）：<br>
<span class="math display">\[
q(Z)=\prod\limits_{i=1}^Mq_i(Z_i)
\]</span><br>
因此，在 <span class="math inline">\(L(q)=\int_Zq(Z)\log p(X,Z)dZ-\int_Zq(Z)\log{q(Z)}\)</span> 中，看 <span class="math inline">\(p(Z_j)\)</span> ，第一项：<br>
<span class="math display">\[
\begin{align*}\int_Zq(Z)\log p(X,Z)dZ&amp;=\int_Z\prod\limits_{i=1}^Mq_i(Z_i)\log p(X,Z)dZ\\
&amp;=\int_{Z_j}q_j(Z_j)\int_{Z-Z_{j}}\prod\limits_{i\ne j}q_i(Z_i)\log p(X,Z)dZ\\
&amp;=\int_{Z_j}q_j(Z_j)\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]dZ_j
\end{align*}
\]</span></p>
<p>第二项：<br>
<span class="math display">\[
\int_Zq(Z)\log q(Z)dZ=\int_Z\prod\limits_{i=1}^Mq_i(Z_i)\sum\limits_{i=1}^M\log q_i(Z_i)dZ
\]</span><br>
展开求和项第一项为：<br>
<span class="math display">\[
\int_Z\prod\limits_{i=1}^Mq_i(Z_i)\log q_1(Z_1)dZ=\int_{Z_1}q_1(Z_1)\log q_1(Z_1)dZ_1
\]</span><br>
所以：<br>
<span class="math display">\[
\int_Zq(Z)\log q(Z)dZ=\sum\limits_{i=1}^M\int_{Z_i}q_i(Z_i)\log q_i(Z_i)dZ_i=\int_{Z_j}q_j(Z_j)\log q_j(Z_j)dZ_j+Const
\]</span><br>
两项相减，令 <span class="math inline">\(\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]=\log \hat{p}(X,Z_j)\)</span> 可以得到：<br>
<span class="math display">\[
-\int_{Z_j}q_j(Z_j)\log\frac{q_j(Z_j)}{\hat{p}(X,Z_j)}dZ_j\le 0
\]</span><br>
于是最大的 <span class="math inline">\(q_j(Z_j)=\hat{p}(X,Z_j)\)</span> 才能得到最大值。我们看到，对每一个 <span class="math inline">\(q_j\)</span>，都是固定其余的 <span class="math inline">\(q_i\)</span>，求这个值，于是可以使用坐标上升的方法进行迭代求解，上面的推导针对单个样本，但是对数据集也是适用的。</p>
<p>基于平均场假设的变分推断存在一些问题：</p>
<ol type="1">
<li>假设太强，<span class="math inline">\(Z\)</span> 非常复杂的情况下，假设不适用</li>
<li>期望中的积分，可能无法计算</li>
</ol>
<h2 id="sgvi">SGVI</h2>
<p>从 <span class="math inline">\(Z\)</span> 到 <span class="math inline">\(X\)</span> 的过程叫做生成过程或译码，反过来的额过程叫推断过程或编码过程，基于平均场的变分推断可以导出坐标上升的算法，但是这个假设在一些情况下假设太强，同时积分也不一定能算。我们知道，优化方法除了坐标上升，还有梯度上升的方式，我们希望通过梯度上升来得到变分推断的另一种算法。</p>
<p>我们的目标函数：<br>
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span><br>
假定 <span class="math inline">\(q(Z)=q_\phi(Z)\)</span>，是和 <span class="math inline">\(\phi\)</span> 这个参数相连的概率分布。于是 <span class="math inline">\(\mathop{argmax}_{q(Z)}L(q)=\mathop{argmax}_{\phi}L(\phi)\)</span>，其中 <span class="math inline">\(L(\phi)=\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]\)</span>，这里 <span class="math inline">\(x^i\)</span> 表示第 <span class="math inline">\(i\)</span> 个样本。<br>
<span class="math display">\[
\begin{align*}\nabla_\phi L(\phi)&amp;=\nabla_\phi\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]\\
&amp;=\nabla_\phi\int q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz+\int q_\phi(z)\nabla_\phi [\log p_\theta(x^i,z)-\log q_\phi(z)]dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz-\int q_\phi(z)\nabla_\phi \log q_\phi(z)dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz-\int \nabla_\phi q_\phi(z)dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz\\
&amp;=\int q_\phi(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))dz\\
&amp;=\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))]
\end{align*}
\]</span><br>
这个期望可以通过蒙特卡洛采样来近似，从而得到梯度，然后利用梯度上升的方法来得到参数：<br>
<span class="math display">\[
\begin{gather*}
z^l\sim q_\phi(z)\\
\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))]\sim \frac{1}{L}\sum\limits_{l=1}^L(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))
\end{gather*}
\]</span><br>
但是由于求和符号中存在一个对数项，于是直接采样的方差很大，需要采样的样本非常多。为了解决方差太大的问题，我们采用 Reparameterization 的技巧。</p>
<p>考虑：<br>
<span class="math display">\[
\nabla_\phi L(\phi)=\nabla_\phi\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]
\]</span><br>
我们取：<span class="math inline">\(z=g_\phi(\varepsilon,x^i),\varepsilon\sim p(\varepsilon)\)</span>，于是对后验：<span class="math inline">\(z\sim q_\phi(z|x^i)\)</span>，有 <span class="math inline">\(|q_\phi(z|x^i)dz|=|p(\varepsilon)d\varepsilon|\)</span>。代入上面的梯度中：<br>
<span class="math display">\[
\begin{align*}
\nabla_\phi L(\phi)&amp;=\nabla_\phi\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]\\
&amp;=\nabla_\phi L(\phi)=\nabla_\phi\int[\log p_\theta(x^i,z)-\log q_\phi(z)]q_\phi dz\\
&amp;=\nabla_\phi\int[\log p_\theta(x^i,z)-\log q_\phi(z)]p_\varepsilon d\varepsilon\\
&amp;=\mathbb{E}_{p(\varepsilon)}[\nabla_\phi[\log p_\theta(x^i,z)-\log q_\phi(z)]]\\
&amp;=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log q_\phi(z)]\nabla_\phi z]\\
&amp;=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log q_\phi(z)]\nabla_\phi g_\phi(\varepsilon,x^i)]
\end{align*}
\]</span><br>
对这个式子进行蒙特卡洛采样，然后计算期望，得到梯度。</p>
<h1 id="马尔可夫链蒙特卡洛">马尔可夫链蒙特卡洛</h1>
<p>MCMC 是一种随机的近似推断，其核心就是基于采样的随机近似方法蒙特卡洛方法。对于采样任务来说，有下面一些常用的场景：</p>
<ol type="1">
<li>采样作为任务，用于生成新的样本</li>
<li>求和/求积分</li>
</ol>
<p>采样结束后，我们需要评价采样出来的样本点是不是好的样本集：</p>
<ol type="1">
<li>样本趋向于高概率的区域</li>
<li>样本之间必须独立</li>
</ol>
<p>具体采样中，采样是一个困难的过程：</p>
<ol type="1">
<li>无法采样得到归一化因子，即无法直接对概率 $ p(x)=(x)$ 采样，常常需要对 CDF 采样，但复杂的情况不行</li>
<li>如果归一化因子可以求得，但是对高维数据依然不能均匀采样（维度灾难），这是由于对 <span class="math inline">\(p\)</span> 维空间，总的状态空间是 <span class="math inline">\(K^p\)</span> 这么大，于是在这种情况下，直接采样也不行</li>
</ol>
<p>因此需要借助其他手段，如蒙特卡洛方法中的拒绝采样，重要性采样和 MCMC。</p>
<h2 id="蒙特卡洛方法">蒙特卡洛方法</h2>
<p>蒙特卡洛方法旨在求得复杂概率分布下的期望值：<span class="math inline">\(\mathbb{E}_{z|x}[f(z)]=\int p(z|x)f(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\)</span>，也就是说，从概率分布中取 <span class="math inline">\(N\)</span> 个点，从而近似计算这个积分。采样方法有：</p>
<ol type="1">
<li><p>概率分布采样，首先求得概率密度的累积密度函数 CDF，然后求得 CDF 的反函数，在0到1之间均匀采样，代入反函数，就得到了采样点。但是实际大部分概率分布不能得到 CDF。</p></li>
<li><p>Rejection Sampling 拒绝采样：对于概率分布 <span class="math inline">\(p(z)\)</span>，引入简单的提议分布 <span class="math inline">\(q(z)\)</span>，使得 <span class="math inline">\(\forall z_i,Mq(z_i)\ge p(z_i)\)</span>。我们先在 $ q(z)$ 中采样，定义接受率：<span class="math inline">\(\alpha=\frac{p(z^i)}{Mq(z^i)}\le1\)</span>。算法描述为：</p>
<ol type="1">
<li>取 <span class="math inline">\(z^i\sim q(z)\)</span>。</li>
<li>在均匀分布中选取 <span class="math inline">\(u\)</span>。</li>
<li>如果 <span class="math inline">\(u\le\alpha\)</span>，则接受 <span class="math inline">\(z^i\)</span>，否则，拒绝这个值。</li>
</ol></li>
<li><p>Importance Sampling：直接对期望：<span class="math inline">\(\mathbb{E}_{p(z)}[f(z)]\)</span> 进行采样。<br>
<span class="math display">\[
\mathbb{E}_{p(z)}[f(z)]=\int p(z)f(z)dz=\int \frac{p(z)}{q(z)}f(z)q(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span><br>
于是采样在 $ q(z)$ 中采样，并通过权重计算和。重要值采样对于权重非常小的时候，效率非常低。重要性采样有一个变种 Sampling-Importance-Resampling，这种方法，首先和上面一样进行采样，然后在采样出来的 <span class="math inline">\(N\)</span> 个样本中，重新采样，这个重新采样，使用每个样本点的权重作为概率分布进行采样。</p></li>
</ol>
<h2 id="mcmc">MCMC</h2>
<p>马尔可夫链式一种时间状态都是离散的随机变量序列。我们关注的主要是齐次的一阶马尔可夫链。马尔可夫链满足：<span class="math inline">\(p(X_{t+1}|X_1,X_2,\cdots,X_t)=p(X_{t+1}|X_t)\)</span>。这个式子可以写成转移矩阵的形式 <span class="math inline">\(p_{ij}=p(X_{t+1}=j|X_t=i)\)</span>。我们有：<br>
<span class="math display">\[
\pi_{t+1}(x^*)=\int\pi_i(x)p_{x\to x^*}dx
\]</span><br>
如果存在 <span class="math inline">\(\pi=(\pi(1),\pi(2),\cdots),\sum\limits_{i=1}^{+\infty}\pi(i)=1\)</span>，有上式成立，这个序列就叫马尔可夫链 <span class="math inline">\(X_t\)</span> 的平稳分布，平稳分布就是表示在某一个时刻后，分布不再改变。MCMC 就是通过构建马尔可夫链概率序列，使其收敛到平稳分布 <span class="math inline">\(p(z)\)</span>。引入细致平衡：<span class="math inline">\(\pi(x)p_{x\to x^*}=\pi(x^*)p_{x^*\to x}\)</span>。如果一个分布满足细致平衡，那么一定满足平稳分布（反之不成立）：<br>
<span class="math display">\[
\int\pi(x)p_{x\to x^*}dx=\int\pi(x^*)p_{x^*\to x}dx=\pi(x^*)
\]</span><br>
细致平衡条件将平稳分布的序列和马尔可夫链的转移矩阵联系在一起了，通过转移矩阵可以不断生成样本点。假定随机取一个转移矩阵 <span class="math inline">\((Q=Q_{ij})\)</span>，作为一个提议矩阵。我们有：<br>
<span class="math display">\[
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=p(z^*)\cdot Q_{z^*\to z}\alpha(z^*,z)
\]</span><br>
取 ：<br>
<span class="math display">\[
\alpha(z,z^*)=\min\{1,\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}\}
\]</span><br>
则<br>
<span class="math display">\[
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=\min\{p(z)Q_{z\to z^*},p(z^*)Q_{z^*\to z}\}=p(z^*)\cdot Q_{z^*\to z}\alpha(z^*,z)
\]</span><br>
于是，迭代就得到了序列，这个算法叫做 Metropolis-Hastings 算法：</p>
<ol type="1">
<li>通过在0，1之间均匀分布取点 <span class="math inline">\(u\)</span></li>
<li>生成 <span class="math inline">\(z^*\sim Q(z^*|z^{i-1})\)</span></li>
<li>计算 <span class="math inline">\(\alpha\)</span> 值</li>
<li>如果 <span class="math inline">\(\alpha\ge u\)</span>，则 <span class="math inline">\(z^i=z^*\)</span>，否则 <span class="math inline">\(z^{i}=z^{i-1}\)</span></li>
</ol>
<p>这样取的样本就服从 <span class="math inline">\(p(z)=\frac{\hat{p}(z)}{z_p}\sim \hat{p}(z)\)</span>。</p>
<p>下面介绍另一种采样方式 Gibbs 采样，如果 <span class="math inline">\(z\)</span> 的维度非常高，那么通过固定被采样的维度其余的维度来简化采样过程：<span class="math inline">\(z_i\sim p(z_i|z_{-i})\)</span>：</p>
<ol type="1">
<li>给定初始值 <span class="math inline">\(z_1^0,z_2^0,\cdots\)</span></li>
<li>在 <span class="math inline">\(t+1\)</span> 时刻，采样 <span class="math inline">\(z_i^{t+1}\sim p(z_i|z_{-i})\)</span>，从第一个维度一个个采样。</li>
</ol>
<p>Gibbs 采样方法是一种特殊的 MH 采样，可以计算 Gibbs 采样的接受率：<br>
<span class="math display">\[
\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}=\frac{p(z_i^*|z^*_{-i})p(z^*_{-i})p(z_i|z_{-i}^*)}{p(z_i|z_{-i})p(z_{-i})p(z_i^*|z_{-i})}
\]</span><br>
对于每个 Gibbs 采样步骤，<span class="math inline">\(z_{-i}=z_{-i}^*\)</span>，这是由于每个维度 <span class="math inline">\(i\)</span> 采样的时候，其余的参量保持不变。所以上式为1。于是 Gibbs 采样过程中，相当于找到了一个步骤，使得所有的接受率为 1。</p>
<h2 id="平稳分布">平稳分布</h2>
<p>定义随机矩阵：<br>
<span class="math display">\[
Q=\begin{pmatrix}Q_{11}&amp;Q_{12}&amp;\cdots&amp;Q_{1K}\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\Q_{k1}&amp;Q_{k2}&amp;\cdots&amp;Q_{KK}\end{pmatrix}
\]</span><br>
这个矩阵每一行或者每一列的和都是1。随机矩阵的特征值都小于等于1。假设只有一个特征值为 <span class="math inline">\(\lambda_i=1\)</span>。于是在马尔可夫过程中：<br>
<span class="math display">\[
q^{t+1}(x=j)=\sum\limits_{i=1}^Kq^t(x=i)Q_{ij}\\
\Rightarrow q^{t+1}=q^t\cdot Q=q^1Q^t
\]</span><br>
于是有：<br>
<span class="math display">\[
q^{t+1}=q^1A\Lambda^t A^{-1}
\]</span><br>
如果 <span class="math inline">\(m\)</span> 足够大，那么，<span class="math inline">\(\Lambda^m=diag(0,0,\cdots,1,\cdots,0)\)</span>，则：<span class="math inline">\(q^{m+1}=q^{m}\)</span> ，则趋于平稳分布了。马尔可夫链可能具有平稳分布的性质，所以我们可以构建马尔可夫链使其平稳分布收敛于需要的概率分布（设计转移矩阵）。</p>
<p>在采样过程中，需要经历一定的时间（燃烧期/混合时间）才能达到平稳分布。但是 MCMC 方法有一些问题：</p>
<ol type="1">
<li>无法判断是否已经收敛</li>
<li>燃烧期过长（维度太高，并且维度之间有关，可能无法采样到某些维度），例如在 GMM 中，可能无法采样到某些峰。于是在一些模型中，需要对隐变量之间的关系作出约束，如 RBM 假设隐变量之间无关。</li>
<li>样本之间一定是有相关性的，如果每个时刻都取一个点，那么每个样本一定和前一个相关，这可以通过间隔一段时间采样。</li>
</ol>
<h2 id="隐马尔可夫模型">隐马尔可夫模型</h2>
<p>隐马尔可夫模型是一种概率图模型。我们知道，机器学习模型可以从频率派和贝叶斯派两个方向考虑，在频率派的方法中的核心是优化问题，而在贝叶斯派的方法中，核心是积分问题，也发展出来了一系列的积分方法如变分推断，MCMC 等。概率图模型最基本的模型可以分为有向图（贝叶斯网络）和无向图（马尔可夫随机场）两个方面，例如 GMM，在这些基本的模型上，如果样本之间存在关联，可以认为样本中附带了时序信息，从而样本之间不独立全同分布的，这种模型就叫做动态模型，隐变量随着时间发生变化，于是观测变量也发生变化：</p>
<pre class="mermaid">graph LR;
    z1-->z2-->z3;</pre>
<p>根据状态变量的特点，可以分为：</p>
<ol type="1">
<li>HMM，状态变量（隐变量）是离散的</li>
<li>Kalman 滤波，状态变量是连续的，线性的</li>
<li>粒子滤波，状态变量是连续，非线性的</li>
</ol>
<h2 id="hmm">HMM</h2>
<p>HMM 用概率图表示为：</p>
<pre class="mermaid">graph TD;
t1-->t2;
subgraph four
    t4-->x4((x4))
end
subgraph three
    t3-->x3((x3))
end
subgraph two
    t2-->x2((x2))
end
subgraph one
    t1-->x1((x1))
end

t2-->t3;
t3-->t4;</pre>
<p>上图表示了四个时刻的隐变量变化。用参数 <span class="math inline">\(\lambda=(\pi,A,B)\)</span> 来表示，其中 <span class="math inline">\(\pi\)</span> 是开始的概率分布，<span class="math inline">\(A\)</span> 为状态转移矩阵，<span class="math inline">\(B\)</span> 为发射矩阵。</p>
<p>下面使用 $ o_t$ 来表示观测变量，<span class="math inline">\(O\)</span> 为观测序列，<span class="math inline">\(V=\{v_1,v_2,\cdots,v_M\}\)</span> 表示观测的值域，<span class="math inline">\(i_t\)</span> 表示状态变量，<span class="math inline">\(I\)</span> 为状态序列，<span class="math inline">\(Q=\{q_1,q_2,\cdots,q_N\}\)</span> 表示状态变量的值域。定义 <span class="math inline">\(A=(a_{ij}=p(i_{t+1}=q_j|i_t=q_i))\)</span> 表示状态转移矩阵，<span class="math inline">\(B=(b_j(k)=p(o_t=v_k|i_t=q_j))\)</span> 表示发射矩阵。</p>
<p>在 HMM 中，有两个基本假设：</p>
<ol type="1">
<li><p>齐次 Markov 假设（未来只依赖于当前）：<br>
<span class="math display">\[
p(i_{t+1}|i_t,i_{t-1},\cdots,i_1,o_t,o_{t-1},\cdots,o_1)=p(i_{t+1}|i_t)
\]</span></p></li>
<li><p>观测独立假设：<br>
<span class="math display">\[
p(o_t|i_t,i_{t-1},\cdots,i_1,o_{t-1},\cdots,o_1)=p(o_t|i_t)
\]</span></p></li>
</ol>
<p>HMM 要解决三个问题：</p>
<ol type="1">
<li>Evaluation：<span class="math inline">\(p(O|\lambda)\)</span>，Forward-Backward 算法</li>
<li>Learning：<span class="math inline">\(\lambda=\mathop{argmax}\limits_{\lambda}p(O|\lambda)\)</span>，EM 算法（Baum-Welch）</li>
<li>Decoding：<span class="math inline">\(I=\mathop{argmax}\limits_{I}p(I|O,\lambda)\)</span>，Vierbi 算法
<ol type="1">
<li>预测问题：<span class="math inline">\(p(i_{t+1}|o_1,o_2,\cdots,o_t)\)</span></li>
<li>滤波问题：<span class="math inline">\(p(i_t|o_1,o_2,\cdots,o_t)\)</span></li>
</ol></li>
</ol>
<h3 id="evaluation">Evaluation</h3>
<p><span class="math display">\[
p(O|\lambda)=\sum\limits_{I}p(I,O|\lambda)=\sum\limits_{I}p(O|I,\lambda)p(I|\lambda)
\]</span></p>
<p><span class="math display">\[
p(I|\lambda)=p(i_1,i_2,\cdots,i_t|\lambda)=p(i_t|i_1,i_2,\cdots,i_{t-1},\lambda)p(i_1,i_2,\cdots,i_{t-1}|\lambda)
\]</span></p>
<p>根据齐次 Markov 假设：<br>
<span class="math display">\[
p(i_t|i_1,i_2,\cdots,i_{t-1},\lambda)=p(i_t|i_{t-1})=a_{i_{t-1}i_t}
\]</span><br>
所以：<br>
<span class="math display">\[
p(I|\lambda)=\pi_1\prod\limits_{t=2}^Ta_{i_{t-1},i_t}
\]</span><br>
又由于：<br>
<span class="math display">\[
p(O|I,\lambda)=\prod\limits_{t=1}^Tb_{i_t}(o_t)
\]</span><br>
于是：<br>
<span class="math display">\[
p(O|\lambda)=\sum\limits_{I}\pi_{i_1}\prod\limits_{t=2}^Ta_{i_{t-1},i_t}\prod\limits_{t=1}^Tb_{i_t}(o_t)
\]</span><br>
我们看到，上面的式子中的求和符号是对所有的观测变量求和，于是复杂度为 <span class="math inline">\(O(N^T)\)</span>。</p>
<p>下面，记 <span class="math inline">\(\alpha_t(i)=p(o_1,o_2,\cdots,o_t,i_t=q_i|\lambda)\)</span>，所以，<span class="math inline">\(\alpha_T(i)=p(O,i_T=q_i|\lambda)\)</span>。我们看到：<br>
<span class="math display">\[
p(O|\lambda)=\sum\limits_{i=1}^Np(O,i_T=q_i|\lambda)=\sum\limits_{i=1}^N\alpha_T(i)
\]</span><br>
对 <span class="math inline">\(\alpha_{t+1}(j)\)</span>：<br>
<span class="math display">\[
\begin{align*}\alpha_{t+1}(j)&amp;=p(o_1,o_2,\cdots,o_{t+1},i_{t+1}=q_j|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_1,o_2,\cdots,o_{t+1},i_{t+1}=q_j,i_t=q_i|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_{t+1}|o_1,o_2,\cdots,i_{t+1}=q_j,i_t=q_i|\lambda)p(o_1,\cdots,o_t,i_t=q_i,i_{t+1}=q_j|\lambda)
\end{align*}
\]</span><br>
利用观测独立假设：<br>
<span class="math display">\[
\begin{align*}\alpha_{t+1}(j)&amp;=\sum\limits_{i=1}^Np(o_{t+1}|i_{t+1}=q_j)p(o_1,\cdots,o_t,i_t=q_i,i_{t+1}=q_j|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_{t+1}|i_{t+1}=q_j)p(i_{t+1}=q_j|o_1,\cdots,o_t,i_t=q_i,\lambda)p(o_1,\cdots,o_t,i_t=q_i|\lambda)\\
&amp;=\sum\limits_{i=1}^Nb_{j}(o_t)a_{ij}\alpha_t(i)
\end{align*}
\]</span><br>
上面利用了齐次 Markov 假设得到了一个递推公式，这个算法叫做前向算法。</p>
<p>还有一种算法叫做后向算法，定义 <span class="math inline">\(\beta_t(i)=p(o_{t+1},o_{t+1},\cdots，o_T|i_t=i,\lambda)\)</span>：<br>
<span class="math display">\[
\begin{align*}p(O|\lambda)&amp;=p(o_1,\cdots,o_T|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_1,o_2,\cdots,o_T,i_1=q_i|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_1,o_2,\cdots,o_T|i_1=q_i,\lambda)\pi_i\\
&amp;=\sum\limits_{i=1}^Np(o_1|o_2,\cdots,o_T,i_1=q_i,\lambda)p(o_2,\cdots,o_T|i_1=q_i,\lambda)\pi_i\\
&amp;=\sum\limits_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)
\end{align*}
\]</span><br>
对于这个 <span class="math inline">\(\beta_1(i)\)</span>：<br>
<span class="math display">\[
\begin{align*}\beta_t(i)&amp;=p(o_{t+1},\cdots,o_T|i_t=q_i)\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1},o_{t+2},\cdots,o_T,i_{t+1}=q_j|i_t=q_i)\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1},\cdots,o_T|i_{t+1}=q_j,i_t=q_i)p(i_{t+1}=q_j|i_t=q_i)\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1},\cdots,o_T|i_{t+1}=q_j)a_{ij}\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1}|o_{t+2},\cdots,o_T,i_{t+1}=q_j)p(o_{t+2},\cdots,o_T|i_{t+1}=q_j)a_{ij}\\
&amp;=\sum\limits_{j=1}^Nb_j(o_{t+1})a_{ij}\beta_{t+1}(j)
\end{align*}
\]</span><br>
于是后向地得到了第一项。</p>
<h3 id="learning">Learning</h3>
<p>为了学习得到参数的最优值，在 MLE 中：<br>
<span class="math display">\[
\lambda_{MLE}=\mathop{argmax}_\lambda p(O|\lambda)
\]</span><br>
我们采用 EM 算法（在这里也叫 Baum Welch 算法），用上标表示迭代：<br>
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}_{\theta}\int_z\log p(X,Z|\theta)p(Z|X,\theta^t)dz
\]</span><br>
其中，<span class="math inline">\(X\)</span> 是观测变量，<span class="math inline">\(Z\)</span> 是隐变量序列。于是：<br>
<span class="math display">\[
\lambda^{t+1}=\mathop{argmax}_\lambda\sum\limits_I\log p(O,I|\lambda)p(I|O,\lambda^t)\\
=\mathop{argmax}_\lambda\sum\limits_I\log p(O,I|\lambda)p(O,I|\lambda^t)
\]</span><br>
这里利用了 <span class="math inline">\(p(O|\lambda^t)\)</span> 和<span class="math inline">\(\lambda\)</span> 无关。将 Evaluation 中的式子代入：<br>
<span class="math display">\[
\sum\limits_I\log p(O,I|\lambda)p(O,I|\lambda^t)=\sum\limits_I[\log \pi_{i_1}+\sum\limits_{t=2}^T\log a_{i_{t-1},i_t}+\sum\limits_{t=1}^T\log b_{i_t}(o_t)]p(O,I|\lambda^t)
\]</span><br>
对 <span class="math inline">\(\pi^{t+1}\)</span>：<br>
<span class="math display">\[
\begin{align*}\pi^{t+1}&amp;=\mathop{argmax}_\pi\sum\limits_I[\log \pi_{i_1}p(O,I|\lambda^t)]\\
&amp;=\mathop{argmax}_\pi\sum\limits_I[\log \pi_{i_1}\cdot p(O,i_1,i_2,\cdots,i_T|\lambda^t)]
\end{align*}
\]</span><br>
上面的式子中，对 <span class="math inline">\(i_2,i_2,\cdots,i_T\)</span> 求和可以将这些参数消掉：<br>
<span class="math display">\[
\pi^{t+1}=\mathop{argmax}_\pi\sum\limits_{i_1}[\log \pi_{i_1}\cdot p(O,i_1|\lambda^t)]
\]</span><br>
上面的式子还有对 <span class="math inline">\(\pi\)</span> 的约束 <span class="math inline">\(\sum\limits_i\pi_i=1\)</span>。定义 Lagrange 函数：<br>
<span class="math display">\[
L(\pi,\eta)=\sum\limits_{i=1}^N\log \pi_i\cdot p(O,i_1=q_i|\lambda^t)+\eta(\sum\limits_{i=1}^N\pi_i-1)
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial L}{\partial\pi_i}=\frac{1}{\pi_i}p(O,i_1=q_i|\lambda^t)+\eta=0
\]</span><br>
对上式求和：<br>
<span class="math display">\[
\sum\limits_{i=1}^Np(O,i_1=q_i|\lambda^t)+\pi_i\eta=0\Rightarrow\eta=-p(O|\lambda^t)
\]</span><br>
所以：<br>
<span class="math display">\[
\pi_i^{t+1}=\frac{p(O,i_1=q_i|\lambda^t)}{p(O|\lambda^t)}
\]</span></p>
<h3 id="decoding">Decoding</h3>
<p>Decoding 问题表述为：<br>
<span class="math display">\[
I=\mathop{argmax}\limits_{I}p(I|O,\lambda)
\]</span><br>
我们需要找到一个序列，其概率最大，这个序列就是在参数空间中的一个路径，可以采用动态规划的思想。</p>
<p>定义：<br>
<span class="math display">\[
\delta_{t}(j)=\max\limits_{i_1,\cdots,i_{t-1}}p(o_1,\cdots,o_t,i_1,\cdots,i_{t-1},i_t=q_i)
\]</span><br>
于是：<br>
<span class="math display">\[
\delta_{t+1}(j)=\max\limits_{1\le i\le N}\delta_t(i)a_{ij}b_j(o_{t+1})
\]</span><br>
这个式子就是从上一步到下一步的概率再求最大值。记这个路径为：<br>
<span class="math display">\[
\psi_{t+1}(j)=\mathop{argmax}\limits_{1\le i\le N}\delta_t(i)a_{ij}
\]</span></p>
<h2 id="小结-5">小结</h2>
<p>HMM 是一种动态模型，是由混合树形模型和时序结合起来的一种模型（类似 GMM + Time）。对于类似 HMM 的这种状态空间模型，普遍的除了学习任务（采用 EM ）外，还有推断任务，推断任务包括：</p>
<ol type="1">
<li><p>译码 Decoding：<span class="math inline">\(p(z_1,z_2,\cdots,z_t|x_1,x_2,\cdots,x_t)\)</span></p></li>
<li><p>似然概率：<span class="math inline">\(p(X|\theta)\)</span></p></li>
<li><p>滤波：$ p(z_t|x_1,,x_t)$，Online<br>
<span class="math display">\[
p(z_t|x_{1:t})=\frac{p(x_{1:t},z_t)}{p(x_{1:t})}=C\alpha_t(z_t)
\]</span></p></li>
<li><p>平滑：<span class="math inline">\(p(z_t|x_1,\cdots,x_T)\)</span>，Offline<br>
<span class="math display">\[
p(z_t|x_{1:T})=\frac{p(x_{1:T},z_t)}{p(x_{1:T})}=\frac{\alpha_t(z_t)p(x_{t+1:T}|x_{1:t},z_t)}{p(x_{1:T})}
\]</span><br>
根据概率图的条件独立性，有：<br>
<span class="math display">\[
p(z_t|x_{1:T})=\frac{\alpha_t(z_t)p(x_{t+1:T}|z_t)}{p(x_{1:T})}=C\alpha_t(z_t)\beta_t(z_t)
\]</span><br>
这个算法叫做前向后向算法。</p></li>
<li><p>预测：<span class="math inline">\(p(z_{t+1},z_{t+2}|x_1,\cdots,x_t),p(x_{t+1},x_{t+2}|x_1,\cdots,x_t)\)</span><br>
<span class="math display">\[
p(z_{t+1}|x_{1:t})=\sum_{z_t}p(z_{t+1},z_t|x_{1:t})=\sum\limits_{z_t}p(z_{t+1}|z_t)p(z_t|x_{1:t})
\]</span></p>
<p><span class="math display">\[
p(x_{t+1}|x_{1:t})=\sum\limits_{z_{t+1}}p(x_{t+1},z_{t+1}|x_{1:t})=\sum\limits_{z_{t+1}}p(x_{t+1}|z_{t+1})p(z_{t+1}|x_{1:t})
\]</span></p></li>
</ol>
<h1 id="线性动态系统">线性动态系统</h1>
<p>HMM 模型适用于隐变量是离散的值的时候，对于连续隐变量的 HMM，常用线性动态系统描述线性高斯模型的态变量，使用粒子滤波来表述非高斯非线性的态变量。</p>
<p>LDS 又叫卡尔曼滤波，其中，线性体现在上一时刻和这一时刻的隐变量以及隐变量和观测之间：<br>
<span class="math display">\[
\begin{align*}
z_t&amp;=A\cdot z_{t-1}+B+\varepsilon\\
x_t&amp;=C\cdot z_t+D+\delta\\
\varepsilon&amp;\sim\mathcal{N}(0,Q)\\
\delta&amp;\sim\mathcal{N}(0,R)
\end{align*}
\]</span><br>
类比 HMM 中的几个参数：<br>
<span class="math display">\[
\begin{align*}
p(z_t|z_{t-1})&amp;\sim\mathcal{N}(A\cdot z_{t-1}+B,Q)\\
p(x_t|z_t)&amp;\sim\mathcal{N}(C\cdot z_t+D,R)\\
z_1&amp;\sim\mathcal{N}(\mu_1,\Sigma_1)
\end{align*}
\]</span><br>
在含时的概率图中，除了对参数估计的学习问题外，在推断任务中，包括译码，证据概率，滤波，平滑，预测问题，LDS 更关心滤波这个问题：<span class="math inline">\(p(z_t|x_1,x_2,\cdots,x_t)\)</span>。类似 HMM 中的前向算法，我们需要找到一个递推关系。<br>
<span class="math display">\[
p(z_t|x_{1:t})=p(x_{1:t},z_t)/p(x_{1:t})=Cp(x_{1:t},z_t)
\]</span><br>
对于 <span class="math inline">\(p(x_{1:t},z_t)\)</span>：<br>
<span class="math display">\[
\begin{align*}p(x_{1:t},z_t)&amp;=p(x_t|x_{1:t-1},z_t)p(x_{1:t-1},z_t)=p(x_t|z_t)p(x_{1:t-1},z_t)\\
&amp;=p(x_t|z_t)p(z_t|x_{1:t-1})p(x_{1:t-1})=Cp(x_t|z_t)p(z_t|x_{1:t-1})\\
\end{align*}
\]</span><br>
我们看到，右边除了只和观测相关的常数项，还有一项是预测任务需要的概率。对这个值：<br>
<span class="math display">\[
\begin{align*}
p(z_t|x_{1:t-1})&amp;=\int_{z_{t-1}}p(z_t,z_{t-1}|x_{1:t-1})dz_{t-1}\\
&amp;=\int_{z_{t-1}}p(z_t|z_{t-1},x_{1:t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}\\
&amp;=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}
\end{align*}
\]</span><br>
我们看到，这又化成了一个滤波问题。于是我们得到了一个递推公式：</p>
<ol type="1">
<li><span class="math inline">\(t=1\)</span>，<span class="math inline">\(p(z_1|x_1)\)</span>，称为 update 过程，然后计算 <span class="math inline">\(p(z_2|x_1)\)</span>，通过上面的积分进行，称为 prediction 过程。</li>
<li><span class="math inline">\(t=2\)</span>，<span class="math inline">\(p(z_2|x_2,x_1)\)</span> 和 <span class="math inline">\(p(z_3|x_1,x_2)\)</span></li>
</ol>
<p>我们看到，这个过程是一个 Online 的过程，对于我们的线性高斯假设，这个计算过程都可以得到解析解。</p>
<ol type="1">
<li><p>Prediction：<br>
<span class="math display">\[
p(z_t|x_{1:t-1})=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}=\int_{z_{t-1}}\mathcal{N}(Az_{t-1}+B,Q)\mathcal{N}(\mu_{t-1},\Sigma_{t-1})dz_{t-1}
\]</span><br>
其中第二个高斯分布是上一步的 Update 过程，所以根据线性高斯模型，直接可以写出这个积分：<br>
<span class="math display">\[
p(z_t|x_{1:t-1})=\mathcal{N}(A\mu_{t-1}+B,Q+A\Sigma_{t-1}A^T)
\]</span></p></li>
<li><p>Update:<br>
<span class="math display">\[
p(z_t|x_{1:t})\propto p(x_t|z_t)p(z_t|x_{1:t-1})
\]</span><br>
同样利用线性高斯模型，也可以直接写出这个高斯分布。</p></li>
</ol>
<h1 id="粒子滤波">粒子滤波</h1>
<p>Kalman 滤波根据线性高斯模型可以求得解析解，但是在非线性，非高斯的情况，是无法得到解析解的，对这类一般的情况，我们叫做粒子滤波，我们需要求得概率分布，需要采用采样的方式。</p>
<p>我们希望应用 Monte Carlo 方法来进行采样，对于一个概率分布，如果我们希望计算依这个分布的某个函数 <span class="math inline">\(f(z)\)</span> 的期望，可以利用某种抽样方法，在这个概率分布中抽取 <span class="math inline">\(N\)</span> 个样本，则 <span class="math inline">\(\mathbb{E}[f(z)]\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\)</span>。但是如果这个概率十分复杂，那么采样比较困难。对于复杂的概率分布，我们可以通过一个简单的概率分布 <span class="math inline">\(q(z)\)</span> 作为桥梁（重要值采样）:<br>
<span class="math display">\[
\mathbb{E}[f(z)]=\int_zf(z)p(z)dz=\int_zf(z)\frac{p(z)}{q(z)}q(z)dz=\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span><br>
于是直接通过对 <span class="math inline">\(q(z)\)</span> 采样，然后对每一个采样的样本应用权重就得到了期望的近似，当然为了概率分布的特性，我们需要对权重进行归一化。</p>
<p>在滤波问题中，需要求解 <span class="math inline">\(p(z_t|x_{1:t})\)</span>，其权重为：<br>
<span class="math display">\[
w_t^i=\frac{p(z_t^i|x_{1:t})}{q(z_t^i|x_{1:t})},i=1,2,\cdots,N
\]</span><br>
于是在每一个时刻 <span class="math inline">\(t\)</span>，都需要采样 <span class="math inline">\(N\)</span> 个点，但是即使采样了这么多点，分子上面的那一项也十分难求，于是希望找到一个关于权重的递推公式。为了解决这个问题，引入序列重要性采样（SIS）。</p>
<h2 id="sis">SIS</h2>
<p>在 SIS 中，解决的问题是 <span class="math inline">\(p(z_{1:t}|x_{1:t})\)</span>。<br>
<span class="math display">\[
w_t^i\propto\frac{p(z_{1:t}|x_{1:t})}{q(z_{1:t}|x_{1:t})}
\]</span><br>
根据 LDS 中的推导：<br>
<span class="math display">\[
\begin{align*}p(z_{1:t}|x_{1:t})\propto p(x_{1:t},z_{1:t})&amp;=p(x_t|z_{1:t},x_{1:t-1})p(z_{1:t},x_{1:t-1})\\
&amp;=p(x_t|z_t)p(z_t|x_{1:t-1},z_{1:t-1})p(x_{1:t-1},z_{1:t-1})\\
&amp;=p(x_t|z_t)p(z_t|z_{t-1})p(x_{1:t-1},z_{1:t-1})\\
&amp;\propto p(x_t|z_t)p(z_t|z_{t-1})p(z_{1:t-1}|x_{1:t-1})
\end{align*}
\]</span><br>
于是分子的递推式就得到了。对于提议分布的分母，可以取：<br>
<span class="math display">\[
q(z_{1:t}|x_{1:t})=q(z_t|z_{1:t-1},x_{1:t})q(z_{1:t-1}|x_{1:t-1})
\]</span><br>
所以有：<br>
<span class="math display">\[
w_t^i\propto\frac{p(z_{1:t}|x_{1:t})}{q(z_{1:t}|x_{1:t})}\propto \frac{p(x_t|z_t)p(z_t|z_{t-1})p(z_{1:t-1}|x_{1:t-1})}{q(z_t|z_{1:t-1},x_{1:t})q(z_{1:t-1}|x_{1:t-1})}=\frac{p(x_t|z_t)p(z_t|z_{t-1})}{q(z_t|z_{1:t-1},x_{1:t})}w_{t-1}^i
\]</span><br>
我们得到的对权重的算法为：</p>
<ol type="1">
<li><span class="math inline">\(t-1\)</span> 时刻，采样完成并计算得到权重</li>
<li>t 时刻，根据 <span class="math inline">\(q(z_t|z_{1:t-1},x_{1:t})\)</span> 进行采样得到 <span class="math inline">\(z_t^i\)</span>。然后计算得到 <span class="math inline">\(N\)</span> 个权重。</li>
<li>最后对权重归一化。</li>
</ol>
<p>SIS 算法会出现权值退化的情况，在一定时间后，可能会出现大部分权重都逼近0的情况，这是由于空间维度越来越高，需要的样本也越来越多。解决这个问题的方法有：</p>
<ol type="1">
<li>重采样，以权重作为概率分布，重新在已经采样的样本中采样，然后所有样本的权重相同，这个方法的思路是将权重作为概率分布，然后得到累积密度函数，在累积密度上取点（阶梯函数）。</li>
<li>选择一个合适的提议分布，<span class="math inline">\(q(z_t|z_{1:t-1},x_{1:t})=p(z_t|z_{t-1})\)</span>，于是就消掉了一项，并且采样的概率就是 <span class="math inline">\(p(z_t|z_{t-1})\)</span>，这就叫做生成与测试方法。</li>
</ol>
<p>采用重采样的 SIS 算法就是基本的粒子滤波算法。如果像上面那样选择提议分布，这个算法叫做 SIR 算法。</p>
<h1 id="条件随机场">条件随机场</h1>
<p>我们知道，分类问题可以分为硬分类和软分类两种，其中硬分类有 SVM，PLA，LDA 等。软分类问题大体上可以分为概率生成和概率判别模型，其中较为有名的概率判别模型有 Logistic 回归，生成模型有朴素贝叶斯模型。Logistic 回归模型的损失函数为交叉熵，这类模型也叫对数线性模型，一般地，又叫做最大熵模型，这类模型和指数族分布的概率假设是一致的。对朴素贝叶斯假设，如果将其中的单元素的条件独立性做推广到一系列的隐变量，那么，由此得到的模型又被称为动态模型，比较有代表性的如 HMM，从概率意义上，HMM也可以看成是 GMM 在时序上面的推广。</p>
<p>我们看到，一般地，如果将最大熵模型和 HMM相结合，那么这种模型叫做最大熵 Markov 模型（MEMM）：</p>
<pre class="mermaid">graph LR;
    x4((x4))-->y4
        x2((x2))-->y2
            x1((x1))-->y1
                x3((x3))-->y3
    y1-->y2;
    y2-->y3;
y3-->y4;</pre>
<p>这个图就是将 HMM 的图中观测变量和隐变量的边方向反向，应用在分类中，隐变量就是输出的分类，这样 HMM 中的两个假设就不成立了，特别是观测之间不是完全独立的了。</p>
<p>HMM 是一种生成式模型，其建模对象为 <span class="math inline">\(p(X,Y|\lambda)\)</span>，根据 HMM 的概率图，<span class="math inline">\(p(X,Y|\lambda)=\prod\limits_{t=1}^Tp(x_t,y_t|\lambda,y_{t-1})\)</span>。我们看到，观测独立性假设是一个很强的假设，如果我们有一个文本样本，那么观测独立性假设就假定了所有的单词之间没有关联。</p>
<p>在 MEMM 中，建模对象是 <span class="math inline">\(p(Y|X,\lambda)\)</span>，我们看概率图，给定 <span class="math inline">\(y_t\)</span>，<span class="math inline">\(x_t,x_{t-1}\)</span> 是不独立的，这样，观测独立假设就不成立了。根据概率图，<span class="math inline">\(p(Y|X,\lambda)=\prod\limits_{t=1}^Tp(y_t|y_{t-1},X,\lambda)\)</span>。</p>
<p>MEMM 的缺陷是其必须满足局域的概率归一化（Label Bias Problem），我们看到，在上面的概率图中，<span class="math inline">\(p(y_t|y_{t-1},x_t)\)</span>， 这个概率，如果 <span class="math inline">\(p(y_t|y_{t-1})\)</span> 非常接近1，那么事实上，观测变量是什么就不会影响这个概率了。</p>
<p>对于这个问题，我们将 <span class="math inline">\(y\)</span> 之间的箭头转为直线转为无向图（线性链条件随机场），这样就只要满足全局归一化了（破坏齐次 Markov 假设）。</p>
<pre class="mermaid">graph LR;
    x4((x4))-->y4
        x2((x2))-->y2
            x1((x1))-->y1
                x3((x3))-->y3
    y1---y2;
    y2---y3;
y3---y4;</pre>
<h2 id="crf-的-pdf">CRF 的 PDF</h2>
<p>线性链的 CRF 的 PDF 为 <span class="math inline">\(p(Y|X)=\frac{1}{Z}\exp\sum\limits_{t=1}^T(F_t(y_{t-1},y_t,x_{1:T}))\)</span>，两两形成了最大团，其中 <span class="math inline">\(y_0\)</span> 是随意外加的一个元素。作为第一个简化，我们假设每个团的势函数相同 <span class="math inline">\(F_t=F\)</span>。</p>
<p>对于这个 <span class="math inline">\(F\)</span>，我们进一步，可以将其写为 $ F(y_{t-1},y_t,X)=<em>{y</em>{t-1},X}+<em>{y</em>{t},X}+<em>{y_t,y</em>{t-1},X}$这三个部分，分别表示状态函数已经转移函数，由于整体的求和，可以简化为 $ F(y_{t-1},y_t,X)=<em>{y</em>{t},X}+<em>{y_t,y</em>{t-1},X}$。</p>
<p>我们可以设计一个表达式将其参数化：<br>
<span class="math display">\[
\begin{align*}
\Delta_{y_t,y_{t-1},X}&amp;=\sum\limits_{k=1}^K\lambda_kf_k(y_{t-1},y_t,X)\\
\Delta_{y_{t},X}&amp;=\sum\limits_{l=1}^L\eta_lg_l(y_t,X)
\end{align*}
\]</span><br>
其中 $g,f $ 叫做特征函数，对于 <span class="math inline">\(y\)</span> 有 <span class="math inline">\(S\)</span> 种元素，那么 <span class="math inline">\(K\le S^2,L\le S\)</span>。</p>
<p>代入概率密度函数中：<br>
<span class="math display">\[
p(Y|X)=\frac{1}{Z}\exp\sum\limits_{t=1}^T[\sum\limits_{k=1}^K\lambda_kf_k(y_{t-1},y_t,X)+\sum\limits_{l=1}^L\eta_lg_l(y_t,X)]
\]</span><br>
对于单个样本，将其写成向量的形式。定义 <span class="math inline">\(y=(y_1,y_2,\cdots,y_T)^T,x=(x_1,x_2,\cdots,x_T)^T,\lambda=(\lambda_1,\lambda_2,\cdots,\lambda_K)^T,\eta=(\eta_1,\eta_2,\cdots,\eta_L)^T\)</span>。并且有 <span class="math inline">\(f=(f_1,f_2,\cdots,f_K)^T,g=(g_1,g_2,\cdots,g_L)^T\)</span>。于是：<br>
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z}\exp\sum\limits_{t=1}^T[\lambda^Tf(y_{t-1},y_t,x)+\eta^Tg(y_t,x)]
\]</span><br>
不妨记：<span class="math inline">\(\theta=(\lambda,\eta)^T,H=(\sum\limits_{t=1}^Tf,\sum\limits_{t=1}^Tg)^T\)</span>：<br>
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z(x,\theta)}\exp[\theta^TH(y_t,y_{t-1},x)]
\]</span><br>
上面这个式子是一个指数族分布，于是 <span class="math inline">\(Z\)</span> 是配分函数。</p>
<p>CRF 需要解决下面几个问题：</p>
<ol type="1">
<li><p>Learning：参数估计问题，对 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(T\)</span> 维样本，<span class="math inline">\(\hat{\theta}=\mathop{argmax}\limits_{\theta}\prod\limits_{i=1}^Np(y^i|x^i)\)</span>，这里用上标表示样本的编号。</p></li>
<li><p>Inference：</p>
<ol type="1">
<li>边缘概率：<br>
<span class="math display">\[
p(y_t|x)
\]</span></li>
</ol></li>
<li><p>条件概率：一般在生成模型中较为关注，CRF 中不关注</p></li>
<li><p>MAP 推断：<br>
<span class="math display">\[
    \hat{y}=\mathop{argmax}p(y|x)
    \]</span></p></li>
</ol>
<h2 id="边缘概率">边缘概率</h2>
<p>边缘概率这个问题描述为，根据学习任务得到的参数，给定了 <span class="math inline">\(p(Y=y|X=x)\)</span>，求解 <span class="math inline">\(p(y_t=i|x)\)</span>。根据无向图可以给出：<br>
<span class="math display">\[
p(y_t=i|x)=\sum\limits_{y_{1:t-1},y_{t+1:T}}p(y|x)=\sum\limits_{y_{1:t-1}}\sum\limits_{y_{t+1:T}}\frac{1}{Z}\prod\limits_{t&#39;=1}^T\phi_{t&#39;}(y_{t&#39;-1},y_{t&#39;},x)
\]</span><br>
我们看到上面的式子，直接计算的复杂度很高，这是由于求和的复杂度在 <span class="math inline">\(O(S^T)\)</span>，求积的复杂度在 <span class="math inline">\(O(T)\)</span>，所以整体复杂度为 <span class="math inline">\(O(TS^T)\)</span>。我们需要调整求和符号的顺序，从而降低复杂度。</p>
<p>首先，将两个求和分为：<br>
<span class="math display">\[
\begin{align*}&amp;p(y_t=i|x)=\frac{1}{Z}\Delta_l\Delta_r\\
&amp;\Delta_l=\sum\limits_{y_{1:t-1}}\phi_{1}(y_0,y_1,x)\phi_2(y_1,y_2,x)\cdots\phi_{t-1}(y_{t-2},y_{t-1},x)\phi_t(y_{t-1},y_t=i,x)\\
&amp;\Delta_r=\sum\limits_{y_{t+1:T}}\phi_{t+1}(y_t=i,y_{t+1},x)\phi_{t+2}(y_{t+1},y_{t+2},x)\cdots\phi_T(y_{T-1},y_T,x)
\end{align*}
\]</span><br>
对于 <span class="math inline">\(\Delta_l\)</span>，从左向右，一步一步将 <span class="math inline">\(y_t\)</span> 消掉：<br>
<span class="math display">\[
\Delta_l=\sum\limits_{y_{t-1}}\phi_t(y_{t-1},y_t=i,x)\sum\limits_{y_{t-2}}\phi_{t-1}(y_{t-2},y_{t-1},x)\cdots\sum\limits_{y_0}\phi_1(y_0,y_1,x)
\]</span><br>
引入：<br>
<span class="math display">\[
\alpha_t(i)=\Delta_l
\]</span><br>
于是：<br>
<span class="math display">\[
\alpha_{t}(i)=\sum\limits_{j\in S}\phi_t(y_{t-1}=j,y_t=i,x)\alpha_{t-1}(j)
\]</span><br>
这样我们得到了一个递推式。</p>
<p>类似地，<span class="math inline">\(\Delta_r=\beta_t(i)=\sum\limits_{j\in S}\phi_{t+1}(y_t=i,y_{t+1}=j,x)\beta_{t+1}(j)\)</span>。这个方法和 HMM 中的前向后向算法类似，就是概率图模型中精确推断的变量消除算法（信念传播）。</p>
<h2 id="参数估计">参数估计</h2>
<p>在进行各种类型的推断之前，还需要对参数进行学习：<br>
<span class="math display">\[
\begin{align*}\hat{\theta}&amp;=\mathop{argmax}_{\theta}\prod\limits_{i=1}^Np(y^i|x^i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log p(y^i|x^i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N[-\log Z(x^i,\lambda,\eta)+\sum\limits_{t=1}^T[\lambda^Tf(y_{t-1},y_t,x)+\eta^Tg(y_t,x)]]
\end{align*}
\]</span><br>
上面的式子中，第一项是对数配分函数，根据指数族分布的结论：<br>
<span class="math display">\[
\nabla_\lambda(\log Z(x^i,\lambda,\eta))=\mathbb{E}_{p(y^i|x^i)}[\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)]
\]</span><br>
其中，和 <span class="math inline">\(\eta\)</span> 相关的项相当于一个常数。求解这个期望值：<br>
<span class="math display">\[
\mathbb{E}_{p(y^i|x^i)}[\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)]=\sum\limits_{y}p(y|x^i)\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)
\]</span><br>
第一个求和号的复杂度为 <span class="math inline">\(O(S^T)\)</span>，重新排列求和符号：<br>
<span class="math display">\[
\begin{align*}\mathbb{E}_{p(y^i|x^i)}[\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)]&amp;=\sum\limits_{t=1}^T\sum\limits_{y_{1:t-2}}\sum\limits_{y_{t-1}}\sum\limits_{y_t}\sum\limits_{y_{t+1:T}}p(y|x^i)f(y_{t-1},y_t,x^i)\\
&amp;=\sum\limits_{t=1}^T\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)
\end{align*}
\]</span><br>
和上面的边缘概率类似，也可以通过前向后向算法得到上面式子中的边缘概率。</p>
<p>于是：<br>
<span class="math display">\[
\nabla_\lambda L=\sum\limits_{i=1}^N\sum\limits_{t=1}^T[f(y_{t-1},y_t,x^i)-\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)]
\]</span><br>
利用梯度上升算法可以求解。对于 <span class="math inline">\(\eta\)</span> 也是类似的过程。</p>
<h2 id="译码">译码</h2>
<p>译码问题和 HMM 中的 Viterbi 算法类似，同样采样动态规划的思想一层一层求解最大值。</p>
<h1 id="高斯网络">高斯网络</h1>
<p>高斯图模型（高斯网络）是一种随机变量为连续的有向或者无向图。有向图版本的高斯图是高斯贝叶斯网络，无向版本的叫高斯马尔可夫网络。</p>
<p>高斯网络的每一个节点都是高斯分布：<span class="math inline">\(\mathcal{N}(\mu_i,\Sigma_i)\)</span>，于是所有节点的联合分布就是一个高斯分布，均值为 <span class="math inline">\(\mu\)</span>，方差为 <span class="math inline">\(\Sigma\)</span>。</p>
<p>对于边缘概率，我们有下面三个结论：</p>
<ol type="1">
<li><p>对于方差矩阵，可以得到独立性条件：<span class="math inline">\(x_i\perp x_j\Leftrightarrow\sigma_{ij}=0\)</span>，这个叫做全局独立性。</p></li>
<li><p>我们看方差矩阵的逆（精度矩阵或信息矩阵）：<span class="math inline">\(\Lambda=\Sigma^{-1}=(\lambda_{ij})_{pp}\)</span>，有定理：</p>
<blockquote>
<p><span class="math inline">\(x_i\perp x_j|(X-\{x_i,x_j\})\Leftrightarrow\lambda_{ij}=0\)</span></p>
</blockquote>
<p>因此，我们使用精度矩阵来表示条件独立性。</p></li>
<li><p>对于任意一个无向图中的节点 <span class="math inline">\(x_i\)</span>，<span class="math inline">\(x_i|(X-x_i)\sim \mathcal{N}(\sum\limits_{j\ne i}\frac{\lambda_{ij}}{\lambda_{ii}}x_j,\lambda_{ii}^{-1})\)</span></p>
<p>也就是其他所有分量的线性组合，即所有与它有链接的分量的线性组合。</p></li>
</ol>
<h2 id="高斯贝叶斯网络-gbn">高斯贝叶斯网络 GBN</h2>
<p>高斯贝叶斯网络可以看成是 LDS 的一个推广，LDS 的假设是相邻时刻的变量之间的依赖关系，因此是一个局域模型，而高斯贝叶斯网络，每一个节点的父亲节点不一定只有一个，因此可以看成是一个全局的模型。根据有向图的因子分解：<br>
<span class="math display">\[
p(x)=\prod\limits_{i=1}^pp(x_i|x_{Parents(i)})
\]</span><br>
对里面每一项，假设每一个特征是一维的，可以写成线性组合：<br>
<span class="math display">\[
p(x_i|x_{Parents(i)})=\mathcal{N}(x_i|\mu_i+W_i^Tx_{Parents(i)},\sigma^2_i)
\]</span><br>
将随机变量写成：<br>
<span class="math display">\[
x_i=\mu_i+\sum\limits_{j\in x_{Parents(i)}}w_{ij}(x_j-\mu_j)+\sigma_i\varepsilon_i,\varepsilon_i\sim \mathcal{N}(0,1)
\]</span><br>
写成矩阵形式，并且对 <span class="math inline">\(w\)</span> 进行扩展：<br>
<span class="math display">\[
x-\mu=W(x-\mu)+S\varepsilon
\]</span><br>
其中，<span class="math inline">\(S=diag(\sigma_i)\)</span>。所以有：<span class="math inline">\(x-\mu=(\mathbb{I}-W)^{-1}S\varepsilon\)</span></p>
<p>由于：<br>
<span class="math display">\[
Cov(x)=Cov(x-\mu)
\]</span><br>
可以得到协方差矩阵。</p>
<h2 id="高斯马尔可夫网络-gmn">高斯马尔可夫网络 GMN</h2>
<p>对于无向图版本的高斯网络，可以写成：<br>
<span class="math display">\[
p(x)=\frac{1}{Z}\prod\limits_{i=1}^p\phi_i(x_i)\prod\limits_{i,j\in X}\phi_{i,j}(x_i,x_j)
\]</span><br>
为了将高斯分布和这个式子结合，我们写出高斯分布和变量相关的部分：<br>
<span class="math display">\[
\begin{align*}p(x)&amp;\propto \exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))\\
&amp;=\exp(-\frac{1}{2}(x^T\Lambda x-2\mu^T\Lambda x+\mu^T\Lambda\mu))\\
&amp;=\exp(-\frac{1}{2}x^T\Lambda x+(\Lambda\mu)^Tx)
\end{align*}
\]</span><br>
可以看到，这个式子与无向图分解中的两个部分对应，我们记 <span class="math inline">\(h=\Lambda\mu\)</span>为 Potential Vector。其中和 <span class="math inline">\(x_i\)</span> 相关的为：<span class="math inline">\(x_i:-\frac{1}{2}\lambda_{ii}x_i^2+h_ix_i\)</span>，与 <span class="math inline">\(x_i,x_j\)</span> 相关的是：<span class="math inline">\(x_i,x_j:-\lambda_{ij}x_ix_j\)</span>，这里利用了精度矩阵为对称矩阵的性质。我们看到，这里也可以看出，<span class="math inline">\(x_i,x_j\)</span> 构成的一个势函数，只和 <span class="math inline">\(\lambda_{ij}\)</span> 有关，于是 $x_ix_j|(X-{x_i,x_j})_{ij}=0 $。</p>
<h1 id="贝叶斯线性回归">贝叶斯线性回归</h1>
<p>我们知道，线性回归当噪声为高斯分布的时候，最小二乘损失导出的结果相当于对概率模型应用 MLE，引入参数的先验时，先验分布是高斯分布，那么 MAP的结果相当于岭回归的正则化，如果先验是拉普拉斯分布，那么相当于 Lasso 的正则化。这两种方案都是点估计方法。我们希望利用贝叶斯方法来求解参数的后验分布。</p>
<p>线性回归的模型假设为：<br>
<span class="math display">\[
\begin{align*}f(x)=w^Tx
\\y=f(x)+\varepsilon\\
\varepsilon\sim\mathcal{N}(0,\sigma^2)
\end{align*}
\]</span><br>
在贝叶斯方法中，需要解决推断和预测两个问题。</p>
<h2 id="推断-1">推断</h2>
<p>引入高斯先验：<br>
<span class="math display">\[
p(w)=\mathcal{N}(0,\Sigma_p)
\]</span><br>
对参数的后验分布进行推断：<br>
<span class="math display">\[
p(w|X,Y)=\frac{p(w,Y|X)}{p(Y|X)}=\frac{p(Y|w,X)p(w|X)}{\int p(Y|w,X)p(w|X)dw}
\]</span><br>
分母和参数无关，由于 <span class="math inline">\(p(w|X)=p(w)\)</span>，代入先验得到：<br>
<span class="math display">\[
p(w|X,Y)\propto \prod\limits_{i=1}^N\mathcal{N}(y_i|w^Tx_i,\sigma^2)\cdot\mathcal{N}(0,\Sigma_p)
\]</span><br>
高斯分布取高斯先验的共轭分布依然是高斯分布，于是可以得到后验分布也是一个高斯分布。第一项：<br>
<span class="math display">\[
\begin{align*}\prod\limits_{i=1}^N\mathcal{N}(y_i|w^Tx_i,\sigma^2)&amp;=\frac{1}{(2\pi)^{N/2}\sigma^N}\exp(-\frac{1}{2\sigma^2}\sum\limits_{i=1}^N(y_i-w^Tx_i)^2)\\
&amp;=\frac{1}{(2\pi)^{N/2}\sigma^N}\exp(-\frac{1}{2}(Y-Xw)^T(\sigma^{-2}\mathbb{I})(Y-Xw))
\\&amp;=\mathcal{N}(Xw,\sigma^2\mathbb{I})
\end{align*}
\]</span><br>
代入上面的式子：<br>
<span class="math display">\[
p(w|X,Y)\propto\exp(-\frac{1}{2\sigma^2}(Y-Xw)^T\sigma^{-2}\mathbb{I}(Y-Xw)-\frac{1}{2}w^T\Sigma_p^{-1}w)
\]</span><br>
假定最后得到的高斯分布为：<span class="math inline">\(\mathcal{N}(\mu_w,\Sigma_w)\)</span>。对于上面的分布，采用配方的方式来得到最终的分布，指数上面的二次项为：<br>
<span class="math display">\[
-\frac{1}{2\sigma^2}w^TX^TXw-\frac{1}{2}w^T\Sigma_p^{-1}w
\]</span><br>
于是：<br>
<span class="math display">\[
\Sigma_w^{-1}=\sigma^{-2}X^TX+\Sigma_p^{-1}=A
\]</span><br>
一次项：<br>
<span class="math display">\[
\frac{1}{2\sigma^2}2Y^TXw=\sigma^{-2}Y^TXw
\]</span><br>
于是：<br>
<span class="math display">\[
\mu_w^T\Sigma_w^{-1}=\sigma^{-2}Y^TX\Rightarrow\mu_w=\sigma^{-2}A^{-1}X^TY
\]</span></p>
<h2 id="预测">预测</h2>
<p>给定一个 <span class="math inline">\(x^*\)</span>，求解 <span class="math inline">\(y^*\)</span>，所以 <span class="math inline">\(f(x^*)=x^{*T}w\)</span>，代入参数后验，有 <span class="math inline">\(x^{*T}w\sim \mathcal{N}(x^{*T}\mu_w,x^{*T}\Sigma_wx^*)\)</span>，添上噪声项：<br>
<span class="math display">\[
\begin{align*}
p(y^*|X,Y,x^*)&amp;=\int_wp(y^*|w,X,Y,x^*)p(w|X,Y,x^*)dw\\&amp;=\int_wp(y^*|w,x^*)p(w|X,Y)dw\\
&amp;=\mathcal{N}(x^{*T}\mu_w,x^{*T}\Sigma_wx^*+\sigma^2)
\end{align*}
\]</span></p>
<h1 id="高斯过程回归">高斯过程回归</h1>
<p>将一维高斯分布推广到多变量中就得到了高斯网络，将多变量推广到无限维，就得到了高斯过程，高斯过程是定义在连续域（时间空间）上的无限多个高维随机变量所组成的随机过程。</p>
<p>在时间轴上的任意一个点都满足高斯分布吗，将这些点的集合叫做高斯过程的一个样本。</p>
<blockquote>
<p>对于时间轴上的序列 <span class="math inline">\(\xi_t\)</span>，如果 <span class="math inline">\(\forall n\in N^+，t_i\in T\)</span>，有 <span class="math inline">\(\xi_{t_1-t_n}\sim \mathcal{N}(\mu_{t_1-t_n},\Sigma_{t_1-t_n})\)</span>， 那么 <span class="math inline">\(\{\xi_t\}_{t\in T}\)</span> 是一个高斯过程。</p>
<p>高斯过程有两个参数（高斯过程存在性定理），均值函数 <span class="math inline">\(m(t)=\mathbb{E}[\xi_t]\)</span> 和协方差函数 <span class="math inline">\(k(s,t)=\mathbb{E}[(\xi_s-\mathbb{E}[\xi_s])(\xi_t-\mathbb{E}[\xi_t])]\)</span>。</p>
</blockquote>
<p>我们将贝叶斯线性回归添加核技巧的这个模型叫做高斯过程回归，高斯过程回归分为两种视角：</p>
<ol type="1">
<li>权空间的视角-核贝叶斯线性回归，相当于 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(t\)</span>，在每个时刻的高斯分布来源于权重，根据上面的推导，预测的函数依然是高斯分布。</li>
<li>函数空间的视角-高斯分布通过函数 <span class="math inline">\(f(x)\)</span> 来体现。</li>
</ol>
<h2 id="核贝叶斯线性回归">核贝叶斯线性回归</h2>
<p>贝叶斯线性回归可以通过加入核函数的方法来解决非线性函数的问题，将 <span class="math inline">\(f(x)=x^Tw\)</span> 这个函数变为 <span class="math inline">\(f(x)=\phi(x)^Tw\)</span>（当然这个时候，$ _p$ 也要变为更高维度的），变换到更高维的空间，有：<br>
<span class="math display">\[
\begin{align*}f(x^*)\sim \mathcal{N}(\phi(x^*)^{T}\sigma^{-2}A^{-1}\Phi^TY,\phi(x^*)^{T}A^{-1}\phi(x^*))\\
A=\sigma^{-2}\Phi^T\Phi+\Sigma_p^{-1}
\end{align*}
\]</span><br>
其中，<span class="math inline">\(\Phi=(\phi(x_1),\phi(x_2),\cdots,\phi(x_N))^T\)</span>。</p>
<p>为了求解 <span class="math inline">\(A^{-1}\)</span>，可以利用 Woodbury Formula，<span class="math inline">\(A=\Sigma_p^{-1},C=\sigma^{-2}\mathbb{I}\)</span>：<br>
<span class="math display">\[
(A+UCV)^{-1}=A^{-1}-A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}
\]</span><br>
所以 <span class="math inline">\(A^{-1}=\Sigma_p-\Sigma_p\Phi^T(\sigma^2\mathbb{I}+\Phi\Sigma_p\Phi^T)^{-1}\Phi\Sigma_p\)</span></p>
<p>也可以用另一种方法：<br>
<span class="math display">\[
\begin{align*}
A&amp;=\sigma^{-2}\Phi^T\Phi+\Sigma_p^{-1}\\
\Leftrightarrow A\Sigma_p&amp;=\sigma^{-2}\Phi^T\Phi\Sigma_p+\mathbb{I}\\
\Leftrightarrow A\Sigma_p\Phi^T&amp;=\sigma^{-2}\Phi^T\Phi\Sigma_p\Phi^T+\Phi^T=\sigma^{-2}\Phi^T(k+\sigma^2\mathbb{I})\\
\Leftrightarrow \Sigma_p\Phi^T&amp;=\sigma^{-2}A^{-1}\Phi^T(k+\sigma^2\mathbb{I})\\
\Leftrightarrow \sigma^{-2}A^{-1}\Phi^T&amp;=\Sigma_p\Phi^T(k+\sigma^2\mathbb{I})^{-1}\\
\Leftrightarrow \phi(x^*)^T\sigma^{-2}A^{-1}\Phi^T&amp;=\phi(x^*)^T\Sigma_p\Phi^T(k+\sigma^2\mathbb{I})^{-1}
\end{align*}
\]</span><br>
上面的左边的式子就是变换后的均值，而右边的式子就是不含 <span class="math inline">\(A^{-1}\)</span> 的式子，其中 <span class="math inline">\(k=\Phi\Sigma_p\Phi^T\)</span>。</p>
<p>根据 <span class="math inline">\(A^{-1}\)</span> 得到方差为：<br>
<span class="math display">\[
\phi(x^*)^T\Sigma_p\phi(x^*)-\phi(x^*)^T\Sigma_p\Phi^T(\sigma^2\mathbb{I}+k)^{-1}\Phi\Sigma_p\phi(x^*)
\]</span><br>
上面定义了：<br>
<span class="math display">\[
k=\Phi\Sigma_p\Phi^T
\]</span><br>
我们看到，在均值和方差中，含有下面四项：<br>
<span class="math display">\[
\phi(x^*)^T\Sigma_p\Phi^T,\phi(x^*)^T\Sigma_p\phi(x^*),\phi(x^*)^T\Sigma_p\Phi^T,\Phi\Sigma_p\phi(x^*)
\]</span><br>
展开后，可以看到，有共同的项：<span class="math inline">\(k(x,x&#39;)=\phi(x)^T\Sigma_p\phi(x‘)\)</span>。由于 <span class="math inline">\(\Sigma_p\)</span> 是正定对称的方差矩阵，所以，这是一个核函数。</p>
<p>对于高斯过程中的协方差：<br>
<span class="math display">\[
k(t,s)=Cov[f(x),f(x&#39;)]=\mathbb{E}[\phi(x)^Tww^T\phi(x&#39;)]=\phi(x)^T\mathbb{E}[ww^T]\phi(x&#39;)=\phi(x)^T\Sigma_p\phi(x&#39;)
\]</span><br>
我们可以看到，这个就对应着上面的核函数。因此我们看到 <span class="math inline">\(\{f(x)\}\)</span> 组成的组合就是一个高斯过程。</p>
<h2 id="函数空间的观点">函数空间的观点</h2>
<p>相比权重空间，我们也可以直接关注 <span class="math inline">\(f\)</span> 这个空间，对于预测任务，这就是类似于求：<br>
<span class="math display">\[
p(y^*|X,Y,x^*)=\int_fp(y^*|f,X,Y,x^*)p(f|X,Y,x^*)df
\]</span><br>
对于数据集来说，取 <span class="math inline">\(f(X)\sim\mathcal{N}(\mu(X),k(X,X)),Y=f(X)+\varepsilon\sim\mathcal{N}(\mu(X),k(X,X)+\sigma^2\mathbb{I})\)</span>。预测任务的目的是给定一个新数据序列 <span class="math inline">\(X^*=(x_1^*,\cdots,x_M^*)^T\)</span>，得到 <span class="math inline">\(Y^*=f(X^*)+\varepsilon\)</span>。我们可以写出：<br>
<span class="math display">\[
\begin{pmatrix}Y\\f(X^*)\end{pmatrix}\sim\mathcal{N}\left(\begin{pmatrix}\mu(X)\\\mu(X^*)\end{pmatrix},\begin{pmatrix}k(X,X)+\sigma^2\mathbb{I}&amp;k(X,X^*)\\k(X^*,X)&amp;k(X^*,X^*)\end{pmatrix}\right)
\]</span><br>
根据高斯分布的方法：<br>
<span class="math display">\[
\begin{align*}x=\begin{pmatrix}x_a\\x_b\end{pmatrix}\sim\mathcal{N}\left(\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix},\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\right)\\
x_b|x_a\sim\mathcal{N}(\mu_{b|a},\Sigma_{b|a})\\
\mu_{b|a}=\Sigma_{ba}\Sigma_{aa}^{-1}(x_a-\mu_a)+\mu_b\\
\Sigma_{b|a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{align*}
\]</span><br>
可以直接写出：<br>
<span class="math display">\[
\begin{gather*}
p(f(X^*)|X,Y,X^*)=p(f(X^*)|Y)\\
=\mathcal{N}(k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{-1}(Y-\mu(X))+\mu(X^*),\\
k(X^*,X^*)-k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{1}k(X,X^*))
\end{gather*}
\]</span><br>
所以对于 <span class="math inline">\(Y=f(X^*)+\varepsilon\)</span>：<br>
<span class="math display">\[
\begin{gather*}
\mathcal{N}(k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{-1}(Y-\mu(X))+\mu(X^*),\\
k(X^*,X^*)-k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{1}k(X,X^*)+\sigma^2\mathbb{I})
\end{gather*}
\]</span><br>
我们看到，函数空间的观点更加简单易于求解。</p>
<h1 id="受限玻尔兹曼机">受限玻尔兹曼机</h1>
<p>玻尔兹曼机是一种存在隐节点的无向图模型。在图模型中最简单的是朴素贝叶斯模型（朴素贝叶斯假设），引入单个隐变量后，发展出了 GMM，如果单个隐变量变成序列的隐变量，就得到了状态空间模型（引入齐次马尔可夫假设和观测独立假设就有HMM，Kalman Filter，Particle Filter），为了引入观测变量之间的关联，引入了一种最大熵模型-MEMM，为了克服 MEMM 中的局域问题，又引入了 CRF，CRF 是一个无向图，其中，破坏了齐次马尔可夫假设，如果隐变量是一个链式结构，那么又叫线性链 CRF。</p>
<p>在无向图的基础上，引入隐变量得到了玻尔兹曼机，这个图模型的概率密度函数是一个指数族分布。对隐变量和观测变量作出一定的限制，就得到了受限玻尔兹曼机（RBM）。</p>
<p>我们看到，不同的概率图模型对下面几个特点作出假设：</p>
<ol type="1">
<li>方向-边的性质</li>
<li>离散/连续/混合-点的性质</li>
<li>条件独立性-边的性质</li>
<li>隐变量-节点的性质</li>
<li>指数族-结构特点</li>
</ol>
<p>将观测变量和隐变量分别记为 <span class="math inline">\(v,h,h=\{h_1,\cdots,h_m\},v=\{v_1,\cdots,v_n\}\)</span>。我们知道，无向图根据最大团的分解，可以写为玻尔兹曼分布的形式 <span class="math inline">\(p(x)=\frac{1}{Z}\prod\limits_{i=1}^K\psi_i(x_{ci})=\frac{1}{Z}\exp(-\sum\limits_{i=1}^KE(x_{ci}))\)</span>，这也是一个指数族分布。</p>
<p>一个玻尔兹曼机存在一系列的问题，在其推断任务中，想要精确推断，是无法进行的，想要近似推断，计算量过大。为了解决这个问题，一种简化的玻尔兹曼机-受限玻尔兹曼机作出了假设，所有隐变量内部以及观测变量内部没有连接，只在隐变量和观测变量之间有连接，这样一来：<br>
<span class="math display">\[
p(x)=p(h,v)=\frac{1}{Z}\exp(-E(v,h))
\]</span><br>
其中能量函数 <span class="math inline">\(E(v,h)\)</span> 可以写出三个部分，包括与节点集合相关的两项以及与边 <span class="math inline">\(w\)</span> 相关的一项，记为：<br>
<span class="math display">\[
E(v,h)=-(h^Twv+\alpha^T v+\beta^T h)
\]</span><br>
所以：<br>
<span class="math display">\[
p(x)=\frac{1}{Z}\exp(h^Twv)\exp(\alpha^T v)\exp(\beta^T h)=\frac{1}{Z}\prod_{i=1}^m\prod_{j=1}^n\exp(h_iw_{ij}v_j)\prod_{j=1}^n\exp(\alpha_jv_j)\prod_{i=1}^m\exp(\beta_ih_i)
\]</span><br>
上面这个式子也和 RBM 的因子图一一对应。</p>
<h2 id="推断-2">推断</h2>
<p>推断任务包括求后验概率 $ p(v|h),p(h|v)$ 以及求边缘概率 <span class="math inline">\(p(v)\)</span>。</p>
<h3 id="phv"><span class="math inline">\(p(h|v)\)</span></h3>
<p>对于一个无向图，满足局域的 Markov 性质，即 <span class="math inline">\(p(h_1|h-\{h_1\},v)=p(h_1|Neighbour(h_1))=p(h_1|v)\)</span>。我们可以得到：<br>
<span class="math display">\[
p(h|v)=\prod_{i=1}^mp(h_i|v)
\]</span><br>
考虑 Binary RBM，所有的隐变量只有两个取值 <span class="math inline">\(0,1\)</span>：<br>
<span class="math display">\[
p(h_l=1|v)=\frac{p(h_l=1,h_{-l},v)}{p(h_{-l},v)}=\frac{p(h_l=1,h_{-l},v)}{p(h_l=1,h_{-l},v)+p(h_l=0,h_{-l},v)}
\]</span><br>
将能量函数写成和 <span class="math inline">\(l\)</span> 相关或不相关的两项：<br>
<span class="math display">\[
E(v,h)=-(\sum\limits_{i=1,i\ne l}^m\sum\limits_{j=1}^nh_iw_{ij}v_j+h_l\sum\limits_{j=1}^nw_{lj}v_j+\sum\limits_{j=1}^n\alpha_j v_j+\sum\limits_{i=1,i\ne l}^m\beta_ih_i+\beta_lh_l)
\]</span><br>
定义：<span class="math inline">\(h_lH_l(v)=h_l\sum\limits_{j=1}^nw_{lj}v_j+\beta_lh_l,\overline{H}(h_{-l},v)=\sum\limits_{i=1,i\ne l}^m\sum\limits_{j=1}^nh_iw_{ij}v_j+\sum\limits_{j=1}^n\alpha_j v_j+\sum\limits_{i=1,i\ne l}^m\beta_ih_i\)</span>。</p>
<p>代入，有：<br>
<span class="math display">\[
p(h_l=1|v)=\frac{\exp(H_l(v)+\overline{H}(h_{-l},v))}{\exp(H_l(v)+\overline{H}(h_{-l},v))+\exp(\overline{H}(h_{-l},v))}=\frac{1}{1+\exp(-H_l(v))}=\sigma(H_l(v))
\]</span><br>
于是就得到了后验概率。对于 <span class="math inline">\(v\)</span> 的后验是对称的，所以类似的可以求解。</p>
<h3 id="pv"><span class="math inline">\(p(v)\)</span></h3>
<p><span class="math display">\[
\begin{align*}p(v)&amp;=\sum\limits_hp(h,v)=\sum\limits_h\frac{1}{Z}\exp(h^Twv+\alpha^Tv+\beta^Th)\\
&amp;=\exp(\alpha^Tv)\frac{1}{Z}\sum\limits_{h_1}\exp(h_1w_1v+\beta_1h_1)\cdots\sum\limits_{h_m}\exp(h_mw_mv+\beta_mh_m)\\
&amp;=\exp(\alpha^Tv)\frac{1}{Z}(1+\exp(w_1v+\beta_1))\cdots(1+\exp(w_mv+\beta_m))\\
&amp;=\frac{1}{Z}\exp(\alpha^Tv+\sum\limits_{i=1}^m\log(1+\exp(w_iv+\beta_i)))
\end{align*}
\]</span></p>
<p>其中，<span class="math inline">\(\log(1+\exp(x))\)</span> 叫做 Softplus 函数。</p>
<h1 id="谱聚类">谱聚类</h1>
<p>聚类问题可以分为两种思路：</p>
<ol type="1">
<li>Compactness，这类有 K-means，GMM 等，但是这类算法只能处理凸集，为了处理非凸的样本集，必须引入核技巧。</li>
<li>Connectivity，这类以谱聚类为代表。</li>
</ol>
<p>谱聚类是一种基于无向带权图的聚类方法。这个图用 <span class="math inline">\(G=(V,E)\)</span> 表示，其中 <span class="math inline">\(V=\{1,2,\cdots,N\}\)</span>，<span class="math inline">\(E=\{w_{ij}\}\)</span>，这里 <span class="math inline">\(w_{ij}\)</span> 就是边的权重，这里权重取为相似度，<span class="math inline">\(W=(w_{ij})\)</span> 是相似度矩阵，定义相似度（径向核）：<br>
<span class="math display">\[
\begin{gather*}
w_{ij}=k(x_i,x_j)=\exp(-\frac{||x_i-x_j||_2^2}{2\sigma^2}),(i,j)\in E\\
w_{ij}=0,(i,j)\notin E
\end{gather*}
\]</span><br>
下面定义图的分割，这种分割就相当于聚类的结果。定义 <span class="math inline">\(w(A,B)\)</span>：<br>
<span class="math display">\[
A\subset V,B\subset V,A\cap B=\emptyset,w(A,B)=\sum\limits_{i\in A,j\in B}w_{ij}
\]</span><br>
假设一共有 <span class="math inline">\(K\)</span> 个类别，对这个图的分割 <span class="math inline">\(CUT(V)=CUT(A_1,A_2,\cdots,A_K)=\sum\limits_{k=1}^Kw(A_k,\overline{A_k})=\sum\limits_{k=1}^K[w(A_k,V)-w(A_k,A_k)]\)</span></p>
<p>于是，我们的目标就是 <span class="math inline">\(\min\limits_{A_k}CUT(V)\)</span>。</p>
<p>为了平衡每一类内部的权重不同，我们做归一化的操作，定义每一个集合的度，首先，对单个节点的度定义：<br>
<span class="math display">\[
d_i=\sum\limits_{j=1}^Nw_{ij}
\]</span><br>
其次，每个集合：<br>
<span class="math display">\[
\Delta_k=degree(A_k)=\sum\limits_{i\in A_k}d_i
\]</span><br>
于是：<br>
<span class="math display">\[
N(CUT)=\sum\limits_{k=1}^K\frac{w(A_k,\overline{A_k})}{\sum\limits_{i\in A_k}d_i}
\]</span><br>
所以目标函数就是最小化这个式子。</p>
<p>谱聚类的模型就是：<br>
<span class="math display">\[
\{\hat{A}_k\}_{k=1}^K=\mathop{argmin}_{A_k}N(CUT)
\]</span><br>
引入指示向量：<br>
<span class="math display">\[
\left\{
\begin{align*}y_i\in \{0,1\}^K\\
\sum\limits_{j=1}^Ky_{ij}=1\end{align*}
\right.
\]</span><br>
其中，<span class="math inline">\(y_{ij}\)</span> 表示第 <span class="math inline">\(i\)</span> 个样本属于 <span class="math inline">\(j\)</span> 个类别，记：<span class="math inline">\(Y=(y_1,y_2,\cdots,y_N)^T\)</span>。所以：<br>
<span class="math display">\[
\hat{Y}=\mathop{argmin}_YN(CUT)
\]</span><br>
将 <span class="math inline">\(N(CUT)\)</span> 写成对角矩阵的形式，于是：<br>
<span class="math display">\[
\begin{align*}N(CUT)&amp;=Trace[diag(\frac{w(A_1,\overline{A_1})}{\sum\limits_{i\in A_1}d_i},\frac{w(A_2,\overline{A_2})}{\sum\limits_{i\in A_2}d_i},\cdots,\frac{w(A_K,\overline{A_K})}{\sum\limits_{i\in A_K}d_i})]\\
&amp;=Trace[diag(w(A_1,\overline{A_1}),w(A_2,\overline{A_2}),\cdots,w(A_K,\overline{A_K}))\cdot diag(\sum\limits_{i\in A_1}d_i,\cdots,\sum\limits_{i\in A_K}d_i)^{-1}]\\
&amp;=Trace[O\cdot P^{-1}]
\end{align*}
\]</span><br>
我们已经知道 <span class="math inline">\(Y,w\)</span> 这两个矩阵，我们希望求得 <span class="math inline">\(O,P\)</span>。</p>
<p>由于：<br>
<span class="math display">\[
Y^TY=\sum\limits_{i=1}^Ny_iy_i^T
\]</span><br>
对于 <span class="math inline">\(y_iy_i^T\)</span>，只在对角线上的 <span class="math inline">\(k\times k\)</span> 处为 1，所以：<br>
<span class="math display">\[
Y^TY=diag(N_1,N_2,\cdots,N_K)
\]</span><br>
其中，<span class="math inline">\(N_i\)</span> 表示有 <span class="math inline">\(N_i\)</span> 个样本属于 <span class="math inline">\(i\)</span>，即 <span class="math inline">\(N_k=\sum\limits_{k\in A_k}1\)</span>。</p>
<p>引入对角矩阵，根据 <span class="math inline">\(d_i\)</span> 的定义， <span class="math inline">\(D=diag(d_1,d_2,\cdots,d_N)=diag(w_{NN}\mathbb{I}_{N1})\)</span>，于是：<br>
<span class="math display">\[
P=Y^TDY
\]</span><br>
对另一项 <span class="math inline">\(O=diag(w(A_1,\overline{A_1}),w(A_2,\overline{A_2}),\cdots,w(A_K,\overline{A_K})\)</span>：<br>
<span class="math display">\[
O=diag(w(A_i,V))-diag(w(A_i,A_i))=diag(\sum\limits_{j\in A_i}d_j)-diag(w(A_i,A_i))
\]</span><br>
其中，第一项已知，第二项可以写成 <span class="math inline">\(Y^TwY\)</span>，这是由于：<br>
<span class="math display">\[
Y^TwY=\sum\limits_{i=1}^N\sum\limits_{j=1}^Ny_iy_j^Tw_{ij}
\]</span><br>
于是这个矩阵的第 <span class="math inline">\(lm\)</span> 项可以写为：<br>
<span class="math display">\[
\sum\limits_{i\in A_l,j\in A_m}w_{ij}
\]</span><br>
这个矩阵的对角线上的项和 <span class="math inline">\(w(A_i,A_i)\)</span> 相同，所以取迹后的取值不会变化。</p>
<p>所以：<br>
<span class="math display">\[
N(CUT)=Trace[(Y^T(D-w))Y)\cdot(Y^TDY)^{-1}]
\]</span><br>
其中，$ L=D-w$ 叫做拉普拉斯矩阵。</p>
<h1 id="前馈神经网络">前馈神经网络</h1>
<p>机器学习我们已经知道可以分为两大流派：</p>
<ol type="1">
<li><p>频率派，这个流派的方法叫做统计学习，根据具体问题有下面的算法：</p>
<ol type="1">
<li><p>正则化，L1，L2 等</p></li>
<li><p>核化，如核支撑向量机</p></li>
<li><p>集成化，AdaBoost，RandomForest</p></li>
<li><p>层次化，神经网络，神经网络有各种不同的模型，有代表性的有：</p>
<ol type="1">
<li>多层感知机</li>
<li>Autoencoder</li>
<li>CNN</li>
<li>RNN</li>
</ol>
<p>这几种模型又叫做深度神经网络。</p></li>
</ol></li>
<li><p>贝叶斯派，这个流派的方法叫概率图模型，根据图特点分为：</p>
<ol type="1">
<li>有向图-贝叶斯网络，加入层次化后有深度有向网络，包括
<ol type="1">
<li>Sigmoid Belief Network</li>
<li>Variational Autoencoder</li>
<li>GAN</li>
</ol></li>
<li>无向图-马尔可夫网络，加入层次化后有深度玻尔兹曼机。</li>
<li>混合，加入层次化后有深度信念网络</li>
</ol>
<p>这几个加入层次化后的模型叫做深度生成网络。</p></li>
</ol>
<p>从广义来说，深度学习包括深度生成网络和深度神经网络。</p>
<h2 id="from-pla-to-dl">From PLA to DL</h2>
<ul>
<li>1958，PLA</li>
<li>1969，PLA 不能解决 XOR 等非线性数据</li>
<li>1981，MLP，多层感知机的出现解决了上面的问题</li>
<li>1986，BP 算法应用在 MLP 上，RNN</li>
<li>1989，CNN，Univeral Approximation Theorem，但是于此同时，由于深度和宽度的相对效率不知道，并且无法解决 BP 算法的梯度消失问题</li>
<li>1993，1995，SVM + kernel，AdaBoost，RandomForest，这些算法的发展，DL 逐渐没落</li>
<li>1997，LSTM</li>
<li>2006，基于 RBM 的 深度信念网络和深度自编码</li>
<li>2009，GPU的发展</li>
<li>2011，在语音方面的应用</li>
<li>2012，ImageNet</li>
<li>2013，VAE</li>
<li>2014，GAN</li>
<li>2016，AlphaGo</li>
<li>2018，GNN</li>
</ul>
<p>DL 不是一个新的东西，其近年来的大发展主要原因如下：</p>
<ol type="1">
<li>数据量变大</li>
<li>分布式计算的发展</li>
<li>硬件算力的发展</li>
</ol>
<h2 id="非线性问题">非线性问题</h2>
<p>对于非线性的问题，有三种方法：</p>
<ol type="1">
<li>非线性转换，将低维空间转换到高维空间（Cover 定理），从而变为一个线性问题。</li>
<li>核方法，由于非线性转换是变换为高维空间，因此可能导致维度灾难，并且可能很难得到这个变换函数，核方法不直接寻找这个转换，而是寻找一个内积。</li>
<li>神经网络方法，将复合运算变为基本的线性运算的组合。</li>
</ol>
<h1 id="配分函数">配分函数</h1>
<p>在学习和推断中，对于一个概率的归一化因子很难处理，这个归一化因子和配分函数相关。假设一个概率分布：<br>
<span class="math display">\[
p(x|\theta)=\frac{1}{Z(\theta)}\hat{p}(x|\theta),Z(\theta)=\int\hat{p}(x|\theta)dx
\]</span></p>
<h2 id="包含配分函数的-mle">包含配分函数的 MLE</h2>
<p>在学习任务中，采用最大似然：<br>
<span class="math display">\[
\begin{align*}
\hat{\theta}&amp;=\mathop{argmax}_{\theta}p(x|\theta)=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log p(x_i|\theta)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log \hat{p}(x|\theta)-N\log Z(\theta)\\
&amp;=\mathop{argmax}_{\theta}\frac{1}{N}\sum\limits_{i=1}^N\log \hat{p}(x|\theta)-\log Z(\theta)=\mathop{argmax}_\theta l(\theta)
\end{align*}
\]</span><br>
求导：<br>
<span class="math display">\[
\begin{align*}\nabla_\theta\log Z(\theta)&amp;=\frac{1}{Z(\theta)}\nabla_\theta Z(\theta)\\
&amp;=\frac{p(x|\theta)}{\hat{p}(x|\theta)}\int\nabla_\theta \hat{p}(x|\theta)dx\\
&amp;=\int\frac{p(x|\theta)}{\hat{p}(x|\theta)}\nabla_\theta\hat{p}(x|\theta)dx\\
&amp;=\mathbb{E}_{p(x|\theta)}[\nabla_\theta\log\hat{p}(x|\theta)]
\end{align*}
\]</span><br>
由于这个表达式和未知的概率相关，于是无法直接精确求解，需要近似采样，如果没有这一项，那么可以采用梯度下降，但是存在配分函数就无法直接采用梯度下降了。</p>
<p>上面这个期望值，是对模型假设的概率分布，定义真实概率分布为 <span class="math inline">\(p_{data}\)</span>，于是，<span class="math inline">\(l(\theta)\)</span> 中的第一项的梯度可以看成是从这个概率分布中采样出来的 <span class="math inline">\(N\)</span> 个点求和平均，可以近似期望值。<br>
<span class="math display">\[
\nabla_\theta l(\theta)=\mathbb{E}_{p_{data}}[\nabla_\theta\log\hat{p}(x|\theta)]-\mathbb{E}_{p(x|\theta)}[\nabla_\theta\log\hat{p}(x|\theta)]
\]</span><br>
于是，相当于真实分布和模型假设越接近越好。上面这个式子第一项叫做正相，第二项叫做负相。为了得到负相的值，需要采用各种采样方法，如 MCMC。</p>
<p>采样得到 <span class="math inline">\(\hat{x}_{1-m}\sim p_{model}(x|\theta^t)\)</span>，那么：<br>
<span class="math display">\[
\theta^{t+1}=\theta^t+\eta(\sum\limits_{i=1}^m\nabla_\theta \log \hat{p}(x_i|\theta^t)-\sum\limits_{i=1}^m\nabla_\theta\log \hat{p}(\hat{x_i}|\theta^t))
\]</span><br>
这个算法也叫做基于 MCMC 采样的梯度上升。每次通过采样得到的样本叫做幻想粒子，如果这些幻想粒子区域的概率高于实际分布，那么最大化参数的结果就是降低这些部分的概率。</p>
<h2 id="对比散度-cd-learning">对比散度-CD Learning</h2>
<p>上面对于负相的采样，最大的问题是，采样到达平稳分布的步骤数量是未知的。对比散度的方法，是对上述的采样是的初始值作出限制，直接采样 <span class="math inline">\(\hat{x}_i=x_i\)</span>，这样可以缩短采样的混合时间。这个算法叫做 CD-k 算法，<span class="math inline">\(k\)</span> 就是初始化后进行的演化时间，很多时候，即使 <span class="math inline">\(k=1\)</span> 也是可以的。</p>
<p>我们看 MLE 的表达式：<br>
<span class="math display">\[
\begin{align*}\hat{\theta}&amp;=\mathop{argmax}_{\theta}p(x|\theta)=\mathop{argmax}_{\theta}\frac{1}{N}\sum\limits_{i=1}^N\log p(x_i|\theta)=\mathbb{E}_{p_{data}}[\log p_{model}(x|\theta)]\\
&amp;=\mathop{argmax}_\theta\int p_{data}\log p_{model}dx\\
&amp;=\mathop{argmax}_\theta\int p_{data}\log \frac{p_{model}}{p_{data}}dx\\
&amp;=\mathop{argmin}_\theta KL(p_{data}||p_{model})
\end{align*}
\]</span><br>
对于 CD-k 的采样过程，可以将初始值这些点表示为：<br>
<span class="math display">\[
p^0=p_{data}
\]</span><br>
而我们的模型需要采样过程达到平稳分布：<br>
<span class="math display">\[
p^\infty=p_{model}
\]</span><br>
因此，我们需要的是 <span class="math inline">\(KL(p^0||p^\infty)\)</span>。定义 CD：<br>
<span class="math display">\[
KL(p^0||p^\infty)-KL(p^k||p^\infty)
\]</span><br>
这就是 CD-k 算法第 <span class="math inline">\(k\)</span> 次采样的目标函数。</p>
<h2 id="rbm-的学习问题">RBM 的学习问题</h2>
<p>RBM 的参数为：<br>
<span class="math display">\[
\begin{align*}
h=(h_1,\cdots,h_m)^T\\
v=(v_1,\cdots,v_n)^T\\
w=(w_{ij})_{mn}\\
\alpha=(\alpha_1,\cdots,\alpha_n)^T\\
\beta=(\beta_1,\cdots,\beta_m)^T
\end{align*}
\]</span><br>
学习问题关注的概率分布为：<br>
<span class="math display">\[
\begin{align*}
\log p(v)&amp;=\log\sum\limits_{h}p(h,v)\\
&amp;=\log\sum\limits_h\frac{1}{Z}\exp(-E(v,h))\\
&amp;=\log\sum\limits_{h}\exp(-E(v,h))-\log\sum\limits_{v,h}\exp(-E(h,v))
\end{align*}
\]</span><br>
对上面这个式子求导第一项：<br>
<span class="math display">\[
\begin{align*}
\frac{\partial \log\sum\limits_{h}\exp(-E(v,h))}{\partial\theta}&amp;=-\frac{\sum\limits_h\exp(-E(v,h))\frac{\partial E(v,h)}{\partial\theta}}{\sum\limits_{h}\exp(-E(v,h))}\\
&amp;=-\sum\limits_h\frac{\exp(-E(v,h))\frac{\partial E(v,h)}{\partial\theta}}{\sum\limits_{h}\exp(-E(v,h))}\\&amp;=-\sum\limits_hp(h|v)\frac{\partial E(v,h)}{\partial\theta}
\end{align*}
\]</span><br>
第二项：<br>
<span class="math display">\[
\frac{\partial \log\sum\limits_{v,h}\exp(-E(h,v))}{\partial\theta}=-\sum\limits_{h,v}\frac{\exp(-E(v,h))\frac{\partial E(v,h)}{\partial\theta}}{\sum\limits_{h,v}\exp(-E(v,h))}=-\sum\limits_{v,h}p(v,h)\frac{\partial E(v,h)}{\partial\theta}
\]</span><br>
所以有：<br>
<span class="math display">\[
\frac{\partial}{\partial\theta}\log p(v)=-\sum\limits_hp(h|v)\frac{\partial E(v,h)}{\partial\theta}+\sum\limits_{v,h}p(v,h)\frac{\partial E(v,h)}{\partial\theta}
\]</span><br>
将 RBM 的模型假设代入：<br>
<span class="math display">\[
E(v,h)=-(h^Twv+\alpha^Tv+\beta^Th)
\]</span></p>
<ol type="1">
<li><p><span class="math inline">\(w_{ij}\)</span>：<br>
<span class="math display">\[
\frac{\partial}{\partial w_{ij}}E(v,h)=-h_iv_j
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial}{\partial\theta}\log p(v)=\sum\limits_{h}p(h|v)h_iv_j-\sum\limits_{h,v}p(h,v)h_iv_j
\]</span><br>
第一项：<br>
<span class="math display">\[
\sum\limits_{h_1,h_2,\cdots,h_m}p(h_1,h_2,\cdots,h_m|v)h_iv_j=\sum\limits_{h_i}p(h_i|v)h_iv_j=p(h_i=1|v)v_j
\]</span><br>
这里假设了 <span class="math inline">\(h_i\)</span> 是二元变量。</p>
<p>第二项：<br>
<span class="math display">\[
\sum\limits_{h,v}p(h,v)h_iv_j=\sum\limits_{h,v}p(v)p(h|v)h_iv_j=\sum\limits_vp(v)p(h_i=1|v)v_j
\]</span><br>
这个求和是指数阶的，于是需要采样解决，我么使用 CD-k 方法。</p>
<p>对于第一项，可以直接使用训练样本得到，第二项采用 CD-k 采样方法，首先使用样本 <span class="math inline">\(v^0=v\)</span>，然后采样得到 <span class="math inline">\(h^0\)</span>，然后采样得到 <span class="math inline">\(v^1\)</span>，这样顺次进行，最终得到 <span class="math inline">\(v^k\)</span>，对于每个样本都得到一个 <span class="math inline">\(v^k\)</span>，最终采样得到 <span class="math inline">\(N\)</span> 个 $v^k $，于是第二项就是：<br>
<span class="math display">\[
p(h_i=1|v^k)v_j^k
\]</span><br>
具体的算法为：</p>
<ol type="1">
<li>对每一个样本中的 <span class="math inline">\(v\)</span>，进行采样：
<ol type="1">
<li>使用这个样本初始化采样</li>
<li>进行 <span class="math inline">\(k\)</span> 次采样（0-k-1）：
<ol type="1">
<li><span class="math inline">\(h_i^l\sim p(h_i|v^l)\)</span></li>
<li><span class="math inline">\(v_i^{l+1}\sim p(v_i|h^l)\)</span></li>
</ol></li>
<li>将这些采样出来的结果累加进梯度中</li>
</ol></li>
<li>重复进行上述过程，最终的梯度除以 <span class="math inline">\(N\)</span></li>
</ol></li>
</ol>
<h1 id="近似推断">近似推断</h1>
<p>这一讲中的近似推断具体描述在深度生成模型中的近似推断。推断的目的有下面几个部分：</p>
<ol type="1">
<li>推断本身，根据结果（观测）得到原因（隐变量）。</li>
<li>为参数的学习提供帮助。</li>
</ol>
<p>但是推断本身是一个困难的额任务，计算复杂度往往很高，对于无向图，由于节点之间的联系过多，那么因子分解很难进行，并且相互之间都有耦合，于是很难求解，仅仅在某些情况如 RBM 中可解，在有向图中，常常由于条件独立性问题，如两个节点之间条件相关（explain away），于是求解这些节点的条件概率就很困难，仅仅在某些概率假设情况下可解如高斯模型，于是需要近似推断。</p>
<p>事实上，我们常常讲推断问题变为优化问题，即：<br>
<span class="math display">\[
Log-likehood:\sum\limits_{v\in V}\log p(v)
\]</span><br>
对上面这个问题，由于：<br>
<span class="math display">\[
\log p(v)=\log\frac{p(v,h)}{p(h|v)}=\log\frac{p(v,h)}{q(h|v)}+\log\frac{q(h|v)}{p(h|v)}
\]</span><br>
左右两边对 <span class="math inline">\(h\)</span> 积分：<br>
<span class="math display">\[
\int_h\log p(v)\cdot q(h|v)dh=\log p(v)
\]</span><br>
右边积分有：<br>
<span class="math display">\[
\mathbb{E}_{q(h|v)}[\log\frac{p(v,h)}{q(h|v)}]+KL(q(h|v)||p(h|v))=\mathbb{E}_{q(h|v)}[\log p(v,h)]+H(q)+KL(q||p)
\]</span><br>
其中前两项是 ELBO，于是这就变成一个优化 ELBO 的问题。</p>
<h1 id="总结">总结</h1>
<h2 id="math">Math</h2>
<ol type="1">
<li><p>MLE<br>
<span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span></p></li>
<li><p>MAP<br>
<span class="math display">\[
\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)
\]</span></p></li>
<li><p>Gaussian Distribution<br>
<span class="math display">\[
\begin{align*}&amp;p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}\\
&amp;\Delta=(x-\mu)^{T}\Sigma^{-1}(x-\mu)=\sum\limits _{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu)=\sum\limits _{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}}
\end{align*}
\]</span></p></li>
<li><p>已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma), y\sim Ax+b\)</span>，有：<br>
<span class="math display">\[
\begin{align*}y\sim\mathcal{N}(A\mu+b, A\Sigma A^T)
\end{align*}
\]</span></p></li>
<li><p>记 <span class="math inline">\(x=(x_1, x_2,\cdots,x_p)^T=(x_{a,m\times 1}, x_{b,n\times1})^T,\mu=(\mu_{a,m\times1}, \mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)</span>，已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma)\)</span>，则：<br>
<span class="math display">\[
\begin{align*}&amp;x_a\sim\mathcal{N}(\mu_a,\Sigma_{aa})\\
&amp;x_b|x_a\sim\mathcal{N}(\mu_{b|a},\Sigma_{b|a})\\
&amp;\mu_{b|a}=\Sigma_{ba}\Sigma_{aa}^{-1}(x_a-\mu_a)+\mu_b\\
&amp;\Sigma_{b|a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{align*}
\]</span></p></li>
</ol>
<h2 id="linear-regression">Linear Regression</h2>
<h3 id="model">Model</h3>
<ol type="1">
<li><p>Dataset:<br>
<span class="math display">\[
\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}
\]</span></p></li>
<li><p>Notation:<br>
<span class="math display">\[
X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T
\]</span></p></li>
<li><p>Model:<br>
<span class="math display">\[
f(w)=w^Tx
\]</span></p></li>
</ol>
<h3 id="loss-function">Loss Function</h3>
<ol type="1">
<li>最小二乘误差/高斯噪声的MLE<br>
<span class="math display">\[
L(w)=\sum\limits_{i=1}^N||w^Tx_i-y_i||^2_2
\]</span></li>
</ol>
<h3 id="闭式解">闭式解</h3>
<p><span class="math display">\[
\begin{align*}\hat{w}=(X^TX)^{-1}X^TY=X^+Y\\
X=U\Sigma V^T\\
X^+=V\Sigma^{-1}U^T
\end{align*}
\]</span></p>
<h3 id="正则化-1">正则化</h3>
<p><span class="math display">\[
\begin{align*}
L1-Gaussian \ priori&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||_1,\lambda\gt0\\
L2-Laplasian\ priori-Sparsity&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||^2_2,\lambda \gt 0
\end{align*}
\]</span></p>
<h2 id="linear-classification">Linear Classification</h2>
<h3 id="hard">Hard</h3>
<h4 id="pca">PCA</h4>
<ol type="1">
<li><p>Idea: 在线性模型上加入激活函数</p></li>
<li><p>Loss Function:</p></li>
</ol>
<p><span class="math display">\[
L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i
\]</span></p>
<ol start="3" type="1">
<li>Parameters:</li>
</ol>
<p><span class="math display">\[
w^{t+1}\leftarrow w^{t}+\lambda y_ix_i
\]</span></p>
<h4 id="fisher">Fisher</h4>
<ol type="1">
<li><p>Idea: 投影，类内小，类间大。</p></li>
<li><p>Loss Function:<br>
<span class="math display">\[
\begin{align*}&amp;J(w)=\frac{w^TS_bw}{w^TS_ww}\\
&amp;S_b=(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^T\\
&amp;S_w=S_1+S_2
\end{align*}
\]</span></p></li>
<li><p>闭式解，投影方向:<br>
<span class="math display">\[
S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})
\]</span></p></li>
</ol>
<h3 id="soft">Soft</h3>
<h4 id="判别模型">判别模型</h4>
<h5 id="logistic-regression">Logistic Regression</h5>
<ol type="1">
<li><p>Idea，激活函数:<br>
<span class="math display">\[
\begin{align*}p(C_1|x)&amp;=\frac{1}{1+\exp(-a)}\\
a&amp;=w^Tx
\end{align*}
\]</span></p></li>
<li><p>Loss Function(交叉熵):<br>
<span class="math display">\[
\hat{w}=\mathop{argmax}_wJ(w)=\mathop{argmax}_w\sum\limits_{i=1}^N(y_i\log p_1+(1-y_i)\log p_0)
\]</span></p></li>
<li><p>解法，SGD<br>
<span class="math display">\[
J&#39;(w)=\sum\limits_{i=1}^N(y_i-p_1)x_i
\]</span></p></li>
</ol>
<h4 id="生成模型">生成模型</h4>
<h5 id="gda">GDA</h5>
<ol type="1">
<li><p>Model</p>
<ol type="1">
<li><span class="math inline">\(y\sim Bernoulli(\phi)\)</span></li>
<li><span class="math inline">\(x|y=1\sim\mathcal{N}(\mu_1,\Sigma)\)</span></li>
<li><span class="math inline">\(x|y=0\sim\mathcal{N}(\mu_0,\Sigma)\)</span></li>
</ol></li>
<li><p>MAP<br>
<span class="math display">\[
\begin{align*}
&amp;\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)\\
&amp;=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log \mathcal{N}(\mu_1,\Sigma)+y_i\log\phi+(1-y_i)\log(1-\phi))
\end{align*}
\]</span></p></li>
<li><p>解<br>
<span class="math display">\[
\begin{align*}\phi&amp;=\frac{N_1}{N}\\
\mu_1&amp;=\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1}\\
\mu_0&amp;=\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0}\\
\Sigma&amp;=\frac{N_1S_1+N_2S_2}{N}
\end{align*}
\]</span></p></li>
</ol>
<h5 id="naive-bayesian">Naive Bayesian</h5>
<ol type="1">
<li><p>Model, 对单个数据点的各个维度作出限制<br>
<span class="math display">\[
x_i\perp x_j|y,\forall\  i\ne j
\]</span></p>
<ol type="1">
<li><span class="math inline">\(x_i\)</span> 为连续变量：<span class="math inline">\(p(x_i|y)=\mathcal{N}(\mu_i,\sigma_i^2)\)</span></li>
<li><span class="math inline">\(x_i\)</span> 为离散变量：类别分布（Categorical）：<span class="math inline">\(p(x_i=i|y)=\theta_i,\sum\limits_{i=1}^K\theta_i=1\)</span></li>
<li><span class="math inline">\(p(y)=\phi^y(1-\phi)^{1-y}\)</span></li>
</ol></li>
<li><p>解：和GDA相同</p></li>
</ol>
<h2 id="dimension-reduction">Dimension Reduction</h2>
<p>中心化：<br>
<span class="math display">\[
\begin{align*}S
&amp;=\frac{1}{N}X^T(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})^TX\\
&amp;=\frac{1}{N}X^TH^2X=\frac{1}{N}X^THX
\end{align*}
\]</span></p>
<h3 id="pca-1">PCA</h3>
<ol type="1">
<li><p>Idea: 坐标变换，寻找线性无关的新基矢，取信息损失最小的前几个维度</p></li>
<li><p>Loss Function:<br>
<span class="math display">\[
\begin{align*}J
&amp;=\sum\limits_{j=1}^qu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align*}
\]</span></p></li>
<li><p>解：</p>
<ol type="1">
<li><p>特征分解法<br>
<span class="math display">\[
S=U\Lambda U^T
\]</span></p></li>
<li><p>SVD for X/S<br>
<span class="math display">\[
\begin{align*}HX=U\Sigma V^T\\
S=\frac{1}{N}V\Sigma^T\Sigma V^T
\\new\ co=HX\cdot V\end{align*}
\]</span></p></li>
<li><p>SVD for T<br>
<span class="math display">\[
\begin{align*}T=HXX^TH=U\Sigma\Sigma^TU^T\\
new\ co=U\Sigma
\end{align*}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="p-pca-1">p-PCA</h3>
<ol type="1">
<li><p>Model:<br>
<span class="math display">\[
\begin{align*}
z&amp;\sim\mathcal{N}(\mathbb{O}_{q1},\mathbb{I}_{qq})\\
x&amp;=Wz+\mu+\varepsilon\\
\varepsilon&amp;\sim\mathcal{N}(0,\sigma^2\mathbb{I}_{pp})
\end{align*}
\]</span></p></li>
<li><p>Learning: E-M</p></li>
<li><p>Inference:<br>
<span class="math display">\[
p(z|x)=\mathcal{N}(W^T(WW^T+\sigma^2\mathbb{I})^{-1}(x-\mu),\mathbb{I}-W^T(WW^T+\sigma^2\mathbb{I})^{-1}W)
\]</span></p></li>
</ol>
<h2 id="svm">SVM</h2>
<ol type="1">
<li>强对偶关系：凸优化+（松弛）Slater 条件-&gt;强对偶。</li>
<li>参数求解：KKT条件
<ol type="1">
<li>可行域</li>
<li>互补松弛+梯度为0</li>
</ol></li>
</ol>
<h3 id="hard-margin">Hard-margin</h3>
<ol type="1">
<li><p>Idea: 最大化间隔</p></li>
<li><p>Model:<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\ y_i(w^Tx_i+b)\ge1,i=1,2,\cdots,N
\]</span></p></li>
<li><p>对偶问题<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span></p></li>
<li><p>模型参数<br>
<span class="math display">\[
\begin{gather*}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)=0
\end{gather*}
\]</span></p></li>
</ol>
<h3 id="soft-margin">Soft-margin</h3>
<ol type="1">
<li><p>Idea:允许少量错误</p></li>
<li><p>Model:<br>
<span class="math display">\[
\begin{gather*}
error=\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}\\
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\end{gather*}
\]</span></p></li>
</ol>
<h3 id="kernel">Kernel</h3>
<p>对称的正定函数都可以作为正定核。</p>
<h2 id="exp-family">Exp Family</h2>
<ol type="1">
<li><p>表达式<br>
<span class="math display">\[
p(x|\eta)=h(x)\exp(\eta^T\phi(x)-A(\eta))=\frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))
\]</span></p></li>
<li><p>对数配分函数<br>
<span class="math display">\[
\begin{align*} 
A&#39;(\eta)=\mathbb{E}_{p(x|\eta)}[\phi(x)]\\
A&#39;&#39;(\eta)=Var_{p(x|\eta)}[\phi(x)]
\end{align*}
\]</span></p></li>
<li><p>指数族分布满足最大熵定理</p></li>
</ol>
<h2 id="pgm">PGM</h2>
<h3 id="representation">Representation</h3>
<ol type="1">
<li><p>有向图<br>
<span class="math display">\[
p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{parent(i)})
\]</span><br>
D-separation<br>
<span class="math display">\[
p(x_i|x_{-i})=\frac{p(x)}{\int p(x)dx_{i}}=\frac{\prod\limits_{j=1}^pp(x_j|x_{parents(j)})}{\int\prod\limits_{j=1}^pp(x_j|x_{parents(j)})dx_i}=\frac{p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)}{\int p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)dx_i}
\]</span></p></li>
<li><p>无向图<br>
<span class="math display">\[
\begin{align*}p(x)=\frac{1}{Z}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
Z=\sum\limits_{x\in\mathcal{X}}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
\phi(x_{ci})=\exp(-E(x_{ci}))
\end{align*}
\]</span></p></li>
<li><p>有向转无向</p>
<ol type="1">
<li>将每个节点的父节点两两相连</li>
<li>将有向边替换为无向边</li>
</ol></li>
</ol>
<h3 id="learning-1">Learning</h3>
<p>参数学习-EM</p>
<ol type="1">
<li><p>目的：解决具有隐变量的混合模型的参数估计（极大似然估计）</p></li>
<li><p>参数：<br>
<span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits_\theta\log p(x|\theta)
\]</span></p></li>
<li><p>迭代求解：<br>
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz=\mathbb{E}_{z|x,\theta^t}[\log p(x,z|\theta)]
\]</span></p></li>
<li><p>原理<br>
<span class="math display">\[
\log p(x|\theta^t)\le\log p(x|\theta^{t+1})
\]</span></p></li>
<li><p>广义EM</p>
<ol type="1">
<li><p>E step：<br>
<span class="math display">\[
\hat{q}^{t+1}(z)=\mathop{argmax}_q\int_zq^t(z)\log\frac{p(x,z|\theta)}{q^t(z)}dz,fixed\ \theta
\]</span></p></li>
<li><p>M step：<br>
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_\theta \int_zq^{t+1}(z)\log\frac{p(x,z|\theta)}{q^{t+1}(z)}dz,fixed\ \hat{q}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="inference">Inference</h3>
<ol type="1">
<li><p>精确推断</p>
<ol type="1">
<li><p>VE</p></li>
<li><p>BP<br>
<span class="math display">\[
m_{j\to i}(i)=\sum\limits_j\phi_j(j)\phi_{ij}(ij)\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}(j)
\]</span></p></li>
<li><p>MP<br>
<span class="math display">\[
m_{j\to i}=\max\limits_{j}\phi_j\phi_{ij}\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}
\]</span></p></li>
</ol></li>
<li><p>近似推断</p>
<ol type="1">
<li><p>确定性近似，VI</p>
<ol type="1">
<li><p>变分表达式<br>
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span></p></li>
<li><p>平均场近似下的 VI-坐标上升<br>
<span class="math display">\[
\begin{gather*}
\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]=\log \hat{p}(X,Z_j)\\
q_j(Z_j)=\hat{p}(X,Z_j)
\end{gather*}
\]</span></p></li>
<li><p>SGVI-变成优化问题，重参数法<br>
<span class="math display">\[
\begin{gather*}
\mathop{argmax}_{q(Z)}L(q)=\mathop{argmax}_{\phi}L(\phi)\\
\nabla_\phi L(\phi)=\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))]\\
=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log q_\phi(z)]\nabla_\phi g_\phi(\varepsilon,x^i)]\\
z=g_\phi(\varepsilon,x^i),\varepsilon\sim p(\varepsilon)
\end{gather*}
\]</span></p></li>
</ol></li>
<li><p>随机性近似</p>
<ol type="1">
<li><p>蒙特卡洛方法采样</p>
<ol type="1">
<li><p>CDF 采样</p></li>
<li><p>拒绝采样， <span class="math inline">\(q(z)\)</span>，使得 <span class="math inline">\(\forall z_i,Mq(z_i)\ge p(z_i)\)</span>，拒绝因子：<span class="math inline">\(\alpha=\frac{p(z^i)}{Mq(z^i)}\le1\)</span></p></li>
<li><p>重要性采样<br>
<span class="math display">\[
\mathbb{E}_{p(z)}[f(z)]=\int p(z)f(z)dz=\int \frac{p(z)}{q(z)}f(z)q(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span></p></li>
<li><p>重要性重采样：重要性采样+重采样</p></li>
</ol></li>
<li><p>MCMC：构建马尔可夫链概率序列，使其收敛到平稳分布 <span class="math inline">\(p(z)\)</span>。</p>
<ol type="1">
<li><p>转移矩阵（提议分布）<br>
<span class="math display">\[
\begin{gather*}
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=p(z^*)\cdot Q_{z^*\to z}\alpha(z^*,z)\\
\alpha(z,z^*)=\min\{1,\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}\}
\end{gather*}
\]</span></p></li>
<li><p>算法（MH）：</p>
<ol type="1">
<li>通过在0，1之间均匀分布取点 <span class="math inline">\(u\)</span></li>
<li>生成 <span class="math inline">\(z^*\sim Q(z^*|z^{i-1})\)</span></li>
<li>计算 <span class="math inline">\(\alpha\)</span> 值</li>
<li>如果 <span class="math inline">\(\alpha\ge u\)</span>，则 <span class="math inline">\(z^i=z^*\)</span>，否则 <span class="math inline">\(z^{i}=z^{i-1}\)</span></li>
</ol></li>
</ol></li>
<li><p>Gibbs 采样：给定初始值 <span class="math inline">\(z_1^0,z_2^0,\cdots\)</span>在 <span class="math inline">\(t+1\)</span> 时刻，采样 <span class="math inline">\(z_i^{t+1}\sim p(z_i|z_{-i})\)</span>，从第一个维度一个个采样。</p></li>
</ol></li>
</ol></li>
</ol>
<h2 id="gmm">GMM</h2>
<ol type="1">
<li><p>Model<br>
<span class="math display">\[
p(x)=\sum\limits_{k=1}^Kp_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span></p></li>
<li><p>求解-EM<br>
<span class="math display">\[
\begin{align*}Q(\theta,\theta^t)&amp;=\sum\limits_z[\log\prod\limits_{i=1}^Np(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_z[\sum\limits_{i=1}^N\log p(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p(x_i,z_i|\theta)p(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p_{z_i}\mathcal{N(x_i|\mu_{z_i},\Sigma_{z_i})}\frac{p_{z_i}^t\mathcal{N}(x_i|\mu_{z_i}^t,\Sigma_{z_i}^t)}{\sum\limits_kp_k^t\mathcal{N}(x_i|\mu_k^t,\Sigma_k^t)}
\end{align*}
\]</span></p>
<p><span class="math display">\[
p_k^{t+1}=\frac{1}{N}\sum\limits_{i=1}^Np(z_i=k|x_i,\theta^t)
\]</span></p></li>
</ol>
<h2 id="序列模型-hmmldsparticle">序列模型-HMM，LDS，Particle</h2>
<ol type="1">
<li><p>假设：</p>
<ol type="1">
<li><p>齐次 Markov 假设（未来只依赖于当前）：<br>
<span class="math display">\[
p(i_{t+1}|i_t,i_{t-1},\cdots,i_1,o_t,o_{t-1},\cdots,o_1)=p(i_{t+1}|i_t)
\]</span></p></li>
<li><p>观测独立假设：<br>
<span class="math display">\[
p(o_t|i_t,i_{t-1},\cdots,i_1,o_{t-1},\cdots,o_1)=p(o_t|i_t)
\]</span></p></li>
</ol></li>
<li><p>参数<br>
<span class="math display">\[
\lambda=(\pi,A,B)
\]</span></p></li>
</ol>
<h3 id="离散线性隐变量-hmm">离散线性隐变量-HMM</h3>
<ol type="1">
<li><p>Evaluation：<span class="math inline">\(p(O|\lambda)\)</span>，Forward-Backward 算法<br>
<span class="math display">\[
\begin{gather*}
p(O|\lambda)=\sum\limits_{i=1}^Np(O,i_T=q_i|\lambda)=\sum\limits_{i=1}^N\alpha_T(i)=\sum\limits_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)\\
\alpha_{t+1}(j)=\sum\limits_{i=1}^Nb_{j}(o_t)a_{ij}\alpha_t(i)\\
\beta_t(i)=\sum\limits_{j=1}^Nb_j(o_{t+1})a_{ij}\beta_{t+1}(j)
\end{gather*}
\]</span></p></li>
<li><p>Learning：<span class="math inline">\(\lambda=\mathop{argmax}\limits_{\lambda}p(O|\lambda)\)</span>，EM 算法（Baum-Welch）<br>
<span class="math display">\[
\begin{align*}
\lambda^{t+1}&amp;=\mathop{argmax}_\lambda\sum\limits_I\log p(O,I|\lambda)p(O,I|\lambda^t)\\&amp;=\sum\limits_I[\log \pi_{i_1}+\sum\limits_{t=2}^T\log a_{i_{t-1},i_t}+\sum\limits_{t=1}^T\log b_{i_t}(o_t)]p(O,I|\lambda^t)
\end{align*}
\]</span></p></li>
<li><p>Decoding：<span class="math inline">\(I=\mathop{argmax}\limits_{I}p(I|O,\lambda)\)</span>，Viterbi 算法-动态规划<br>
<span class="math display">\[
\begin{gather*}
\delta_{t}(j)=\max\limits_{i_1,\cdots,i_{t-1}}p(o_1,\cdots,o_t,i_1,\cdots,i_{t-1},i_t=q_i)\\\delta_{t+1}(j)=\max\limits_{1\le i\le N}\delta_t(i)a_{ij}b_j(o_{t+1})\\\psi_{t+1}(j)=\mathop{argmax}\limits_{1\le i\le N}\delta_t(i)a_{ij}
\end{gather*}
\]</span></p></li>
</ol>
<h3 id="连续线性隐变量-lds">连续线性隐变量-LDS</h3>
<ol type="1">
<li><p>Model<br>
<span class="math display">\[
\begin{align*}
p(z_t|z_{t-1})&amp;\sim\mathcal{N}(A\cdot z_{t-1}+B,Q)\\
p(x_t|z_t)&amp;\sim\mathcal{N}(C\cdot z_t+D,R)\\
z_1&amp;\sim\mathcal{N}(\mu_1,\Sigma_1)
\end{align*}
\]</span></p></li>
<li><p>滤波<br>
<span class="math display">\[
\begin{align*}
p(z_t|x_{1:t})&amp;=p(x_{1:t},z_t)/p(x_{1:t})\propto p(x_{1:t},z_t)\\&amp;=p(x_t|z_t)p(z_t|x_{1:t-1})p(x_{1:t-1})\propto p(x_t|z_t)p(z_t|x_{1:t-1})
\end{align*}
\]</span></p></li>
<li><p>递推求解-线性高斯模型</p>
<ol type="1">
<li><p>Prediction<br>
<span class="math display">\[
\begin{align*}
p(z_t|x_{1:t-1})&amp;=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}\\&amp;=\int_{z_{t-1}}\mathcal{N}(Az_{t-1}+B,Q)\mathcal{N}(\mu_{t-1},\Sigma_{t-1})dz_{t-1}
\end{align*}
\]</span></p></li>
<li><p>Update:<br>
<span class="math display">\[
p(z_t|x_{1:t})\propto p(x_t|z_t)p(z_t|x_{1:t-1}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="连续非线性隐变量-粒子滤波">连续非线性隐变量-粒子滤波</h3>
<p>通过采样(SIR)解决：<br>
<span class="math display">\[
\mathbb{E}[f(z)]=\int_zf(z)p(z)dz=\int_zf(z)\frac{p(z)}{q(z)}q(z)dz=\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span></p>
<ol type="1">
<li><p>采样<br>
<span class="math display">\[
\begin{gather*}
w_t^i\propto\frac{p(x_t|z_t)p(z_t|z_{t-1})}{q(z_t|z_{1:t-1},x_{1:t})}w_{t-1}^i\\
q(z_t|z_{1:t-1},x_{1:t})=p(z_t|z_{t-1})
\end{gather*}
\]</span></p></li>
<li><p>重采样</p></li>
</ol>
<h2 id="crf">CRF</h2>
<ol type="1">
<li><p>PDF<br>
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z(x,\theta)}\exp[\theta^TH(y_t,y_{t-1},x)]
\]</span></p></li>
<li><p>边缘概率<br>
<span class="math display">\[
\begin{gather*}
p(y_t=i|x)=\sum\limits_{y_{1:t-1}}\sum\limits_{y_{t+1:T}}\frac{1}{Z}\prod\limits_{t&#39;=1}^T\phi_{t&#39;}(y_{t&#39;-1},y_{t&#39;},x)\\
p(y_t=i|x)=\frac{1}{Z}\Delta_l\Delta_r\\
\Delta_l=\sum\limits_{y_{1:t-1}}\phi_{1}(y_0,y_1,x)\phi_2(y_1,y_2,x)\cdots\phi_{t-1}(y_{t-2},y_{t-1},x)\phi_t(y_{t-1},y_t=i,x)\\
\Delta_r=\sum\limits_{y_{t+1:T}}\phi_{t+1}(y_t=i,y_{t+1},x)\phi_{t+2}(y_{t+1},y_{t+2},x)\cdots\phi_T(y_{T-1},y_T,x)
\end{gather*}
\]</span></p>
<p><span class="math display">\[
\begin{gather*}
\alpha_t(i)=\Delta_l=\sum\limits_{j\in S}\phi_t(y_{t-1}=j,y_t=i,x)\alpha_{t-1}(j)\\
\Delta_r=\beta_t(i)=\sum\limits_{j\in S}\phi_{t+1}(y_t=i,y_{t+1}=j,x)\beta_{t+1}(j)
\end{gather*}
\]</span></p></li>
<li><p>学习<br>
<span class="math display">\[
\nabla_\lambda L=\sum\limits_{i=1}^N\sum\limits_{t=1}^T[f(y_{t-1},y_t,x^i)-\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)]
\]</span></p></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.narutozxp.top">tsyw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.narutozxp.top/2022/07/05/ML-Theory-Summary/">https://www.narutozxp.top/2022/07/05/ML-Theory-Summary/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.narutozxp.top" target="_blank">narutozxp</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ML-Theory/">ML Theory</a></div><div class="post_share"><div class="social-share" data-image="/img/23.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v2/"><img class="prev-cover" src="/img/21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Static Timing Analysis for Nanometer Designs:A Practical Approach(v2)</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/06/FROM-VPR-TO-OPENFPGA/"><img class="next-cover" src="/img/26.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FROM VPR TO OPENFPGA</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%91%E7%8E%87%E6%B4%BE%E7%9A%84%E8%A7%82%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">频率派的观点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE%E7%9A%84%E8%A7%82%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">贝叶斯派的观点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mathbasics"><span class="toc-number">2.</span> <span class="toc-text">MathBasics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-number">2.1.</span> <span class="toc-text">高斯分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%83%85%E5%86%B5-mle"><span class="toc-number">2.1.1.</span> <span class="toc-text">一维情况 MLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%83%85%E5%86%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">多维情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">3.</span> <span class="toc-text">线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">最小二乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%99%AA%E5%A3%B0%E4%B8%BA%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84-mle"><span class="toc-number">3.2.</span> <span class="toc-text">噪声为高斯分布的 MLE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%87%8D%E5%85%88%E9%AA%8C%E4%B9%9F%E4%B8%BA%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84-map"><span class="toc-number">3.3.</span> <span class="toc-text">权重先验也为高斯分布的 MAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">正则化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#l1-lasso"><span class="toc-number">3.4.1.</span> <span class="toc-text">L1 Lasso</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#l2-ridge"><span class="toc-number">3.4.2.</span> <span class="toc-text">L2 Ridge</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">线性分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%88%86%E7%B1%BB-%E7%A1%AC%E5%88%86%E7%B1%BB-%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">两分类-硬分类-感知机算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%88%86%E7%B1%BB-%E7%A1%AC%E5%88%86%E7%B1%BB-%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90-lda"><span class="toc-number">4.2.</span> <span class="toc-text">两分类-硬分类-线性判别分析 LDA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%88%86%E7%B1%BB-%E8%BD%AF%E5%88%86%E7%B1%BB-%E6%A6%82%E7%8E%87%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B-logistic-%E5%9B%9E%E5%BD%92"><span class="toc-number">4.3.</span> <span class="toc-text">两分类-软分类-概率判别模型-Logistic 回归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%88%86%E7%B1%BB-%E8%BD%AF%E5%88%86%E7%B1%BB-%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-%E9%AB%98%E6%96%AF%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90-gda"><span class="toc-number">4.4.</span> <span class="toc-text">两分类-软分类-概率生成模型-高斯判别分析 GDA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%88%86%E7%B1%BB-%E8%BD%AF%E5%88%86%E7%B1%BB-%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF"><span class="toc-number">4.5.</span> <span class="toc-text">两分类-软分类-概率生成模型-朴素贝叶斯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">4.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%8D%E7%BB%B4"><span class="toc-number">5.</span> <span class="toc-text">降维</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E9%99%8D%E7%BB%B4-%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90-pca"><span class="toc-number">5.1.</span> <span class="toc-text">线性降维-主成分分析 PCA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">损失函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#svd-%E4%B8%8E-pcoa"><span class="toc-number">5.1.2.</span> <span class="toc-text">SVD 与 PCoA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p-pca"><span class="toc-number">5.1.3.</span> <span class="toc-text">p-PCA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">5.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%AF%E6%92%91%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">支撑向量机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">约束优化问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hard-margin-svm"><span class="toc-number">6.2.</span> <span class="toc-text">Hard-margin SVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#soft-margin-svm"><span class="toc-number">6.3.</span> <span class="toc-text">Soft-margin SVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel-method"><span class="toc-number">6.4.</span> <span class="toc-text">Kernel Method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">6.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E6%97%8F%E5%88%86%E5%B8%83"><span class="toc-number">7.</span> <span class="toc-text">指数族分布</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83"><span class="toc-number">7.1.</span> <span class="toc-text">一维高斯分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%85%E5%88%86%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%92%8C%E5%AF%B9%E6%95%B0%E9%85%8D%E5%88%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.</span> <span class="toc-text">充分统计量和对数配分函数的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%85%E5%88%86%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%92%8C%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="toc-number">7.3.</span> <span class="toc-text">充分统计量和极大似然估计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%86%B5"><span class="toc-number">7.4.</span> <span class="toc-text">最大熵</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">概率图模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE-%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C"><span class="toc-number">8.1.</span> <span class="toc-text">有向图-贝叶斯网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%BD%91%E7%BB%9C%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%9A%8F%E6%9C%BA%E5%9C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">无向图-马尔可夫网络（马尔可夫随机场）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%9B%BE%E7%9A%84%E8%BD%AC%E6%8D%A2-%E9%81%93%E5%BE%B7%E5%9B%BE"><span class="toc-number">8.3.</span> <span class="toc-text">两种图的转换-道德图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E5%88%86%E8%A7%A3-%E5%9B%A0%E5%AD%90%E5%9B%BE"><span class="toc-number">8.4.</span> <span class="toc-text">更精细的分解-因子图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD"><span class="toc-number">8.5.</span> <span class="toc-text">推断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD-%E5%8F%98%E9%87%8F%E6%B6%88%E9%99%A4ve"><span class="toc-number">8.5.1.</span> <span class="toc-text">推断-变量消除（VE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD-%E4%BF%A1%E5%BF%B5%E4%BC%A0%E6%92%ADbp"><span class="toc-number">8.5.2.</span> <span class="toc-text">推断-信念传播（BP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD-max-product-%E7%AE%97%E6%B3%95"><span class="toc-number">8.5.3.</span> <span class="toc-text">推断-Max-Product 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7"><span class="toc-number">9.</span> <span class="toc-text">期望最大</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89-em"><span class="toc-number">9.1.</span> <span class="toc-text">广义 EM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#em-%E7%9A%84%E6%8E%A8%E5%B9%BF"><span class="toc-number">9.2.</span> <span class="toc-text">EM 的推广</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">高斯混合模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="toc-number">10.1.</span> <span class="toc-text">极大似然估计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#em-%E6%B1%82%E8%A7%A3-gmm"><span class="toc-number">10.2.</span> <span class="toc-text">EM 求解 GMM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD"><span class="toc-number">11.</span> <span class="toc-text">变分推断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B9%B3%E5%9D%87%E5%9C%BA%E5%81%87%E8%AE%BE%E7%9A%84%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD"><span class="toc-number">11.1.</span> <span class="toc-text">基于平均场假设的变分推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sgvi"><span class="toc-number">11.2.</span> <span class="toc-text">SGVI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B"><span class="toc-number">12.</span> <span class="toc-text">马尔可夫链蒙特卡洛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">蒙特卡洛方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mcmc"><span class="toc-number">12.2.</span> <span class="toc-text">MCMC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E7%A8%B3%E5%88%86%E5%B8%83"><span class="toc-number">12.3.</span> <span class="toc-text">平稳分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.4.</span> <span class="toc-text">隐马尔可夫模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hmm"><span class="toc-number">12.5.</span> <span class="toc-text">HMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#evaluation"><span class="toc-number">12.5.1.</span> <span class="toc-text">Evaluation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#learning"><span class="toc-number">12.5.2.</span> <span class="toc-text">Learning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decoding"><span class="toc-number">12.5.3.</span> <span class="toc-text">Decoding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">12.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.</span> <span class="toc-text">线性动态系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2"><span class="toc-number">14.</span> <span class="toc-text">粒子滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sis"><span class="toc-number">14.1.</span> <span class="toc-text">SIS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA"><span class="toc-number">15.</span> <span class="toc-text">条件随机场</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#crf-%E7%9A%84-pdf"><span class="toc-number">15.1.</span> <span class="toc-text">CRF 的 PDF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E6%A6%82%E7%8E%87"><span class="toc-number">15.2.</span> <span class="toc-text">边缘概率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-number">15.3.</span> <span class="toc-text">参数估计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%91%E7%A0%81"><span class="toc-number">15.4.</span> <span class="toc-text">译码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E7%BD%91%E7%BB%9C"><span class="toc-number">16.</span> <span class="toc-text">高斯网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C-gbn"><span class="toc-number">16.1.</span> <span class="toc-text">高斯贝叶斯网络 GBN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E7%BD%91%E7%BB%9C-gmn"><span class="toc-number">16.2.</span> <span class="toc-text">高斯马尔可夫网络 GMN</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">17.</span> <span class="toc-text">贝叶斯线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD-1"><span class="toc-number">17.1.</span> <span class="toc-text">推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B"><span class="toc-number">17.2.</span> <span class="toc-text">预测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B%E5%9B%9E%E5%BD%92"><span class="toc-number">18.</span> <span class="toc-text">高斯过程回归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">18.1.</span> <span class="toc-text">核贝叶斯线性回归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%A9%BA%E9%97%B4%E7%9A%84%E8%A7%82%E7%82%B9"><span class="toc-number">18.2.</span> <span class="toc-text">函数空间的观点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%97%E9%99%90%E7%8E%BB%E5%B0%94%E5%85%B9%E6%9B%BC%E6%9C%BA"><span class="toc-number">19.</span> <span class="toc-text">受限玻尔兹曼机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD-2"><span class="toc-number">19.1.</span> <span class="toc-text">推断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#phv"><span class="toc-number">19.1.1.</span> <span class="toc-text">\(p(h|v)\)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pv"><span class="toc-number">19.1.2.</span> <span class="toc-text">\(p(v)\)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%B1%E8%81%9A%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">谱聚类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">21.</span> <span class="toc-text">前馈神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#from-pla-to-dl"><span class="toc-number">21.1.</span> <span class="toc-text">From PLA to DL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">21.2.</span> <span class="toc-text">非线性问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E5%88%86%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">配分函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%90%AB%E9%85%8D%E5%88%86%E5%87%BD%E6%95%B0%E7%9A%84-mle"><span class="toc-number">22.1.</span> <span class="toc-text">包含配分函数的 MLE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%95%A3%E5%BA%A6-cd-learning"><span class="toc-number">22.2.</span> <span class="toc-text">对比散度-CD Learning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rbm-%E7%9A%84%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98"><span class="toc-number">22.3.</span> <span class="toc-text">RBM 的学习问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC%E6%8E%A8%E6%96%AD"><span class="toc-number">23.</span> <span class="toc-text">近似推断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">24.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#math"><span class="toc-number">24.1.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linear-regression"><span class="toc-number">24.2.</span> <span class="toc-text">Linear Regression</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#model"><span class="toc-number">24.2.1.</span> <span class="toc-text">Model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loss-function"><span class="toc-number">24.2.2.</span> <span class="toc-text">Loss Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%BC%8F%E8%A7%A3"><span class="toc-number">24.2.3.</span> <span class="toc-text">闭式解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E5%8C%96-1"><span class="toc-number">24.2.4.</span> <span class="toc-text">正则化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linear-classification"><span class="toc-number">24.3.</span> <span class="toc-text">Linear Classification</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hard"><span class="toc-number">24.3.1.</span> <span class="toc-text">Hard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pca"><span class="toc-number">24.3.1.1.</span> <span class="toc-text">PCA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fisher"><span class="toc-number">24.3.1.2.</span> <span class="toc-text">Fisher</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soft"><span class="toc-number">24.3.2.</span> <span class="toc-text">Soft</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B"><span class="toc-number">24.3.2.1.</span> <span class="toc-text">判别模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#logistic-regression"><span class="toc-number">24.3.2.1.1.</span> <span class="toc-text">Logistic Regression</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">24.3.2.2.</span> <span class="toc-text">生成模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gda"><span class="toc-number">24.3.2.2.1.</span> <span class="toc-text">GDA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#naive-bayesian"><span class="toc-number">24.3.2.2.2.</span> <span class="toc-text">Naive Bayesian</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dimension-reduction"><span class="toc-number">24.4.</span> <span class="toc-text">Dimension Reduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pca-1"><span class="toc-number">24.4.1.</span> <span class="toc-text">PCA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p-pca-1"><span class="toc-number">24.4.2.</span> <span class="toc-text">p-PCA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#svm"><span class="toc-number">24.5.</span> <span class="toc-text">SVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hard-margin"><span class="toc-number">24.5.1.</span> <span class="toc-text">Hard-margin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soft-margin"><span class="toc-number">24.5.2.</span> <span class="toc-text">Soft-margin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel"><span class="toc-number">24.5.3.</span> <span class="toc-text">Kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp-family"><span class="toc-number">24.6.</span> <span class="toc-text">Exp Family</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pgm"><span class="toc-number">24.7.</span> <span class="toc-text">PGM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#representation"><span class="toc-number">24.7.1.</span> <span class="toc-text">Representation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#learning-1"><span class="toc-number">24.7.2.</span> <span class="toc-text">Learning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inference"><span class="toc-number">24.7.3.</span> <span class="toc-text">Inference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gmm"><span class="toc-number">24.8.</span> <span class="toc-text">GMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B-hmmldsparticle"><span class="toc-number">24.9.</span> <span class="toc-text">序列模型-HMM，LDS，Particle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E7%BA%BF%E6%80%A7%E9%9A%90%E5%8F%98%E9%87%8F-hmm"><span class="toc-number">24.9.1.</span> <span class="toc-text">离散线性隐变量-HMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%BA%BF%E6%80%A7%E9%9A%90%E5%8F%98%E9%87%8F-lds"><span class="toc-number">24.9.2.</span> <span class="toc-text">连续线性隐变量-LDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E9%9D%9E%E7%BA%BF%E6%80%A7%E9%9A%90%E5%8F%98%E9%87%8F-%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2"><span class="toc-number">24.9.3.</span> <span class="toc-text">连续非线性隐变量-粒子滤波</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#crf"><span class="toc-number">24.10.</span> <span class="toc-text">CRF</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@10.2.3/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-vercel-gray.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-vercel-gray.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo@1/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.jsdelivr.net/gh/narutozxp/live2d-widget@2.1.4/autoload.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>