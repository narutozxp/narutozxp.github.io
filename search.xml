<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CRC校验详解</title>
    <url>/2024/07/31/CRC%E6%A0%A1%E9%AA%8C%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="摘要">摘要</h1>
<p>本文首先阐述了错误检测的目的以及纠错复杂度，然后以此引出了CRC背后的基础思想。为了能够充分理解CRC运算所基于的运算系统，本文还介绍了抽象代数中的相关概念（多项式环、素域、扩域）。然后描述了如何选取CRC的多项式。有了这些基本概念之后，本文介绍了三种CRC的实现，对于同一个CRC算法，其中SIMPLE于TABLE ALGORITHM所使用的寄存器初值是一样的，只是后者更高效一点，而DIRECT TABLE ALGORITHM则更高效，而且寄存器初值也与前两种不一样（通常CRC算法所说的初值就是指的这个算法的寄存器初值），因此需要进行初值转换。在此之后还介绍了一些决定CRC算法的其他参数，并且以此定义一个名为Rocksoft™的参数化模型，用以精确描述CRC算法。最后本文还包含了CRC算法的C实现。</p>
<p>本文很大程度上参考了<a href="https://www.zlib.net/crc_v3.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>，在其中加入了一些自己的理解。因此非常感谢Ross N. Williams.大佬</p>
<h1 id="错误检测的目的">错误检测的目的</h1>
<p>发射机产生的数据，在经过带有噪声的信道之后，会被噪声所污染，从而导致接收机接收到错误的数据。为了解决这一情况，通常可以使用一个校验算法函数<span class="math inline">\(f(Msg)\)</span>，该函通常是一个关于数据原文的函数，产生一个校验和<span class="math inline">\(CheckSum\)</span>。然后接收方即可以通过实现约定好的算法，验证<span class="math inline">\(Msg\)</span>与<span class="math inline">\(CheckSum\)</span>之间的关系。</p>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"CheckSum",type:1},
        {bits:24,name:"Msg",type:6}
    ]
}</script>
<p>例如，如若定义<span class="math inline">\(CheckSum = f(Msg) = sum(int(byte))\mod 256\)</span>，则整个校验流程如下图，接收方可以计算出<span class="math inline">\((6+27+4) \mod 256 \neq 33\)</span>，因此可以判断出数据收到了损坏。</p>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"4",type:6},
        {bits:8,name:"23",type:6},
        {bits:8,name:"6",type:6}
    ],config:{label:{left:"Msg"}},
}</script>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"33",type:1},
        {bits:8,name:"4",type:6},
        {bits:8,name:"23",type:6},
        {bits:8,name:"6",type:6}
    ],config:{label:{left:"Tran"}}
}</script>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"33",type:1},
        {bits:8,name:"4",type:6},
        {bits:8,name:"27",type:6},
        {bits:8,name:"6",type:6}
    ],config:{label:{left:"Recv"}}
}</script>
<p>但是如果<span class="math inline">\(Msg\)</span>与<span class="math inline">\(CheckSum\)</span>都被改变了，而且改变之后的值能够与校验函数<span class="math inline">\(f\)</span>对应上，就会使接收方误以为数据正确，从而引发故障。不幸的是，这种可能性是完全不能够避免的，最好的办法就是增加校验中的信息量来减小其发生的概率。</p>
<h1 id="纠错复杂度">纠错复杂度</h1>
<p>上述的算法的问题在于其太过于简单，如果数据受到了随机污染，则会接收方有<span class="math inline">\(\frac{1}{256}\)</span>的概率无法检测处错误。例如：</p>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"4",type:6},
        {bits:8,name:"23",type:6},
        {bits:8,name:"6",type:6}
    ],config:{label:{left:"Msg"}},
}</script>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"33",type:1},
        {bits:8,name:"4",type:6},
        {bits:8,name:"23",type:6},
        {bits:8,name:"6",type:6}
    ],config:{label:{left:"Tran"}}
}</script>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"33",type:1},
        {bits:8,name:"5",type:6},
        {bits:8,name:"20",type:6},
        {bits:8,name:"8",type:6}
    ],config:{label:{left:"Recv"}}
}</script>
<p>为了增加该校验算法，我们可以将存储校验和的寄存器从8bit增加到16bit，然后使用模<span class="math inline">\(2^{16}\)</span>的加法作为校验算法。这样无法检测出错误的概率就降低到了<span class="math inline">\(\frac{1}{2^{16}}\)</span>。虽然这是一个好的改进，但是依然无法解决本例的错误。因为该校验算法是求和，不够随机——每次求和的时候，不管校验寄存器有多宽，都只会影响校验寄存器中大约一个字节的数据。从而我们可以从以下两个方面来增强校验算法：</p>
<ul>
<li><strong>WIDTH:</strong> 校验寄存器的宽度——减小碰撞的概率</li>
<li><strong>CHAOS:</strong> 改进校验算法，使得每个字节都有潜力去改变校验急窜去中的任意数量bits</li>
</ul>
<h1 id="crc算法背后的基础思想">CRC算法背后的基础思想</h1>
<p>虽然加法不够具有随机性，但是只要除数的宽度与校验寄存器的宽度一样，除法就能满足要求。而CRC算法的基本思想是简单地将消息视为一个巨大的二进制数，将其除以另一个固定二进制数，并将该除法的余数作为校验和。收到消息后，接收器可以执行相同的除法，并将余数与“校验和”（传输的余数）进行比较。</p>
<p>例如，有两个字节的消息原文（6，23），校验寄存器一个字节宽，除数为1001，其结果如下所示：</p>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"23",attr:["0001-0111","0x17"],type:6},
        {bits:8,name:"6",attr:["0000-0110","0x06"],type:6}
    ],config:{label:{left:"Msg"}}
}</script>
<script type="WaveDrom">{
    reg:[
        {bits:8,name:"2",attr:["0000-0010","0x02"],type:1},
        {bits:8,name:"23",attr:["0001-0111","0x17"],type:6},
        {bits:8,name:"6",attr:["0000-0110","0x06"],type:6}
    ],config:{label:{left:"Tran"}}
}</script>
<p><span class="math display">\[
\require{enclose}
\begin{array}{r}
                000\underline{0}000\underline{0}101\underline{0}110\underline{1}\, \\[-3pt]
9= 1001 \enclose{longdiv}{000\underline{0}011\underline{0}000\underline{1}011\underline{1}} \\[-3pt]
    \underline{\underline{1001}0000000}\, \\[-3pt]
    110010111\, \\
    \underline{\underline{1001}00000}\, \\
    1110111\, \\
    \underline{\underline{1001}000}\, \\
    101111\, \\
    \underline{\underline{1001}00}\, \\
    1011\, \\
    \underline{\underline{1001}}\, \\
    10\,
\end{array}\\
\]</span></p>
<p>虽然输入消息的每个位对商的影响并不那么显著，但在计算过程中，4位余数会被影响得很厉害，如果向消息中添加更多字节（被除数），它的值可能会很快再次发生根本性变化。这就是为什么除法在加法不起作用的地方起作用。</p>
<h1 id="多项式运算">多项式运算</h1>
<p>虽然前一节中描述的除法方案与称为CRC方案的校验和方案非常相似，但CRC方案实际上有点奇怪，我们需要深入研究一些奇怪的数字系统来理解它们。</p>
<h2 id="多项式环">多项式环</h2>
<p>我们知道，函数是一种映射，特指 “值域是数字集合” 的映射。这里的 “数字集合”，通常指任何一个环，换句话说，只要是个环，其元素都可以被视为 “数字”。我们熟悉的整数环、有理数域2、实数域、复数域等都是很好的例子。</p>
<p>多项式就是一种极为重要的函数。在微积分中，性质良好的函数（解析函数）都可以被表示为一列多项式函数的极限，或者说总可以用一个多项式函数来逼近它。而多项式的性质较为简单，求导也很容易。我们现在讨论的是代数，所以就不关心可以怎么用求导啊积分啊等手段去处理多项式函数，而是关心这个概念可以怎么在代数上拓展。</p>
<p>先来观察一下我们熟知的多项式吧。作为实变量函数，一个多项式<span class="math inline">\(f(x)\)</span>可以表示为：</p>
<p><span class="math display">\[
\begin{equation}
f(x) = \sum_{i=0}^N a_i x^i~,
\end{equation}
\]</span></p>
<p>其中各<span class="math inline">\(a_i\)</span>都是实数，而 xi是用来抽象表示 “任意自变量” 的。我们可以给<span class="math inline">\(x\)</span>赋值，比如取一个实数<span class="math inline">\(c\)</span>，然后令<span class="math inline">\(x=c\)</span>，这样就能得到一个<strong>实数</strong><span class="math inline">\(f(c)=\sum_{i=0}^N a_i c^i\)</span>。但要是不赋值，那<span class="math inline">\(f(x)\)</span>就不是一个具体的数，而是一个映射；<span class="math inline">\(x\)</span>只是一个抽象符号。</p>
<p>两个多项式之间根本的不同，体现在哪里呢？是抽象符号吗？显然不是。<span class="math inline">\(x^2+1\)</span>和<span class="math inline">\(y^2+1\)</span>完全可以视为同一个多项式，用的符号不同而已。决定两个多项式差异的，是多项式的<strong>系数</strong>，对吧？<span class="math inline">\(x^2+1\)</span>和<span class="math inline">\(x^2+3\)</span>就不是同一个多项式。很明显，我们应该拓展的是系数的概念。</p>
<div class="admonition admonition-success">
<p class="admonition-title">定义
</p>
<p>设<span class="math inline">\(R\)</span>是一个环,<span class="math inline">\(x\)</span>是一个抽象符号。则形如:</p>
<p><span class="math display">\[
\begin{equation}
f(x) = \sum_{i=0}^N a_i x^i~
\end{equation}
\]</span></p>
<p>的表达式称为环<span class="math inline">\(R\)</span>上的（一元）<strong>多项式（polynomial）</strong>，其中各<span class="math inline">\(a_i\in R\)</span>，称为该多项式的<strong>系数（coefficient）</strong>。<span class="math inline">\(a_i x^i\)</span>称为<span class="math inline">\(f(x)\)</span>的<span class="math inline">\(i\)</span>次<strong>项（item）</strong>，或者一个单项式，<span class="math inline">\(i\)</span>称为其<strong>次数（degree）</strong>。全体以<span class="math inline">\(x\)</span>为抽象符号的一元多项式构成的集合，记为<span class="math inline">\(R[x]\)</span>。<span class="math inline">\(R\)</span>称为<span class="math inline">\(R[x]\)</span>的<strong>系数环</strong>；如果<span class="math inline">\(R\)</span>是个域，也称之为<strong>系数域</strong>。</p>
<p>类似地，设各<span class="math inline">\(x_k\)</span>都是抽象符号，那么形如</p>
<p><span class="math display">\[
\begin{equation}
f(x_1, x_2, \cdots, x_m) = \sum_{k_1+k_2+\cdots k_m=0}^N a_{k_1, k_2, \cdots, k_m} x_1^{k_1}x_2^{k_2}\cdots x_m^{k_m}~
\end{equation}
\]</span></p>
<p>的表达式称为环<span class="math inline">\(R\)</span>上的<span class="math inline">\(m\)</span> <strong>元多项式（polynomial）</strong>，其中各<span class="math inline">\(a_{k_1, k_2, \cdots, k_m}\in R\)</span>，称为其系数。每个<span class="math inline">\(a_{k_1, k_2, \cdots, k_m} x_1^{k_1}x_2^{k_2}\cdots x_m^{k_m}\)</span>是该多项式的一个<span class="math inline">\(k_1+k_2+\cdots k_m\)</span>次项。</p>
<p>多项式中最高次的单项式的次数，称为该多项式的<strong>次数（degree）</strong>。特别的例外是，<span class="math inline">\(\operatorname {deg}0 = -\infty\)</span>。多项式<span class="math inline">\(f⁡(x)\)</span>的次数记为<span class="math inline">\(\operatorname {deg} f(x)\)</span>。在不至于混淆的情况下，也可以简单地用<span class="math inline">\(f\)</span>来表示多项式<span class="math inline">\(f⁡(x)\)</span>或<span class="math inline">\(f(x_1, x_2, \cdots, x_m)\)</span>。</p>
</div>
<div class="admonition admonition-success">
<p class="admonition-title">定义
</p>
<p>设<span class="math inline">\(g(x_1, x_2, \cdots, x_m)\in R[x_1, x_2, \cdots, x_m]\)</span>。<br>
如果<span class="math inline">\(r\in R\)</span>满足<span class="math inline">\(f(r)=0\)</span>，则称<span class="math inline">\(r\)</span>是<span class="math inline">\(f\)</span>的一个<strong>根（root）</strong>。如果数组<span class="math inline">\(\{r_1, r_2, \cdots, r_m\}\)</span>满足<span class="math inline">\(g(r_1, r_2, \cdots, r_m)\)</span>，则称该数组是<span class="math inline">\(g\)</span>的一个根。</p>
</div>
<p>举几个例子。<span class="math inline">\(x^2y+xy+y^3+2y\)</span>是一个整数环上的二元三次多项式，其中<span class="math inline">\(x^2y\)</span>和<span class="math inline">\(y^3\)</span>是其<span class="math inline">\(3\)</span>次项。我们常会用到 “多项式环” 这一术语，这是因为环上的全体多项式构成的集合<span class="math inline">\(R[x]\)</span>，还真就是一个环。</p>
<div class="admonition admonition-attention">
<p class="admonition-title">Attention</p>
<p><span class="math inline">\(R[x]\)</span>上加法和乘法的定义：同类单项式（即仅系数不同的单项式）之间的加法定义为以其系数相加的结果为系数的同类单项式，乘法类似地定义为系数的乘法；多项式乘法由单项式加法、乘法以及乘法对加法的分配律定义。</p>
</div>
<p>上面说了那么多，我一直在强调<span class="math inline">\(x\)</span>是“抽象符号”。作为实变量函数的多项式，可以把抽象符号替换为实数来赋值，一般的环上当然也可以这么做。设<span class="math inline">\(f\)</span>是环<span class="math inline">\(R\)</span>上的一元多项式，那任取一个<span class="math inline">\(r \in R\)</span>，依然有<span class="math inline">\(f(r) \in R\)</span>。</p>
<h2 id="域上的多项式除法">域上的多项式除法</h2>
<p>设<span class="math inline">\(f(x)\)</span>是一个多项式，那么使得<span class="math inline">\(f(r)=0\)</span>的<span class="math inline">\(r\)</span>就被称为这个多项式的<strong>根（root）</strong>。根的性质决定了多项式的性质。为了理解这一点，我们要先讨论一下多项式之间的除法。不过要注意的是，我们这里要讨论的是域上的多项式除法，也就是系数选自域中，而不只是一个环中。尽管如此，多项式构成的集合依然只是一个环。</p>
<p>由于环没有要求乘法逆元存在性，故除法并不总是可行的。比如<span class="math inline">\(5 \div 2\)</span>的结果就不在整数环中，尽管<span class="math inline">\(5\)</span>和<span class="math inline">\(2\)</span>都是整数。但是也正因为这样，环上诞生了独特的 “带余除法”，对，就是小学学过的<span class="math inline">\(5/2=2\cdots 1\)</span>。但是<span class="math inline">\(a/b=c\cdots r\)</span>的表述方法挺累赘的，不如写成<span class="math inline">\(a=bc+r\)</span>好了，<span class="math inline">\(a\)</span>是被除数，<span class="math inline">\(b\)</span>是除数，<span class="math inline">\(c\)</span>是商，<span class="math inline">\(r\)</span>是余数。</p>
<p>尽管上述讨论中的<span class="math inline">\(a, b, c, r\)</span>都是整数，我们也可以把这个概念移植到一般的环上。在稍后我们会讨论的 “欧几里得环” 中，这种带余除法非常重要，但现在我们就着眼于多项式环即可。</p>
<p>虑环<span class="math inline">\(R\)</span>上的多项式<span class="math inline">\(f(x)\)</span>和<span class="math inline">\(g(x)\)</span>，则总存在<span class="math inline">\(h(x)\)</span>和<span class="math inline">\(r(x)\)</span>，其中<span class="math inline">\(\operatorname {deg}r\leq \operatorname {deg}g\)</span>，使得<span class="math inline">\(f(x)=h(x)g(x)+r(x)\)</span>。这就是多项式之间的除法。如果遇到<span class="math inline">\(r(x)=0\)</span>的情况，那么就说<span class="math inline">\(g\)</span>整除<span class="math inline">\(f\)</span>，记为<span class="math inline">\(g|f\)</span> 。</p>
<div class="admonition admonition-abstract">
<p class="admonition-title">定理1<span id="定理一"></span>
</p>
<p>给定域<span class="math inline">\(\mathbb{F}\)</span>上的一个多项式<span class="math inline">\(f(x)\)</span>。如果<span class="math inline">\(r \in R\)</span>是<span class="math inline">\(f\)</span>的一个根，那么<span class="math inline">\((x-r)|f\)</span>。</p>
<div class="admonition admonition-note">
<p class="admonition-title">证明
</p>
<p>存在<span class="math inline">\(h(x), s(x)\in\mathbb{F}[x]\)</span>，使得<span class="math inline">\(f(x)=h(x)\cdot(x-r)+s(x)\)</span>，且<span class="math inline">\(s(x)\)</span>的次数小于<span class="math inline">\(1\)</span>。这样一来，<span class="math inline">\(s\)</span>实际上就是<span class="math inline">\(\mathbb{F}\)</span>的一个元素。将<span class="math inline">\(r\)</span>代入<span class="math inline">\(x\)</span>，得到<span class="math inline">\(0=f(r)=h(r)\cdot(r-r)+s\)</span>，因此<span class="math inline">\(s=0\)</span>。故得证。</p>
</div>
</div>
<p>如果环<span class="math inline">\(R\)</span>上的多项式<span class="math inline">\(f⁡(x)\)</span>可以表示为两个多项式的乘积<span class="math inline">\(h(x)g(x)\)</span>，或者说它可以被另一个次数为正的多项式整除，那么我们就说这个多项式是<strong>可约（reducible）</strong>的，而<span class="math inline">\(h\)</span> 和<span class="math inline">\(g\)</span>就被称为其<strong>因子</strong>；否则，称<span class="math inline">\(f\)</span>是<strong>不可约（irreducible）</strong>的。这样，我们只需要研究好其因子的性质，就能方便地推知<span class="math inline">\(f\)</span>本身的性质。又由于<a href="#定理一">定理1</a>，多项式的性质归根到底由根来决定——如果根存在的话。</p>
<p>现在，我们引入一个实际计算多项式除法的方法，称为长除法，用表格表示。为方便理解，我们直接用一个具体实例来讲解：在整数环上，用<span class="math inline">\(2x^2+1\)</span>去除<span class="math inline">\(6x^5+x^4+2x^3-x^2-2\)</span>。</p>
<p>第一步，是比较两个多项式的最高次项，即<span class="math inline">\(2⁢x^2\)</span>和<span class="math inline">\(6⁢x^5\)</span>，然后凑一个<span class="math inline">\(3⁢x^3\)</span>，比较<span class="math inline">\((2x^2+1)\cdot(3x^3)\)</span>和<span class="math inline">\(6x^5+x^4+2x^3-x^2-2\)</span>的差，得到<span class="math inline">\(x^4-x^3-x^2-2\)</span>。整个过程表示如下：</p>
<table>
<caption>表1</caption>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(3⁢x^3\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(2x^2+1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6x^5+x^4+2x^3-x^2-2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(x^4-x^3-x^2-2\)</span></td>
</tr>
</tbody>
</table>
<p>然后，再考虑剩下的<span class="math inline">\(x^4-x^3-x^2-2\)</span>被<span class="math inline">\(2x^2+1\)</span>除：</p>
<table>
<caption>表2</caption>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(3x^3+0.5x^2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(2x^2+1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6x^5+x^4+2x^3-x^2-2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(x^4-x^3-x^2-2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(-x^3-1.5x^2-2\)</span></td>
</tr>
</tbody>
</table>
<p>以此类推，最终使被除多项式的次数小于<span class="math inline">\(2x^2+1\)</span>的次数：</p>
<table>
<caption>表3<span id="表3"></span></caption>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(3x^3+0.5x^2-0.5x-0.75\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(2x^2+1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6x^5+x^4+2x^3-x^2-2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(x^4-x^3-x^2-2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(-x^3-1.5x^2-2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(-1.5x^2+0.5x-2\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(0.5x-1.25\)</span></td>
</tr>
</tbody>
</table>
<p>于是我们就得到了:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
&amp;6x^5+x^4+2x^3-x^2-2 \\
= &amp;(3x^3+0.5x^2-0.5x-0.75)(2x^2+1)+(0.5x-1.25)~.
\end{aligned}
\end{equation}
\]</span></p>
<p>我们所求的有效信息在<a href="#表3">表 3</a>的最上方和最下方，即 “商数” 和 “余数”，而第二行则是已知的信息。剩下的部分全都是中间计算过程，算完以后就不用再关心了。</p>
<p>从运算过程你也可以看出来，为什么我们之前要求讨论范围是 “域” 上的多项式。除法的概念是可以局限在 “环” 上的多项式来讨论的，也依然可以使用长除法来计算，但就没法用到<span class="math inline">\(0.5\)</span>这样的元素，也就无法保证余的次数比除数要小了。</p>
<h2 id="素域prime-field">素域（Prime field）</h2>
<p>有限域也叫伽罗瓦域（galois field），指的是由有限个元素组成的集合，在这个集合内可以执行加、减、乘和逆运算。</p>
<ul>
<li>域中包含元素的个数称为<strong>域的阶</strong>。</li>
<li>只有当<span class="math inline">\(m\)</span>是一个素数幂时，即<span class="math inline">\(m=p^n\)</span>(其中<span class="math inline">\(n\)</span>为正整数是<span class="math inline">\(p\)</span>的次数，<span class="math inline">\(p\)</span>为素数)，阶为<span class="math inline">\(m\)</span>的域才存在，<span class="math inline">\(p\)</span>称为这个<strong>域的特征</strong>。</li>
</ul>
<p>也就是说，有限域中元素的个数可以是11(<span class="math inline">\(p\)</span>=11是一个素数,<span class="math inline">\(n\)</span>=1)、可以是81(<span class="math inline">\(p\)</span>=3是一个素数，<span class="math inline">\(n\)</span>=4)、也可以是256(<span class="math inline">\(p\)</span>=2是一个素数，<span class="math inline">\(n\)</span>=8).....但有限域的中不可能拥有12个元素，因为<span class="math inline">\(12=2·2·3\)</span>，因此12也不是一个素数幂。</p>
<p>有限域中最直观的例子就是阶为素数的域，即<span class="math inline">\(m=pn,(n=1)\)</span>的域，域中的元素可以用整数<span class="math inline">\(\{0、1、...、p−1\}\)</span>来表示。</p>
<p>域的两种操作就是<strong>整数加法（模<span class="math inline">\(p\)</span>）</strong>和<strong>整数乘法（模<span class="math inline">\(p\)</span>）</strong>，<span class="math inline">\(p\)</span>是一个素数，整数环Z表示为<span class="math inline">\(GF(p)\)</span>，也成为拥<strong>有素数个元素的素数域</strong>或者<strong>伽罗瓦域</strong>。</p>
<div class="admonition admonition-note">
<p class="admonition-title">总结
</p>
<p>素域就是有素数个元素的有限域，即阶为素数的有限域。</p>
</div>
<ul>
<li><span class="math inline">\(GF(p)\)</span>中所有的非零元素都存在逆元</li>
<li><span class="math inline">\(GF(p)\)</span>内所有的运算都是模<span class="math inline">\(p\)</span>实现的。</li>
</ul>
<p>素域内的算数运算规则如下：</p>
<ul>
<li>加法和乘法都是通过模<span class="math inline">\(p\)</span>实现的；</li>
<li>任何一个元素<span class="math inline">\(a\)</span>的加法逆元都是由<span class="math inline">\(a+\)</span>(<span class="math inline">\(a\)</span>的逆元)=<span class="math inline">\(0\)</span>(mod <span class="math inline">\(p\)</span>)得到的；</li>
<li>任何一个非零元素<span class="math inline">\(a\)</span>的乘法逆元定义为<span class="math inline">\(a·\)</span>(<span class="math inline">\(a\)</span>的逆元)=<span class="math inline">\(1\)</span>(mod <span class="math inline">\(p\)</span>)。</li>
</ul>
<p>例：在素域<span class="math inline">\(GF(5)=\{0,1,2,3,4\}\)</span>中，<span class="math inline">\(2\)</span>的加法逆元为<span class="math inline">\(3\)</span>，这是因为，<span class="math inline">\(2+(3)=5\)</span>，<span class="math inline">\(5 \mod 5=0\)</span>,所以<span class="math inline">\(2+3=5 \mod 5=0\)</span>；<span class="math inline">\(2\)</span>的乘法逆元为<span class="math inline">\(3\)</span>，这是因为，<span class="math inline">\(2·3=6\)</span>，<span class="math inline">\(6 \mod 5=1\)</span>，所以<span class="math inline">\(2·3=6 \mod 5=1\)</span>。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>在很多地方<span class="math inline">\(a\)</span>的加法逆元用<span class="math inline">\(-a\)</span>表示，<span class="math inline">\(a\)</span>的乘法逆元用<span class="math inline">\(a^{-1}\)</span>表示</p>
</div>
<p>注：<span class="math inline">\(GF(2)\)</span>是一个非常重要的素域，也是存在的最小的有限域，由于<span class="math inline">\(GF(2)\)</span>的加法，即模<span class="math inline">\(2\)</span>加法与<strong>异或(XOR)门</strong>等价，<span class="math inline">\(GF(2)\)</span>的乘法与<strong>逻辑与(AND)门</strong>等价。<br>
加法：<span class="math inline">\(0+1=1;1+1=0;0+0=0\)</span><br>
乘法：<span class="math inline">\(1\times 0 = 0;1 \times 1 =1; 0 \times 0 = 0\)</span></p>
<p>另外素域<span class="math inline">\(GF(p)\)</span>一般还用符号<span class="math inline">\(F_p\)</span>表示，记<span class="math inline">\(F_p^*\)</span>是由<span class="math inline">\(F_p\)</span>中所有非零元构成的乘法群，即<span class="math inline">\((1,2,\dots,p-1)\)</span>，又因为<span class="math inline">\(F_p^*\)</span>是循环群，所以在<span class="math inline">\(F_p\)</span>中至少存在一个元素<span class="math inline">\(g\)</span>，使得<span class="math inline">\(F_p\)</span>中任意非零元都可以由<span class="math inline">\(g\)</span>的一个幂表示，称<span class="math inline">\(g\)</span>为<span class="math inline">\(F_p^*\)</span>的生成元（本原元），即<span class="math inline">\(F_p^*=\{g^i|0\leq i \leq p-2\}\)</span>。设<span class="math inline">\(a=g^i \in F_p^*\)</span>，其中<span class="math inline">\(0 \leq i \leq p-2\)</span>。则<span class="math inline">\(a\)</span>的乘法逆元<span class="math inline">\(a^{-1}=g^{p-1-i}\)</span>。</p>
<p>举例：<br>
<span class="math inline">\(13\)</span>是<span class="math inline">\(F_{19}^∗\)</span>的一个生成元，则<span class="math inline">\(F_{19}^∗\)</span>中的元素可以由13的方幂表示出来：<br>
<span class="math inline">\(13^0=1,13^1=13,13^2=17,13^3=12,13^4=4,13^5=14,13^6=11,13^7=10,13^8=16,13^9=18,\)</span><br>
<span class="math inline">\(13^{10}=6,13^{11}=2,13^{12}=7,13^{13}=15,13^{14}=5,13^{15}=8,13^{16}=9,13^{17}=3,13^{18}=1\)</span></p>
<h2 id="扩域extension-field">扩域（extension field）</h2>
<p>如果有限域的阶不是素数，则这样的有限域内的加法和乘法运算就不能用整数加法模<span class="math inline">\(p\)</span>和整数乘法模<span class="math inline">\(p\)</span>表示。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>阶数不是素数，且大于1的有限域被称为扩展域</p>
</div>
<p>为了处理扩展域，我们就要使用不同的符号表示扩展域内的元素，使用不同的规则执行扩展域内元素的算术运算。</p>
<p>设<span class="math inline">\(q\)</span>是一个素数或素数方幂，<span class="math inline">\(f(x)\)</span>是多项式环<span class="math inline">\(F_q[x]\)</span>上的一个<span class="math inline">\(m(m&gt;1)\)</span>次<strong>不可约多项式</strong>，<strong>商环</strong><span class="math inline">\(F_q[x]/f(x)\)</span>是含<span class="math inline">\(q^m\)</span>个元素的有限域，记<span class="math inline">\(F_{q^m}\)</span>，即<span class="math inline">\(F_{q^m}\)</span>是有限域<span class="math inline">\(F_q\)</span>的扩域，域<span class="math inline">\(F_q\)</span>是域<span class="math inline">\(F_{q^m}\)</span>的子域，<span class="math inline">\(m\)</span>是扩展次数（因子）。</p>
<p><span class="math inline">\(F_{q^m}\)</span>可以看作<span class="math inline">\(F_q\)</span>上的<span class="math inline">\(m\)</span>维向量空间，即在<span class="math inline">\(F_{q^m}\)</span>中存在<span class="math inline">\(m\)</span>个元素<span class="math inline">\(\left \{ \alpha_{0},\alpha_{1},...., a_{m-1} \right \}\)</span>，使得<span class="math inline">\(\forall a \in F_{q^{m}}\)</span>，<span class="math inline">\(a\)</span>可以唯一表示为：<span class="math inline">\(a=a_{m-1}\alpha_{m-1}+...+a_{1}\alpha_{1}\)</span>，其中<span class="math inline">\(a_i\in F_q\)</span>，把<span class="math inline">\(\left\{\alpha_{m-1}, \cdots, \alpha_{1}, \alpha_{0}\right\}\)</span>叫做<span class="math inline">\(F_{q^m}\)</span>上在<span class="math inline">\(F_q\)</span>上的一组基。</p>
<p>给定这样的一组基，就可以由向量<span class="math inline">\(\left(a_{m-1},a_{m-2}...., a_{1}, a_{0}\right)\)</span>来表示域元素<span class="math inline">\(a\)</span>。</p>
<p><span class="math inline">\(F_{q^m}\)</span>在<span class="math inline">\(F_q\)</span>上的基有多种选择：多项式基和正规基等，下面简单介绍：</p>
<div class="admonition admonition-success">
<p class="admonition-title">多项式基
</p>
<p>不可约多项式<span class="math inline">\(f(x)\)</span>可以取首一多项式<span class="math inline">\(f(x)=x^{m}+f x^{m-1}+...+f_{2} x^{2}+f_{1} x+f_{0}\)</span>（其中<span class="math inline">\(f_i\in F_q,i=0,...,m-1\)</span>）</p>
<p><span class="math inline">\(F_{q^m}\)</span>中的元素由多项式环<span class="math inline">\(F_q[x]\)</span>中所有次数低于<span class="math inline">\(m\)</span>的多项式构成，即<span class="math inline">\(F_{q^m}=\left\{a_{m-1} x^{m-1}+a_{m-2} x^{m-2}+\cdots+a_{1} x+a_{0} \mid a_{i} \in F_{q}, i=0,1, \cdots, m-1\right\}\)</span></p>
<p>多项式集合<span class="math inline">\(\left\{x^{m-1}, x^{m-2}, \cdots, x, 1\right\}\)</span>是 <span class="math inline">\(F_{q^m}\)</span>作为向量空间在<span class="math inline">\(F_q\)</span>上的一组基，称为多项式基</p>
<p>当<span class="math inline">\(m\)</span>含有因子<span class="math inline">\(d(1&lt;d&lt;m)\)</span>时, <span class="math inline">\(F_{q^m}\)</span>可以由<span class="math inline">\(F_{q^d}\)</span>扩张生成, 从<span class="math inline">\(F_{q^d}[x]\)</span>中选取一个合适的<span class="math inline">\(m/d\)</span>次不可约多项式作为<span class="math inline">\(F_{q^m}\)</span>在<span class="math inline">\(F_{q^d}\)</span>上的不可约多项式，<span class="math inline">\(F_{q^m}\)</span>可以由<strong>塔式扩张方法 (towering method)</strong> 得到, 这种扩张的基本形式仍是由<span class="math inline">\(F_q\)</span>中元素组成的向量</p>
<p>例如当<span class="math inline">\(m=6\)</span>时, 可以先由<span class="math inline">\(F_q\)</span>经过<span class="math inline">\(3\)</span>次扩张得扩域<span class="math inline">\(F_{q^3}\)</span> ，再由<span class="math inline">\(F_{q^3}\)</span>经过<span class="math inline">\(2\)</span>次扩张得到扩域<span class="math inline">\(F_{q^6}\)</span> ; 也可以先由<span class="math inline">\(F_q\)</span>经过<span class="math inline">\(2\)</span>次扩张得扩域<span class="math inline">\(F_{q^2}\)</span>, 再由<span class="math inline">\(F_{q^2}\)</span>经过<span class="math inline">\(3\)</span>次扩张得到扩域<span class="math inline">\(F_{q^6}\)</span></p>
</div>
<div class="admonition admonition-success">
<p class="admonition-title">正规基
</p>
<p><span class="math inline">\(F_{q^m}\)</span>在<span class="math inline">\(F_q\)</span>上形如<span class="math inline">\(\left\{\beta, \beta^{q}, \beta^{q^{2}}, \cdots, \beta^{q^{m-1}}\right\}\)</span>的一组基称为<strong>正规基</strong>, 其中<span class="math inline">\(\beta \in F_{q^{m}}\)</span> 。 <span class="math inline">\(\forall a \in F_{q^{m}}, a\)</span>可以唯一表示为:<span class="math inline">\(a=a_{0} \beta+a_{1} \beta^{q}+\cdots+a_{m-1} \beta^{q^{m-1}}\)</span>, 其中<span class="math inline">\(a_{i} \in F_{q}, i=0,1, \cdots, m-1\)</span>。</p>
<p>对于任意有限域<span class="math inline">\(F_q\)</span>及其扩域<span class="math inline">\(F_{q^m}\)</span>, 这样的基总是存在的。</p>
</div>
<p>例如在扩展域<span class="math inline">\(GF(2^m)\)</span>中，元素并不是用整数表示的，而是用系数为域GF(2)中元素的多项式表示，这个多项式最大<strong>阶数（degree）</strong>为<span class="math inline">\(m-1\)</span>，所以每个元素共有<span class="math inline">\(m\)</span>个系数。比如在AES算法使用的域<span class="math inline">\(GF(2^8)\)</span>中，每个元素<span class="math inline">\(A\in GF(2^8)\)</span>都可以表示为：<span class="math inline">\(A(x)=a_7x^7+a_6x^6+...+a_1x+a_0,a_i\in GF(2)\)</span></p>
<p>注意：在域<span class="math inline">\(GF(2^8)\)</span>中这样的多项式共有<span class="math inline">\(256\)</span>个，这<span class="math inline">\(256\)</span>个多项式组成的集合就是<strong>扩展域</strong><span class="math inline">\(GF(28)\)</span>，每个多项式都可以按一个<span class="math inline">\(8\)</span>位向量的数值形式存储：<span class="math inline">\(A=(a_7,a_6,...,a_1,a_0)\)</span>，像<span class="math inline">\(x^7,x^6,…x\)</span>等因子都无需存储，因为从位的位置就可以清楚地判断出每个系数对应的幂。</p>
<p>扩域<span class="math inline">\(GF(2^m)\)</span>内的算数运算规则如下：</p>
<div class="admonition admonition-success">
<p class="admonition-title">加减法
</p>
<p>在AES算法中的密钥加法层中就使用了这部分的知识，但是不是很明显，因为我们通常把扩展域中的加法当作异或运算进行处理了，因为<strong>在扩展域</strong><span class="math inline">\(GF(2^m)\)</span>中的加减法处理都是在底层域<span class="math inline">\(GF(2)\)</span>内完成的，与按位异或运算等价。假设<span class="math inline">\(A(x)、B(x)∈GF(2^m)\)</span>。</p>
<p>计算两个元素之和的方法就是：<span class="math inline">\(C(x)=A(x)+B(x)=\sum_{i=0}^{m-1}c_ix^i\)</span>,其中<span class="math inline">\(c_i=(a_i+b_i)mod 2\)</span></p>
<p>两个元素之差的计算公式就是：<span class="math inline">\(C(x)=A(x)-B(x)=\sum_{i=0}^{m-1}C_ix^i\)</span>,其中<span class="math inline">\(c_i=(a_i-b_i)mod 2=(a_i+b_i)mod 2\)</span></p>
<p><strong>注：</strong>在减法运算中减号之所以变成加号，这就和二进制减法的性质有关了，从上述两个公式中我们发现<strong>在扩展域中加法和减法等价，并且与XOR等价(异或运算也被称作二进制加法)</strong>。</p>
</div>
<div class="admonition admonition-success">
<p class="admonition-title">乘法
</p>
<p>扩展域的乘法主要运用在AES算法的列混淆层(Mix Column)中，也是列混淆层中最重要的操作。</p>
<p>我们想将扩展域中的两个元素用多项式形式展开，然后使用标准的多项式乘法规则将两个多项式相乘：<span class="math inline">\(C(x)=A(x).B(x)=(a_{m-1}x^{m-1}+...+a_0).(b_{m-1}x^{m-1}+...+b_0)=c_{2m-2}x^{2m-2}+...+c_0\)</span>，其中<span class="math inline">\(c_0=(a_0.b_0)mod 2,c_1=(a_1.b_0+a_0.b_1)mod 2,...,c_{2m-2}=(a_{m-1}.b_{m-1})mod 2\)</span></p>
<p><strong>注：</strong>通常在多项式乘法中<span class="math inline">\(C(x)\)</span>的级数会大于<span class="math inline">\(m−1\)</span>，因此需要对此进行化简，而化简的基本思想与素域内乘法情况相似：在素域<span class="math inline">\(GF(p)\)</span>中，将两个整数相乘得到的结果除以一个素数，化简后的结果就是最后的余数。而在扩展域中进行的操作就是：<strong>将两个多项式相乘的结果除以一个不可约多项式</strong>，最后的结果就是最后的<strong>余数</strong>。(这里的不可约多项式大致可以看作一个素数)</p>
<p><img src="/2024/07/31/CRC%E6%A0%A1%E9%AA%8C%E8%AF%A6%E8%A7%A3/1016082-20191013181934067-1708066142.webp" alt="GF(2^m)乘法"></p>
</div>
<p>举例：<br>
<img src="/2024/07/31/CRC%E6%A0%A1%E9%AA%8C%E8%AF%A6%E8%A7%A3/1016082-20191013181956923-556582755.webp"></p>
<h2 id="crc多项式运算">CRC多项式运算</h2>
<p>在处理CRC算法时，你经常听到的单词是“多项式”。给定的CRC算法将被称为使用特定的多项式，而CRC算法通常被称为是使用多项式算法进行操作的，即数字10111对应于多项式<span class="math inline">\(x^4+x^2+x+1\)</span>,而多项式之间的加法和减法都是异或运算（因为CRC多项式的系数属于GF(2),GF(2)加减法就是异或运算）——指数相同的项的系数进行异或。<br>
而乘法运算则是在原有基础之上，还满足分配律。例如：</p>
<p><span class="math display">\[
\begin{align*}
(x^3+x^2+x^0)(x^3+x^1+x^0)=&amp;x^6+x^4+x^3 \\+&amp;x^5+x^3+x^2 \\ +&amp;x^3+x^1+x^0 \\= &amp;x^6+x^5+x^4+x^3+x^2+x^1+x^0
\end{align*}
\]</span></p>
<h1 id="没有进位信号的二进制运算">没有进位信号的二进制运算</h1>
<p>在省略了多项式之后，我们可以专注于真正的算术问题，即CRC计算期间执行的所有算术都是在二进制中执行的，没有进位。这通常被称为多项式算术，但正如我在本文档的其余部分所声明的那样，我们必须称之为CRC算术。由于这个算法是CRC计算的关键部分，我们最好习惯它。</p>
<p>CRC算术中的两个数字相加与普通二进制算术中的数字相加相同，除了没有进位。这意味着每对对应的比特确定对应的输出比特，而不参考任何其他比特位置。例如：</p>
<p><span class="math display">\[
\begin{align*}
    &amp;10011011 \\+ &amp;11001010 \\= &amp;01010001 \\
    \\ \\
    &amp;10011011 \\- &amp;11001010 \\= &amp;01010001
\end{align*}
\]</span></p>
<p>定义了加减法之后，就可以很容易地定义<strong>乘除法</strong>。例如乘法就与普通的二进制乘法类似，除了最后求和的时候，使用的是忽略进位的加法。而除法也与普通的二进制除法类似（不考虑借位，而且大小的判断也与二进制不一样，如果<span class="math inline">\(X\)</span>最高位的1的位置大于或者等于<span class="math inline">\(Y\)</span>最高位1的位置，则<span class="math inline">\(X\)</span>大于等于<span class="math inline">\(Y\)</span>）。</p>
<p>乘法示例：</p>
<p><span class="math display">\[
\begin{align*}
            1101    \\
    \times  1011    \\
            ---     \\
            1101    \\
            11010   \\
            000000  \\
            1101000 \\
            ----    \\
            1111111
\end{align*}
\]</span></p>
<p>除法示例：</p>
<p><span class="math display">\[
\require{enclose}
\begin{array}{r}
                1100001010\, \\[-3pt]
 10011 \enclose{longdiv}{11010110110000} \\[-3pt]
    10011\phantom{110110000\,} \\
    --------    \\
    1001110110000\,     \\
    10011\phantom{10110000\,} \\
    -------     \\
    10110000\,  \\
    10011\phantom{000\,} \\
    ----- \\
    101000\, \\
    10011\phantom{0\,}\\
    ----\\
    1110
\end{array}\\
\]</span></p>
<p>定义了乘除之后，就可以定义倍数和整除的概念了（其实就是除法的余数等于0）。但是根据其乘法的性质，还可以得到如下的推论。</p>
<div class="admonition admonition-note">
<p class="admonition-title">倍数的推论
</p>
<p>如果<span class="math inline">\(A\)</span>是<span class="math inline">\(B\)</span>的倍数，则意味着，<span class="math inline">\(A\)</span>可以由<span class="math inline">\(B\)</span>的不同移位的结果相加得到。</p>
<div class="admonition admonition-example">
<p class="admonition-title">Example</p>
<p><span class="math inline">\(A=0111010110\)</span>，<span class="math inline">\(B=11\)</span>，则<span class="math inline">\(A\)</span>可以通过如下方式从<span class="math inline">\(B\)</span>构造而来:</p>
<p><span class="math display">\[
\begin{align*}
    0111010110 \\
    =\phantom{00000000}11\phantom{0}    \\
    +\phantom{000000}11\phantom{0000}    \\
    +\phantom{00000}11\phantom{00000}    \\
    +\phantom{000}11\phantom{0000000}    \\
\end{align*}
\]</span></p>
<p>而如果<span class="math inline">\(A\)</span>是<span class="math inline">\(0111010111\)</span>，则无法通过<span class="math inline">\(B\)</span>构造而来，因此就不能被B整除。</p>
</div>
</div>
<h1 id="一个可行的示例">一个可行的示例</h1>
<p>定义了上述的运算法则之后，特别是除法运算规则之后，我们就可以得到CRC算法了。</p>
<p>要执行CRC计算，我们需要选择一个除数。在数学营销中，除数被称为“生成多项式”或简称为“多项式”，是任何CRC算法的关键参数。你可以选择任何多项式，并提出CRC算法。然而，有些多项式比其他多项式更好，所以明智的做法是坚持使用经过测试的多项式。稍后的部分将讨论这个问题。</p>
<p>多项式的宽度（最高位的1所处的位置，例如10011的宽度就是4，而不是5）是很重要的，因为它主导着整个计算，通常来说，16或者32的宽度比较常用，因为可以简化现代计算机实现。为了示例的目的，我选择多项式10011（<span class="math inline">\(W\)</span>等于4）作为演示。</p>
<p>选择好多项式之后，就可以进行CRC计算了（就是CRC除法），需要注意的是，在进行除法之前，需要在原始消息的末尾添加<span class="math inline">\(W\)</span>位的0(这么做的原因是，除法会得到<span class="math inline">\(W\)</span>位的余数<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，而将得到的余数替换增加的<span class="math inline">\(W\)</span>位0之后，就可以被整除了)</p>
<p>例如：</p>
<blockquote>
<p>原始信息     ：1101011011<br>
多项式      ：10011<br>
补0后的信息    ：11010110110000</p>
</blockquote>
<p>至此，就可以使用CRC除法，来将补0后的信息来除以多项式。</p>
<p><span class="math display">\[
\begin{align*}
    1100001010\, &amp; = 商（没人关心这个结果）\\[-3pt]
 多项式=10011\enclose{longdiv}{11010110110000}&amp; = 补0后的消息数据\\[-3pt]
    10011\phantom{110110000\,} \\
    --------    \\
    1001110110000\,     \\
    10011\phantom{10110000\,} \\
    -------     \\
    10110000\,  \\
    10011\phantom{000\,} \\
    ----- \\
    101000\, \\
    10011\phantom{0\,}\\
    ----\\
    1110 &amp; = 余数 = 校验数据
\end{align*}
\]</span></p>
<p>因此最终用发送的消息是1101011011<strong>1110</strong></p>
<p>而在另一端的接收方需要做如下两件事情中的一件：</p>
<ol type="1">
<li>分开消息与校验信息，计算消息的校验信息（需要补<span class="math inline">\(W\)</span>位0），然后比较校验信息是否一致。</li>
<li>对收到的数据整体计算校验信息（就是除以多项式，而且不用补0），然后看得到的校验信息是否为0（余数是否等于0）</li>
</ol>
<div class="admonition admonition-abstract">
<p class="admonition-title">总结
</p>
<p>CRC算法的整个运作流程如下：<br>
1. 确定宽度<span class="math inline">\(W\)</span>和多项式<span class="math inline">\(G\)</span>(宽度为<span class="math inline">\(W\)</span>)<br>
2. 添加<span class="math inline">\(W\)</span>比特的0到消息的末尾，称之为<span class="math inline">\(M^{\prime}\)</span><br>
3. 使用CRC除法，用<span class="math inline">\(G\)</span>来除<span class="math inline">\(M^{\prime}\)</span>，余数就是校验和</p>
</div>
<h1 id="多项式的选择">多项式的选择</h1>
<p>选择多项式有点像一门黑魔法，读者可以参考[Tanenbaum81]<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>（第130-132页），其中对这个问题进行了非常清晰的讨论。本节主要针对于想要了解构建自己的多项式的人。如果你不关心为什么一个poly可能比另一个好，只是想了解高速实现，请选择本节末尾列出的算术上合理的poly之一，然后跳到下一节。</p>
<p>首先，我们可以发现，经过CRC之后，发送的数据<span class="math inline">\(T\)</span>是多项式的倍数，而如果传输途中受到了干扰，则接收方收到的数据是<span class="math inline">\(T+E\)</span>，其中<span class="math inline">\(E\)</span>是干扰向量，<span class="math inline">\(+\)</span>是CRC加法（即XOR）。当接收机收到消息<span class="math inline">\(T+E\)</span>后，则会将其除以多项式<span class="math inline">\(G\)</span>，由于<span class="math inline">\(T \mod G = 0\)</span>，因此<span class="math inline">\((T+E) \mod G = E \mod G\)</span>，因此我们所选多项式的检错能力取决于多项式<span class="math inline">\(G\)</span>的倍数集，因为只要干扰向量<span class="math inline">\(E\)</span>是多项式<span class="math inline">\(G\)</span>的倍数，错误就不会被检测出来。所以我们的任务就是去找到一类<span class="math inline">\(G\)</span>，使得它的倍数集尽可能与线路的噪声不一致。</p>
<p>我们可以假设有如下类型的线路噪声：</p>
<div class="admonition admonition-danger">
<p class="admonition-title">单比特错误
</p>
<p>单比特错误意味着<span class="math inline">\(E=1000\cdots 0000\)</span>，面对这类错误，只要确保<span class="math inline">\(G\)</span>至少有两比特1，就一定能够检测出来。因为通过对<span class="math inline">\(G\)</span>移位求和的方式，无法从多个1构建出只有一个1。</p>
</div>
<div class="admonition admonition-danger">
<p class="admonition-title">两比特错误
</p>
<p>为了检测出形如<span class="math inline">\(E=100\cdots 000100 \cdots 000\)</span>的错误（<span class="math inline">\(E\)</span>包含两比特的1），<span class="math inline">\(G\)</span>的倍数当中不能包含<span class="math inline">\(11,101,1001,10001,100001,\dots\)</span>等数字，我不知道如何构建这类<span class="math inline">\(G\)</span>，但是Tanenbaum说这类<span class="math inline">\(G\)</span>确实存在，并且他提供了一个例子——<span class="math inline">\(G=x^{15}+x^{14}+1\)</span>无法整除任何等于<span class="math inline">\(x^k+1\)</span>的数，只要<span class="math inline">\(k\)</span>小于<span class="math inline">\(32768\)</span>。</p>
</div>
<div class="admonition admonition-danger">
<p class="admonition-title">奇数位错误
</p>
<p>为了检测出奇数位错误，我们可以选择具有偶数个1的生成多项式。之所以可以这么做的原因如下：</p>
<div class="admonition admonition-tip">
<p class="admonition-title">解释
</p>
<ol type="1">
<li>CRC乘法就是将一个常数的各种移位结果进行XOR。</li>
<li>如果一个数<span class="math inline">\(G\)</span>有偶数个1，然后使用<span class="math inline">\(G\)</span>异或数<span class="math inline">\(M\)</span>，其得到的结果与<span class="math inline">\(M\)</span>中1的个数的奇偶性相同，即使用<span class="math inline">\(G\)</span>来异或一个数，不会改变数中1个数的奇偶性。</li>
</ol>
</div>
<p>大部分流行的CRC多项式都包含偶数个1（Tanenbaum说，所有奇数比特的错误都可以通过将G设为11的倍数来捕获）。</p>
</div>
<div class="admonition admonition-danger">
<p class="admonition-title">突发错误
</p>
<p>长度为<span class="math inline">\(k\)</span>的突发错误可以表示为<span class="math inline">\(E=x^i(x^{k-1}+\cdots +1)\)</span>，其中<span class="math inline">\(i\)</span>表示突发错误在接受帧中的起始位置，且假设消息中的校验位有<span class="math inline">\(r\)</span>比特（生成多项式<span class="math inline">\(G\)</span>的度为<span class="math inline">\(r\)</span>，其二进制表示的宽度为<span class="math inline">\(r+1\)</span>），依据突发错误的长度，可分为以下几种类型：</p>
<div class="admonition admonition-example">
<p class="admonition-title"> 如果 $k < r+1$
</p>
<p>当<span class="math inline">\(G\)</span>包含项<span class="math inline">\(x^0\)</span>时，<span class="math inline">\(x^i\)</span>就不是<span class="math inline">\(G\)</span>的因子（<span class="math inline">\(i=0\)</span>时，没有该项，因此就可以不考虑<span class="math inline">\(x^i\)</span>），如果此时<span class="math inline">\(x^{k-1}+\cdots +1\)</span>的度要小于<span class="math inline">\(G\)</span>的度，则<span class="math inline">\(E \mod G \neq 0\)</span>，因此错误可以被检测到。</p>
<p>所以总的来说，当<span class="math inline">\(G\)</span>包含项<span class="math inline">\(x^0\)</span>时，只要满足<span class="math inline">\(k \leq r\)</span>的突发错误，都可以被检测出来。</p>
</div>
<div class="admonition admonition-example">
<p class="admonition-title">如果 $k = r+1$
</p>
<p>当且仅当<span class="math inline">\(x^{k-1}+\cdots +1=G\)</span>时，<span class="math inline">\(E \mod G = 0\)</span>，由于其首尾两位恒为<span class="math inline">\(1\)</span>，因此是否与<span class="math inline">\(G\)</span>相等主要取决于中间的<span class="math inline">\(r-1\)</span>比特，如果假设中间的每一比特发生错误的概率都是<span class="math inline">\(1/2\)</span>，那么无法检测出错误的概率就是<span class="math inline">\((\frac{1}{2})^{r-1}\)</span>。</p>
</div>
<div class="admonition admonition-example">
<p class="admonition-title">如果 $k > r+1$ 或者 多个短的突发错误发生
</p>
<p>无法检测出错误的概率为<span class="math inline">\((\frac{1}{2})^{r}\)</span>。</p>
</div>
</div>
<table>
<caption>一些流行的多项式</caption>
<thead>
<tr class="header">
<th style="text-align: center;">校验位位数</th>
<th style="text-align: center;">多项式</th>
<th style="text-align: center;">应用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">16</td>
<td style="text-align: center;">（16,12,5,0）</td>
<td style="text-align: center;">X25 standard</td>
</tr>
<tr class="even">
<td style="text-align: center;">16</td>
<td style="text-align: center;">（16,15,2,0）</td>
<td style="text-align: center;">CRC-16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">32</td>
<td style="text-align: center;">(32,26,23,22,16,12,11,10,8,7,5,4,2,1,0)</td>
<td style="text-align: center;">Ethernet</td>
</tr>
</tbody>
</table>
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Polynomial_representations">常用CRC连接</a></p>
<h1 id="一种简单的crc实现simple">一种简单的CRC实现（SIMPLE）</h1>
<p>要实现CRC算法，我们所要做的就是实现CRC除法，而CRC除法的运算过程中，消息的比特流被馈送到除法寄存器当中，因此在下面的讨论中，消息被当作字节流（每个字节8 bits,bit 7时MSB），而字节流中数据的馈送顺序为——第一个字节的MSB(bit 7)到第一个字节的LSB(bit 0)，然后第二个字节，并且依此类推。</p>
<p>为了描述方便，这里选择多项式为<span class="math inline">\(10111\)</span>（<span class="math inline">\(W=4\)</span>）,其结构如下图所示：</p>
<img class="kroki" src="https://kroki.io/svgbob/svg/eNpTUIADYyA2AmJDIDYAYqfMkmIFLri0tq6uLgpW4ArIL1BUsNHVVagByqNioCgQKDiWpuem5pWkpijkphYXJ6an4jcQJgtyAtgNhkjYViEkI1UhID-nEgAOvCM1">
<div class="admonition admonition-note">
<p>Augmented message : the raw message followed by <span class="math inline">\(W\)</span> zero bits</p>
</div>
<p>除法流程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将寄存器初始化为全0</span><br><span class="line">在原始消息的后面补充W位0</span><br><span class="line">While(还有消息比特)</span><br><span class="line">    Begin</span><br><span class="line">        将寄存器中的内容左移一位，寄存器最低位补上剩余消息的首位</span><br><span class="line">        IF(上一步左移时，Pop的数据等于1)</span><br><span class="line">            Register = Register XOR Poly</span><br><span class="line">    End</span><br><span class="line">当前寄存器的值就是余数，即校验码   </span><br></pre></td></tr></table></figure>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>在实际实现中，IF当中的条件可以使用其他判据。例如，在移位之前，判断寄存器最高位是否等于1</p>
</div>
<h1 id="基于表的crc实现table-algorithm">基于表的CRC实现（TABLE ALGORITHM）</h1>
<p>上面的SIMPLE算法是一个很好的起点，因为它直接对应于到目前为止提出的理论。然而，由于它是在位级别操作的，因此编写代码（即使是在C中）也相当笨拙，执行效率也很低（它必须为每个位循环一次）。为了加快速度，我们需要找到一种方法，使算法能够以大于一位的单位处理消息。候选数量是半字节（4位）、字节（8位）、字（16位）和长字（32位），甚至更长。其中，最好避免4位，因为它不对应于字节边界。至少，任何加速都应该允许我们在字节边界上操作。事实上，大多数表驱动算法一次操作一个字节。</p>
<p>为了便于讨论，让我们从4位poly切换到32位poly。我们的寄存器看起来几乎一样，除了方框代表字节而不是位，Poly是33位（最高位是隐式的1）（<span class="math inline">\(W=32\)</span>）。</p>
<img class="kroki" src="https://kroki.io/svgbob/svg/eNpTUEAAYxBhBCIMQYQBEDtVlqQWK3DBlWjrAgE6ocAVkF-gqGCjq6tQA1KEQdiAlOkqOJam56bmlaSmKOSmFhcnpqcSNhiuwhBqiLGRQlJmSbECmKNrBwBQ3SUN">
<p>在这个框图中，SIMPLE算法仍然适用，我们可以在这个模型当中使用上面的SIMPLE算法，然后推导出基于表实现的算法。想象一下，SIMPLE算法正在全面展开，并考虑32位寄存器（字节3）的前8位的值是<span class="math inline">\(t_7,t_6,t_5,t_4,t_3,t_2,t_1,t_0\)</span></p>
<p>在SIMPLE算法的下一次迭代中，<span class="math inline">\(t_7\)</span>决定了寄存器中的值是否需要与Poly进行异或（<span class="math inline">\(t_7=1\)</span>，则需要异或），假设Poly的最高八位是<span class="math inline">\(g_7,g_6,\cdots,g_0\)</span>(剩下的32位中的最高八位)，因此迭代之后，最高字节的值为：</p>
<p><span class="math display">\[
\begin{align*}
    t_6&amp; \quad&amp; t_5&amp; \quad&amp; t_4&amp; \quad&amp; t_3&amp; \quad&amp; t_2&amp; \quad&amp; t_1&amp; \quad&amp; t_0&amp; \quad&amp; ??&amp;  \\
    + \ t_7 \ *(g_7&amp; \quad&amp; g_6&amp; \quad&amp; g_5&amp; \quad&amp; g_4&amp; \quad&amp; g_3&amp; \quad&amp; g_2&amp; \quad&amp; g_1&amp; \quad&amp; g_0&amp;)  \qquad ps:\  +=XOR
\end{align*}
\]</span></p>
<p>因此下一次迭代中的最高位为<span class="math inline">\(t_6+t_7*g_7\)</span>，因此依据递归的方法，我们可以算出前8次（亦或是16，32，可以自定，这里以8举例）迭代时，寄存器中的最高位。而依据这八个值，就可以算出这八次迭代对寄存器的影响（Poly各种移位结果进行异或）。至此我们可以发现如下特性：</p>
<ul>
<li>寄存器的最高字节已经无关紧要了，就算被移出寄存器也无妨</li>
<li>由Poly各种移位结果（8种）进行异或产生的数据<span class="math inline">\(T\)</span>长度为<span class="math inline">\(32+8\)</span>，根据长除法的运算过程可知，<span class="math inline">\(T\)</span>的高<span class="math inline">\(8\)</span>位对当前的余数不产生影响，因此只需要取其低<span class="math inline">\(32\)</span>位即可</li>
</ul>
<p>因此在经历过这8次迭代之后，剩下的余数为<span class="math inline">\(\{Register[23:0],剩余消息的最高字节\} \oplus T[32:0]\)</span>。然后重复流程（计算T,向左移位，XOR）直到剩余消息为空，就得到了校验结果。</p>
<p>其运行的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While(Augmented message非空)</span><br><span class="line">    Begin</span><br><span class="line">        查看寄存器的最高字节，根据其生成控制字节</span><br><span class="line">        根据控制字节产生不同偏移量的Poly,并将其全部进行异或，得到的结果记为T</span><br><span class="line">        将Register左移一个字节，并且将消息的最高字节读入Register的最低字节</span><br><span class="line">        将T低32为与Register进行异或，并将结果写入Register</span><br><span class="line">    End</span><br><span class="line">当前寄存器的值就是余数，即校验码  </span><br></pre></td></tr></table></figure>
<p>就目前而言，这并不比SIMPLE算法好多少。然而，事实证明，大多数计算都可以预先计算并存储到表中。因此，上述算法可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">While(Augmented message非空)</span><br><span class="line">    Begin</span><br><span class="line">        Top = top_byte(Register);</span><br><span class="line">        Register = (Register &lt;&lt;8 | next_Augmented_message_byte);</span><br><span class="line">        Register = Register XOR precomputed_table[Top];</span><br><span class="line">    End</span><br><span class="line">当前寄存器的值就是余数，即校验码  </span><br></pre></td></tr></table></figure>
<p>如果你理解了这个伪代码的含义，你就掌握了表驱动CRC算法的主要思想。以上是一种非常有效的算法，只需要移位、OR、XOR和以字节为地址的表查找。从图形上看，它看起来像这样：</p>
<img class="kroki" src="https://kroki.io/svgbob/svg/eNqVU01PhEAMvfMrel93srDiyZisF48mGhNPJkMoMBtgDFPQTfjxdvjQQYlAE0rSaV_fm3YAJna0LrDOt-7A3_2F0Hhu0m7P9ttNMtpZd2sT93Cq0wJLwhgKNEamuBGcrel_b32c9DtElmXfyLbyurof2w0Hr49PXjsruf0j2ck7zLIaDk95qitFWeE1SzqGs29aEy7_VfgCnjOVEFCGUGGqDGEFOXIkuqxGYdMldnd1xSgyVmUKqgQJJX5sQRkG1yGJ1YWBgBeDnYRxZHCuDUGlSfI-bNJRE-hkeh2kWUyMn-7w7xZwOjIyytGiBeENHINIkYFG5jUasbya4xYJ4N1y4DoA5sOkOLgah23Us775tYAHzY18UAkUukKQ4xvb0tidqis9CMPZyi9nnuJu">
<p>其参考C代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (len--) </span><br><span class="line">&#123; </span><br><span class="line">    byte t = (r &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>; </span><br><span class="line">    r = (r &lt;&lt; <span class="number">8</span>) | *p++; </span><br><span class="line">    r^=table[t]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优雅版</span></span><br><span class="line">r=<span class="number">0</span>; <span class="keyword">while</span> (len--) r = ((r &lt;&lt; <span class="number">8</span>) | *p++) ^ t[(r &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>];</span><br></pre></td></tr></table></figure>
<p>其中len是补0后消息的长度（以字节为单位），p指向增强消息，r是寄存器，t是临时的，table是计算表。</p>
<h1 id="基于表的crc实现direct-table-algorithm">基于表的CRC实现（DIRECT TABLE ALGORITHM）</h1>
<p>尽管上述的代码只有一行，有一种简洁的美，但是就效率而言，其仍然有优化空间。因为上面基于表的CRC实现的循环判断条件是基于拓展后的消息是否为空，这就导致了需要额外的<span class="math inline">\(\frac{W}{8}\)</span>次循环，现在需要做的就是想办法去避免处理后面补充的零字节。</p>
<p>现在我们回顾一下原本的基于表的CRC实现，其框图如下：</p>
<img class="kroki" src="https://kroki.io/svgbob/svg/eNqVU01PhEAMvfMrel93srDiyZisF48mGhNPJkMoMBtgDFPQTfjxdvjQQYlAE0rSaV_fm3YAJna0LrDOt-7A3_2F0Hhu0m7P9ttNMtpZd2sT93Cq0wJLwhgKNEamuBGcrel_b32c9DtElmXfyLbyurof2w0Hr49PXjsruf0j2ck7zLIaDk95qitFWeE1SzqGs29aEy7_VfgCnjOVEFCGUGGqDGEFOXIkuqxGYdMldnd1xSgyVmUKqgQJJX5sQRkG1yGJ1YWBgBeDnYRxZHCuDUGlSfI-bNJRE-hkeh2kWUyMn-7w7xZwOjIyytGiBeENHINIkYFG5jUasbya4xYJ4N1y4DoA5sOkOLgah23Us775tYAHzY18UAkUukKQ4xvb0tidqis9CMPZyi9nnuJu">
<p>从中我们可以发现如下几点：</p>
<div class="admonition admonition-note">
<p class="admonition-title">TAIL
</p>
<p>额外添加的<span class="math inline">\(\frac{W}{8}=4\)</span>个字节的0也会和Raw Message一样，从右边一个字节一个字节得送入寄存器当中，然而由于其值是0，因此对于Register值没有影响；而且由于最后的<span class="math inline">\(W=32\)</span>比特也不会从Register的左侧移出去，因此不会被用作地址来查表。其根本作用就是为了额外进行<span class="math inline">\(\frac{W}{8}=4\)</span>次迭代，直到所有的Raw Messaage都穿过Register。</p>
</div>
<div class="admonition admonition-note">
<p class="admonition-title">HEAD
</p>
<p>如果寄存器的初始值为0，那么前4次迭代的唯一作用就是将消息的前4个字节完全移入寄存器（因为前32比特都是0，查表得到的值都是0，从而在XOR操作中不改变寄存器的值）。即使寄存器的初始值不是0，前4次迭代的也是将消息的前4个自己完全移入寄存器，然后与一个常数（与寄存器的初值相关）进行异或。</p>
</div>
<p>结合异或的运算性质<span class="math inline">\((A \oplus B) \oplus C = A \oplus (B \oplus C)\)</span>，我们可以假装我们现在处于已经迭代了4次时的状态，即寄存器当中的值为<span class="math inline">\(Raw Message \oplus C\)</span>，其中<span class="math inline">\(C\)</span>就是上面说的与寄存器初值相关的常数，用于记录除法对于<span class="math inline">\(Raw Message\)</span>的影响。因此我们可以将<span class="math inline">\(Raw Message\)</span>单独拎出来，使得寄存器中存储<span class="math inline">\(C\)</span>，并且将后续除法产生的对<span class="math inline">\(Raw Message\)</span>的影响都归并到<span class="math inline">\(C\)</span>中，这就使得<span class="math inline">\((Raw Message &lt;&lt; i) \oplus C\)</span>（i从0开始，每迭代以此增加1）等于原本基于表实现的算法当中的寄存器的值。从而可以得到如下的算法流程图。</p>
<img class="kroki" src="https://kroki.io/svgbob/svg/eNqNU01rwzAMvedX6LjR1jTpeusG22WnMegug7GB2yiJRxoP221W6I-f5Hw0K6W1IDro40lPzxlN2BagK4QXtFbmCKu9QzjaPSxl3ScrrNE6XxMdol1fNWOXsIvZTel7ohobHZr8iOecui55OOeudL6_LgfNAF-Rzyx8us10EEfjtjPRNjQ9O6steixzbZQrNh3rS8WTzi6yaItjAW-Fyhy4AsFgrqxDAyVmfOcQADIWkEUZE4BMVZWDqkCyXIEAm4H6IqQnEcAa8M5O_zSv5ntLb8NoJx2moYtvHejsP_WazsyRRtLJwxWI9k0OGdBKsFdYpiCrCIIWUVWKv-Sp03OSqxLh5mM6TubzT7gVITCzwU18_06WW-xBAzfp7hA08k7Asyb4GFQGG23ojPS7Dm9hxx6HaFyTglY0tbKshGmUUNaTWZu1-APh__Ch">
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>从上述的定义不难看出，寄存器的初值<span class="math inline">\(C\)</span>是原先基于表的CRC算法经过4次迭代所产生的四次查表结果的不同offset进行异或得到的。其数值可以通过下面的方法计算出来。</p>
<p>设原来基于表实现的CRC算法当中Register的初始值为<span class="math inline">\(I_r\)</span>，而当前算法中Register的初始值为<span class="math inline">\(C\)</span>，那么<span class="math inline">\(C\)</span>在数值上等于以0为初值，<span class="math inline">\(I_r\)</span>为Message的CRC校验值。<br>
而且如果<span class="math inline">\(I_r\)</span>全为0，则<span class="math inline">\(C\)</span>也是全为零</p>
</div>
<p>本算法的C代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r: Register</span></span><br><span class="line"><span class="comment">// len: length of Raw message(unit is byte)</span></span><br><span class="line"><span class="comment">// p: point to Raw message</span></span><br><span class="line"><span class="comment">// t: look up table</span></span><br><span class="line">r=<span class="number">0</span>; <span class="keyword">while</span> (len--) r = (r &lt;&lt;<span class="number">8</span> ) ^ t[(r &gt;&gt; <span class="number">24</span>) ^ *p++];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原来的基于表实现，放在这里是为了进行对比</span></span><br><span class="line"><span class="comment">// r: Register</span></span><br><span class="line"><span class="comment">// len: length of Augmented message(unit is byte)</span></span><br><span class="line"><span class="comment">// p: point to Augmented message</span></span><br><span class="line"><span class="comment">// t: look up table</span></span><br><span class="line">r=<span class="number">0</span>; <span class="keyword">while</span> (len--) r = ((r &lt;&lt; <span class="number">8</span>) | *p++) ^ t[(r &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与原来的算法相比，这个算法的循环次数要少4次。</p>
<h1 id="reflected-algorithm">REFLECTED algorithm</h1>
<div class="admonition admonition-question">
<p class="admonition-title">Question</p>
<p>如果这一章没有看明白，可以结合后面的代码实现，会容易理解很多</p>
</div>
<p>尽管上述代码可能已经尽可能地优化了，但这并没有阻止一些有进取心的人把事情变得更加复杂。要了解这是如何发生的，我们必须进入硬件世界。</p>
<div class="admonition admonition-success">
<p class="admonition-title">定义
</p>
<p>一个值或者寄存器的反射（Reflected）就是按位进行颠倒，例如：</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">原始值</th>
<th style="text-align: center;">反射之后的值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0101</td>
<td style="text-align: center;">1010</td>
</tr>
<tr class="even">
<td style="text-align: center;">0011</td>
<td style="text-align: center;">1100</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0111-0101-1010-1111-0010-0101-1011-1100</td>
<td style="text-align: center;">0011-1101-1010-0100-1111-0101-1010-1110</td>
</tr>
</tbody>
</table>
</div>
<p>事实证明，UART（那些执行串行IO的方便的小芯片）习惯于首先传输最低有效位（位0），最后传输最高有效位（位数7）的每个字节（即反射）。这种约定的一个效果是，构建在比特级运行的硬件CRC计算器的硬件工程师需要计算字节流的CRC，每个字节都反映在其内部。字节以相同的顺序处理，但每个字节中的位被交换；位0现在是位7，位1现在是位6，以此类推。详细描述如下：</p>
<p>需要发送的原始消息如下图所示：</p>
<script type="WaveDrom">{reg:[
    {name:"Byte0",bits:8,type:6},
    {name:"Byte1",bits:8,type:6},
    {name:"Byte2",bits:8,type:6},
    {name:"Byte3",bits:8,type:6},
],
config:{label:{right:"Raw Msg"}}
}</script>
<p>根据上述的发送数据的原则，最先发送的是Byte3的LSB，因此经过CRC之后，线路上的数据如下图所示，其中<span class="math inline">\(CheckSum=CRC(\{reflect(Byte3),reflect(Byte2),reflect(Byte1),reflect(Byte0)\})\)</span>，至于为什么CheckSum没有被反射，这是由于硬件CRC的性质决定的。</p>
<script type="WaveDrom">{
reg:[
    {name:"CheckSum",bits:16,tyep:1},
    {name:"reflect(Byte0)",bits:8,type:6},
    {name:"reflect(Byte1)",bits:8,type:6},
    {name:"reflect(Byte2)",bits:8,type:6},
    {name:"reflect(Byte3)",bits:8,type:6},
],
config:{label:{right:"Trans"}}
}</script>
<p>而硬件传递给软件的数据则是：</p>
<script type="WaveDrom">{
reg:[
    {name:"CheckSum",bits:16,tyep:1},
    {name:"Byte0",bits:8,type:6},
    {name:"Byte1",bits:8,type:6},
    {name:"Byte2",bits:8,type:6},
    {name:"Byte3",bits:8,type:6},
],
config:{label:{right:"Recv"}}
}</script>
<p>如果这个约定仅限于硬件领域，这就没什么关系了。然而，在某些时候，这些CRC值可能需要软件来处理，因此必须有人编写一些与硬件CRC兼容的代码。</p>
<p>在这个处境当中，一个正常的软件工程师只需要先将每一个字节反射，然后进行处理就行了。但是，总有些不正常的人，这些人将不反射输入字节，然而反射其他所有的东西。</p>
<img class="kroki" src="https://kroki.io/svgbob/svg/eNpTUPBNLS5OTE9V0MjLz1NILE3PTc0rSU1R0FSw0wUCbS4FAqCGy6myJLUYyDIGcY1AhCGIMICpKIOYoQ02D42AmQGhsBFgZ-hqR_gHEWsMAsRhOhZdQAGXgJ9_iKsVinKgE3ArB4Fn6_ufrVn4bP7SFwtXvNi_9snuxU8n9L3f0_N0fcvTtTOezlzxsnnvsxnrX-yf_WJhz9P-zc-X736_p-PJjt6n_b1PN7Q8n9XybPq2pw0zEWq2LwOr6STsbDyBY0BQBYnxNKhV2OgipVusKugpZWRqCgAnT8K3">
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<ul>
<li>The table is identical to the one in the previous algorithm except that each entry has been reflected（table_reflected[i] = reflect(table[reflect(i)])）.</li>
<li>The initial value of the register is the same as in the previous algorithm except that it has been reflected.</li>
<li>The bytes of the message are processed in the same order as before (i.e. the message itself is not reflected).</li>
<li>The message bytes themselves don't need to be explicitly reflected, because everything else has been!</li>
</ul>
</div>
<p>例如下面就是<code>REFLECTED algorithm</code>和正常算法的表的区别，其关系满足上面所说的公式关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/* CRC LOOKUP TABLE                                              */</span></span><br><span class="line"><span class="comment">/* ================                                              */</span></span><br><span class="line"><span class="comment">/* The following CRC lookup table was generated automagically    */</span></span><br><span class="line"><span class="comment">/* by the Rocksoft^tm Model CRC Algorithm Table Generation       */</span></span><br><span class="line"><span class="comment">/* Program V1.0 using the following model parameters:            */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/*    Width   : 4 bytes.                                         */</span></span><br><span class="line"><span class="comment">/*    Poly    : 0x04C11DB7L                                      */</span></span><br><span class="line"><span class="comment">/*    Reverse : FALSE.                                           */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/* For more information on the Rocksoft^tm Model CRC Algorithm,  */</span></span><br><span class="line"><span class="comment">/* see the document titled &quot;A Painless Guide to CRC Error        */</span></span><br><span class="line"><span class="comment">/* Detection Algorithms&quot; by Ross Williams                        */</span></span><br><span class="line"><span class="comment">/* (ross@guest.adelaide.edu.au.). This document is likely to be  */</span></span><br><span class="line"><span class="comment">/* in the FTP archive &quot;ftp.adelaide.edu.au/pub/rocksoft&quot;.        */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>  crctable[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line"> <span class="number">0x00000000</span>L, <span class="number">0x04C11DB7</span>L, <span class="number">0x09823B6E</span>L, <span class="number">0x0D4326D9</span>L,</span><br><span class="line"> <span class="number">0x130476DC</span>L, <span class="number">0x17C56B6B</span>L, <span class="number">0x1A864DB2</span>L, <span class="number">0x1E475005</span>L,</span><br><span class="line"> <span class="number">0x2608EDB8</span>L, <span class="number">0x22C9F00F</span>L, <span class="number">0x2F8AD6D6</span>L, <span class="number">0x2B4BCB61</span>L,</span><br><span class="line"> <span class="number">0x350C9B64</span>L, <span class="number">0x31CD86D3</span>L, <span class="number">0x3C8EA00A</span>L, <span class="number">0x384FBDBD</span>L,</span><br><span class="line"> <span class="number">0x4C11DB70</span>L, <span class="number">0x48D0C6C7</span>L, <span class="number">0x4593E01E</span>L, <span class="number">0x4152FDA9</span>L,</span><br><span class="line"> <span class="number">0x5F15ADAC</span>L, <span class="number">0x5BD4B01B</span>L, <span class="number">0x569796C2</span>L, <span class="number">0x52568B75</span>L,</span><br><span class="line"> <span class="number">0x6A1936C8</span>L, <span class="number">0x6ED82B7F</span>L, <span class="number">0x639B0DA6</span>L, <span class="number">0x675A1011</span>L,</span><br><span class="line"> <span class="number">0x791D4014</span>L, <span class="number">0x7DDC5DA3</span>L, <span class="number">0x709F7B7A</span>L, <span class="number">0x745E66CD</span>L,</span><br><span class="line"> <span class="number">0x9823B6E0</span>L, <span class="number">0x9CE2AB57</span>L, <span class="number">0x91A18D8E</span>L, <span class="number">0x95609039</span>L,</span><br><span class="line"> <span class="number">0x8B27C03C</span>L, <span class="number">0x8FE6DD8B</span>L, <span class="number">0x82A5FB52</span>L, <span class="number">0x8664E6E5</span>L,</span><br><span class="line"> <span class="number">0xBE2B5B58</span>L, <span class="number">0xBAEA46EF</span>L, <span class="number">0xB7A96036</span>L, <span class="number">0xB3687D81</span>L,</span><br><span class="line"> <span class="number">0xAD2F2D84</span>L, <span class="number">0xA9EE3033</span>L, <span class="number">0xA4AD16EA</span>L, <span class="number">0xA06C0B5D</span>L,</span><br><span class="line"> <span class="number">0xD4326D90</span>L, <span class="number">0xD0F37027</span>L, <span class="number">0xDDB056FE</span>L, <span class="number">0xD9714B49</span>L,</span><br><span class="line"> <span class="number">0xC7361B4C</span>L, <span class="number">0xC3F706FB</span>L, <span class="number">0xCEB42022</span>L, <span class="number">0xCA753D95</span>L,</span><br><span class="line"> <span class="number">0xF23A8028</span>L, <span class="number">0xF6FB9D9F</span>L, <span class="number">0xFBB8BB46</span>L, <span class="number">0xFF79A6F1</span>L,</span><br><span class="line"> <span class="number">0xE13EF6F4</span>L, <span class="number">0xE5FFEB43</span>L, <span class="number">0xE8BCCD9A</span>L, <span class="number">0xEC7DD02D</span>L,</span><br><span class="line"> <span class="number">0x34867077</span>L, <span class="number">0x30476DC0</span>L, <span class="number">0x3D044B19</span>L, <span class="number">0x39C556AE</span>L,</span><br><span class="line"> <span class="number">0x278206AB</span>L, <span class="number">0x23431B1C</span>L, <span class="number">0x2E003DC5</span>L, <span class="number">0x2AC12072</span>L,</span><br><span class="line"> <span class="number">0x128E9DCF</span>L, <span class="number">0x164F8078</span>L, <span class="number">0x1B0CA6A1</span>L, <span class="number">0x1FCDBB16</span>L,</span><br><span class="line"> <span class="number">0x018AEB13</span>L, <span class="number">0x054BF6A4</span>L, <span class="number">0x0808D07D</span>L, <span class="number">0x0CC9CDCA</span>L,</span><br><span class="line"> <span class="number">0x7897AB07</span>L, <span class="number">0x7C56B6B0</span>L, <span class="number">0x71159069</span>L, <span class="number">0x75D48DDE</span>L,</span><br><span class="line"> <span class="number">0x6B93DDDB</span>L, <span class="number">0x6F52C06C</span>L, <span class="number">0x6211E6B5</span>L, <span class="number">0x66D0FB02</span>L,</span><br><span class="line"> <span class="number">0x5E9F46BF</span>L, <span class="number">0x5A5E5B08</span>L, <span class="number">0x571D7DD1</span>L, <span class="number">0x53DC6066</span>L,</span><br><span class="line"> <span class="number">0x4D9B3063</span>L, <span class="number">0x495A2DD4</span>L, <span class="number">0x44190B0D</span>L, <span class="number">0x40D816BA</span>L,</span><br><span class="line"> <span class="number">0xACA5C697</span>L, <span class="number">0xA864DB20</span>L, <span class="number">0xA527FDF9</span>L, <span class="number">0xA1E6E04E</span>L,</span><br><span class="line"> <span class="number">0xBFA1B04B</span>L, <span class="number">0xBB60ADFC</span>L, <span class="number">0xB6238B25</span>L, <span class="number">0xB2E29692</span>L,</span><br><span class="line"> <span class="number">0x8AAD2B2F</span>L, <span class="number">0x8E6C3698</span>L, <span class="number">0x832F1041</span>L, <span class="number">0x87EE0DF6</span>L,</span><br><span class="line"> <span class="number">0x99A95DF3</span>L, <span class="number">0x9D684044</span>L, <span class="number">0x902B669D</span>L, <span class="number">0x94EA7B2A</span>L,</span><br><span class="line"> <span class="number">0xE0B41DE7</span>L, <span class="number">0xE4750050</span>L, <span class="number">0xE9362689</span>L, <span class="number">0xEDF73B3E</span>L,</span><br><span class="line"> <span class="number">0xF3B06B3B</span>L, <span class="number">0xF771768C</span>L, <span class="number">0xFA325055</span>L, <span class="number">0xFEF34DE2</span>L,</span><br><span class="line"> <span class="number">0xC6BCF05F</span>L, <span class="number">0xC27DEDE8</span>L, <span class="number">0xCF3ECB31</span>L, <span class="number">0xCBFFD686</span>L,</span><br><span class="line"> <span class="number">0xD5B88683</span>L, <span class="number">0xD1799B34</span>L, <span class="number">0xDC3ABDED</span>L, <span class="number">0xD8FBA05A</span>L,</span><br><span class="line"> <span class="number">0x690CE0EE</span>L, <span class="number">0x6DCDFD59</span>L, <span class="number">0x608EDB80</span>L, <span class="number">0x644FC637</span>L,</span><br><span class="line"> <span class="number">0x7A089632</span>L, <span class="number">0x7EC98B85</span>L, <span class="number">0x738AAD5C</span>L, <span class="number">0x774BB0EB</span>L,</span><br><span class="line"> <span class="number">0x4F040D56</span>L, <span class="number">0x4BC510E1</span>L, <span class="number">0x46863638</span>L, <span class="number">0x42472B8F</span>L,</span><br><span class="line"> <span class="number">0x5C007B8A</span>L, <span class="number">0x58C1663D</span>L, <span class="number">0x558240E4</span>L, <span class="number">0x51435D53</span>L,</span><br><span class="line"> <span class="number">0x251D3B9E</span>L, <span class="number">0x21DC2629</span>L, <span class="number">0x2C9F00F0</span>L, <span class="number">0x285E1D47</span>L,</span><br><span class="line"> <span class="number">0x36194D42</span>L, <span class="number">0x32D850F5</span>L, <span class="number">0x3F9B762C</span>L, <span class="number">0x3B5A6B9B</span>L,</span><br><span class="line"> <span class="number">0x0315D626</span>L, <span class="number">0x07D4CB91</span>L, <span class="number">0x0A97ED48</span>L, <span class="number">0x0E56F0FF</span>L,</span><br><span class="line"> <span class="number">0x1011A0FA</span>L, <span class="number">0x14D0BD4D</span>L, <span class="number">0x19939B94</span>L, <span class="number">0x1D528623</span>L,</span><br><span class="line"> <span class="number">0xF12F560E</span>L, <span class="number">0xF5EE4BB9</span>L, <span class="number">0xF8AD6D60</span>L, <span class="number">0xFC6C70D7</span>L,</span><br><span class="line"> <span class="number">0xE22B20D2</span>L, <span class="number">0xE6EA3D65</span>L, <span class="number">0xEBA91BBC</span>L, <span class="number">0xEF68060B</span>L,</span><br><span class="line"> <span class="number">0xD727BBB6</span>L, <span class="number">0xD3E6A601</span>L, <span class="number">0xDEA580D8</span>L, <span class="number">0xDA649D6F</span>L,</span><br><span class="line"> <span class="number">0xC423CD6A</span>L, <span class="number">0xC0E2D0DD</span>L, <span class="number">0xCDA1F604</span>L, <span class="number">0xC960EBB3</span>L,</span><br><span class="line"> <span class="number">0xBD3E8D7E</span>L, <span class="number">0xB9FF90C9</span>L, <span class="number">0xB4BCB610</span>L, <span class="number">0xB07DABA7</span>L,</span><br><span class="line"> <span class="number">0xAE3AFBA2</span>L, <span class="number">0xAAFBE615</span>L, <span class="number">0xA7B8C0CC</span>L, <span class="number">0xA379DD7B</span>L,</span><br><span class="line"> <span class="number">0x9B3660C6</span>L, <span class="number">0x9FF77D71</span>L, <span class="number">0x92B45BA8</span>L, <span class="number">0x9675461F</span>L,</span><br><span class="line"> <span class="number">0x8832161A</span>L, <span class="number">0x8CF30BAD</span>L, <span class="number">0x81B02D74</span>L, <span class="number">0x857130C3</span>L,</span><br><span class="line"> <span class="number">0x5D8A9099</span>L, <span class="number">0x594B8D2E</span>L, <span class="number">0x5408ABF7</span>L, <span class="number">0x50C9B640</span>L,</span><br><span class="line"> <span class="number">0x4E8EE645</span>L, <span class="number">0x4A4FFBF2</span>L, <span class="number">0x470CDD2B</span>L, <span class="number">0x43CDC09C</span>L,</span><br><span class="line"> <span class="number">0x7B827D21</span>L, <span class="number">0x7F436096</span>L, <span class="number">0x7200464F</span>L, <span class="number">0x76C15BF8</span>L,</span><br><span class="line"> <span class="number">0x68860BFD</span>L, <span class="number">0x6C47164A</span>L, <span class="number">0x61043093</span>L, <span class="number">0x65C52D24</span>L,</span><br><span class="line"> <span class="number">0x119B4BE9</span>L, <span class="number">0x155A565E</span>L, <span class="number">0x18197087</span>L, <span class="number">0x1CD86D30</span>L,</span><br><span class="line"> <span class="number">0x029F3D35</span>L, <span class="number">0x065E2082</span>L, <span class="number">0x0B1D065B</span>L, <span class="number">0x0FDC1BEC</span>L,</span><br><span class="line"> <span class="number">0x3793A651</span>L, <span class="number">0x3352BBE6</span>L, <span class="number">0x3E119D3F</span>L, <span class="number">0x3AD08088</span>L,</span><br><span class="line"> <span class="number">0x2497D08D</span>L, <span class="number">0x2056CD3A</span>L, <span class="number">0x2D15EBE3</span>L, <span class="number">0x29D4F654</span>L,</span><br><span class="line"> <span class="number">0xC5A92679</span>L, <span class="number">0xC1683BCE</span>L, <span class="number">0xCC2B1D17</span>L, <span class="number">0xC8EA00A0</span>L,</span><br><span class="line"> <span class="number">0xD6AD50A5</span>L, <span class="number">0xD26C4D12</span>L, <span class="number">0xDF2F6BCB</span>L, <span class="number">0xDBEE767C</span>L,</span><br><span class="line"> <span class="number">0xE3A1CBC1</span>L, <span class="number">0xE760D676</span>L, <span class="number">0xEA23F0AF</span>L, <span class="number">0xEEE2ED18</span>L,</span><br><span class="line"> <span class="number">0xF0A5BD1D</span>L, <span class="number">0xF464A0AA</span>L, <span class="number">0xF9278673</span>L, <span class="number">0xFDE69BC4</span>L,</span><br><span class="line"> <span class="number">0x89B8FD09</span>L, <span class="number">0x8D79E0BE</span>L, <span class="number">0x803AC667</span>L, <span class="number">0x84FBDBD0</span>L,</span><br><span class="line"> <span class="number">0x9ABC8BD5</span>L, <span class="number">0x9E7D9662</span>L, <span class="number">0x933EB0BB</span>L, <span class="number">0x97FFAD0C</span>L,</span><br><span class="line"> <span class="number">0xAFB010B1</span>L, <span class="number">0xAB710D06</span>L, <span class="number">0xA6322BDF</span>L, <span class="number">0xA2F33668</span>L,</span><br><span class="line"> <span class="number">0xBCB4666D</span>L, <span class="number">0xB8757BDA</span>L, <span class="number">0xB5365D03</span>L, <span class="number">0xB1F740B4</span>L</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"><span class="comment">/*                   End of CRC Lookup Table                     */</span></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/* CRC LOOKUP TABLE                                              */</span></span><br><span class="line"><span class="comment">/* ================                                              */</span></span><br><span class="line"><span class="comment">/* The following CRC lookup table was generated automagically    */</span></span><br><span class="line"><span class="comment">/* by the Rocksoft^tm Model CRC Algorithm Table Generation       */</span></span><br><span class="line"><span class="comment">/* Program V1.0 using the following model parameters:            */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/*    Width   : 4 bytes.                                         */</span></span><br><span class="line"><span class="comment">/*    Poly    : 0x04C11DB7L                                      */</span></span><br><span class="line"><span class="comment">/*    Reverse : TRUE.                                            */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/* For more information on the Rocksoft^tm Model CRC Algorithm,  */</span></span><br><span class="line"><span class="comment">/* see the document titled &quot;A Painless Guide to CRC Error        */</span></span><br><span class="line"><span class="comment">/* Detection Algorithms&quot; by Ross Williams                        */</span></span><br><span class="line"><span class="comment">/* (ross@guest.adelaide.edu.au.). This document is likely to be  */</span></span><br><span class="line"><span class="comment">/* in the FTP archive &quot;ftp.adelaide.edu.au/pub/rocksoft&quot;.        */</span></span><br><span class="line"><span class="comment">/*                                                               */</span></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>  crctable[<span class="number">256</span>] =</span><br><span class="line">&#123;</span><br><span class="line"> <span class="number">0x00000000</span>L, <span class="number">0x77073096</span>L, <span class="number">0xEE0E612C</span>L, <span class="number">0x990951BA</span>L,</span><br><span class="line"> <span class="number">0x076DC419</span>L, <span class="number">0x706AF48F</span>L, <span class="number">0xE963A535</span>L, <span class="number">0x9E6495A3</span>L,</span><br><span class="line"> <span class="number">0x0EDB8832</span>L, <span class="number">0x79DCB8A4</span>L, <span class="number">0xE0D5E91E</span>L, <span class="number">0x97D2D988</span>L,</span><br><span class="line"> <span class="number">0x09B64C2B</span>L, <span class="number">0x7EB17CBD</span>L, <span class="number">0xE7B82D07</span>L, <span class="number">0x90BF1D91</span>L,</span><br><span class="line"> <span class="number">0x1DB71064</span>L, <span class="number">0x6AB020F2</span>L, <span class="number">0xF3B97148</span>L, <span class="number">0x84BE41DE</span>L,</span><br><span class="line"> <span class="number">0x1ADAD47D</span>L, <span class="number">0x6DDDE4EB</span>L, <span class="number">0xF4D4B551</span>L, <span class="number">0x83D385C7</span>L,</span><br><span class="line"> <span class="number">0x136C9856</span>L, <span class="number">0x646BA8C0</span>L, <span class="number">0xFD62F97A</span>L, <span class="number">0x8A65C9EC</span>L,</span><br><span class="line"> <span class="number">0x14015C4F</span>L, <span class="number">0x63066CD9</span>L, <span class="number">0xFA0F3D63</span>L, <span class="number">0x8D080DF5</span>L,</span><br><span class="line"> <span class="number">0x3B6E20C8</span>L, <span class="number">0x4C69105E</span>L, <span class="number">0xD56041E4</span>L, <span class="number">0xA2677172</span>L,</span><br><span class="line"> <span class="number">0x3C03E4D1</span>L, <span class="number">0x4B04D447</span>L, <span class="number">0xD20D85FD</span>L, <span class="number">0xA50AB56B</span>L,</span><br><span class="line"> <span class="number">0x35B5A8FA</span>L, <span class="number">0x42B2986C</span>L, <span class="number">0xDBBBC9D6</span>L, <span class="number">0xACBCF940</span>L,</span><br><span class="line"> <span class="number">0x32D86CE3</span>L, <span class="number">0x45DF5C75</span>L, <span class="number">0xDCD60DCF</span>L, <span class="number">0xABD13D59</span>L,</span><br><span class="line"> <span class="number">0x26D930AC</span>L, <span class="number">0x51DE003A</span>L, <span class="number">0xC8D75180</span>L, <span class="number">0xBFD06116</span>L,</span><br><span class="line"> <span class="number">0x21B4F4B5</span>L, <span class="number">0x56B3C423</span>L, <span class="number">0xCFBA9599</span>L, <span class="number">0xB8BDA50F</span>L,</span><br><span class="line"> <span class="number">0x2802B89E</span>L, <span class="number">0x5F058808</span>L, <span class="number">0xC60CD9B2</span>L, <span class="number">0xB10BE924</span>L,</span><br><span class="line"> <span class="number">0x2F6F7C87</span>L, <span class="number">0x58684C11</span>L, <span class="number">0xC1611DAB</span>L, <span class="number">0xB6662D3D</span>L,</span><br><span class="line"> <span class="number">0x76DC4190</span>L, <span class="number">0x01DB7106</span>L, <span class="number">0x98D220BC</span>L, <span class="number">0xEFD5102A</span>L,</span><br><span class="line"> <span class="number">0x71B18589</span>L, <span class="number">0x06B6B51F</span>L, <span class="number">0x9FBFE4A5</span>L, <span class="number">0xE8B8D433</span>L,</span><br><span class="line"> <span class="number">0x7807C9A2</span>L, <span class="number">0x0F00F934</span>L, <span class="number">0x9609A88E</span>L, <span class="number">0xE10E9818</span>L,</span><br><span class="line"> <span class="number">0x7F6A0DBB</span>L, <span class="number">0x086D3D2D</span>L, <span class="number">0x91646C97</span>L, <span class="number">0xE6635C01</span>L,</span><br><span class="line"> <span class="number">0x6B6B51F4</span>L, <span class="number">0x1C6C6162</span>L, <span class="number">0x856530D8</span>L, <span class="number">0xF262004E</span>L,</span><br><span class="line"> <span class="number">0x6C0695ED</span>L, <span class="number">0x1B01A57B</span>L, <span class="number">0x8208F4C1</span>L, <span class="number">0xF50FC457</span>L,</span><br><span class="line"> <span class="number">0x65B0D9C6</span>L, <span class="number">0x12B7E950</span>L, <span class="number">0x8BBEB8EA</span>L, <span class="number">0xFCB9887C</span>L,</span><br><span class="line"> <span class="number">0x62DD1DDF</span>L, <span class="number">0x15DA2D49</span>L, <span class="number">0x8CD37CF3</span>L, <span class="number">0xFBD44C65</span>L,</span><br><span class="line"> <span class="number">0x4DB26158</span>L, <span class="number">0x3AB551CE</span>L, <span class="number">0xA3BC0074</span>L, <span class="number">0xD4BB30E2</span>L,</span><br><span class="line"> <span class="number">0x4ADFA541</span>L, <span class="number">0x3DD895D7</span>L, <span class="number">0xA4D1C46D</span>L, <span class="number">0xD3D6F4FB</span>L,</span><br><span class="line"> <span class="number">0x4369E96A</span>L, <span class="number">0x346ED9FC</span>L, <span class="number">0xAD678846</span>L, <span class="number">0xDA60B8D0</span>L,</span><br><span class="line"> <span class="number">0x44042D73</span>L, <span class="number">0x33031DE5</span>L, <span class="number">0xAA0A4C5F</span>L, <span class="number">0xDD0D7CC9</span>L,</span><br><span class="line"> <span class="number">0x5005713C</span>L, <span class="number">0x270241AA</span>L, <span class="number">0xBE0B1010</span>L, <span class="number">0xC90C2086</span>L,</span><br><span class="line"> <span class="number">0x5768B525</span>L, <span class="number">0x206F85B3</span>L, <span class="number">0xB966D409</span>L, <span class="number">0xCE61E49F</span>L,</span><br><span class="line"> <span class="number">0x5EDEF90E</span>L, <span class="number">0x29D9C998</span>L, <span class="number">0xB0D09822</span>L, <span class="number">0xC7D7A8B4</span>L,</span><br><span class="line"> <span class="number">0x59B33D17</span>L, <span class="number">0x2EB40D81</span>L, <span class="number">0xB7BD5C3B</span>L, <span class="number">0xC0BA6CAD</span>L,</span><br><span class="line"> <span class="number">0xEDB88320</span>L, <span class="number">0x9ABFB3B6</span>L, <span class="number">0x03B6E20C</span>L, <span class="number">0x74B1D29A</span>L,</span><br><span class="line"> <span class="number">0xEAD54739</span>L, <span class="number">0x9DD277AF</span>L, <span class="number">0x04DB2615</span>L, <span class="number">0x73DC1683</span>L,</span><br><span class="line"> <span class="number">0xE3630B12</span>L, <span class="number">0x94643B84</span>L, <span class="number">0x0D6D6A3E</span>L, <span class="number">0x7A6A5AA8</span>L,</span><br><span class="line"> <span class="number">0xE40ECF0B</span>L, <span class="number">0x9309FF9D</span>L, <span class="number">0x0A00AE27</span>L, <span class="number">0x7D079EB1</span>L,</span><br><span class="line"> <span class="number">0xF00F9344</span>L, <span class="number">0x8708A3D2</span>L, <span class="number">0x1E01F268</span>L, <span class="number">0x6906C2FE</span>L,</span><br><span class="line"> <span class="number">0xF762575D</span>L, <span class="number">0x806567CB</span>L, <span class="number">0x196C3671</span>L, <span class="number">0x6E6B06E7</span>L,</span><br><span class="line"> <span class="number">0xFED41B76</span>L, <span class="number">0x89D32BE0</span>L, <span class="number">0x10DA7A5A</span>L, <span class="number">0x67DD4ACC</span>L,</span><br><span class="line"> <span class="number">0xF9B9DF6F</span>L, <span class="number">0x8EBEEFF9</span>L, <span class="number">0x17B7BE43</span>L, <span class="number">0x60B08ED5</span>L,</span><br><span class="line"> <span class="number">0xD6D6A3E8</span>L, <span class="number">0xA1D1937E</span>L, <span class="number">0x38D8C2C4</span>L, <span class="number">0x4FDFF252</span>L,</span><br><span class="line"> <span class="number">0xD1BB67F1</span>L, <span class="number">0xA6BC5767</span>L, <span class="number">0x3FB506DD</span>L, <span class="number">0x48B2364B</span>L,</span><br><span class="line"> <span class="number">0xD80D2BDA</span>L, <span class="number">0xAF0A1B4C</span>L, <span class="number">0x36034AF6</span>L, <span class="number">0x41047A60</span>L,</span><br><span class="line"> <span class="number">0xDF60EFC3</span>L, <span class="number">0xA867DF55</span>L, <span class="number">0x316E8EEF</span>L, <span class="number">0x4669BE79</span>L,</span><br><span class="line"> <span class="number">0xCB61B38C</span>L, <span class="number">0xBC66831A</span>L, <span class="number">0x256FD2A0</span>L, <span class="number">0x5268E236</span>L,</span><br><span class="line"> <span class="number">0xCC0C7795</span>L, <span class="number">0xBB0B4703</span>L, <span class="number">0x220216B9</span>L, <span class="number">0x5505262F</span>L,</span><br><span class="line"> <span class="number">0xC5BA3BBE</span>L, <span class="number">0xB2BD0B28</span>L, <span class="number">0x2BB45A92</span>L, <span class="number">0x5CB36A04</span>L,</span><br><span class="line"> <span class="number">0xC2D7FFA7</span>L, <span class="number">0xB5D0CF31</span>L, <span class="number">0x2CD99E8B</span>L, <span class="number">0x5BDEAE1D</span>L,</span><br><span class="line"> <span class="number">0x9B64C2B0</span>L, <span class="number">0xEC63F226</span>L, <span class="number">0x756AA39C</span>L, <span class="number">0x026D930A</span>L,</span><br><span class="line"> <span class="number">0x9C0906A9</span>L, <span class="number">0xEB0E363F</span>L, <span class="number">0x72076785</span>L, <span class="number">0x05005713</span>L,</span><br><span class="line"> <span class="number">0x95BF4A82</span>L, <span class="number">0xE2B87A14</span>L, <span class="number">0x7BB12BAE</span>L, <span class="number">0x0CB61B38</span>L,</span><br><span class="line"> <span class="number">0x92D28E9B</span>L, <span class="number">0xE5D5BE0D</span>L, <span class="number">0x7CDCEFB7</span>L, <span class="number">0x0BDBDF21</span>L,</span><br><span class="line"> <span class="number">0x86D3D2D4</span>L, <span class="number">0xF1D4E242</span>L, <span class="number">0x68DDB3F8</span>L, <span class="number">0x1FDA836E</span>L,</span><br><span class="line"> <span class="number">0x81BE16CD</span>L, <span class="number">0xF6B9265B</span>L, <span class="number">0x6FB077E1</span>L, <span class="number">0x18B74777</span>L,</span><br><span class="line"> <span class="number">0x88085AE6</span>L, <span class="number">0xFF0F6A70</span>L, <span class="number">0x66063BCA</span>L, <span class="number">0x11010B5C</span>L,</span><br><span class="line"> <span class="number">0x8F659EFF</span>L, <span class="number">0xF862AE69</span>L, <span class="number">0x616BFFD3</span>L, <span class="number">0x166CCF45</span>L,</span><br><span class="line"> <span class="number">0xA00AE278</span>L, <span class="number">0xD70DD2EE</span>L, <span class="number">0x4E048354</span>L, <span class="number">0x3903B3C2</span>L,</span><br><span class="line"> <span class="number">0xA7672661</span>L, <span class="number">0xD06016F7</span>L, <span class="number">0x4969474D</span>L, <span class="number">0x3E6E77DB</span>L,</span><br><span class="line"> <span class="number">0xAED16A4A</span>L, <span class="number">0xD9D65ADC</span>L, <span class="number">0x40DF0B66</span>L, <span class="number">0x37D83BF0</span>L,</span><br><span class="line"> <span class="number">0xA9BCAE53</span>L, <span class="number">0xDEBB9EC5</span>L, <span class="number">0x47B2CF7F</span>L, <span class="number">0x30B5FFE9</span>L,</span><br><span class="line"> <span class="number">0xBDBDF21C</span>L, <span class="number">0xCABAC28A</span>L, <span class="number">0x53B39330</span>L, <span class="number">0x24B4A3A6</span>L,</span><br><span class="line"> <span class="number">0xBAD03605</span>L, <span class="number">0xCDD70693</span>L, <span class="number">0x54DE5729</span>L, <span class="number">0x23D967BF</span>L,</span><br><span class="line"> <span class="number">0xB3667A2E</span>L, <span class="number">0xC4614AB8</span>L, <span class="number">0x5D681B02</span>L, <span class="number">0x2A6F2B94</span>L,</span><br><span class="line"> <span class="number">0xB40BBE37</span>L, <span class="number">0xC30C8EA1</span>L, <span class="number">0x5A05DF1B</span>L, <span class="number">0x2D02EF8D</span>L</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"><span class="comment">/*                   End of CRC Lookup Table                     */</span></span><br><span class="line"><span class="comment">/*****************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在执行结束之后，寄存器留下的值就相当于反射后的消息经过非反射的算法后所得到的结果，再对结果进行反射的值（即对应着Rocksoft模型中的<code>Refin=TRUE</code>和<code>Refot=TRUE</code>），如果没看明白可以看看后面的<a href="#基于表的crc实现">C代码</a>。</p>
<h1 id="多项式反转reversed-polys">多项式反转（Reversed Polys）</h1>
<p>事实证明，一个好的多项式，其反射也是一个好的多项式。也就是说，如果<span class="math inline">\(G=11101\)</span>有不错的效果，那么<span class="math inline">\(G=10111\)</span>的效果也很好。因此，似乎每次一个组织（如CCITT）对一个特别好的多项式进行标准化时，在实际使用过程中，人们也不会放过该多项式的反射。因此，一组“标准”多项式有一组相应的反射，这些反射也在使用中。</p>
<p>为了避免迷惑，我们在这里称之为多项式反转（reversed poly）.</p>
<div class="admonition admonition-example">
<p class="admonition-title">Example</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">标准</th>
<th style="text-align: center;">多项式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">X25 standard</td>
<td style="text-align: center;">1-0001-0000-0010-0001</td>
</tr>
<tr class="even">
<td style="text-align: center;">X25 reversed</td>
<td style="text-align: center;">1-0000-1000-0001-0001</td>
</tr>
<tr class="odd">
<td style="text-align: center;">CRC16 standard</td>
<td style="text-align: center;">1-1000-0000-0000-0101</td>
</tr>
<tr class="even">
<td style="text-align: center;">CRC16 reversed</td>
<td style="text-align: center;">1-0100-0000-0000-0011</td>
</tr>
</tbody>
</table>
</div>
<p>请注意，这里反射（反转）的是整个多项式，而不仅仅是底部的<span class="math inline">\(W\)</span>位。这是一个重要的区别。在前一节描述的反射算法中，反射算法中使用的多项式实际上与非反射算法中的多项式的反射是反射底部的<span class="math inline">\(W\)</span>位，而不包含最高位隐藏<span class="math inline">\(1\)</span>。相比之下，反转多项式是包含最高位的<span class="math inline">\(1\)</span>的。</p>
<h1 id="初始化和最终值">初始化和最终值</h1>
<p>除了上述复杂性之外，CRC算法在另外两个方面也有所不同：</p>
<ol type="1">
<li>寄存器初始值</li>
<li>输出异或值（与最终的寄存器值进行异或）</li>
</ol>
<p>例如CRC32使用<span class="math inline">\(FFFFFFFF\)</span>初始化寄存器，并且使用<span class="math inline">\(FFFFFFFF\)</span>对最终的寄存器值进行异或。</p>
<p>大部分的CRC算法都将寄存器初始化为0，但是还是存在初始化为非0的情况。就理论上来说（messgage完全随机），初始值的选择不影响CRC 算法的有效性，初始值仅仅提供了一个寄存器值开始运算的固定起点。然而，在实践中，有些信息出现的可能性要更高，因此把CRC 寄存器初始化为一个不太可能在实际中出现“盲点” 的值是更明智的。“盲点” 是指一系列不会导致CRC 寄存器值变化的信息字节。特别是当CRC 寄存器被初始化为0 时就具有“零盲点”，当它运行的时候就不知道前面有多少个零字节。而零字节在实际应用中充当信息的前导字节是非常普遍的，所以把CRC 寄存器初始化为非零值是一个明智的做法。</p>
<h1 id="算法的定义">算法的定义</h1>
<p>至此，我们已经介绍了表驱动CRC算法的所有不同方面。由于这些算法有很多变体，因此值得尝试为它们建立一个命名法。这就是本章节的目的。</p>
<p>从上面的讨论我们可以看出，CRC算法主要由下面几个参数决定：</p>
<ul>
<li>多项式的宽度</li>
<li>多项式的值</li>
<li>寄存器的初始值</li>
<li>输入数据的每个字节是否需要反射</li>
<li>算法是直接表算法（DIRECT TABLE ALGORITHM）还是间接表算法(TABLE ALGORITHM)</li>
<li>最终寄存器的值是否需要被反射</li>
<li>输出异或值（与最终CRC值进行异或）</li>
</ul>
<p>为了能够讨论特定的CRC算法，我们需要能够更精确地定义它们。因此，下一节将尝试为CRC算法提供一个定义良好的参数化模型。要引用特定的算法，我们只需根据模型的参数指定算法。</p>
<h1 id="crc参数化模型rocksoft">CRC参数化模型（Rocksoft™）</h1>
<p>在本节中，我们定义了一个精确的参数化模型CRC算法，我们将称之为“Rocksoft™ Model CRC Algorithm”，这个模型最重要的一点就是它忽略了所有的具体实现，而只关注于功能。而构建这么一个模型则是为了能够精确引用特定的CRC算法，而不用管其具体实现是多么的复杂和混乱。因此模型应该简单精确，不会造成混淆。</p>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">
Rocksoft™模型本质上是基于DIRECT TABLE ALGORITHM的，但是该模型也被进一步参数化了，使得其能够表征更加复杂的和混乱的现实算法</p></div>
<p>为了能够表征反射算法，本模型提供了两个bool值选项，其中一个用来控制输入字节是否反射，另一个用来控制输出的校验值是否反射。还有一个参数用于指定寄存器的初始值，已经一个用于指定输出异或值的参数。</p>
<p>总的来说Rocksoft™模型的参数如下表：</p>
<table>
<caption>Rocksoft™模型参数表</caption>
<colgroup>
<col style="width: 6%">
<col style="width: 8%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数名称</th>
<th style="text-align: center;">参数类型</th>
<th style="text-align: center;">参数意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">NAME</td>
<td style="text-align: center;">字符串</td>
<td style="text-align: center;">算法的名称</td>
</tr>
<tr class="even">
<td style="text-align: center;">WIDTH</td>
<td style="text-align: center;">十进制数</td>
<td style="text-align: center;">算法宽度（以bit为单位）。比多项式的位数少1，因为多项式首字节有隐藏的1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">POLY</td>
<td style="text-align: center;"><span style="white-space: nowrap;">十六进制数</span></td>
<td style="text-align: center;">多项式所对应的二进制数的十六进制表示，并且忽略最高位的1，例如多项式<span class="math inline">\(10110\)</span>则表示为<span class="math inline">\(06\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">INIT</td>
<td style="text-align: center;">十六进制数</td>
<td style="text-align: center;">DIRECT TABLE ALGORITHM中的寄存器初值。如果使用的是TALBE ALGORITHM则需要将其转换，才能使结果一致</td>
</tr>
<tr class="odd">
<td style="text-align: center;">REFIN</td>
<td style="text-align: center;">布尔值</td>
<td style="text-align: center;">如果等于True，则反射输入Message的每个字节</td>
</tr>
<tr class="even">
<td style="text-align: center;">REFOUR</td>
<td style="text-align: center;">布尔值</td>
<td style="text-align: center;">如果等于False，则直接将寄存器中的值送入XOR阶段，否则，先将寄存器中的值进行反射，然后送入XOR阶段</td>
</tr>
<tr class="odd">
<td style="text-align: center;">XOROUT</td>
<td style="text-align: center;">十六进制数</td>
<td style="text-align: center;"><span class="math inline">\(W\)</span> bit宽的数，将异或之后的结果作为最终的校验值</td>
</tr>
<tr class="even">
<td style="text-align: center;">CHECK</td>
<td style="text-align: center;">十六进制数</td>
<td style="text-align: center;">这个不是必须的，主要是用来作为检查的，其值等于上述参数描述的算法，对字符串"123456789"产生的校验值</td>
</tr>
</tbody>
</table>
<p>定义了这些参数后，该模型现在可用于精确指定特定的CRC算法。以下是CRC-16算法的一种流行形式的示例规范。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数名称</th>
<th style="text-align: center;">参数值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">NAME</td>
<td style="text-align: center;">“CRC-16”</td>
</tr>
<tr class="even">
<td style="text-align: center;">WIDTH</td>
<td style="text-align: center;">16</td>
</tr>
<tr class="odd">
<td style="text-align: center;">POLY</td>
<td style="text-align: center;">8005</td>
</tr>
<tr class="even">
<td style="text-align: center;">INIT</td>
<td style="text-align: center;">0000</td>
</tr>
<tr class="odd">
<td style="text-align: center;">REFIN</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="even">
<td style="text-align: center;">REFOUR</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="odd">
<td style="text-align: center;">XOROUT</td>
<td style="text-align: center;">0000</td>
</tr>
<tr class="even">
<td style="text-align: center;">CHECK</td>
<td style="text-align: center;">BB3D</td>
</tr>
</tbody>
</table>
<p>以及CRC-32算法（据说是用于PKZip, AUTODIN II, Ethernet, 和 FDDI）。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数名称</th>
<th style="text-align: center;">参数值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Name</td>
<td style="text-align: center;">"CRC-32"</td>
</tr>
<tr class="even">
<td style="text-align: center;">Width</td>
<td style="text-align: center;">32</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Poly</td>
<td style="text-align: center;">04C11DB7</td>
</tr>
<tr class="even">
<td style="text-align: center;">Init</td>
<td style="text-align: center;">FFFFFFFF</td>
</tr>
<tr class="odd">
<td style="text-align: center;">RefIn</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="even">
<td style="text-align: center;">RefOut</td>
<td style="text-align: center;">True</td>
</tr>
<tr class="odd">
<td style="text-align: center;">XorOut</td>
<td style="text-align: center;">FFFFFFFF</td>
</tr>
<tr class="even">
<td style="text-align: center;">Check</td>
<td style="text-align: center;">CBF43926</td>
</tr>
</tbody>
</table>
<h1 id="rocksoft模型的参考实现">Rocksoft™模型的参考实现</h1>
<p>这是用C编程语言实现的模型算法。该实现由一个头文件（.h）和一个实现文件（.c）组成。如果想验证本代码的正确性，可以将其配置称上述的CRC-16和CRC-32，然后使用“123456789”作为message，然后将产生的结果与上述表中的<code>Check</code>进行比较。</p>
<figure class="highlight c"><figcaption><span>crcmodel.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                             Start of crcmodel.h                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Author : Ross Williams (ross@guest.adelaide.edu.au.).                      */</span></span><br><span class="line"><span class="comment">/* Date   : 3 June 1993.                                                      */</span></span><br><span class="line"><span class="comment">/* Status : Public domain.                                                    */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Description : This is the header (.h) file for the reference               */</span></span><br><span class="line"><span class="comment">/* implementation of the Rocksoft^tm Model CRC Algorithm. For more            */</span></span><br><span class="line"><span class="comment">/* information on the Rocksoft^tm Model CRC Algorithm, see the document       */</span></span><br><span class="line"><span class="comment">/* titled &quot;A Painless Guide to CRC Error Detection Algorithms&quot; by Ross        */</span></span><br><span class="line"><span class="comment">/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in   */</span></span><br><span class="line"><span class="comment">/* &quot;ftp.adelaide.edu.au/pub/rocksoft&quot;.                                        */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.    */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* How to Use This Package                                                    */</span></span><br><span class="line"><span class="comment">/* -----------------------                                                    */</span></span><br><span class="line"><span class="comment">/* Step 1: Declare a variable of type cm_t. Declare another variable          */</span></span><br><span class="line"><span class="comment">/*         (p_cm say) of type p_cm_t and initialize it to point to the first  */</span></span><br><span class="line"><span class="comment">/*         variable (e.g. p_cm_t p_cm = &amp;cm_t).                               */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Step 2: Assign values to the parameter fields of the structure.            */</span></span><br><span class="line"><span class="comment">/*         If you don&#x27;t know what to assign, see the document cited earlier.  */</span></span><br><span class="line"><span class="comment">/*         For example:                                                       */</span></span><br><span class="line"><span class="comment">/*            p_cm-&gt;cm_width = 16;                                            */</span></span><br><span class="line"><span class="comment">/*            p_cm-&gt;cm_poly  = 0x8005L;                                       */</span></span><br><span class="line"><span class="comment">/*            p_cm-&gt;cm_init  = 0L;                                            */</span></span><br><span class="line"><span class="comment">/*            p_cm-&gt;cm_refin = TRUE;                                          */</span></span><br><span class="line"><span class="comment">/*            p_cm-&gt;cm_refot = TRUE;                                          */</span></span><br><span class="line"><span class="comment">/*            p_cm-&gt;cm_xorot = 0L;                                            */</span></span><br><span class="line"><span class="comment">/*         Note: Poly is specified without its top bit (18005 becomes 8005).  */</span></span><br><span class="line"><span class="comment">/*         Note: Width is one bit less than the raw poly width.               */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Step 3: Initialize the instance with a call cm_ini(p_cm);                  */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Step 4: Process zero or more message bytes by placing zero or more         */</span></span><br><span class="line"><span class="comment">/*         successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);              */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm);   */</span></span><br><span class="line"><span class="comment">/*         If the CRC is a 16-bit value, it will be in the bottom 16 bits.    */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Design Notes                                                               */</span></span><br><span class="line"><span class="comment">/* ------------                                                               */</span></span><br><span class="line"><span class="comment">/* PORTABILITY: This package has been coded very conservatively so that       */</span></span><br><span class="line"><span class="comment">/* it will run on as many machines as possible. For example, all external     */</span></span><br><span class="line"><span class="comment">/* identifiers have been restricted to 6 characters and all internal ones to  */</span></span><br><span class="line"><span class="comment">/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to avoid */</span></span><br><span class="line"><span class="comment">/* namespace collisions. This package is endian independent.                  */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* EFFICIENCY: This package (and its interface) is not designed for           */</span></span><br><span class="line"><span class="comment">/* speed. The purpose of this package is to act as a well-defined reference   */</span></span><br><span class="line"><span class="comment">/* model for the specification of CRC algorithms. If you want speed, cook up  */</span></span><br><span class="line"><span class="comment">/* a specific table-driven implementation as described in the document cited  */</span></span><br><span class="line"><span class="comment">/* above. This package is designed for validation only; if you have found or  */</span></span><br><span class="line"><span class="comment">/* implemented a CRC algorithm and wish to describe it as a set of parameters */</span></span><br><span class="line"><span class="comment">/* to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm implementation  */</span></span><br><span class="line"><span class="comment">/* should behave identically to this package under those parameters.          */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following #ifndef encloses this entire */</span></span><br><span class="line"><span class="comment">/* header file, rendering it indempotent.     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CM_DONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CM_DONE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following definitions are extracted from my style header file which    */</span></span><br><span class="line"><span class="comment">/* would be cumbersome to distribute with this package. The DONE_STYLE is the */</span></span><br><span class="line"><span class="comment">/* idempotence symbol used in my style header file.                           */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DONE_STYLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ulong;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>* p_ubyte_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Change to the second definition if you don&#x27;t have prototypes. */</span></span><br><span class="line"><span class="comment">// #define P_(A) A</span></span><br><span class="line"><span class="comment">/* #define P_(A) () */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Uncomment this definition if you don&#x27;t have void. */</span></span><br><span class="line"><span class="comment">/* typedef int void; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CRC Model Abstract Type */</span></span><br><span class="line"><span class="comment">/* ----------------------- */</span></span><br><span class="line"><span class="comment">/* The following type stores the context of an executing instance of the  */</span></span><br><span class="line"><span class="comment">/* model algorithm. Most of the fields are model parameters which must be */</span></span><br><span class="line"><span class="comment">/* set before the first initializing call to cm_ini.                      */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> cm_width; <span class="comment">/* Parameter: Width in bits [8,32].       */</span></span><br><span class="line">    ulong cm_poly; <span class="comment">/* Parameter: The algorithm&#x27;s polynomial. */</span></span><br><span class="line">    ulong cm_init; <span class="comment">/* Parameter: Initial register value.     */</span></span><br><span class="line">    <span class="type">bool</span> cm_refin; <span class="comment">/* Parameter: Reflect input bytes?        */</span></span><br><span class="line">    <span class="type">bool</span> cm_refot; <span class="comment">/* Parameter: Reflect output CRC?         */</span></span><br><span class="line">    ulong cm_xorot; <span class="comment">/* Parameter: XOR this to output CRC.     */</span></span><br><span class="line"></span><br><span class="line">    ulong cm_reg; <span class="comment">/* Context: Context during execution.     */</span></span><br><span class="line">&#125; <span class="type">cm_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">cm_t</span>* <span class="type">p_cm_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions That Implement The Model */</span></span><br><span class="line"><span class="comment">/* ---------------------------------- */</span></span><br><span class="line"><span class="comment">/* The following functions animate the cm_t abstraction. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cm_ini</span><span class="params">(<span class="type">p_cm_t</span> p_cm)</span>;</span><br><span class="line"><span class="comment">/* Initializes the argument CRC model instance.          */</span></span><br><span class="line"><span class="comment">/* All parameter fields must be set before calling this. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cm_nxt</span><span class="params">(<span class="type">p_cm_t</span> p_cm, <span class="type">int</span> ch)</span>;</span><br><span class="line"><span class="comment">/* Processes a single message byte [0,255]. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cm_blk</span><span class="params">(<span class="type">p_cm_t</span> p_cm, p_ubyte_ blk_adr, ulong blk_len)</span>;</span><br><span class="line"><span class="comment">/* Processes a block of message bytes. */</span></span><br><span class="line"></span><br><span class="line">ulong <span class="title function_">cm_crc</span><span class="params">(<span class="type">p_cm_t</span> p_cm)</span>;</span><br><span class="line"><span class="comment">/* Returns the CRC value for the message bytes processed so far. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions For Table Calculation */</span></span><br><span class="line"><span class="comment">/* ------------------------------- */</span></span><br><span class="line"><span class="comment">/* The following function can be used to calculate a CRC lookup table.        */</span></span><br><span class="line"><span class="comment">/* It can also be used at run-time to create or check static tables.          */</span></span><br><span class="line"></span><br><span class="line">ulong <span class="title function_">cm_tab</span><span class="params">(<span class="type">p_cm_t</span> p_cm, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="comment">/* Returns the i&#x27;th entry for the lookup table for the specified algorithm.   */</span></span><br><span class="line"><span class="comment">/* The function examines the fields cm_width, cm_poly, cm_refin, and the      */</span></span><br><span class="line"><span class="comment">/* argument table index in the range [0,255] and returns the table entry in   */</span></span><br><span class="line"><span class="comment">/* the bottom cm_width bytes of the return value.                             */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* End of the header file idempotence #ifndef */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                             End of crcmodel.h                              */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>crcmodel.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                             Start of crcmodel.c                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Author : Ross Williams (ross@guest.adelaide.edu.au.).                      */</span></span><br><span class="line"><span class="comment">/* Date   : 3 June 1993.                                                      */</span></span><br><span class="line"><span class="comment">/* Status : Public domain.                                                    */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Description : This is the implementation (.c) file for the reference       */</span></span><br><span class="line"><span class="comment">/* implementation of the Rocksoft^tm Model CRC Algorithm. For more            */</span></span><br><span class="line"><span class="comment">/* information on the Rocksoft^tm Model CRC Algorithm, see the document       */</span></span><br><span class="line"><span class="comment">/* titled &quot;A Painless Guide to CRC Error Detection Algorithms&quot; by Ross        */</span></span><br><span class="line"><span class="comment">/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in   */</span></span><br><span class="line"><span class="comment">/* &quot;ftp.adelaide.edu.au/pub/rocksoft&quot;.                                        */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.    */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Implementation Notes                                                       */</span></span><br><span class="line"><span class="comment">/* --------------------                                                       */</span></span><br><span class="line"><span class="comment">/* To avoid inconsistencies, the specification of each function is not echoed */</span></span><br><span class="line"><span class="comment">/* here. See the header file for a description of these functions.            */</span></span><br><span class="line"><span class="comment">/* This package is light on checking because I want to keep it short and      */</span></span><br><span class="line"><span class="comment">/* simple and portable (i.e. it would be too messy to distribute my entire    */</span></span><br><span class="line"><span class="comment">/* C culture (e.g. assertions package) with this package.                     */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;crcmodel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The following definitions make the code more readable. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITMASK(X) (1L &lt;&lt; (X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MASK32 0xFFFFFFFFL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL static</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the value v with the bottom b [0,32] bits reflected. */</span></span><br><span class="line"><span class="comment">/* Example: reflect(0x3e23L,3) == 0x3e26                        */</span></span><br><span class="line">LOCAL ulong <span class="title function_">reflect</span><span class="params">(ulong v, <span class="type">int</span> b)</span>;</span><br><span class="line">LOCAL ulong <span class="title function_">reflect</span><span class="params">(ulong v, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ulong t = v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1L</span>)</span><br><span class="line">            v |= BITMASK((b - <span class="number">1</span>) - i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v &amp;= ~BITMASK((b - <span class="number">1</span>) - i);</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a longword whose value is (2^p_cm-&gt;cm_width)-1.     */</span></span><br><span class="line"><span class="comment">/* The trick is to do this portably (e.g. without doing &lt;&lt;32). */</span></span><br><span class="line">LOCAL ulong <span class="title function_">widmask</span><span class="params">(<span class="type">p_cm_t</span>)</span>;</span><br><span class="line">LOCAL ulong <span class="title function_">widmask</span><span class="params">(<span class="type">p_cm_t</span> p_cm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="number">1L</span> &lt;&lt; (p_cm-&gt;cm_width - <span class="number">1</span>)) - <span class="number">1L</span>) &lt;&lt; <span class="number">1</span>) | <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cm_ini</span><span class="params">(<span class="type">p_cm_t</span> p_cm)</span></span><br><span class="line">&#123;</span><br><span class="line">    p_cm-&gt;cm_reg = p_cm-&gt;cm_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cm_nxt</span><span class="params">(<span class="type">p_cm_t</span> p_cm, <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ulong uch = (ulong)ch;</span><br><span class="line">    ulong topbit = BITMASK(p_cm-&gt;cm_width - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_cm-&gt;cm_refin)</span><br><span class="line">        uch = reflect(uch, <span class="number">8</span>);</span><br><span class="line">    p_cm-&gt;cm_reg ^= (uch &lt;&lt; (p_cm-&gt;cm_width - <span class="number">8</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p_cm-&gt;cm_reg &amp; topbit)</span><br><span class="line">            p_cm-&gt;cm_reg = (p_cm-&gt;cm_reg &lt;&lt; <span class="number">1</span>) ^ p_cm-&gt;cm_poly;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p_cm-&gt;cm_reg &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        p_cm-&gt;cm_reg &amp;= widmask(p_cm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cm_blk</span><span class="params">(<span class="type">p_cm_t</span> p_cm, p_ubyte_ blk_adr, ulong blk_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (blk_len--)</span><br><span class="line">        cm_nxt(p_cm, *blk_adr++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line">ulong <span class="title function_">cm_crc</span><span class="params">(<span class="type">p_cm_t</span> p_cm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_cm-&gt;cm_refot)</span><br><span class="line">        <span class="keyword">return</span> p_cm-&gt;cm_xorot ^ reflect(p_cm-&gt;cm_reg, p_cm-&gt;cm_width);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p_cm-&gt;cm_xorot ^ p_cm-&gt;cm_reg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line">ulong <span class="title function_">cm_tab</span><span class="params">(<span class="type">p_cm_t</span> p_cm, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ulong r;</span><br><span class="line">    ulong topbit = BITMASK(p_cm-&gt;cm_width - <span class="number">1</span>);</span><br><span class="line">    ulong inbyte = (ulong)index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_cm-&gt;cm_refin)</span><br><span class="line">        inbyte = reflect(inbyte, <span class="number">8</span>);</span><br><span class="line">    r = inbyte &lt;&lt; (p_cm-&gt;cm_width - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (r &amp; topbit)</span><br><span class="line">            r = (r &lt;&lt; <span class="number">1</span>) ^ p_cm-&gt;cm_poly;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p_cm-&gt;cm_refin)</span><br><span class="line">        r = reflect(r, p_cm-&gt;cm_width);</span><br><span class="line">    <span class="keyword">return</span> r &amp; widmask(p_cm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                             End of crcmodel.c                              */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>check.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;crcmodel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* Benchmark = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Checking CRC using string \&quot;123456789\&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CRC-16</span></span><br><span class="line">    <span class="type">cm_t</span> crc16 = &#123;</span><br><span class="line">        .cm_init = <span class="number">0x0000</span>,</span><br><span class="line">        .cm_poly = <span class="number">0x8005</span>,</span><br><span class="line">        .cm_refin = TRUE,</span><br><span class="line">        .cm_refot = TRUE,</span><br><span class="line">        .cm_width = <span class="number">16</span>,</span><br><span class="line">        .cm_xorot = <span class="number">0x0000</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CRC-32</span></span><br><span class="line">    <span class="type">cm_t</span> crc32 = &#123;</span><br><span class="line">        .cm_init = <span class="number">0xffffffff</span>,</span><br><span class="line">        .cm_poly = <span class="number">0x04c11db7</span>,</span><br><span class="line">        .cm_refin = TRUE,</span><br><span class="line">        .cm_refot = TRUE,</span><br><span class="line">        .cm_width = <span class="number">32</span>,</span><br><span class="line">        .cm_xorot = <span class="number">0xffffffff</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">p_cm_t</span> p_crc16 = &amp;crc16;</span><br><span class="line">    <span class="type">p_cm_t</span> p_crc32 = &amp;crc32;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化的值</span></span><br><span class="line">    cm_ini(p_crc16);</span><br><span class="line">    cm_ini(p_crc32);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    cm_blk(p_crc16, (<span class="type">unsigned</span> <span class="type">char</span>*)Benchmark, <span class="built_in">strlen</span>(Benchmark));</span><br><span class="line">    cm_blk(p_crc32, (<span class="type">unsigned</span> <span class="type">char</span>*)Benchmark, <span class="built_in">strlen</span>(Benchmark));</span><br><span class="line"></span><br><span class="line">    ulong checksum16 = cm_crc(p_crc16);</span><br><span class="line">    ulong checksum32 = cm_crc(p_crc32);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;crc 16 : 0x%lx\n&quot;</span>, checksum16);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;crc 32 : 0x%lx\n&quot;</span>, checksum32);</span><br><span class="line"></span><br><span class="line">    assert(checksum16 == <span class="number">0xbb3d</span>);</span><br><span class="line">    assert(checksum32 == <span class="number">0xcbf43926</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[1;32mcheck pass !!!\e[0m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行参考模型</span></span><br><span class="line"><span class="section">run_reference:check.c crcmodel.c</span></span><br><span class="line">	@gcc -g <span class="variable">$^</span> -Wall -Werror -o reference &amp;&amp; ./reference</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成查找表</span></span><br><span class="line"><span class="section">gen_table:crctable.c crcmodel.c</span></span><br><span class="line">	@gcc -g <span class="variable">$^</span> -Wall -Werror -o gen_table &amp;&amp; ./gen_table</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行表驱动算法</span></span><br><span class="line"><span class="section">table_driven:crc32_table_driven.c gen_table</span></span><br><span class="line">	@gcc -g <span class="variable">$&lt;</span> -Wall -Werror -o table_driven &amp;&amp; ./table_driven</span><br><span class="line"></span><br><span class="line"><span class="section">all: run_reference table_driven</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm crctable reference gen_table table_driven</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="基于表的crc实现">基于表的CRC实现</h1>
<p>尽管上面我介绍了很多细节用以理解和定义CRC算法，但是CRC的高速实现并没有那么复杂。总的来说，其高速实现其实 只有两种形式——<code>normal</code>和<code>reflected</code>。其中<code>normal</code>向左移动寄存器（对应着Rocksoft模型中<code>Refin=FALSE</code>和<code>Refot=FALSE</code>），而<code>reflected</code>向右移动寄存器（对应着Rocksoft模型中<code>Refin=TRUE</code>和<code>Refot=TRUE</code>）。如果我们想要对应着Rocksoft模型中<code>Refin=FALSE</code>和<code>Refot=TRUE</code>，则只需要在<code>normal</code>的基础上，对其结果反射即可。而如果我们想要对应着Rocksoft模型中<code>Refin=TRUE</code>和<code>Refot=FALSE</code>，则只需要在<code>reflected</code>的基础上，对其结果进行反射即可。</p>
<p>一个32比特的CRC算法以及其reflected的其示例代码如下：</p>
<figure class="highlight c"><figcaption><span>crc32_table_driven.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// crc-32 parameter</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XOROT 0Xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT 0Xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_REFLECTED 0Xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK 0XCBF43926</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this table is generated by crctable.c using crc-32 parameter</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;crctable&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 32-bit normal form (the 16-bit form is similar).</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">crc_normal</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* blk_adr, <span class="type">unsigned</span> <span class="type">long</span> blk_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> crc = INIT;</span><br><span class="line">    <span class="keyword">while</span> (blk_len--)</span><br><span class="line">        crc = crctable[((crc &gt;&gt; <span class="number">24</span>) ^ *blk_adr++) &amp; <span class="number">0xFF</span>L] ^ (crc &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> crc ^ XOROT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the reflected form:</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">crc_reflected</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* blk_adr, <span class="type">unsigned</span> <span class="type">long</span> blk_len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> crc = INIT_REFLECTED;</span><br><span class="line">    <span class="keyword">while</span> (blk_len--)</span><br><span class="line">        crc = crctable[(crc ^ *blk_adr++) &amp; <span class="number">0xFF</span>L] ^ (crc &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> crc ^ XOROT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check for validating</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Check Algorithm by \&quot;123456789\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span>* message = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> res = crc_reflected((<span class="type">unsigned</span> <span class="type">char</span> *)message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;crc result: %lx \n&quot;</span>, res);</span><br><span class="line">    assert(res == CHECK);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\e[1;32mCheck Pass !!!\e[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成查找表">生成查找表</h1>
<p>上一节中的代码片段中中唯一缺少的组件是查找表。查找表可以在运行时使用前面给出的模型包的<code>cm_tab</code>函数计算，也可以预先计算并插入到C程序中。在任何一种情况下，都应该注意，查找表仅取决于POLY和RefIn参数。</p>
<p>下面的程序可以生成任何所需的32位或者16位查找表：</p>
<figure class="highlight c"><figcaption><span>crctable.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                             Start of crctable.c                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Author  : Ross Williams (ross@guest.adelaide.edu.au.).                     */</span></span><br><span class="line"><span class="comment">/* Date    : 3 June 1993.                                                     */</span></span><br><span class="line"><span class="comment">/* Version : 1.0.                                                             */</span></span><br><span class="line"><span class="comment">/* Status  : Public domain.                                                   */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Description : This program writes a CRC lookup table (suitable for         */</span></span><br><span class="line"><span class="comment">/* inclusion in a C program) to a designated output file. The program can be  */</span></span><br><span class="line"><span class="comment">/* statically configured to produce any table covered by the Rocksoft^tm      */</span></span><br><span class="line"><span class="comment">/* Model CRC Algorithm. For more information on the Rocksoft^tm Model CRC     */</span></span><br><span class="line"><span class="comment">/* Algorithm, see the document titled &quot;A Painless Guide to CRC Error          */</span></span><br><span class="line"><span class="comment">/* Detection Algorithms&quot; by Ross Williams (ross@guest.adelaide.edu.au.). This */</span></span><br><span class="line"><span class="comment">/* document is likely to be in &quot;ftp.adelaide.edu.au/pub/rocksoft&quot;.            */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.    */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;crcmodel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TABLE PARAMETERS                                                           */</span></span><br><span class="line"><span class="comment">/* ================                                                           */</span></span><br><span class="line"><span class="comment">/* The following parameters entirely determine the table to be generated. You */</span></span><br><span class="line"><span class="comment">/* should need to modify only the definitions in this section before running  */</span></span><br><span class="line"><span class="comment">/* this program.                                                              */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/*    TB_FILE  is the name of the output file.                                */</span></span><br><span class="line"><span class="comment">/*    TB_WIDTH is the table width in bytes (either 2 or 4).                   */</span></span><br><span class="line"><span class="comment">/*    TB_POLY  is the &quot;polynomial&quot;, which must be TB_WIDTH bytes wide.        */</span></span><br><span class="line"><span class="comment">/*    TB_REVER indicates whether the table is to be reversed (reflected).     */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/* Example:                                                                   */</span></span><br><span class="line"><span class="comment">/*                                                                            */</span></span><br><span class="line"><span class="comment">/*    #define TB_FILE   &quot;crctable.out&quot;                                        */</span></span><br><span class="line"><span class="comment">/*    #define TB_WIDTH  2                                                     */</span></span><br><span class="line"><span class="comment">/*    #define TB_POLY   0x8005L                                               */</span></span><br><span class="line"><span class="comment">/*    #define TB_REVER  TRUE                                                  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// crc-32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_FILE <span class="string">&quot;crctable&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_WIDTH 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_POLY 0x04C11DB7L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TB_REVER TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Miscellaneous definitions. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL static</span></span><br><span class="line">FILE* outfile;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR(X) fprintf(outfile, (X))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WP(X, Y) fprintf(outfile, (X), (Y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If mess is non-empty, write it out and abort. Otherwise, check the error   */</span></span><br><span class="line"><span class="comment">/* status of outfile and abort if an error has occurred.                      */</span></span><br><span class="line">LOCAL <span class="type">void</span> <span class="title function_">chk_err</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line">LOCAL <span class="type">void</span> <span class="title function_">chk_err</span><span class="params">(<span class="type">char</span>* mess)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mess[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mess);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ferror(outfile)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chk_err&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line">LOCAL <span class="type">void</span> <span class="title function_">chkparam</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">LOCAL <span class="type">void</span> <span class="title function_">chkparam</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((TB_WIDTH != <span class="number">2</span>) &amp;&amp; (TB_WIDTH != <span class="number">4</span>))</span><br><span class="line">        chk_err(<span class="string">&quot;chkparam: Width parameter is illegal.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((TB_WIDTH == <span class="number">2</span>) &amp;&amp; (TB_POLY &amp; <span class="number">0xFFFF0000</span>L))</span><br><span class="line">        chk_err(<span class="string">&quot;chkparam: Poly parameter is too wide.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((TB_REVER != FALSE) &amp;&amp; (TB_REVER != TRUE))</span><br><span class="line">        chk_err(<span class="string">&quot;chkparam: Reverse parameter is not boolean.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line">LOCAL <span class="type">void</span> <span class="title function_">gentable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">LOCAL <span class="type">void</span> <span class="title function_">gentable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WR(<span class="string">&quot;/*****************************************************************/\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/*                                                               */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* CRC LOOKUP TABLE                                              */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* ================                                              */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* The following CRC lookup table was generated automagically    */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* by the Rocksoft^tm Model CRC Algorithm Table Generation       */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* Program V1.0 using the following model parameters:            */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/*                                                               */\n&quot;</span>);</span><br><span class="line">    WP(<span class="string">&quot;/*    Width   : %1lu bytes.                                         */\n&quot;</span>, (ulong)TB_WIDTH);</span><br><span class="line">    <span class="keyword">if</span> (TB_WIDTH == <span class="number">2</span>)</span><br><span class="line">        WP(<span class="string">&quot;/*    Poly    : 0x%04lX                                       */\n&quot;</span>,(ulong)TB_POLY);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        WP(<span class="string">&quot;/*    Poly    : 0x%08lXL                                      */\n&quot;</span>,(ulong)TB_POLY);</span><br><span class="line">    <span class="keyword">if</span> (TB_REVER)</span><br><span class="line">        WR(<span class="string">&quot;/*    Reverse : TRUE.                                            */\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        WR(<span class="string">&quot;/*    Reverse : FALSE.                                           */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/*                                                               */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* For more information on the Rocksoft^tm Model CRC Algorithm,  */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* see the document titled \&quot;A Painless Guide to CRC Error        */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* Detection Algorithms\&quot; by Ross Williams                        */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* (ross@guest.adelaide.edu.au.). This document is likely to be  */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/* in the FTP archive \&quot;ftp.adelaide.edu.au/pub/rocksoft\&quot;.        */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/*                                                               */\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;/*****************************************************************/\n&quot;</span>);</span><br><span class="line">    WR(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (TB_WIDTH) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        WR(<span class="string">&quot;unsigned short crctable[256] =\n&#123;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        WR(<span class="string">&quot;unsigned long  crctable[256] =\n&#123;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        chk_err(<span class="string">&quot;gentable: TB_WIDTH is invalid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    chk_err(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">cm_t</span> cm;</span><br><span class="line">        <span class="type">char</span>* form = (TB_WIDTH == <span class="number">2</span>) ? <span class="string">&quot;0x%04lX&quot;</span> : <span class="string">&quot;0x%08lXL&quot;</span>;</span><br><span class="line">        <span class="type">int</span> perline = (TB_WIDTH == <span class="number">2</span>) ? <span class="number">8</span> : <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        cm.cm_width = TB_WIDTH * <span class="number">8</span>;</span><br><span class="line">        cm.cm_poly = TB_POLY;</span><br><span class="line">        cm.cm_refin = TB_REVER;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            WR(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            WP(form, (ulong)cm_tab(&amp;cm, i));</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">255</span>)</span><br><span class="line">                WR(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (((i + <span class="number">1</span>) % perline) == <span class="number">0</span>)</span><br><span class="line">                WR(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            chk_err(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WR(<span class="string">&quot;&#125;;\n&quot;</span>);</span><br><span class="line">        WR(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        WR(<span class="string">&quot;/*****************************************************************/\n&quot;</span>);</span><br><span class="line">        WR(<span class="string">&quot;/*                   End of CRC Lookup Table                     */\n&quot;</span>);</span><br><span class="line">        WR(<span class="string">&quot;/*****************************************************************/\n&quot;</span>);</span><br><span class="line">        WR(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        chk_err(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Rocksoft^tm Model CRC Algorithm Table Generation Program V1.0\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output file is \&quot;%s\&quot;.\n&quot;</span>, TB_FILE);</span><br><span class="line">    chkparam();</span><br><span class="line">    outfile = fopen(TB_FILE, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    chk_err(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    gentable();</span><br><span class="line">    <span class="keyword">if</span> (fclose(outfile) != <span class="number">0</span>)</span><br><span class="line">        chk_err(<span class="string">&quot;main: Couldn&#x27;t close output file.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nSUCCESS: The table has been successfully written.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                             End of crctable.c                              */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="可用参考">可用参考</h1>
<p>Boudreau, Steen, "Cyclic Redundancy Checking by Program," AFIPS Proceedings, Vol. 39, 1971.</p>
<p>Davies, Barber, "Computer Networks and Their Protocols," J. Wiley &amp; Sons, 1979.</p>
<p>Higginson, Kirstein, "On the Computation of Cyclic Redundancy Checks by Program," The Computer Journal (British), Vol. 16, No. 1, Feb 1973.</p>
<p>McNamara, J. E., "Technical Aspects of Data Communication," 2nd Edition, Digital Press, Bedford, Massachusetts, 1982.</p>
<p>Marton and Frambs, "A Cyclic Redundancy Checking (CRC) Algorithm," Honeywell Computer Journal, Vol. 5, No. 3, 1971.</p>
<p>Nelson M., "File verification using CRC", Dr Dobbs Journal, May 1992, pp.64-67.</p>
<p>Ramabadran T.V., Gaitonde S.S., "A tutorial on CRC computations", IEEE Micro, Aug 1988.</p>
<p>Schwaderer W.D., "CRC Calculation", April 85 PC Tech Journal, pp.118-133.</p>
<p>Ward R.K, Tabandeh M., "Error Correction and Detection, A Geometric Approach" The Computer Journal, Vol. 27, No. 3, 1984, pp.246-253.</p>
<p>Wecker, S., "A Table-Lookup Algorithm for Software Computation of Cyclic Redundancy Check (CRC)," Digital Equipment Corporation memorandum, 1974.</p>
<p>[Griffiths87]<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>[Knuth81]<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>[Nelson91]<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>[Sarwate88]<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>[Tanenbaum81]<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>CRC除法的性质决定的，而二进制除法则会得到<span class="math inline">\(W+1\)</span>位的余数，因为除数的宽度是<span class="math inline">\(W+1\)</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Tanenbaum, A.S., "Computer Networks", Prentice Hall, 1981, ISBN: 0-13-164699-0. Comment: Section 3.5.3 on pages 128 to 132 provides a very clear description of CRC codes. However, it does not describe table-driven implementation techniques.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Griffiths, G., Carlyle Stones, G., "The Tea-Leaf Reader Algorithm: An Efficient Implementation of CRC-16 and CRC-32", Communications of the ACM, 30(7), pp.617-620. Comment: This paper describes a high-speed table-driven implementation of CRC algorithms. The technique seems to be a touch messy, and is superceded by the Sarwete algorithm.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Knuth, D.E., "The Art of Computer Programming", Volume 2: Seminumerical Algorithms, Section 4.6.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Nelson, M., "The Data Compression Book", M&amp;T Books, (501 Galveston Drive, Redwood City, CA 94063), 1991, ISBN: 1-55851-214-4. Comment: If you want to see a real implementation of a real 32-bit checksum algorithm, look on pages 440, and 446-448.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Sarwate, D.V., "Computation of Cyclic Redundancy Checks via Table Look-Up", Communications of the ACM, 31(8), pp.1008-1013. Comment: This paper describes a high-speed table-driven implementation for CRC algorithms that is superior to the tea-leaf algorithm. Although this paper describes the technique used by most modern CRC implementations, I found the appendix of this paper (where all the good stuff is) difficult to understand.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Tanenbaum, A.S., "Computer Networks", Prentice Hall, 1981, ISBN: 0-13-164699-0. Comment: Section 3.5.3 on pages 128 to 132 provides a very clear description of CRC codes. However, it does not describe table-driven implementation techniques.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>CRC</category>
      </categories>
      <tags>
        <tag>CRC</tag>
      </tags>
  </entry>
  <entry>
    <title>FROM VPR TO OPENFPGA</title>
    <url>/2022/06/06/FROM-VPR-TO-OPENFPGA/</url>
    <content><![CDATA[<h1 id="原始的vpr架构">原始的VPR架构</h1>
<p>原始的VPR架构如图所示，是一个同构的FPGA，仅仅只包含CLB(包含四个BLE，和一个全连接的crossbar)和IO。其中每个BLE包含一个四输入的查找表、一个触发器以及一个二选一多路选择器。除此之外，该架构的互联部分采取的长度为1的导线，并且通过（Wilton开关快进行互联）</p>
<p><img src="https://openfpga.readthedocs.io/en/latest/_images/k4n4_arch.png" alt="K4N4 FPGA Architecture"></p>
<figure class="highlight xml"><figcaption><span>orign VPR architecture</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> Architecture file translated from ifar repository N04K04L01.FC15FO25.AREA1DELAY1.CMOS90NM.BPTM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Simple architecture file consisting of clusters of 4 BLEs, each BLE contains a 4-LUT+FF pair.  Delay models from 90nm PTM.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">architecture</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       ODIN II specific config begins </span></span><br><span class="line"><span class="comment">       Describes the types of user-specified netlist blocks (in blif, this corresponds to </span></span><br><span class="line"><span class="comment">       &quot;.model [type_of_block]&quot;) that this architecture supports.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       <span class="doctag">Note:</span> Basic LUTs, I/Os, and flip-flops are not included here as there are </span></span><br><span class="line"><span class="comment">       already special structures in blif (.names, .input, .output, and .latch) </span></span><br><span class="line"><span class="comment">       that describe them.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">models</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">models</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tile</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sub_tile</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span> <span class="attr">capacity</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">equivalent_sites</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">site</span> <span class="attr">pb_type</span>=<span class="string">&quot;io&quot;</span> <span class="attr">pin_mapping</span>=<span class="string">&quot;direct&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">equivalent_sites</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clock&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fc</span> <span class="attr">in_type</span>=<span class="string">&quot;frac&quot;</span> <span class="attr">in_val</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">out_type</span>=<span class="string">&quot;frac&quot;</span> <span class="attr">out_val</span>=<span class="string">&quot;0.25&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pinlocations</span> <span class="attr">pattern</span>=<span class="string">&quot;custom&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">loc</span> <span class="attr">side</span>=<span class="string">&quot;left&quot;</span>&gt;</span>io.outpad io.inpad io.clock<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">loc</span> <span class="attr">side</span>=<span class="string">&quot;top&quot;</span>&gt;</span>io.outpad io.inpad io.clock<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">loc</span> <span class="attr">side</span>=<span class="string">&quot;right&quot;</span>&gt;</span>io.outpad io.inpad io.clock<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">loc</span> <span class="attr">side</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>io.outpad io.inpad io.clock<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pinlocations</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sub_tile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tile</span> <span class="attr">name</span>=<span class="string">&quot;clb&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sub_tile</span> <span class="attr">name</span>=<span class="string">&quot;clb&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">equivalent_sites</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">site</span> <span class="attr">pb_type</span>=<span class="string">&quot;clb&quot;</span> <span class="attr">pin_mapping</span>=<span class="string">&quot;direct&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">equivalent_sites</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;I&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;10&quot;</span> <span class="attr">equivalent</span>=<span class="string">&quot;full&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;O&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;4&quot;</span> <span class="attr">equivalent</span>=<span class="string">&quot;instance&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fc</span> <span class="attr">in_type</span>=<span class="string">&quot;frac&quot;</span> <span class="attr">in_val</span>=<span class="string">&quot;0.15&quot;</span> <span class="attr">out_type</span>=<span class="string">&quot;frac&quot;</span> <span class="attr">out_val</span>=<span class="string">&quot;0.25&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pinlocations</span> <span class="attr">pattern</span>=<span class="string">&quot;spread&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">sub_tile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tiles</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ODIN II specific config ends --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Physical descriptions begin --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auto_layout</span> <span class="attr">aspect_ratio</span>=<span class="string">&quot;1.000000&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Perimeter of &#x27;io&#x27; blocks with &#x27;EMPTY&#x27; blocks at corners--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">perimeter</span> <span class="attr">type</span>=<span class="string">&quot;io&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">corners</span> <span class="attr">type</span>=<span class="string">&quot;EMPTY&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;101&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Fill with &#x27;clb&#x27;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fill</span> <span class="attr">type</span>=<span class="string">&quot;clb&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">auto_layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">device</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sizing</span> <span class="attr">R_minW_nmos</span>=<span class="string">&quot;4220.930176&quot;</span> <span class="attr">R_minW_pmos</span>=<span class="string">&quot;11207.599609&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">grid_logic_tile_area</span>=<span class="string">&quot;2229.320068&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">chan_width_distr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">x</span> <span class="attr">distr</span>=<span class="string">&quot;uniform&quot;</span> <span class="attr">peak</span>=<span class="string">&quot;1.000000&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">y</span> <span class="attr">distr</span>=<span class="string">&quot;uniform&quot;</span> <span class="attr">peak</span>=<span class="string">&quot;1.000000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">chan_width_distr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">switch_block</span> <span class="attr">type</span>=<span class="string">&quot;wilton&quot;</span> <span class="attr">fs</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connection_block</span> <span class="attr">input_switch_name</span>=<span class="string">&quot;ipin_cblock&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">switchlist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">switch</span> <span class="attr">type</span>=<span class="string">&quot;mux&quot;</span> <span class="attr">name</span>=<span class="string">&quot;0&quot;</span> <span class="attr">R</span>=<span class="string">&quot;0.000000&quot;</span> <span class="attr">Cin</span>=<span class="string">&quot;0.000000e+00&quot;</span> <span class="attr">Cout</span>=<span class="string">&quot;0.000000e+00&quot;</span> <span class="attr">Tdel</span>=<span class="string">&quot;6.244000e-11&quot;</span> <span class="attr">mux_trans_size</span>=<span class="string">&quot;1.835460&quot;</span> <span class="attr">buf_size</span>=<span class="string">&quot;10.498600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--switch ipin_cblock resistance set to yeild for 4x minimum drive strength buffer--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">switch</span> <span class="attr">type</span>=<span class="string">&quot;mux&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ipin_cblock&quot;</span> <span class="attr">R</span>=<span class="string">&quot;1055.232544&quot;</span> <span class="attr">Cout</span>=<span class="string">&quot;0.&quot;</span> <span class="attr">Cin</span>=<span class="string">&quot;0.000000e+00&quot;</span> <span class="attr">Tdel</span>=<span class="string">&quot;8.045000e-11&quot;</span> <span class="attr">mux_trans_size</span>=<span class="string">&quot;0.983352&quot;</span> <span class="attr">buf_size</span>=<span class="string">&quot;auto&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">switchlist</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">segmentlist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">segment</span> <span class="attr">freq</span>=<span class="string">&quot;1.000000&quot;</span> <span class="attr">length</span>=<span class="string">&quot;1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;unidir&quot;</span> <span class="attr">Rmetal</span>=<span class="string">&quot;0.000000&quot;</span> <span class="attr">Cmetal</span>=<span class="string">&quot;0.000000e+00&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mux</span> <span class="attr">name</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sb</span> <span class="attr">type</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span>1 1<span class="tag">&lt;/<span class="name">sb</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">cb</span> <span class="attr">type</span>=<span class="string">&quot;pattern&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">cb</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">segment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">segmentlist</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">complexblocklist</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define I/O pads begin --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clock&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- IOs can operate as either inputs or outputs.</span></span><br><span class="line"><span class="comment">	     Delays below come from Ian Kuon. They are small, so they should be interpreted as</span></span><br><span class="line"><span class="comment">	     the delays to and from registers in the I/O (and generally I/Os are registered </span></span><br><span class="line"><span class="comment">	     today and that is when you timing analyze them.</span></span><br><span class="line"><span class="comment">	     --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.input&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">input</span>=<span class="string">&quot;inpad.inpad&quot;</span> <span class="attr">output</span>=<span class="string">&quot;io.inpad&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;9.492000e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;inpad.inpad&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;io.inpad&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.output&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">input</span>=<span class="string">&quot;io.outpad&quot;</span> <span class="attr">output</span>=<span class="string">&quot;outpad.outpad&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;2.675000e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;io.outpad&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;outpad.outpad&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- IOs go on the periphery of the FPGA, for consistency, </span></span><br><span class="line"><span class="comment">          make it physically equivalent on all sides so that only one definition of I/Os is needed.</span></span><br><span class="line"><span class="comment">          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Place I/Os on the sides of the FPGA --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">power</span> <span class="attr">method</span>=<span class="string">&quot;ignore&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define I/O pads ends --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define general purpose logic block (CLB) begin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;clb&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;I&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;10&quot;</span> <span class="attr">equivalent</span>=<span class="string">&quot;full&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;O&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;4&quot;</span> <span class="attr">equivalent</span>=<span class="string">&quot;instance&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Describe basic logic element. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;fle&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;in&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;out&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 4-LUT mode definition begin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;n1_lut4&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- Define 4-LUT mode --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;ble4&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;in&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;out&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Define LUT --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;lut4&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.names&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;lut&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;in&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;4&quot;</span> <span class="attr">port_class</span>=<span class="string">&quot;lut_in&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;out&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span> <span class="attr">port_class</span>=<span class="string">&quot;lut_out&quot;</span>/&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- LUT timing using delay matrix --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;max&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;lut4.in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;lut4.out&quot;</span>&gt;</span></span><br><span class="line">                2.253000e-10</span><br><span class="line">                2.253000e-10</span><br><span class="line">                2.253000e-10</span><br><span class="line">                2.253000e-10</span><br><span class="line">              <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Define flip-flop --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;ff&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.latch&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;flipflop&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;D&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span> <span class="attr">port_class</span>=<span class="string">&quot;D&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;Q&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span> <span class="attr">port_class</span>=<span class="string">&quot;Q&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span> <span class="attr">port_class</span>=<span class="string">&quot;clock&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">T_setup</span> <span class="attr">value</span>=<span class="string">&quot;2.160000e-10&quot;</span> <span class="attr">port</span>=<span class="string">&quot;ff.D&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">T_clock_to_Q</span> <span class="attr">max</span>=<span class="string">&quot;1.426000e-10&quot;</span> <span class="attr">port</span>=<span class="string">&quot;ff.Q&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;direct1&quot;</span> <span class="attr">input</span>=<span class="string">&quot;ble4.in&quot;</span> <span class="attr">output</span>=<span class="string">&quot;lut4[0:0].in&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;direct2&quot;</span> <span class="attr">input</span>=<span class="string">&quot;lut4.out&quot;</span> <span class="attr">output</span>=<span class="string">&quot;ff.D&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Advanced user option that tells CAD tool to find LUT+FF pairs in netlist --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pack_pattern</span> <span class="attr">name</span>=<span class="string">&quot;ble6&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;lut4.out&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;ff.D&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;direct3&quot;</span> <span class="attr">input</span>=<span class="string">&quot;ble4.clk&quot;</span> <span class="attr">output</span>=<span class="string">&quot;ff.clk&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mux</span> <span class="attr">name</span>=<span class="string">&quot;mux1&quot;</span> <span class="attr">input</span>=<span class="string">&quot;ff.Q lut4.out&quot;</span> <span class="attr">output</span>=<span class="string">&quot;ble4.out&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">mux</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;direct1&quot;</span> <span class="attr">input</span>=<span class="string">&quot;fle.in&quot;</span> <span class="attr">output</span>=<span class="string">&quot;ble4.in&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;direct2&quot;</span> <span class="attr">input</span>=<span class="string">&quot;ble4.out&quot;</span> <span class="attr">output</span>=<span class="string">&quot;fle.out[0:0]&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;direct3&quot;</span> <span class="attr">input</span>=<span class="string">&quot;fle.clk&quot;</span> <span class="attr">output</span>=<span class="string">&quot;ble4.clk&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 4-LUT mode definition end --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- We use a full crossbar to get logical equivalence at inputs of CLB  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complete</span> <span class="attr">name</span>=<span class="string">&quot;crossbar&quot;</span> <span class="attr">input</span>=<span class="string">&quot;clb.I fle[3:0].out&quot;</span> <span class="attr">output</span>=<span class="string">&quot;fle[3:0].in&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;5.735000e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;clb.I&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;fle[3:0].in&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;5.428000e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;fle[3:0].out&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;fle[3:0].in&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">complete</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complete</span> <span class="attr">name</span>=<span class="string">&quot;clks&quot;</span> <span class="attr">input</span>=<span class="string">&quot;clb.clk&quot;</span> <span class="attr">output</span>=<span class="string">&quot;fle[3:0].clk&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">complete</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;clbouts1&quot;</span> <span class="attr">input</span>=<span class="string">&quot;fle[3:0].out&quot;</span> <span class="attr">output</span>=<span class="string">&quot;clb.O&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 25% of the tracks in a channel --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Place this general purpose logic block in any unspecified column --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define general purpose logic block (CLB) ends --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">complexblocklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">architecture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="改变vpr架构">改变VPR架构</h1>
<h2 id="物理io模型">物理IO模型</h2>
<p>因为Open FPGA需要物理IO块，而不是抽象的VPR的IO模型，因此需要在<code>&lt;complexblocklist&gt;</code>标签下添加<code>&lt;pb_type name="io"&gt;</code>，如一下代码所示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Define I/O pads begin --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- A mode denotes the physical implementation of an I/O</span></span><br><span class="line"><span class="comment">         This mode will not be used by packer but is mainly used for fabric verilog generation</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;physical&quot;</span> <span class="attr">packable</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;iopad&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.subckt io&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">input</span>=<span class="string">&quot;io.outpad&quot;</span> <span class="attr">output</span>=<span class="string">&quot;iopad.outpad&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;1.394e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;io.outpad&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;iopad.outpad&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">input</span>=<span class="string">&quot;iopad.inpad&quot;</span> <span class="attr">output</span>=<span class="string">&quot;io.inpad&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;4.243e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;iopad.inpad&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;io.inpad&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- Operating modes of I/O used by VPR</span></span><br><span class="line"><span class="comment">        IOs can operate as either inputs or outputs. --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.input&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">input</span>=<span class="string">&quot;inpad.inpad&quot;</span> <span class="attr">output</span>=<span class="string">&quot;io.inpad&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;9.492000e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;inpad.inpad&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;io.inpad&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.output&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">interconnect</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">direct</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">input</span>=<span class="string">&quot;io.outpad&quot;</span> <span class="attr">output</span>=<span class="string">&quot;outpad.outpad&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;2.675000e-11&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;io.outpad&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;outpad.outpad&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">direct</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">interconnect</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与原始的XML相比，主要有以下几点变化：</p>
<ol type="1">
<li>添加了physical mode的IO，用于生成fabric网表</li>
<li>移除了IO的时钟端口（因为实际上是一个悬空端口）</li>
<li>在physical mode里面使用了属性<code>packable=false</code>，可以降低打包器的运行时间。</li>
</ol>
<p>由于上述的操作添加了新的BLIF模型<code>subckt io</code>，所以应该在<code>&lt;models&gt;</code>标签下添加一个新的IO模型。如下代码所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">models</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- A virtual model for I/O to be used in the physical mode of io block --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">model</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input_ports</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;outpad&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">input_ports</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output_ports</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;inpad&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">output_ports</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">models</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="tileable架构">Tileable架构</h2>
<p>OpenFPGA 确实支持细粒度的tileable的架构，tileable架构可快速生成网表，并通过后端流程实现高度优化的物理设计。为了使能tileable架构，应该将<code>tileable</code>属性添加到<code>&lt;layout&gt;</code>节点。通过启用此功能，将生成尽可能相同的所有开关块和连接块。因此，对于任何 FPGA 阵列大小，在网表中只生成 9 个独特的块。请参阅[<a href="https://openfpga.readthedocs.io/en/latest/reference/#xtang-fpt-2019">TGAG19]</a>中的详细信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">tileable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="openfpga工艺架构">OPENFPGA工艺架构</h1>
<p>整个IOENFPGA的工艺架构组织如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">openfpga_architecture</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Technology-related (device/transistor-level) information--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">technology_library</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">technology_library</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Circuit-level description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circuit_library</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">circuit_library</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Configuration protocol definition --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration_protocol</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration_protocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Annotation on VPR architecture modules --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">connection_block</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">connection_block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">switch_block</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">switch_block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">routing_segment</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">routing_segment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type_annotations</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">pb_type_annotations</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">openfpga_architecture</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="technology-library">technology library</h2>
<p>此部分包含了构建FPGA的晶体管级的信息，这对于FPGA-SPICE来生成网表来说是很重要的，但是如果不适用FPGA-SPICE，就可以提供虚拟的（dummy）technology library。</p>
<p>open-source ASU Predictive Technology Modeling (PTM) 45nm process library的xml描述如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">technology_library</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">device_library</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">device_model</span> <span class="attr">name</span>=<span class="string">&quot;logic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;transistor&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">lib</span> <span class="attr">type</span>=<span class="string">&quot;industry&quot;</span> <span class="attr">corner</span>=<span class="string">&quot;TOP_TT&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;M&quot;</span> <span class="attr">path</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/tech/PTM_45nm/45nm.pm&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">design</span> <span class="attr">vdd</span>=<span class="string">&quot;0.9&quot;</span> <span class="attr">pn_ratio</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pmos</span> <span class="attr">name</span>=<span class="string">&quot;pch&quot;</span> <span class="attr">chan_length</span>=<span class="string">&quot;40e-9&quot;</span> <span class="attr">min_width</span>=<span class="string">&quot;140e-9&quot;</span> <span class="attr">variation</span>=<span class="string">&quot;logic_transistor_var&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nmos</span> <span class="attr">name</span>=<span class="string">&quot;nch&quot;</span> <span class="attr">chan_length</span>=<span class="string">&quot;40e-9&quot;</span> <span class="attr">min_width</span>=<span class="string">&quot;140e-9&quot;</span> <span class="attr">variation</span>=<span class="string">&quot;logic_transistor_var&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">device_model</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">device_model</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span> <span class="attr">type</span>=<span class="string">&quot;transistor&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">lib</span> <span class="attr">type</span>=<span class="string">&quot;academia&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;M&quot;</span> <span class="attr">path</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/tech/PTM_45nm/45nm.pm&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">design</span> <span class="attr">vdd</span>=<span class="string">&quot;2.5&quot;</span> <span class="attr">pn_ratio</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pmos</span> <span class="attr">name</span>=<span class="string">&quot;pch_25&quot;</span> <span class="attr">chan_length</span>=<span class="string">&quot;270e-9&quot;</span> <span class="attr">min_width</span>=<span class="string">&quot;320e-9&quot;</span> <span class="attr">variation</span>=<span class="string">&quot;io_transistor_var&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nmos</span> <span class="attr">name</span>=<span class="string">&quot;nch_25&quot;</span> <span class="attr">chan_length</span>=<span class="string">&quot;270e-9&quot;</span> <span class="attr">min_width</span>=<span class="string">&quot;320e-9&quot;</span> <span class="attr">variation</span>=<span class="string">&quot;io_transistor_var&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">device_model</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">device_library</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">variation_library</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variation</span> <span class="attr">name</span>=<span class="string">&quot;logic_transistor_var&quot;</span> <span class="attr">abs_deviation</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">num_sigma</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variation</span> <span class="attr">name</span>=<span class="string">&quot;io_transistor_var&quot;</span> <span class="attr">abs_deviation</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">num_sigma</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">variation_library</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">technology_library</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="circuit-library">circuit library</h2>
<p>circuit library是架构描述的关键部件，包含了一系列的<code>&lt;circuit_model&gt;</code>，每一个都描述了FPGA部件是如何电路实现的。通常的实现过程中会先描述一部分原子模型，然后通过原子模型来描述基元模型，而基元模型则直接用来构建FPGA组件（LUT等）。</p>
<p>以下的参考代码描述了反相器、缓冲器以及传输门等原子逻辑：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Atom circuit models begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;inv_buf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;INVTX1&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;INVTX1&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">topology</span>=<span class="string">&quot;inverter&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;rise&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;fall&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;inv_buf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;buf4&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;buf4&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">topology</span>=<span class="string">&quot;buffer&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">num_level</span>=<span class="string">&quot;2&quot;</span> <span class="attr">f_per_stage</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;rise&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;fall&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;inv_buf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tap_buf4&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;tap_buf4&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">topology</span>=<span class="string">&quot;buffer&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">num_level</span>=<span class="string">&quot;3&quot;</span> <span class="attr">f_per_stage</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;rise&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;fall&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;pass_gate&quot;</span> <span class="attr">name</span>=<span class="string">&quot;TGATE&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;TGATE&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">topology</span>=<span class="string">&quot;transmission_gate&quot;</span> <span class="attr">nmos_size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">pmos_size</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;sel&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;selb&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;rise&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in sel selb&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12 5e-12 5e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;fall&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in sel selb&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    10e-12 5e-12 5e-12</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delay_matrix</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;chan_wire&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chan_segment&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;track_seg&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">wire_param</span> <span class="attr">model_type</span>=<span class="string">&quot;pi&quot;</span> <span class="attr">R</span>=<span class="string">&quot;101&quot;</span> <span class="attr">C</span>=<span class="string">&quot;22.5e-15&quot;</span> <span class="attr">num_level</span>=<span class="string">&quot;1&quot;</span>/&gt;</span> <span class="comment">&lt;!-- model_type could be T, res_val and cap_val DON&#x27;T CARE --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;wire&quot;</span> <span class="attr">name</span>=<span class="string">&quot;direct_interc&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;direct_interc&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">wire_param</span> <span class="attr">model_type</span>=<span class="string">&quot;pi&quot;</span> <span class="attr">R</span>=<span class="string">&quot;0&quot;</span> <span class="attr">C</span>=<span class="string">&quot;0&quot;</span> <span class="attr">num_level</span>=<span class="string">&quot;1&quot;</span>/&gt;</span> <span class="comment">&lt;!-- model_type could be T, res_val cap_val should be defined --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Atom circuit models end--&gt;</span></span><br></pre></td></tr></table></figure>
<p>在以下实例代码中描述了布线多路选择器、LUT以及IO cells等基元模型。其中<code>static_diff</code>、<code>sc_dff_compact</code>以及<code>iopad</code>需要手动指定Verilog网表，而其他电路模型则可以通过OpenFPGA自动生成。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Primitive circuit models begin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;mux&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mux_2level&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;mux_2level&quot;</span> <span class="attr">dump_structural_verilog</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">structure</span>=<span class="string">&quot;multi_level&quot;</span> <span class="attr">num_level</span>=<span class="string">&quot;2&quot;</span> <span class="attr">add_const_input</span>=<span class="string">&quot;true&quot;</span> <span class="attr">const_input_val</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pass_gate_logic</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;TGATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;mux&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mux_2level_tapbuf&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;mux_2level_tapbuf&quot;</span> <span class="attr">dump_structural_verilog</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">structure</span>=<span class="string">&quot;multi_level&quot;</span> <span class="attr">num_level</span>=<span class="string">&quot;2&quot;</span> <span class="attr">add_const_input</span>=<span class="string">&quot;true&quot;</span> <span class="attr">const_input_val</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;tap_buf4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pass_gate_logic</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;TGATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;mux&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mux_1level_tapbuf&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;mux_1level_tapbuf&quot;</span> <span class="attr">is_default</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dump_structural_verilog</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span> <span class="attr">structure</span>=<span class="string">&quot;one_level&quot;</span> <span class="attr">add_const_input</span>=<span class="string">&quot;true&quot;</span> <span class="attr">const_input_val</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;tap_buf4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pass_gate_logic</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;TGATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--DFF subckt ports should be defined as &lt;D&gt; &lt;Q&gt; &lt;CLK&gt; &lt;RESET&gt; &lt;SET&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;ff&quot;</span> <span class="attr">name</span>=<span class="string">&quot;static_dff&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;dff&quot;</span> <span class="attr">spice_netlist</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/SpiceNetlists/ff.sp&quot;</span> <span class="attr">verilog_netlist</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/VerilogNetlists/ff.v&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;D&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">is_global</span>=<span class="string">&quot;true&quot;</span> <span class="attr">default_val</span>=<span class="string">&quot;0&quot;</span> <span class="attr">is_set</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">is_global</span>=<span class="string">&quot;true&quot;</span> <span class="attr">default_val</span>=<span class="string">&quot;0&quot;</span> <span class="attr">is_reset</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;Q&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;clock&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">is_global</span>=<span class="string">&quot;true&quot;</span> <span class="attr">default_val</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;lut&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lut4&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;lut4&quot;</span> <span class="attr">dump_structural_verilog</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lut_input_inverter</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lut_input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;buf4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pass_gate_logic</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;TGATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;in&quot;</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;out&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">size</span>=<span class="string">&quot;16&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Scan-chain DFF subckt ports should be defined as &lt;D&gt; &lt;Q&gt; &lt;Qb&gt; &lt;CLK&gt; &lt;RESET&gt; &lt;SET&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;ccff&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sc_dff_compact&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;scff&quot;</span> <span class="attr">spice_netlist</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/SpiceNetlists/ff.sp&quot;</span> <span class="attr">verilog_netlist</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/VerilogNetlists/ff.v&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;pReset&quot;</span> <span class="attr">lib_name</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">is_global</span>=<span class="string">&quot;true&quot;</span> <span class="attr">default_val</span>=<span class="string">&quot;0&quot;</span> <span class="attr">is_reset</span>=<span class="string">&quot;true&quot;</span> <span class="attr">is_prog</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;D&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;Q&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;Qb&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;clock&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;prog_clk&quot;</span> <span class="attr">lib_name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">is_global</span>=<span class="string">&quot;true&quot;</span> <span class="attr">default_val</span>=<span class="string">&quot;0&quot;</span> <span class="attr">is_prog</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circuit_model</span> <span class="attr">type</span>=<span class="string">&quot;iopad&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iopad&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;iopad&quot;</span> <span class="attr">spice_netlist</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/SpiceNetlists/io.sp&quot;</span> <span class="attr">verilog_netlist</span>=<span class="string">&quot;$&#123;OPENFPGA_PATH&#125;/openfpga_flow/VerilogNetlists/io.v&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">design_technology</span> <span class="attr">type</span>=<span class="string">&quot;cmos&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">output_buffer</span> <span class="attr">exist</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;INVTX1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;inout&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;pad&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">is_global</span>=<span class="string">&quot;true&quot;</span> <span class="attr">is_io</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;sram&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;en&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span> <span class="attr">mode_select</span>=<span class="string">&quot;true&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;sc_dff_compact&quot;</span> <span class="attr">default_val</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;outpad&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">type</span>=<span class="string">&quot;output&quot;</span> <span class="attr">prefix</span>=<span class="string">&quot;inpad&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">circuit_model</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Primitive circuit models end --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置协议定义">配置协议定义</h2>
<p>以下代码指定 FPGA 架构将通过一系列触发器 (FF) 进行配置，该触发器使用.<code>&lt;circuit_model name=sc_dff_compact&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration_protocol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">organization</span> <span class="attr">type</span>=<span class="string">&quot;scan_chain&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;sc_dff_compact&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration_protocol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="对vpr模型进行标注">对VPR模型进行标注</h2>
<p>对于路由架构，需要指定连接块、开关快内使用的多路选择器的<code>circuit_model</code>以及布线导线的<code>circuit_model</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">connection_block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">switch</span> <span class="attr">name</span>=<span class="string">&quot;ipin_cblock&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;mux_2level_tapbuf&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">connection_block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">switch_block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">switch</span> <span class="attr">name</span>=<span class="string">&quot;0&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;mux_2level_tapbuf&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">switch_block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">routing_segment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">segment</span> <span class="attr">name</span>=<span class="string">&quot;L4&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;chan_segment&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">routing_segment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note info flat"><p>为了获得正确的绑定，连接块、交换机块和路由段的名称应与 VPR 体系结构描述中的名称定义相匹配！</p>
</div>
<p>对于在<code>&lt;comlpexblocklist&gt;</code>中定义的每一个<code>pb_type</code>如果包含多个模式，则应该指定物理模式（physical mode），并且这个物理模块的名字应该与VPR架构中定义的模式名字相匹配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span> <span class="attr">physical_mode_name</span>=<span class="string">&quot;physical&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在物理模式下，当要指定任何基元<code>pb_type</code>所使用的实现方式（circuit model），需要提供<code>pb_type</code>的详细层次结构。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io[physical].iopad&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;iopad&quot;</span> <span class="attr">mode_bits</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note info flat"><p>对于可配置资源，应该提供默认的配置比特。例如正如<code>cirtuit_model name=iopad</code>中所定义的一样，IO cell有一个配置比特</p>
</div>
<p>对于物理模式以外的其他模式（操作模式），则应该提供从操作模式到物理模式的映射，以至于能够生成比特流。这一步也需要提供<code>pb_type</code>的完整层次结构。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io[inpad].inpad&quot;</span> <span class="attr">physical_pb_type_name</span>=<span class="string">&quot;io[physical].iopad&quot;</span> <span class="attr">mode_bits</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码就指明了当配置位为1时，被配置为输入模式（应该与io的实现代码有关，有待求证）。</p>
<p>以下代码用于指定用于实现互联模块的电路模型，其中name应该与VPR中的定义相匹配（如果未指定，则会使用默认的<code>circuit_model</code>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interconnect</span> <span class="attr">name</span>=<span class="string">&quot;crossbar&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;mux_2level&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note success flat"><p>OpenFPGA能自动推断每一个interconnect所需要的circuit model</p>
<p>总感觉与上面的话矛盾！！！</p>
</div>
<p>整个完整的标注如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pb_type_annotations</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- physical pb_type binding in complex block IO --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io&quot;</span> <span class="attr">physical_mode_name</span>=<span class="string">&quot;physical&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io[physical].iopad&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;iopad&quot;</span> <span class="attr">mode_bits</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io[inpad].inpad&quot;</span> <span class="attr">physical_pb_type_name</span>=<span class="string">&quot;io[physical].iopad&quot;</span> <span class="attr">mode_bits</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;io[outpad].outpad&quot;</span> <span class="attr">physical_pb_type_name</span>=<span class="string">&quot;io[physical].iopad&quot;</span> <span class="attr">mode_bits</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- End physical pb_type binding in complex block IO --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- physical pb_type binding in complex block CLB --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- physical mode will be the default mode if not specified --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;clb&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Binding interconnect to circuit models as their physical implementation, if not defined, we use the default model --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interconnect</span> <span class="attr">name</span>=<span class="string">&quot;crossbar&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;mux_2level&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;clb.fle[n1_lut4].ble4.lut4&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;lut4&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;clb.fle[n1_lut4].ble4.ff&quot;</span> <span class="attr">circuit_model_name</span>=<span class="string">&quot;static_dff&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- End physical pb_type binding in complex block IO --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pb_type_annotations</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="仿真设置">仿真设置</h1>
<p>OpenFPGA需要一个xml文件详细描述仿真设置，仿真设置中包含了用于构建验证testbench的重要参数。本例子的（第一幅图）的仿真设置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">openfpga_simulation_setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">clock_setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">operating</span> <span class="attr">frequency</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">num_cycles</span>=<span class="string">&quot;auto&quot;</span> <span class="attr">slack</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">programming</span> <span class="attr">frequency</span>=<span class="string">&quot;100e6&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">clock_setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simulator_option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">operating_condition</span> <span class="attr">temperature</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output_log</span> <span class="attr">verbose</span>=<span class="string">&quot;false&quot;</span> <span class="attr">captab</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">accuracy</span> <span class="attr">type</span>=<span class="string">&quot;abs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1e-13&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">runtime</span> <span class="attr">fast_simulation</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">simulator_option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">monte_carlo</span> <span class="attr">num_simulation_points</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">measurement_setting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slew</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rise</span> <span class="attr">upper_thres_pct</span>=<span class="string">&quot;0.95&quot;</span> <span class="attr">lower_thres_pct</span>=<span class="string">&quot;0.05&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fall</span> <span class="attr">upper_thres_pct</span>=<span class="string">&quot;0.05&quot;</span> <span class="attr">lower_thres_pct</span>=<span class="string">&quot;0.95&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slew</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delay</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rise</span> <span class="attr">input_thres_pct</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">output_thres_pct</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fall</span> <span class="attr">input_thres_pct</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">output_thres_pct</span>=<span class="string">&quot;0.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delay</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">measurement_setting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">stimulus</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clock</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rise</span> <span class="attr">slew_type</span>=<span class="string">&quot;abs&quot;</span> <span class="attr">slew_time</span>=<span class="string">&quot;20e-12&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fall</span> <span class="attr">slew_type</span>=<span class="string">&quot;abs&quot;</span> <span class="attr">slew_time</span>=<span class="string">&quot;20e-12&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rise</span> <span class="attr">slew_type</span>=<span class="string">&quot;abs&quot;</span> <span class="attr">slew_time</span>=<span class="string">&quot;25e-12&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">fall</span> <span class="attr">slew_type</span>=<span class="string">&quot;abs&quot;</span> <span class="attr">slew_time</span>=<span class="string">&quot;25e-12&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">stimulus</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">openfpga_simulation_setting</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;clock_setting&gt;</code>用于在testbench中创建时钟信号。</p>
<div class="note info flat"><p>FPGA有两种类型的时钟，一种是操作时钟，用于控制部署到FPGA fabric中的应用。另一个是编程时钟，用于控制配置协议</p>
</div>
<p><code>&lt;simulator_option&gt;</code>是用于SPICE仿真的选项</p>
<p>感觉暂时用不到</p>
<p>详情请见<a href="https://openfpga.readthedocs.io/en/latest/manual/arch_lang/simulation_setting/#simulation-setting">仿真设置</a></p>
]]></content>
      <categories>
        <category>CAD</category>
      </categories>
      <tags>
        <tag>OPENFPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>ML Theory Summary</title>
    <url>/2022/07/05/ML-Theory-Summary/</url>
    <content><![CDATA[<h1 id="introduction">Introduction</h1>
<p>对概率的诠释有两大学派，一种是频率派另一种是贝叶斯派。后面我们对观测集采用下面记号：<br>
<span class="math display">\[
X_{N\times p}=(x_{1},x_{2},\cdots,x_{N})^{T},x_{i}=(x_{i1},x_{i2},\cdots,x_{ip})^{T}
\]</span><br>
这个记号表示有 <span class="math inline">\(N\)</span> 个样本，每个样本都是 <span class="math inline">\(p\)</span> 维向量。其中每个观测都是由 <span class="math inline">\(p(x|\theta)\)</span> 生成的。</p>
<h2 id="频率派的观点">频率派的观点</h2>
<p><span class="math inline">\(p(x|\theta)\)</span>中的 <span class="math inline">\(\theta\)</span> 是一个常量。对于 <span class="math inline">\(N\)</span> 个观测来说观测集的概率为 <span class="math inline">\(p(X|\theta)\mathop{=}\limits _{iid}\prod\limits _{i=1}^{N}p(x_{i}|\theta))\)</span> 。为了求 <span class="math inline">\(\theta\)</span> 的大小，我们采用最大对数似然MLE的方法：</p>
<p><span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span></p>
<h2 id="贝叶斯派的观点">贝叶斯派的观点</h2>
<p>贝叶斯派认为 <span class="math inline">\(p(x|\theta)\)</span> 中的 <span class="math inline">\(\theta\)</span> 不是一个常量。这个 <span class="math inline">\(\theta\)</span> 满足一个预设的先验的分布 <span class="math inline">\(\theta\sim p(\theta)\)</span> 。于是根据贝叶斯定理依赖观测集参数的后验可以写成：</p>
<p><span class="math display">\[
p(\theta|X)=\frac{p(X|\theta)\cdot p(\theta)}{p(X)}=\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}
\]</span><br>
为了求 <span class="math inline">\(\theta\)</span> 的值，我们要最大化这个参数后验MAP：</p>
<p><span class="math display">\[
\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)
\]</span><br>
其中第二个等号是由于分母和 <span class="math inline">\(\theta\)</span> 没有关系。求解这个 <span class="math inline">\(\theta\)</span> 值后计算<span class="math inline">\(\frac{p(X|\theta)\cdot p(\theta)}{\int\limits _{\theta}p(X|\theta)\cdot p(\theta)d\theta}\)</span> ，就得到了参数的后验概率。其中 <span class="math inline">\(p(X|\theta)\)</span> 叫似然，是我们的模型分布。得到了参数的后验分布后，我们可以将这个分布用于预测贝叶斯预测：<br>
<span class="math display">\[
p(x_{new}|X)=\int\limits _{\theta}p(x_{new}|\theta)\cdot p(\theta|X)d\theta
\]</span><br>
其中积分中的被乘数是模型，乘数是后验分布。</p>
<h2 id="小结">小结</h2>
<p>频率派和贝叶斯派分别给出了一系列的机器学习算法。频率派的观点导出了一系列的统计机器学习算法而贝叶斯派导出了概率图理论。在应用频率派的 MLE 方法时最优化理论占有重要地位。而贝叶斯派的算法无论是后验概率的建模还是应用这个后验进行推断时积分占有重要地位。因此采样积分方法如 MCMC 有很多应用。</p>
<h1 id="mathbasics">MathBasics</h1>
<h2 id="高斯分布">高斯分布</h2>
<h3 id="一维情况-mle">一维情况 MLE</h3>
<p>高斯分布在机器学习中占有举足轻重的作用。在 MLE 方法中：</p>
<p><span class="math display">\[
\theta=(\mu,\Sigma)=(\mu,\sigma^{2}),\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span><br>
一般地，高斯分布的概率密度函数PDF写为：</p>
<p><span class="math display">\[
p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}
\]</span><br>
带入 MLE 中我们考虑一维的情况</p>
<p><span class="math display">\[
\log p(X|\theta)=\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)=\sum\limits _{i=1}^{N}\log\frac{1}{\sqrt{2\pi}\sigma}\exp(-(x_{i}-\mu)^{2}/2\sigma^{2})
\]</span><br>
首先对 <span class="math inline">\(\mu\)</span> 的极值可以得到 ：<br>
<span class="math display">\[
\mu_{MLE}=\mathop{argmax}\limits _{\mu}\log p(X|\theta)=\mathop{argmax}\limits _{\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial}{\partial\mu}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}=0\longrightarrow\mu_{MLE}=\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}
\]</span><br>
其次对 <span class="math inline">\(\theta\)</span> 中的另一个参数 <span class="math inline">\(\sigma\)</span> ，有：<br>
<span class="math display">\[
\begin{align*}
\sigma_{MLE}=\mathop{argmax}\limits _{\sigma}\log p(X|\theta)&amp;=\mathop{argmax}\limits _{\sigma}\sum\limits _{i=1}^{N}[-\log\sigma-\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]\\
&amp;=\mathop{argmin}\limits _{\sigma}\sum\limits _{i=1}^{N}[\log\sigma+\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]
\end{align*}
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial}{\partial\sigma}\sum\limits _{i=1}^{N}[\log\sigma+\frac{1}{2\sigma^{2}}(x_{i}-\mu)^{2}]=0\longrightarrow\sigma_{MLE}^{2}=\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span><br>
值得注意的是，上面的推导中，首先对 <span class="math inline">\(\mu\)</span> 求 MLE， 然后利用这个结果求 <span class="math inline">\(\sigma_{MLE}\)</span> ，因此可以预期的是对数据集求期望时 <span class="math inline">\(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}]\)</span> 是无偏差的：<br>
<span class="math display">\[
\mathbb{E}_{\mathcal{D}}[\mu_{MLE}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\frac{1}{N}\sum\limits _{i=1}^{N}\mathbb{E}_{\mathcal{D}}[x_{i}]=\mu
\]</span><br>
但是当对 <span class="math inline">\(\sigma_{MLE}\)</span> 求 期望的时候由于使用了单个数据集的 <span class="math inline">\(\mu_{MLE}\)</span>，因此对所有数据集求期望的时候我们会发现 <span class="math inline">\(\sigma_{MLE}\)</span> 是 有偏的：</p>
<p><span class="math display">\[
\begin{align*}
\mathbb{E}_{\mathcal{D}}[\sigma_{MLE}^{2}]&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}-\mu_{MLE})^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}(x_{i}^{2}-2x_{i}\mu_{MLE}+\mu_{MLE}^{2})
\\&amp;=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu_{MLE}^{2}]=\mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}+\mu^{2}-\mu_{MLE}^{2}]\\
&amp;= \mathbb{E}_{\mathcal{D}}[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}^{2}-\mu^{2}]-\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}-\mu^{2}]=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mu^{2})r\\&amp;=\sigma^{2}-(\mathbb{E}_{\mathcal{D}}[\mu_{MLE}^{2}]-\mathbb{E}_{\mathcal{D}}^{2}[\mu_{MLE}])=\sigma^{2}-Var[\mu_{MLE}]\\&amp;=\sigma^{2}-Var[\frac{1}{N}\sum\limits _{i=1}^{N}x_{i}]=\sigma^{2}-\frac{1}{N^{2}}\sum\limits _{i=1}^{N}Var[x_{i}]=\frac{N-1}{N}\sigma^{2}
\end{align*}
\]</span><br>
所以：<br>
<span class="math display">\[
\hat{\sigma}^{2}=\frac{1}{N-1}\sum\limits _{i=1}^{N}(x_{i}-\mu)^{2}
\]</span></p>
<h3 id="多维情况">多维情况</h3>
<p>多维高斯分布表达式为：<br>
<span class="math display">\[
p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}
\]</span><br>
其中 <span class="math inline">\(x,\mu\in\mathbb{R}^{p},\Sigma\in\mathbb{R}^{p\times p}\)</span> ，<span class="math inline">\(\Sigma\)</span> 为协方差矩阵，一般而言也是半正定矩阵。这里我们只考虑正定矩阵。首先我们处理指数上的数字，指数上的数字可以记为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\mu\)</span> 之间的马氏距离。对于对称的协方差矩阵可进行特征值分解，<span class="math inline">\(\Sigma=U\Lambda U^{T}=(u_{1},u_{2},\cdots,u_{p})diag(\lambda_{i})(u_{1},u_{2},\cdots,u_{p})^{T}=\sum\limits _{i=1}^{p}u_{i}\lambda_{i}u_{i}^{T}\)</span> ，于是：</p>
<p><span class="math display">\[
\Sigma^{-1}=\sum\limits _{i=1}^{p}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}
\]</span></p>
<p><span class="math display">\[
\Delta=(x-\mu)^{T}\Sigma^{-1}(x-\mu)=\sum\limits _{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu)=\sum\limits _{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}}
\]</span></p>
<p>我们注意到 <span class="math inline">\(y_{i}\)</span> 是 <span class="math inline">\(x-\mu\)</span> 在特征向量 <span class="math inline">\(u_{i}\)</span> 上的投影长度，因此上式子就是 <span class="math inline">\(\Delta\)</span> 取不同值时的同心椭圆。</p>
<p>下面我们看多维高斯模型在实际应用时的两个问题</p>
<ol type="1">
<li><p>参数 <span class="math inline">\(\Sigma,\mu\)</span> 的自由度为 <span class="math inline">\(O(p^{2})\)</span> 对于维度很高的数据其自由度太高。解决方案：高自由度的来源是 <span class="math inline">\(\Sigma\)</span> 有 <span class="math inline">\(\frac{p(p+1)}{2}\)</span> 个自由参数，可以假设其是对角矩阵，甚至在各向同性假设中假设其对角线上的元素都相同。前一种的算法有 Factor Analysis，后一种有概率 PCA(p-PCA) 。</p></li>
<li><p>第二个问题是单个高斯分布是单峰的，对有多个峰的数据分布不能得到好的结果。解决方案：高斯混合GMM 模型。</p></li>
</ol>
<p>下面对多维高斯分布的常用定理进行介绍。</p>
<p>我们记 <span class="math inline">\(x=(x_1, x_2,\cdots,x_p)^T=(x_{a,m\times 1}, x_{b,n\times1})^T,\mu=(\mu_{a,m\times1}, \mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)</span>，已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma)\)</span>。</p>
<p>首先是一个高斯分布的定理：</p>
<blockquote>
<p>定理：已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma), y\sim Ax+b\)</span>，那么 <span class="math inline">\(y\sim\mathcal{N}(A\mu+b, A\Sigma A^T)\)</span>。</p>
<p>证明：<span class="math inline">\(\mathbb{E}[y]=\mathbb{E}[Ax+b]=A\mathbb{E}[x]+b=A\mu+b\)</span>，<span class="math inline">\(Var[y]=Var[Ax+b]=Var[Ax]=A\cdot Var[x]\cdot A^T\)</span>。</p>
</blockquote>
<p>下面利用这个定理得到 <span class="math inline">\(p(x_a),p(x_b),p(x_a|x_b),p(x_b|x_a)\)</span> 这四个量。</p>
<ol type="1">
<li><p><span class="math inline">\(x_a=\begin{pmatrix}\mathbb{I}_{m\times m}&amp;\mathbb{O}_{m\times n})\end{pmatrix}\begin{pmatrix}x_a\\x_b\end{pmatrix}\)</span>，代入定理中得到：<br>
<span class="math display">\[
\mathbb{E}[x_a]=\begin{pmatrix}\mathbb{I}&amp;\mathbb{O}\end{pmatrix}\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix}=\mu_a\\
Var[x_a]=\begin{pmatrix}\mathbb{I}&amp;\mathbb{O}\end{pmatrix}\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\begin{pmatrix}\mathbb{I}\\\mathbb{O}\end{pmatrix}=\Sigma_{aa}
\]</span><br>
所以 <span class="math inline">\(x_a\sim\mathcal{N}(\mu_a,\Sigma_{aa})\)</span>。</p></li>
<li><p>同样的，<span class="math inline">\(x_b\sim\mathcal{N}(\mu_b,\Sigma_{bb})\)</span>。</p></li>
<li><p>对于两个条件概率，我们引入三个量：<br>
<span class="math display">\[
\begin{gather*}
x_{b\cdot a}=x_b-\Sigma_{ba}\Sigma_{aa}^{-1}x_a\\
\mu_{b\cdot a}=\mu_b-\Sigma_{ba}\Sigma_{aa}^{-1}\mu_a\\
\Sigma_{bb\cdot a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{gather*}
\]</span><br>
特别的，最后一个式子叫做 <span class="math inline">\(\Sigma_{bb}\)</span> 的 Schur Complementary。可以看到：<br>
<span class="math display">\[
x_{b\cdot a}=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}x_a\\x_b\end{pmatrix}
\]</span><br>
所以：<br>
<span class="math display">\[
\begin{gather*}
\mathbb{E}[x_{b\cdot a}]=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix}=\mu_{b\cdot a}\\
Var[x_{b\cdot a}]=\begin{pmatrix}-\Sigma_{ba}\Sigma_{aa}^{-1}&amp;\mathbb{I}_{n\times n}\end{pmatrix}\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\begin{pmatrix}-\Sigma_{aa}^{-1}\Sigma_{ba}^T\\\mathbb{I}_{n\times n}\end{pmatrix}=\Sigma_{bb\cdot a}
\end{gather*}
\]</span><br>
利用这三个量可以得到 <span class="math inline">\(x_b=x_{b\cdot a}+\Sigma_{ba}\Sigma_{aa}^{-1}x_a\)</span>。因此：<br>
<span class="math display">\[
\begin{gather*}
\mathbb{E}[x_b|x_a]=\mu_{b\cdot a}+\Sigma_{ba}\Sigma_{aa}^{-1}x_a\\
Var[x_b|x_a]=\Sigma_{bb\cdot a}
\end{gather*}
\]</span></p>
<p>这里同样用到了定理。</p></li>
<li><p>同样：<br>
<span class="math display">\[
\begin{gather*}
x_{a\cdot b}=x_a-\Sigma_{ab}\Sigma_{bb}^{-1}x_b\\
\mu_{a\cdot b}=\mu_a-\Sigma_{ab}\Sigma_{bb}^{-1}\mu_b\\
\Sigma_{aa\cdot b}=\Sigma_{aa}-\Sigma_{ab}\Sigma_{bb}^{-1}\Sigma_{ba}
\end{gather*}
\]</span><br>
所以：<br>
<span class="math display">\[
\mathbb{E}[x_a|x_b]=\mu_{a\cdot b}+\Sigma_{ab}\Sigma_{bb}^{-1}x_b
\]</span></p>
<p><span class="math display">\[
Var[x_a|x_b]=\Sigma_{aa\cdot b}
\]</span></p></li>
</ol>
<p>下面利用上边四个量，求解线性模型：</p>
<blockquote>
<p>已知：<span class="math inline">\(p(x)=\mathcal{N}(\mu,\Lambda^{-1}),p(y|x)=\mathcal{N}(Ax+b,L^{-1})\)</span>，求解：<span class="math inline">\(p(y),p(x|y)\)</span>。</p>
<p>解：令 <span class="math inline">\(y=Ax+b+\epsilon,\epsilon\sim\mathcal{N}(0,L^{-1})\)</span>，所以 <span class="math inline">\(\mathbb{E}[y]=\mathbb{E}[Ax+b+\epsilon]=A\mu+b\)</span>，<span class="math inline">\(Var[y]=A \Lambda^{-1}A^T+L^{-1}\)</span>，因此：<br>
<span class="math display">\[
  p(y)=\mathcal{N}(A\mu+b,L^{-1}+A\Lambda^{-1}A^T)
  \]</span><br>
引入 <span class="math inline">\(z=\begin{pmatrix}x\\y\end{pmatrix}\)</span>，我们可以得到 <span class="math inline">\(Cov[x,y]=\mathbb{E}[(x-\mathbb{E}[x])(y-\mathbb{E}[y])^T]\)</span>。对于这个协方差可以直接计算：<br>
<span class="math display">\[
  \begin{align*}
  Cov(x,y)&amp;=\mathbb{E}[(x-\mu)(Ax-A\mu+\epsilon)^T]=\mathbb{E}[(x-\mu)(x-\mu)^TA^T]=Var[x]A^T=\Lambda^{-1}A^T
  \end{align*}
  \]</span><br>
注意到协方差矩阵的对称性，所以 <span class="math inline">\(p(z)=\mathcal{N}\begin{pmatrix}\mu\\A\mu+b\end{pmatrix},\begin{pmatrix}\Lambda^{-1}&amp;\Lambda^{-1}A^T\\A\Lambda^{-1}&amp;L^{-1}+A\Lambda^{-1}A^T\end{pmatrix})\)</span>。根据之前的公式，我们可以得到：<br>
<span class="math display">\[
  \mathbb{E}[x|y]=\mu+\Lambda^{-1}A^T(L^{-1}+A\Lambda^{-1}A^T)^{-1}(y-A\mu-b)
  \]</span></p>
<p><span class="math display">\[
  Var[x|y]=\Lambda^{-1}-\Lambda^{-1}A^T(L^{-1}+A\Lambda^{-1}A^T)^{-1}A\Lambda^{-1}
  \]</span></p>
</blockquote>
<h1 id="线性回归">线性回归</h1>
<p>假设数据集为：<br>
<span class="math display">\[
\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}
\]</span><br>
后面我们记：<br>
<span class="math display">\[
X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T
\]</span><br>
线性回归假设：<br>
<span class="math display">\[
f(w)=w^Tx
\]</span></p>
<h2 id="最小二乘法">最小二乘法</h2>
<p>对这个问题，采用二范数定义的平方误差来定义损失函数：<br>
<span class="math display">\[
L(w)=\sum\limits_{i=1}^N||w^Tx_i-y_i||^2_2
\]</span><br>
展开得到：<br>
<span class="math display">\[
\begin{align*}
L(w)&amp;=(w^Tx_1-y_1,\cdots,w^Tx_N-y_N)\cdot (w^Tx_1-y_1,\cdots,w^Tx_N-y_N)^T\\
&amp;=(w^TX^T-Y^T)\cdot (Xw-Y)=w^TX^TXw-Y^TXw-w^TX^TY+Y^TY\\
&amp;=w^TX^TXw-2w^TX^TY+Y^TY
\end{align*}
\]</span><br>
最小化这个值的 $ $ ：<br>
<span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmin}\limits_wL(w)&amp;\longrightarrow\frac{\partial}{\partial w}L(w)=0\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY=0\\
&amp;\longrightarrow \hat{w}=(X^TX)^{-1}X^TY=X^+Y
\end{align*}
\]</span><br>
这个式子中 <span class="math inline">\((X^TX)^{-1}X^T\)</span> 又被称为伪逆。对于行满秩或者列满秩的 <span class="math inline">\(X\)</span>，可以直接求解，但是对于非满秩的样本集合，需要使用奇异值分解（SVD）的方法，对 <span class="math inline">\(X\)</span> 求奇异值分解，得到<br>
<span class="math display">\[
X=U\Sigma V^T
\]</span><br>
于是：<br>
<span class="math display">\[
X^+=V\Sigma^{-1}U^T
\]</span><br>
在几何上，最小二乘法相当于模型（这里就是直线）和试验值的距离的平方求和，假设我们的试验样本张成一个 <span class="math inline">\(p\)</span> 维空间（满秩的情况）：<span class="math inline">\(X=Span(x_1,\cdots,x_N)\)</span>，而模型可以写成 <span class="math inline">\(f(w)=X\beta\)</span>，也就是 <span class="math inline">\(x_1,\cdots,x_N\)</span> 的某种组合，而最小二乘法就是说希望 <span class="math inline">\(Y\)</span> 和这个模型距离越小越好，于是它们的差应该与这个张成的空间垂直：<br>
<span class="math display">\[
X^T\cdot(Y-X\beta)=0\longrightarrow\beta=(X^TX)^{-1}X^TY
\]</span></p>
<h2 id="噪声为高斯分布的-mle">噪声为高斯分布的 MLE</h2>
<p>对于一维的情况，记 <span class="math inline">\(y=w^Tx+\epsilon,\epsilon\sim\mathcal{N}(0,\sigma^2)\)</span>，那么 <span class="math inline">\(y\sim\mathcal{N}(w^Tx,\sigma^2)\)</span>。代入极大似然估计中：<br>
<span class="math display">\[
\begin{align*}
L(w)=\log p(Y|X,w)&amp;=\log\prod\limits_{i=1}^Np(y_i|x_i,w)\\
&amp;=\sum\limits_{i=1}^N\log(\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(y_i-w^Tx_i)^2}{2\sigma^2}})\\
\mathop{argmax}\limits_wL(w)&amp;=\mathop{argmin}\limits_w\sum\limits_{i=1^N}(y_i-w^Tx_i)^2
\end{align*}
\]</span><br>
这个表达式和最小二乘估计得到的结果一样。</p>
<h2 id="权重先验也为高斯分布的-map">权重先验也为高斯分布的 MAP</h2>
<p>取先验分布 <span class="math inline">\(w\sim\mathcal{N}(0,\sigma_0^2)\)</span>。于是： <br>
<span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmax}\limits_wp(w|Y)&amp;=\mathop{argmax}\limits_wp(Y|w)p(w)\\
&amp;=\mathop{argmax}\limits_w\log p(Y|w)p(w)\\
&amp;=\mathop{argmax}\limits_w(\log p(Y|w)+\log p(w))\\
&amp;=\mathop{argmin}\limits_w[(y-w^Tx)^2+\frac{\sigma^2}{\sigma_0^2}w^Tw]
\end{align*}
\]</span><br>
这里省略了 <span class="math inline">\(X\)</span>，<span class="math inline">\(p(Y)\)</span>和 <span class="math inline">\(w\)</span> 没有关系，同时也利用了上面高斯分布的 MLE的结果。</p>
<p>我们将会看到，超参数 <span class="math inline">\(\sigma_0\)</span>的存在和下面会介绍的 Ridge 正则项可以对应，同样的如果将先验分布取为 Laplace 分布，那么就会得到和 L1 正则类似的结果。</p>
<h2 id="正则化">正则化</h2>
<p>在实际应用时，如果样本容量不远远大于样本的特征维度，很可能造成过拟合，对这种情况，我们有下面三个解决方式：</p>
<ol type="1">
<li>加数据</li>
<li>特征选择（降低特征维度）如 PCA 算法。</li>
<li>正则化</li>
</ol>
<p>正则化一般是在损失函数（如上面介绍的最小二乘损失）上加入正则化项（表示模型的复杂度对模型的惩罚），下面我们介绍一般情况下的两种正则化框架。<br>
<span class="math display">\[
\begin{align*}
L1&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||_1,\lambda\gt0\\
L2&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||^2_2,\lambda \gt 0
\end{align*}
\]</span><br>
下面对最小二乘误差分别分析这两者的区别。</p>
<h3 id="l1-lasso">L1 Lasso</h3>
<p>L1正则化可以引起稀疏解。</p>
<p>从最小化损失的角度看，由于 L1 项求导在0附近的左右导数都不是0，因此更容易取到0解。</p>
<p>从另一个方面看，L1 正则化相当于：<br>
<span class="math display">\[
\begin{gather*}
\mathop{argmin}\limits_wL(w)\\
s.t. ||w||_1\lt C
\end{gather*}
\]</span><br>
我们已经看到平方误差损失函数在 <span class="math inline">\(w\)</span> 空间是一个椭球，因此上式求解就是椭球和 <span class="math inline">\(||w||_1=C\)</span>的切点，因此更容易相切在坐标轴上。</p>
<h3 id="l2-ridge">L2 Ridge</h3>
<p><span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmin}\limits_wL(w)+\lambda w^Tw&amp;\longrightarrow\frac{\partial}{\partial w}L(w)+2\lambda w=0\\
&amp;\longrightarrow2X^TX\hat{w}-2X^TY+2\lambda \hat w=0\\
&amp;\longrightarrow \hat{w}=(X^TX+\lambda \mathbb{I})^{-1}X^TY
\end{align*}
\]</span></p>
<p>可以看到，这个正则化参数和前面的 MAP 结果不谋而合。利用2范数进行正则化不仅可以是模型选择 <span class="math inline">\(w\)</span> 较小的参数，同时也避免 $ X^TX$不可逆的问题。</p>
<h2 id="小结-1">小结</h2>
<p>线性回归模型是最简单的模型，但是麻雀虽小，五脏俱全，在这里，我们利用最小二乘误差得到了闭式解。同时也发现，在噪声为高斯分布的时候，MLE 的解等价于最小二乘误差，而增加了正则项后，最小二乘误差加上 L2 正则项等价于高斯噪声先验下的 MAP解，加上 L1 正则项后，等价于 Laplace 噪声先验。</p>
<p>传统的机器学习方法或多或少都有线性回归模型的影子：</p>
<ol type="1">
<li>线性模型往往不能很好地拟合数据，因此有三种方案克服这一劣势：
<ol type="1">
<li>对特征的维数进行变换，例如多项式回归模型就是在线性特征的基础上加入高次项。</li>
<li>在线性方程后面加入一个非线性变换，即引入一个非线性的激活函数，典型的有线性分类模型如感知机。</li>
<li>对于一致的线性系数，我们进行多次变换，这样同一个特征不仅仅被单个系数影响，例如多层感知机（深度前馈网络）。</li>
</ol></li>
<li>线性回归在整个样本空间都是线性的，我们修改这个限制，在不同区域引入不同的线性或非线性，例如线性样条回归和决策树模型。</li>
<li>线性回归中使用了所有的样本，但是对数据预先进行加工学习的效果可能更好（所谓的维数灾难，高维度数据更难学习），例如 PCA 算法和流形学习。</li>
</ol>
<h1 id="线性分类">线性分类</h1>
<p>对于分类任务，线性回归模型就无能为力了，但是我们可以在线性模型的函数进行后再加入一层激活函数，这个函数是非线性的，激活函数的反函数叫做链接函数。我们有两种线性分类的方式：</p>
<ol type="1">
<li>硬分类，我们直接需要输出观测对应的分类。这类模型的代表为：
<ol type="1">
<li>线性判别分析（Fisher 判别）</li>
<li>感知机</li>
</ol></li>
<li>软分类，产生不同类别的概率，这类算法根据概率方法的不同分为两种
<ol type="1">
<li>生成式（根据贝叶斯定理先计算参数后验，再进行推断）：高斯判别分析（GDA）和朴素贝叶斯等为代表
<ol type="1">
<li>GDA</li>
<li>Naive Bayes</li>
</ol></li>
<li>判别式（直接对条件概率进行建模）：Logistic 回归</li>
</ol></li>
</ol>
<h2 id="两分类-硬分类-感知机算法">两分类-硬分类-感知机算法</h2>
<p>我们选取激活函数为：<br>
<span class="math display">\[
sign(a)=\left\{\begin{matrix}+1,a\ge0\\-1,a\lt0\end{matrix}\right.
\]</span><br>
这样就可以将线性回归的结果映射到两分类的结果上了。</p>
<p>定义损失函数为错误分类的数目，比较直观的方式是使用指示函数，但是指示函数不可导，因此可以定义：<br>
<span class="math display">\[
L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i
\]</span><br>
其中，<span class="math inline">\(\mathcal{D}_{wrong}\)</span>是错误分类集合，实际在每一次训练的时候，我们采用梯度下降的算法。损失函数对 <span class="math inline">\(w\)</span> 的偏导为：<br>
<span class="math display">\[
\frac{\partial}{\partial w}L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_ix_i
\]</span><br>
但是如果样本非常多的情况下，计算复杂度较高，但是，实际上我们并不需要绝对的损失函数下降的方向，我们只需要损失函数的期望值下降，但是计算期望需要知道真实的概率分布，我们实际只能根据训练数据抽样来估算这个概率分布（经验风险）：<br>
<span class="math display">\[
\mathbb{E}_{\mathcal D}[\mathbb{E}_\hat{p}[\nabla_wL(w)]]=\mathbb{E}_{\mathcal D}[\frac{1}{N}\sum\limits_{i=1}^N\nabla_wL(w)]
\]</span><br>
我们知道， <span class="math inline">\(N\)</span> 越大，样本近似真实分布越准确，但是对于一个标准差为 <span class="math inline">\(\sigma\)</span> 的数据，可以确定的标准差仅和 <span class="math inline">\(\sqrt{N}\)</span> 成反比，而计算速度却和 <span class="math inline">\(N\)</span> 成正比。因此可以每次使用较少样本，则在数学期望的意义上损失降低的同时，有可以提高计算速度，如果每次只使用一个错误样本，我们有下面的更新策略（根据泰勒公式，在负方向）：<br>
<span class="math display">\[
w^{t+1}\leftarrow w^{t}+\lambda y_ix_i
\]</span><br>
是可以收敛的，同时使用单个观测更新也可以在一定程度上增加不确定度，从而减轻陷入局部最小的可能。在更大规模的数据上，常用的是小批量随机梯度下降法。</p>
<h2 id="两分类-硬分类-线性判别分析-lda">两分类-硬分类-线性判别分析 LDA</h2>
<p>在 LDA 中，我们的基本想法是选定一个方向，将试验样本顺着这个方向投影，投影后的数据需要满足两个条件，从而可以更好地分类：</p>
<ol type="1">
<li>相同类内部的试验样本距离接近。</li>
<li>不同类别之间的距离较大。</li>
</ol>
<p>首先是投影，我们假定原来的数据是向量 <span class="math inline">\(x\)</span>，那么顺着 $ w$ 方向的投影就是标量：<br>
<span class="math display">\[
z=w^T\cdot x(=|w|\cdot|x|\cos\theta)
\]</span><br>
对第一点，相同类内部的样本更为接近，我们假设属于两类的试验样本数量分别是 <span class="math inline">\(N_1\)</span>和 <span class="math inline">\(N_2\)</span>，那么我们采用方差矩阵来表征每一个类内的总体分布，这里我们使用了协方差的定义，用 <span class="math inline">\(S\)</span> 表示原数据的协方差：<br>
<span class="math display">\[
\begin{align*}
C_1:Var_z[C_1]&amp;=\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(z_i-\overline{z_{c1}})(z_i-\overline{z_{c1}})^T\\
&amp;=\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(w^Tx_i-\frac{1}{N_1}\sum\limits_{j=1}^{N_1}w^Tx_j)(w^Tx_i-\frac{1}{N_1}\sum\limits_{j=1}^{N_1}w^Tx_j)^T\\
&amp;=w^T\frac{1}{N_1}\sum\limits_{i=1}^{N_1}(x_i-\overline{x_{c1}})(x_i-\overline{x_{c1}})^Tw\\
&amp;=w^TS_1w\\
C_2:Var_z[C_2]&amp;=\frac{1}{N_2}\sum\limits_{i=1}^{N_2}(z_i-\overline{z_{c2}})(z_i-\overline{z_{c2}})^T\\
&amp;=w^TS_2w
\end{align*}
\]</span><br>
所以类内距离可以记为：<br>
<span class="math display">\[
\begin{align*}
Var_z[C_1]+Var_z[C_2]=w^T(S_1+S_2)w
\end{align*}
\]</span><br>
对于第二点，我们可以用两类的均值表示这个距离：<br>
<span class="math display">\[
\begin{align*}
(\overline{z_{c1}}-\overline{z_{c2}})^2&amp;=(\frac{1}{N_1}\sum\limits_{i=1}^{N_1}w^Tx_i-\frac{1}{N_2}\sum\limits_{i=1}^{N_2}w^Tx_i)^2\\
&amp;=(w^T(\overline{x_{c1}}-\overline{x_{c2}}))^2\\
&amp;=w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw
\end{align*}
\]</span><br>
综合这两点，由于协方差是一个矩阵，于是我们用将这两个值相除来得到我们的损失函数，并最大化这个值：<br>
<span class="math display">\[
\begin{align*}
\hat{w}=\mathop{argmax}\limits_wJ(w)&amp;=\mathop{argmax}\limits_w\frac{(\overline{z_{c1}}-\overline{z_{c2}})^2}{Var_z[C_1]+Var_z[C_2]}\\
&amp;=\mathop{argmax}\limits_w\frac{w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw}{w^T(S_1+S_2)w}\\
&amp;=\mathop{argmax}\limits_w\frac{w^TS_bw}{w^TS_ww}
\end{align*}
\]</span><br>
这样，我们就把损失函数和原数据集以及参数结合起来了。下面对这个损失函数求偏导，注意我们其实对 <span class="math inline">\(w\)</span> 的绝对值没有任何要求，只对方向有要求，因此只要一个方程就可以求解了：<br>
<span class="math display">\[
\begin{gather*}
\frac{\partial}{\partial w}J(w)=2S_bw(w^TS_ww)^{-1}-2w^TS_bw(w^TS_ww)^{-2}S_ww=0\\
\Longrightarrow S_bw(w^TS_ww)=(w^TS_bw)S_ww\\
\Longrightarrow w\propto S_w^{-1}S_bw=S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw\propto S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})
\end{gather*}
\]</span><br>
于是 $ S_w^{-1}(-)$ 就是我们需要寻找的方向。最后可以归一化求得单位的 <span class="math inline">\(w\)</span> 值。</p>
<h2 id="两分类-软分类-概率判别模型-logistic-回归">两分类-软分类-概率判别模型-Logistic 回归</h2>
<p>有时候我们只要得到一个类别的概率，那么我们需要一种能输出 <span class="math inline">\([0,1]\)</span> 区间的值的函数。考虑两分类模型，我们利用判别模型，希望对 <span class="math inline">\(p(C|x)\)</span> 建模，利用贝叶斯定理：<br>
<span class="math display">\[
p(C_1|x)=\frac{p(x|C_1)p(C_1)}{p(x|C_1)p(C_1)+p(x|C_2)p(C_2)}
\]</span><br>
取 <span class="math inline">\(a=\ln\frac{p(x|C_1)p(C_1)}{p(x|C_2)p(C_2)}\)</span>，于是：<br>
<span class="math display">\[
p(C_1|x)=\frac{1}{1+\exp(-a)}
\]</span><br>
上面的式子叫 Logistic Sigmoid 函数，其参数表示了两类联合概率比值的对数。在判别式中，不关心这个参数的具体值，模型假设直接对 <span class="math inline">\(a\)</span> 进行。</p>
<p>Logistic 回归的模型假设是：<br>
<span class="math display">\[
a=w^Tx
\]</span><br>
于是，通过寻找 $  w$ 的最佳值可以得到在这个模型假设下的最佳模型。概率判别模型常用最大似然估计的方式来确定参数。</p>
<p>对于一次观测，获得分类 <span class="math inline">\(y\)</span> 的概率为（假定<span class="math inline">\(C_1=1,C_2=0\)</span>）：<br>
<span class="math display">\[
p(y|x)=p_1^yp_0^{1-y}
\]</span></p>
<p>那么对于 <span class="math inline">\(N\)</span> 次独立全同的观测 MLE为：<br>
<span class="math display">\[
\hat{w}=\mathop{argmax}_wJ(w)=\mathop{argmax}_w\sum\limits_{i=1}^N(y_i\log p_1+(1-y_i)\log p_0)
\]</span><br>
注意到，这个表达式是交叉熵表达式的相反数乘 <span class="math inline">\(N\)</span>，MLE 中的对数也保证了可以和指数函数相匹配，从而在大的区间汇总获取稳定的梯度。</p>
<p>对这个函数求导数，注意到：<br>
<span class="math display">\[
p_1&#39;=(\frac{1}{1+\exp(-a)})&#39;=p_1(1-p_1)
\]</span><br>
则：<br>
<span class="math display">\[
J&#39;(w)=\sum\limits_{i=1}^Ny_i(1-p_1)x_i-p_1x_i+y_ip_1x_i=\sum\limits_{i=1}^N(y_i-p_1)x_i
\]</span><br>
由于概率值的非线性，放在求和符号中时，这个式子无法直接求解。于是在实际训练的时候，和感知机类似，也可以使用不同大小的批量随机梯度上升（对于最小化就是梯度下降）来获得这个函数的极大值。</p>
<h2 id="两分类-软分类-概率生成模型-高斯判别分析-gda">两分类-软分类-概率生成模型-高斯判别分析 GDA</h2>
<p>生成模型中，我们对联合概率分布进行建模，然后采用 MAP 来获得参数的最佳值。两分类的情况，我们采用的假设：</p>
<ol type="1">
<li><span class="math inline">\(y\sim Bernoulli(\phi)\)</span></li>
<li><span class="math inline">\(x|y=1\sim\mathcal{N}(\mu_1,\Sigma)\)</span></li>
<li><span class="math inline">\(x|y=0\sim\mathcal{N}(\mu_0,\Sigma)\)</span></li>
</ol>
<p>那么独立全同的数据集最大后验概率可以表示为：<br>
<span class="math display">\[
\begin{align*}
\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N (\log p(x_i|y_i)+\log p(y_i))\\
=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log \mathcal{N}(\mu_1,\Sigma)+y_i\log\phi+(1-y_i)\log(1-\phi))
\end{align*}
\]</span></p>
<ul>
<li><p>首先对 <span class="math inline">\(\phi\)</span> 进行求解，将式子对 <span class="math inline">\(\phi\)</span> 求偏导：<br>
<span class="math display">\[
\begin{align*}\sum\limits_{i=1}^N\frac{y_i}{\phi}+\frac{y_i-1}{1-\phi}=0\\
\Longrightarrow\phi=\frac{\sum\limits_{i=1}^Ny_i}{N}=\frac{N_1}{N}
\end{align*}
\]</span></p></li>
<li><p>然后求解 <span class="math inline">\(\mu_1\)</span>：<br>
<span class="math display">\[
\begin{align*}\hat{\mu_1}&amp;=\mathop{argmax}_{\mu_1}\sum\limits_{i=1}^Ny_i\log\mathcal{N}(\mu_1,\Sigma)\\
&amp;=\mathop{argmin}_{\mu_1}\sum\limits_{i=1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)
\end{align*}
\]</span><br>
由于：<br>
<span class="math display">\[
\sum\limits_{i=1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)=\sum\limits_{i=1}^Ny_ix_i^T\Sigma^{-1}x_i-2y_i\mu_1^T\Sigma^{-1}x_i+y_i\mu_1^T\Sigma^{-1}\mu_1
\]</span></p>
<p>求微分左边乘以 <span class="math inline">\(\Sigma\)</span> 可以得到：<br>
<span class="math display">\[
\begin{align*}\sum\limits_{i=1}^N-2y_i\Sigma^{-1}x_i+2y_i\Sigma^{-1}\mu_1=0\\
\Longrightarrow\mu_1=\frac{\sum\limits_{i=1}^Ny_ix_i}{\sum\limits_{i=1}^Ny_i}=\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1}
\end{align*}
\]</span></p></li>
<li><p>求解 <span class="math inline">\(\mu_0\)</span>，由于正反例是对称的，所以：<br>
<span class="math display">\[
\mu_0=\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0}
\]</span></p></li>
<li><p>最为困难的是求解 <span class="math inline">\(\Sigma\)</span>，我们的模型假设对正反例采用相同的协方差矩阵，当然从上面的求解中我们可以看到，即使采用不同的矩阵也不会影响之前的三个参数。首先我们有：<br>
<span class="math display">\[
\begin{align*}
\sum\limits_{i=1}^N\log\mathcal{N}(\mu,\Sigma)&amp;=\sum\limits_{i=1}^N\log(\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}})+(-\frac{1}{2}(x_i-\mu)^T\Sigma^{-1}(x_i-\mu))\\
&amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}Trace((x_i-\mu)^T\Sigma^{-1}(x_i-\mu))\\
&amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}Trace((x_i-\mu)(x_i-\mu)^T\Sigma^{-1})\\
&amp;=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}NTrace(S\Sigma^{-1})
\end{align*}
\]</span><br>
在这个表达式中，我们在标量上加入迹从而可以交换矩阵的顺序，对于包含绝对值和迹的表达式的导数，我们有：<br>
<span class="math display">\[
\begin{align*}
\frac{\partial}{\partial A}(|A|)&amp;=|A|A^{-1}\\
\frac{\partial}{\partial A}Trace(AB)&amp;=B^T
\end{align*}
\]</span><br>
因此：<br>
<span class="math display">\[
\begin{align*}[\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log \mathcal{N}(\mu_1,\Sigma)]&#39;
\\=Const-\frac{1}{2}N\log|\Sigma|-\frac{1}{2}N_1Trace(S_1\Sigma^{-1})-\frac{1}{2}N_2Trace(S_2\Sigma^{-1})
\end{align*}
\]</span><br>
其中，<span class="math inline">\(S_1,S_2\)</span> 分别为两个类数据内部的协方差矩阵，于是：<br>
<span class="math display">\[
\begin{align*}N\Sigma^{-1}-N_1S_1^T\Sigma^{-2}-N_2S_2^T\Sigma^{-2}=0
\\\Longrightarrow\Sigma=\frac{N_1S_1+N_2S_2}{N}
\end{align*}
\]</span><br>
这里应用了类协方差矩阵的对称性。</p></li>
</ul>
<p>于是我们就利用最大后验的方法求得了我们模型假设里面的所有参数，根据模型，可以得到联合分布，也就可以得到用于推断的条件分布了。</p>
<h2 id="两分类-软分类-概率生成模型-朴素贝叶斯">两分类-软分类-概率生成模型-朴素贝叶斯</h2>
<p>上面的高斯判别分析的是对数据集的分布作出了高斯分布的假设，同时引入伯努利分布作为类先验，从而利用最大后验求得这些假设中的参数。</p>
<p>朴素贝叶斯队数据的属性之间的关系作出了假设，一般地，我们有需要得到 <span class="math inline">\(p(x|y)\)</span> 这个概率值，由于 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(p\)</span> 个维度，因此需要对这么多的维度的联合概率进行采样，但是我们知道这么高维度的空间中采样需要的样本数量非常大才能获得较为准确的概率近似。</p>
<p>在一般的有向概率图模型中，对各个属性维度之间的条件独立关系作出了不同的假设，其中最为简单的一个假设就是在朴素贝叶斯模型描述中的条件独立性假设。<br>
<span class="math display">\[
p(x|y)=\prod\limits_{i=1}^pp(x_i|y)
\]</span><br>
即：<br>
<span class="math display">\[
x_i\perp x_j|y,\forall\  i\ne j
\]</span><br>
于是利用贝叶斯定理，对于单次观测：<br>
<span class="math display">\[
p(y|x)=\frac{p(x|y)p(y)}{p(x)}=\frac{\prod\limits_{i=1}^pp(x_i|y)p(y)}{p(x)}
\]</span><br>
对于单个维度的条件概率以及类先验作出进一步的假设：</p>
<ol type="1">
<li><span class="math inline">\(x_i\)</span> 为连续变量：<span class="math inline">\(p(x_i|y)=\mathcal{N}(\mu_i,\sigma_i^2)\)</span></li>
<li><span class="math inline">\(x_i\)</span> 为离散变量：类别分布（Categorical）：<span class="math inline">\(p(x_i=i|y)=\theta_i,\sum\limits_{i=1}^K\theta_i=1\)</span></li>
<li><span class="math inline">\(p(y)=\phi^y(1-\phi)^{1-y}\)</span></li>
</ol>
<p>对这些参数的估计，常用 MLE 的方法直接在数据集上估计，由于不需要知道各个维度之间的关系，因此，所需数据量大大减少了。估算完这些参数，再代入贝叶斯定理中得到类别的后验分布。</p>
<h2 id="小结-2">小结</h2>
<p>分类任务分为两类，对于需要直接输出类别的任务，感知机算法中我们在线性模型的基础上加入符号函数作为激活函数，那么就能得到这个类别，但是符号函数不光滑，于是我们采用错误驱动的方式，引入 <span class="math inline">\(\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i\)</span> 作为损失函数，然后最小化这个误差，采用批量随机梯度下降的方法来获取最佳的参数值。而在线性判别分析中，我们将线性模型看作是数据点在某一个方向的投影，采用类内小，类间大的思路来定义损失函数，其中类内小定义为两类数据的方差之和，类间大定义为两类数据中心点的间距，对损失函数求导得到参数的方向，这个方向就是 <span class="math inline">\(S_w^{-1}(\overline x_{c1}-\overline x_{c2})\)</span>，其中 <span class="math inline">\(S_w\)</span> 为原数据集两类的方差之和。</p>
<p>另一种任务是输出分类的概率，对于概率模型，我们有两种方案，第一种是判别模型，也就是直接对类别的条件概率建模，将线性模型套入 Logistic 函数中，我们就得到了 Logistic 回归模型，这里的概率解释是两类的联合概率比值的对数是线性的，我们定义的损失函数是交叉熵（等价于 MLE），对这个函数求导得到 <span class="math inline">\(\frac{1}{N}\sum\limits_{i=1}^N(y_i-p_1)x_i\)</span>，同样利用批量随机梯度（上升）的方法进行优化。第二种是生成模型，生成模型引入了类别的先验，在高斯判别分析中，我们对数据集的数据分布作出了假设，其中类先验是二项分布，而每一类的似然是高斯分布，对这个联合分布的对数似然进行最大化就得到了参数， <span class="math inline">\(\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1},\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0},\frac{N_1S_1+N_2S_2}{N},\frac{N_1}{N}\)</span>。在朴素贝叶斯中，我们进一步对属性的各个维度之间的依赖关系作出假设，条件独立性假设大大减少了数据量的需求。</p>
<h1 id="降维">降维</h1>
<p>我们知道，解决过拟合的问题除了正则化和添加数据之外，降维就是最好的方法。降维的思路来源于维度灾难的问题，我们知道 <span class="math inline">\(n\)</span> 维球的体积为：<br>
<span class="math display">\[
CR^n
\]</span><br>
那么在球体积与边长为 <span class="math inline">\(2R\)</span> 的超立方体比值为：<br>
<span class="math display">\[
\lim\limits_{n\rightarrow0}\frac{CR^n}{2^nR^n}=0
\]</span></p>
<p>这就是所谓的维度灾难，在高维数据中，主要样本都分布在立方体的边缘，所以数据集更加稀疏。</p>
<p>降维的算法分为：</p>
<ol type="1">
<li>直接降维，特征选择</li>
<li>线性降维，PCA，MDS等</li>
<li>分线性，流形包括 Isomap，LLE 等</li>
</ol>
<p>为了方便，我们首先将协方差矩阵（数据集）写成中心化的形式：<br>
<span class="math display">\[
\begin{align*}S&amp;=\frac{1}{N}\sum\limits_{i=1}^N(x_i-\overline{x})(x_i-\overline{x})^T\\
&amp;=\frac{1}{N}(x_1-\overline{x},x_2-\overline{x},\cdots,x_N-\overline{x})(x_1-\overline{x},x_2-\overline{x},\cdots,x_N-\overline{x})^T\\
&amp;=\frac{1}{N}(X^T-\frac{1}{N}X^T\mathbb{I}_{N1}\mathbb{I}_{N1}^T)(X^T-\frac{1}{N}X^T\mathbb{I}_{N1}\mathbb{I}_{N1}^T)^T\\
&amp;=\frac{1}{N}X^T(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})^TX\\
&amp;=\frac{1}{N}X^TH_NH_N^TX\\
&amp;=\frac{1}{N}X^TH_NH_NX=\frac{1}{N}X^THX
\end{align*}
\]</span><br>
这个式子利用了中心矩阵 $ H$的对称性，这也是一个投影矩阵。</p>
<h2 id="线性降维-主成分分析-pca">线性降维-主成分分析 PCA</h2>
<h3 id="损失函数">损失函数</h3>
<p>主成分分析中，我们的基本想法是将所有数据投影到一个字空间中，从而达到降维的目标，为了寻找这个子空间，我们基本想法是：</p>
<ol type="1">
<li>所有数据在子空间中更为分散</li>
<li>损失的信息最小，即：在补空间的分量少</li>
</ol>
<p>原来的数据很有可能各个维度之间是相关的，于是我们希望找到一组 <span class="math inline">\(p\)</span> 个新的线性无关的单位基 <span class="math inline">\(u_i\)</span>，降维就是取其中的 <span class="math inline">\(q\)</span> 个基。于是对于一个样本 <span class="math inline">\(x_i\)</span>，经过这个坐标变换后：<br>
<span class="math display">\[
\hat{x_i}=\sum\limits_{i=1}^p(u_i^Tx_i)u_i=\sum\limits_{i=1}^q(u_i^Tx_i)u_i+\sum\limits_{i=q+1}^p(u_i^Tx_i)u_i
\]</span><br>
对于数据集来说，我们首先将其中心化然后再去上面的式子的第一项，并使用其系数的平方平均作为损失函数并最大化：<br>
<span class="math display">\[
\begin{align*}J&amp;=\frac{1}{N}\sum\limits_{i=1}^N\sum\limits_{j=1}^q((x_i-\overline{x})^Tu_j)^2\\
&amp;=\sum\limits_{j=1}^qu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align*}
\]</span><br>
由于每个基都是线性无关的，于是每一个 <span class="math inline">\(u_j\)</span> 的求解可以分别进行，使用拉格朗日乘子法：<br>
<span class="math display">\[
\mathop{argmax}_{u_j}L(u_j,\lambda)=\mathop{argmax}_{u_j}u_j^TSu_j+\lambda(1-u_j^Tu_j)
\]</span><br>
于是：<br>
<span class="math display">\[
Su_j=\lambda u_j
\]</span><br>
可见，我们需要的基就是协方差矩阵的本征矢。损失函数最大取在本征值前 <span class="math inline">\(q\)</span> 个最大值。</p>
<p>下面看其损失的信息最少这个条件，同样适用系数的平方平均作为损失函数，并最小化：<br>
<span class="math display">\[
\begin{align*}J&amp;=\frac{1}{N}\sum\limits_{i=1}^N\sum\limits_{j=q+1}^p((x_i-\overline{x})^Tu_j)^2\\
&amp;=\sum\limits_{j=q+1}^pu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align*}
\]</span><br>
同样的：<br>
<span class="math display">\[
\mathop{argmin}_{u_j}L(u_j,\lambda)=\mathop{argmin}_{u_j}u_j^TSu_j+\lambda(1-u_j^Tu_j)
\]</span><br>
损失函数最小取在本征值剩下的个最小的几个值。数据集的协方差矩阵可以写成 <span class="math inline">\(S=U\Lambda U^T\)</span>，直接对这个表达式当然可以得到本征矢。</p>
<h3 id="svd-与-pcoa">SVD 与 PCoA</h3>
<p>下面使用实际训练时常常使用的 SVD 直接求得这个 <span class="math inline">\(q\)</span> 个本征矢。</p>
<p>对中心化后的数据集进行奇异值分解：<br>
<span class="math display">\[
HX=U\Sigma V^T,U^TU=E_N,V^TV=E_p,\Sigma:N\times p
\]</span></p>
<p>于是：<br>
<span class="math display">\[
S=\frac{1}{N}X^THX=\frac{1}{N}X^TH^THX=\frac{1}{N}V\Sigma^T\Sigma V^T
\]</span><br>
因此，我们直接对中心化后的数据集进行 SVD，就可以得到特征值和特征向量 <span class="math inline">\(V\)</span>，在新坐标系中的坐标就是：<br>
<span class="math display">\[
HX\cdot V
\]</span><br>
由上面的推导，我们也可以得到另一种方法 PCoA 主坐标分析，定义并进行特征值分解：<br>
<span class="math display">\[
T=HXX^TH=U\Sigma\Sigma^TU^T
\]</span><br>
由于：<br>
<span class="math display">\[
TU\Sigma=U\Sigma(\Sigma^T\Sigma)
\]</span><br>
于是可以直接得到坐标。这两种方法都可以得到主成分，但是由于方差矩阵是 <span class="math inline">\(p\times p\)</span> 的，而 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(N\times N\)</span> 的，所以对样本量较少的时候可以采用 PCoA的方法。</p>
<h3 id="p-pca">p-PCA</h3>
<p>下面从概率的角度对 PCA 进行分析，概率方法也叫 p-PCA。我们使用线性模型，类似之前 LDA，我们选定一个方向，对原数据 <span class="math inline">\(x\in\mathbb{R}^p\)</span> ，降维后的数据为 <span class="math inline">\(z\in\mathbb{R}^q,q&lt;p\)</span>。降维通过一个矩阵变换（投影）进行：<br>
<span class="math display">\[
\begin{align*}
z&amp;\sim\mathcal{N}(\mathbb{O}_{q1},\mathbb{I}_{qq})\\
x&amp;=Wz+\mu+\varepsilon\\
\varepsilon&amp;\sim\mathcal{N}(0,\sigma^2\mathbb{I}_{pp})
\end{align*}
\]</span><br>
对于这个模型，我么可以使用期望-最大（EM）的算法进行学习，在进行推断的时候需要求得 <span class="math inline">\(p(z|x)\)</span>，推断的求解过程和线性高斯模型类似。<br>
<span class="math display">\[
\begin{align*}
&amp;p(z|x)=\frac{p(x|z)p(z)}{p(x)}\\
&amp;\mathbb{E}[x]=\mathbb{E}[Wz+\mu+\varepsilon]=\mu\\
&amp;Var[x]=WW^T+\sigma^2\mathbb{I}_{pp}\\
\Longrightarrow p(z|x)=\mathcal{N}(W^T(WW^T+&amp;\sigma^2\mathbb{I})^{-1}(x-\mu),\mathbb{I}-W^T(WW^T+\sigma^2\mathbb{I})^{-1}W)
\end{align*}
\]</span></p>
<h2 id="小结-3">小结</h2>
<p>降维是解决维度灾难和过拟合的重要方法，除了直接的特征选择外，我们还可以采用算法的途径对特征进行筛选，线性的降维方法以 PCA 为代表，在 PCA 中，我们只要直接对数据矩阵进行中心化然后求奇异值分解或者对数据的协方差矩阵进行分解就可以得到其主要维度。非线性学习的方法如流形学习将投影面从平面改为超曲面。</p>
<h1 id="支撑向量机">支撑向量机</h1>
<p>支撑向量机（SVM）算法在分类问题中有着重要地位，其主要思想是最大化两类之间的间隔。按照数据集的特点：</p>
<ol type="1">
<li>线性可分问题，如之前的感知机算法处理的问题</li>
<li>线性可分，只有一点点错误点，如感知机算法发展出来的 Pocket 算法处理的问题</li>
<li>非线性问题，完全不可分，如在感知机问题发展出来的多层感知机和深度学习</li>
</ol>
<p>这三种情况对于 SVM 分别有下面三种处理手段：</p>
<ol type="1">
<li>hard-margin SVM</li>
<li>soft-margin SVM</li>
<li>kernel Method</li>
</ol>
<p>SVM 的求解中，大量用到了 Lagrange 乘子法，首先对这种方法进行介绍。</p>
<h2 id="约束优化问题">约束优化问题</h2>
<p>一般地，约束优化问题（原问题）可以写成：</p>
<p><span class="math display">\[
\begin{align*}
&amp;\min_{x\in\mathbb{R^p}}f(x)\\
&amp;s.t.\ m_i(x)\le0,i=1,2,\cdots,M\\
&amp;\ \ \ \ \ \ \ \ n_j(x)=0,j=1,2,\cdots,N
\end{align*}
\]</span></p>
<p>定义 Lagrange 函数：</p>
<p><span class="math display">\[
L(x,\lambda,\eta)=f(x)+\sum\limits_{i=1}^M\lambda_im_i(x)+\sum\limits_{i=1}^N\eta_in_i(x)
\]</span></p>
<p>那么原问题可以等价于无约束形式：</p>
<p><span class="math display">\[
\min_{x\in\mathbb{R}^p}\max_{\lambda,\eta}L(x,\lambda,\eta)\ s.t.\ \lambda_i\ge0
\]</span></p>
<p>这是由于，当满足原问题的不等式约束的时候，<span class="math inline">\(\lambda_i=0\)</span> 才能取得最大值，直接等价于原问题，如果不满足原问题的不等式约束，那么最大值就为 <span class="math inline">\(+\infty\)</span> ，由于需要取最小值，于是不会取到这个情况。</p>
<p>这个问题的对偶形式：</p>
<p><span class="math display">\[
\max_{\lambda,\eta}\min_{x\in\mathbb{R}^p}L(x,\lambda,\eta)\ s.t.\ \lambda_i\ge0
\]</span></p>
<p>对偶问题是关于 $ , $ 的最大化问题。</p>
<p>由于：<br>
<span class="math display">\[
\max_{\lambda_i,\eta_j}\min_{x}L(x,\lambda_i,\eta_j)\le\min_{x}\max_{\lambda_i,\eta_j}L(x,\lambda_i,\eta_j)
\]</span></p>
<blockquote>
<p>证明：显然有 <span class="math inline">\(\min\limits_{x}L\le L\le\max\limits_{\lambda,\eta}L\)</span>，于是显然有 <span class="math inline">\(\max\limits_{\lambda,\eta}\min\limits_{x}L\le L\)</span>，且 <span class="math inline">\(\min\limits_{x}\max\limits_{\lambda,\eta}L\ge L\)</span>。</p>
</blockquote>
<p>对偶问题的解小于原问题，有两种情况：</p>
<ol type="1">
<li>强对偶：可以取等于号</li>
<li>弱对偶：不可以取等于号</li>
</ol>
<p>其实这一点也可以通过一张图来说明：</p>
<p><img src="/2022/07/05/ML-Theory-Summary/originVSdual.webp" alt="originVsdual"></p>
<p>对于一个凸优化问题，有如下定理：</p>
<blockquote>
<p>如果凸优化问题满足某些条件如 Slater 条件，那么它和其对偶问题满足强对偶关系。记问题的定义域为：<span class="math inline">\(\mathcal{D}=domf(x)\cap dom m_i(x)\cap domn_j(x)\)</span>。于是 Slater 条件为：<br>
<span class="math display">\[
  \exists \hat{x}\in Relint\mathcal{D}\ s.t.\ \forall i=1,2,\cdots,M,m_i(x)\lt0
  \]</span><br>
其中 Relint 表示相对内部（不包含边界的内部）。</p>
</blockquote>
<ol type="1">
<li>对于大多数凸优化问题，Slater 条件成立。</li>
<li>松弛 Slater 条件，如果 M 个不等式约束中，有 K 个函数为仿射函数，那么只要其余的函数满足 Slater 条件即可。</li>
</ol>
<p>上面介绍了原问题和对偶问题的对偶关系，但是实际还需要对参数进行求解，求解方法使用 KKT 条件进行：</p>
<blockquote>
<p>KKT 条件和强对偶关系是等价关系。KKT 条件对最优解的条件为：</p>
<ol type="1">
<li><p>可行域：<br>
<span class="math display">\[
\begin{align*}
m_i(x^*)\le0\\
n_j(x^*)=0\\
\lambda^*\ge0
\end{align*}
\]</span></p></li>
<li><p>互补松弛 <span class="math inline">\(\lambda^*m_i(x^*)=0,\forall m_i\)</span>，对偶问题的最佳值为 <span class="math inline">\(d^*\)</span>，原问题为 <span class="math inline">\(p^*\)</span><br>
<span class="math display">\[
\begin{align*}
d^*&amp;=\max_{\lambda,\eta}g(\lambda,\eta)=g(\lambda^*,\eta^*)\\
&amp;=\min_{x}L(x,\lambda^*,\eta^*)\\
&amp;\le L(x^*,\lambda^*,\eta^*)\\
&amp;=f(x^*)+\sum\limits_{i=1}^M\lambda^*m_i(x^*)\\
&amp;\le f(x^*)=p^*
\end{align*}
\]</span><br>
为了满足相等，两个不等式必须成立，于是，对于第一个不等于号，需要有梯度为0条件，对于第二个不等于号需要满足互补松弛条件。</p></li>
<li><p>梯度为0：<span class="math inline">\(\frac{\partial L(x,\lambda^*,\eta^*)}{\partial x}|_{x=x^*}=0\)</span></p></li>
</ol>
</blockquote>
<h2 id="hard-margin-svm">Hard-margin SVM</h2>
<p>支撑向量机也是一种硬分类模型，在之前的感知机模型中，我们在线性模型的基础上叠加了符号函数，在几何直观上，可以看到，如果两类分的很开的话，那么其实会存在无穷多条线可以将两类分开。在 SVM 中，我们引入最大化间隔这个概念，间隔指的是数据和直线的距离的最小值，因此最大化这个值反映了我们的模型倾向。</p>
<p>分割的超平面可以写为：<br>
<span class="math display">\[
0=w^Tx+b
\]</span><br>
那么最大化间隔（约束为分类任务的要求）：<br>
<span class="math display">\[
\begin{align*}
\mathop{argmax}_{w,b}[\min_i\frac{|w^Tx_i+b|}{||w||}]\ s.t.\ y_i(w^Tx_i+b)&gt;0\\
\Longrightarrow\mathop{argmax}_{w,b}[\min_i\frac{y_i(w^Tx_i+b)}{||w||}]\ s.t.\ y_i(w^Tx_i+b)&gt;0
\end{align*}
\]</span><br>
对于这个约束 <span class="math inline">\(y_i(w^Tx_i+b)&gt;0\)</span>，不妨固定 <span class="math inline">\(\min y_i(w^Tx_i+b)=1&gt;0\)</span>，这是由于分开两类的超平面的系数经过比例放缩不会改变这个平面，这也相当于给超平面的系数作出了约束。化简后的式子可以表示为：</p>
<p><span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw \ s.t.\ \min_iy_i(w^Tx_i+b)=1 
\]</span><br>
<span class="math display">\[
\Rightarrow\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\ y_i(w^Tx_i+b)\ge1,i=1,2,\cdots,N
\]</span></p>
<p>这就是一个包含 <span class="math inline">\(N\)</span> 个约束的凸优化问题，有很多求解这种问题的软件。</p>
<p>但是，如果样本数量或维度非常高，直接求解困难甚至不可解，于是需要对这个问题进一步处理。引入 Lagrange 函数：<br>
<span class="math display">\[
L(w,b,\lambda)=\frac{1}{2}w^Tw+\sum\limits_{i=1}^N\lambda_i(1-y_i(w^Tx_i+b))
\]</span><br>
我们有原问题就等价于：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\max_{\lambda}L(w,b,\lambda_i)\ s.t.\ \lambda_i\ge0
\]</span><br>
我们交换最小和最大值的符号得到对偶问题：<br>
<span class="math display">\[
\max_{\lambda_i}\min_{w,b}L(w,b,\lambda_i)\ s.t.\ \lambda_i\ge0
\]</span><br>
由于不等式约束是仿射函数，对偶问题和原问题等价：</p>
<ul>
<li><p><span class="math inline">\(b\)</span>：<span class="math inline">\(\frac{\partial}{\partial b}L=0\Rightarrow\sum\limits_{i=1}^N\lambda_iy_i=0\)</span></p></li>
<li><p><span class="math inline">\(w\)</span>：首先将 <span class="math inline">\(b\)</span> 代入：<br>
<span class="math display">\[
L(w,b,\lambda_i)=\frac{1}{2}w^Tw+\sum\limits_{i=1}^N\lambda_i(1-y_iw^Tx_i-y_ib)=\frac{1}{2}w^Tw+\sum\limits_{i=1}^N\lambda_i-\sum\limits_{i=1}^N\lambda_iy_iw^Tx_i
\]</span><br>
所以：<br>
<span class="math display">\[
\frac{\partial}{\partial w}L=0\Rightarrow w=\sum\limits_{i=1}^N\lambda_iy_ix_i
\]</span></p></li>
<li><p>将上面两个参数代入：<br>
<span class="math display">\[
L(w,b,\lambda_i)=-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i
\]</span></p></li>
</ul>
<p>因此，对偶问题就是：<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span><br>
从 KKT 条件得到超平面的参数：</p>
<blockquote>
<p>原问题和对偶问题满足强对偶关系的充要条件为其满足 KKT 条件：<br>
<span class="math display">\[
  \begin{align*}
  &amp;\frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0
  \\&amp;\lambda_k(1-y_k(w^Tx_k+b))=0(slackness\ complementary)\\
  &amp;\lambda_i\ge0\\
  &amp;1-y_i(w^Tx_i+b)\le0
  \end{align*}
  \]</span></p>
</blockquote>
<p>根据这个条件就得到了对应的最佳参数：<br>
<span class="math display">\[
\begin{gather*}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)=0
\end{gather*}
\]</span><br>
于是这个超平面的参数 <span class="math inline">\(w\)</span> 就是数据点的线性组合，最终的参数值就是部分满足 <span class="math inline">\(y_i(w^Tx_i+b)=1\)</span>向量的线性组合（互补松弛条件给出），这些向量也叫支撑向量。</p>
<h2 id="soft-margin-svm">Soft-margin SVM</h2>
<p>Hard-margin 的 SVM 只对可分数据可解，如果不可分的情况，我们的基本想法是在损失函数中加入错误分类的可能性。错误分类的个数可以写成：<br>
<span class="math display">\[
error=\sum\limits_{i=1}^N\mathbb{I}\{y_i(w^Tx_i+b)\lt1\}
\]</span><br>
这个函数不连续，可以将其改写为：<br>
<span class="math display">\[
error=\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}
\]</span><br>
求和符号中的式子又叫做 Hinge Function。</p>
<p>将这个错误加入 Hard-margin SVM 中，于是：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,i=1,2,\cdots,N
\]</span><br>
这个式子中，常数 <span class="math inline">\(C\)</span> 可以看作允许的错误水平，同时上式为了进一步消除 <span class="math inline">\(\max\)</span> 符号，对数据集中的每一个观测，我们可以认为其大部分满足约束，但是其中部分违反约束，因此这部分约束变成 <span class="math inline">\(y_i(w^Tx+b)\ge1-\xi_i\)</span>，其中 <span class="math inline">\(\xi_i=1-y_i(w^Tx_i+b)\)</span>，进一步的化简：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\]</span></p>
<h2 id="kernel-method">Kernel Method</h2>
<p>核方法可以应用在很多问题上，在分类问题中，对于严格不可分问题，我们引入一个特征转换函数将原来的不可分的数据集变为可分的数据集，然后再来应用已有的模型。往往将低维空间的数据集变为高维空间的数据集后，数据会变得可分（数据变得更为稀疏）：</p>
<blockquote>
<p>Cover TH：高维空间比低维空间更易线性可分。</p>
</blockquote>
<p>应用在 SVM 中时，观察上面的 SVM 对偶问题：<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span><br>
在求解的时候需要求得内积，于是不可分数据在通过特征变换后，需要求得变换后的内积。我们常常很难求得变换函数的内积。于是直接引入内积的变换函数：<br>
<span class="math display">\[
\forall x,x&#39;\in\mathcal{X},\exists\phi\in\mathcal{H}:x\rightarrow z\ s.t.\ k(x,x&#39;)=\phi(x)^T\phi(x)
\]</span><br>
称 <span class="math inline">\(k(x,x&#39;)\)</span> 为一个正定核函数，其中<span class="math inline">\(\mathcal{H}\)</span> 是 Hilbert 空间（完备的线性内积空间），如果去掉内积这个条件我们简单地称为核函数。</p>
<blockquote>
<p><span class="math inline">\(k(x,x&#39;)=\exp(-\frac{(x-x&#39;)^2}{2\sigma^2})\)</span> 是一个核函数。</p>
<p>证明：<br>
<span class="math display">\[
  \begin{align*}
  \exp(-\frac{(x-x&#39;)^2}{2\sigma^2})&amp;=\exp(-\frac{x^2}{2\sigma^2})\exp(\frac{xx&#39;}{\sigma^2})\exp(-\frac{x&#39;^2}{2\sigma^2})\\
  &amp;=\exp(-\frac{x^2}{2\sigma^2})\sum\limits_{n=0}^{+\infty}\frac{x^nx&#39;^n}{\sigma^{2n}n!}\exp(-\frac{x&#39;^2}{2\sigma^2})\\
  &amp;=\exp(-\frac{x^2}{2\sigma^2})\varphi(x)\varphi(x&#39;)\exp(-\frac{x&#39;^2}{2\sigma^2})\\
  &amp;=\phi(x)\phi(x&#39;)
  \end{align*}
  \]</span></p>
</blockquote>
<p>正定核函数有下面的等价定义：</p>
<blockquote>
<p>如果核函数满足：</p>
<ol type="1">
<li>对称性</li>
<li>正定性</li>
</ol>
<p>那么这个核函数时正定核函数。</p>
<p>证明：</p>
<ol type="1">
<li>对称性 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(k(x,z)=k(z,x)\)</span>，显然满足内积的定义</li>
<li>正定性 <span class="math inline">\(\Leftrightarrow\)</span> <span class="math inline">\(\forall N,x_1,x_2,\cdots,x_N\in\mathcal{X}\)</span>，对应的 Gram Matrix <span class="math inline">\(K=[k(x_i,x_j)]\)</span> 是半正定的。</li>
</ol>
<p>要证：<span class="math inline">\(k(x,z)=\phi(x)^T\phi(z)\Leftrightarrow K\)</span> 半正定+对称性。</p>
<ol type="1">
<li><p><span class="math inline">\(\Rightarrow\)</span>：首先，对称性是显然的，对于正定性：<br>
<span class="math display">\[
K=\begin{pmatrix}k(x_1,x_2)&amp;\cdots&amp;k(x_1,x_N)\\\vdots&amp;\vdots&amp;\vdots\\k(x_N,x_1)&amp;\cdots&amp;k(x_N,x_N)\end{pmatrix}
\]</span><br>
任意取 <span class="math inline">\(\alpha\in\mathbb{R}^N\)</span>，即需要证明 <span class="math inline">\(\alpha^TK\alpha\ge0\)</span>：<br>
<span class="math display">\[
\alpha^TK\alpha=\sum\limits_{i,j}\alpha_i\alpha_jK_{ij}=\sum\limits_{i,j}\alpha_i\phi^T(x_i)\phi(x_j)\alpha_j=\sum\limits_{i}\alpha_i\phi^T(x_i)\sum\limits_{j}\alpha_j\phi(x_j)
\]</span><br>
这个式子就是内积的形式，Hilbert 空间满足线性性，于是正定性的证。</p></li>
<li><p><span class="math inline">\(\Leftarrow\)</span>：对于 <span class="math inline">\(K\)</span> 进行分解，对于对称矩阵 <span class="math inline">\(K=V\Lambda V^T\)</span>，那么令 <span class="math inline">\(\phi(x_i)=\sqrt{\lambda_i}V_i\)</span>，其中 <span class="math inline">\(V_i\)</span>是特征向量，于是就构造了 <span class="math inline">\(k(x,z)=\sqrt{\lambda_i\lambda_j}V_i^TV_j\)</span></p></li>
</ol>
</blockquote>
<h2 id="小结-4">小结</h2>
<p>分类问题在很长一段时间都依赖 SVM，对于严格可分的数据集，Hard-margin SVM 选定一个超平面，保证所有数据到这个超平面的距离最大，对这个平面施加约束，固定 <span class="math inline">\(y_i(w^Tx_i+b)=1\)</span>，得到了一个凸优化问题并且所有的约束条件都是仿射函数，于是满足 Slater 条件，将这个问题变换成为对偶的问题，可以得到等价的解，并求出约束参数：<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span><br>
对需要的超平面参数的求解采用强对偶问题的 KKT 条件进行。<br>
<span class="math display">\[
\begin{align*}
&amp;\frac{\partial L}{\partial w}=0,\frac{\partial L}{\partial b}=0
\\&amp;\lambda_k(1-y_k(w^Tx_k+b))=0(slackness\ complementary)\\
&amp;\lambda_i\ge0\\
&amp;1-y_i(w^Tx_i+b)\le0
\end{align*}
\]</span><br>
解就是：<br>
<span class="math display">\[
\begin{gather*}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)=0
\end{gather*}
\]</span><br>
当允许一点错误的时候，可以在 Hard-margin SVM 中加入错误项。用 Hinge Function 表示错误项的大小，得到：<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\]</span><br>
对于完全不可分的问题，我们采用特征转换的方式，在 SVM 中，我们引入正定核函数来直接对内积进行变换，只要这个变换满足对称性和正定性，那么就可以用做核函数。</p>
<h1 id="指数族分布">指数族分布</h1>
<p>指数族是一类分布，包括高斯分布、伯努利分布、二项分布、泊松分布、Beta 分布、Dirichlet 分布、Gamma 分布等一系列分布。指数族分布可以写为统一的形式：<br>
<span class="math display">\[
p(x|\eta)=h(x)\exp(\eta^T\phi(x)-A(\eta))=\frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))
\]</span><br>
其中，<span class="math inline">\(\eta\)</span> 是参数向量，<span class="math inline">\(A(\eta)\)</span> 是对数配分函数（归一化因子）。</p>
<p>在这个式子中，$ (x)$ 叫做充分统计量，包含样本集合所有的信息，例如高斯分布中的均值和方差。充分统计量在在线学习中有应用，对于一个数据集，只需要记录样本的充分统计量即可。</p>
<p>对于一个模型分布假设（似然），那么我们在求解中，常常需要寻找一个共轭先验，使得先验与后验的形式相同，例如选取似然是二项分布，可取先验是 Beta 分布，那么后验也是 Beta 分布。指数族分布常常具有共轭的性质，于是我们在模型选择以及推断具有很大的便利。</p>
<p>共轭先验的性质便于计算，同时，指数族分布满足最大熵的思想（无信息先验），也就是说对于经验分布利用最大熵原理导出的分布就是指数族分布。</p>
<p>观察到指数族分布的表达式类似线性模型，事实上，指数族分布很自然地导出广义线性模型：<br>
<span class="math display">\[
\begin{gather*}
y=f(w^Tx)\\
y|x\sim Exp Family
\end{gather*}
\]</span><br>
在更复杂的概率图模型中，例如在无向图模型中如受限玻尔兹曼机中，指数族分布也扮演着重要作用。</p>
<p>在推断的算法中，例如变分推断中，指数族分布也会大大简化计算。</p>
<h2 id="一维高斯分布">一维高斯分布</h2>
<p>一维高斯分布可以写成：<br>
<span class="math display">\[
p(x|\theta)=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2\sigma^2})
\]</span><br>
将这个式子改写：<br>
<span class="math display">\[
\begin{gather*}
\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{1}{2\sigma^2}(x^2-2\mu x+\mu^2))\\
=\exp(\log(2\pi\sigma^2)^{-1/2})\exp(-\frac{1}{2\sigma^2}\begin{pmatrix}-2\mu&amp;1\end{pmatrix}\begin{pmatrix}x\\x^2\end{pmatrix}-\frac{\mu^2}{2\sigma^2})
\end{gather*}
\]</span><br>
所以：<br>
<span class="math display">\[
\eta=\begin{pmatrix}\frac{\mu}{\sigma^2}\\-\frac{1}{2\sigma^2}\end{pmatrix}=\begin{pmatrix}\eta_1\\\eta_2\end{pmatrix}
\]</span><br>
于是 <span class="math inline">\(A(\eta)\)</span>：<br>
<span class="math display">\[
A(\eta)=-\frac{\eta_1^2}{4\eta_2}+\frac{1}{2}\log(-\frac{\pi}{\eta_2})
\]</span></p>
<h2 id="充分统计量和对数配分函数的关系">充分统计量和对数配分函数的关系</h2>
<p>对概率密度函数求积分：<br>
<span class="math display">\[
\begin{align*}
\exp(A(\eta))&amp;=\int h(x)\exp(\eta^T\phi(x))dx
\end{align*}
\]</span><br>
两边对参数求导：<br>
<span class="math display">\[
\exp(A(\eta))A&#39;(\eta)=\int h(x)\exp(\eta^T\phi(x))\phi(x)dx\\
\Longrightarrow A&#39;(\eta)=\mathbb{E}_{p(x|\eta)}[\phi(x)]
\]</span><br>
类似的：<br>
<span class="math display">\[
A&#39;&#39;(\eta)=Var_{p(x|\eta)}[\phi(x)]
\]</span><br>
由于方差为正，于是 <span class="math inline">\(A(\eta)\)</span> 一定是凸函数。</p>
<h2 id="充分统计量和极大似然估计">充分统计量和极大似然估计</h2>
<p>对于独立全同采样得到的数据集 <span class="math inline">\(\mathcal{D}=\{x_1,x_2,\cdots,x_N\}\)</span>。<br>
<span class="math display">\[
\begin{align*}
\eta_{MLE}&amp;=\mathop{argmax}_\eta\sum\limits_{i=1}^N\log p(x_i|\eta)\\
&amp;=\mathop{argmax}_\eta\sum\limits_{i=1}^N(\eta^T\phi(x_i)-A(\eta))\\
&amp;\Longrightarrow A&#39;(\eta_{MLE})=\frac{1}{N}\sum\limits_{i=1}^N\phi(x_i)
\end{align*}
\]</span><br>
由此可以看到，为了估算参数，只需要知道充分统计量就可以了。</p>
<h2 id="最大熵">最大熵</h2>
<p>信息熵记为：<br>
<span class="math display">\[
Entropy=\int-p(x)\log(p(x))dx
\]</span></p>
<blockquote>
<p>一般地，对于完全随机的变量（等可能），信息熵最大。</p>
<p>我们的假设为最大熵原则，假设数据是离散分布的，<span class="math inline">\(k\)</span> 个特征的概率分别为 <span class="math inline">\(p_k\)</span>，最大熵原理可以表述为：<br>
<span class="math display">\[
   \max\{H(p)\}=\min\{\sum\limits_{k=1}^Kp_k\log p_k\}\ s.t.\ \sum\limits_{k=1}^Kp_k=1
   \]</span><br>
利用 Lagrange 乘子法：<br>
<span class="math display">\[
   L(p,\lambda)=\sum\limits_{k=1}^Kp_k\log p_k+\lambda(1-\sum\limits_{k=1}^Kp_k)
   \]</span><br>
于是可得：<br>
<span class="math display">\[
   p_1=p_2=\cdots=p_K=\frac{1}{K}
   \]</span><br>
因此等可能的情况熵最大。</p>
</blockquote>
<p>一个数据集 <span class="math inline">\(\mathcal{D}\)</span>，在这个数据集上的经验分布为 <span class="math inline">\(\hat{p}(x)=\frac{Count(x)}{N}\)</span>，实际不可能满足所有的经验概率相同，于是在上面的最大熵原理中还需要加入这个经验分布的约束。</p>
<p>对任意一个函数，经验分布的经验期望可以求得为：<br>
<span class="math display">\[
\mathbb{E}_{\hat{p}}[f(x)]=\Delta
\]</span><br>
于是：<br>
<span class="math display">\[
\max\{H(p)\}=\min\{\sum\limits_{k=1}^Np_k\log p_k\}\ s.t.\ \sum\limits_{k=1}^Np_k=1,\mathbb{E}_p[f(x)]=\Delta
\]</span><br>
Lagrange 函数为：<br>
<span class="math display">\[
L(p,\lambda_0,\lambda)=\sum\limits_{k=1}^Np_k\log p_k+\lambda_0(1-\sum\limits_{k=1}^Np_k)+\lambda^T(\Delta-\mathbb{E}_p[f(x)])
\]</span><br>
求导得到：<br>
<span class="math display">\[
\begin{gather*}
\frac{\partial}{\partial p(x)}L=\sum\limits_{k=1}^N(\log p(x)+1)-\sum\limits_{k=1}^N\lambda_0-\sum\limits_{k=1}^N\lambda^Tf(x)\\
\Longrightarrow\sum\limits_{k=1}^N\log p(x)+1-\lambda_0-\lambda^Tf(x)=0
\end{gather*}
\]</span><br>
由于数据集是任意的，对数据集求和也意味着求和项里面的每一项都是0：<br>
<span class="math display">\[
p(x)=\exp(\lambda^Tf(x)+\lambda_0-1)
\]</span><br>
这就是指数族分布。</p>
<h1 id="概率图模型">概率图模型</h1>
<p>概率图模型使用图的方式表示概率分布。为了在图中添加各种概率，首先总结一下随机变量分布的一些规则：<br>
<span class="math display">\[
\begin{align*}
&amp;Sum\ Rule:p(x_1)=\int p(x_1,x_2)dx_2\\
&amp;Product\ Rule:p(x_1,x_2)=p(x_1|x_2)p(x_2)\\
&amp;Chain\ Rule:p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{i+1,x_{i+2} \cdots}x_p)\\
&amp;Bayesian\ Rule:p(x_1|x_2)=\frac{p(x_2|x_1)p(x_1)}{p(x_2)}
\end{align*}
\]</span><br>
可以看到，在链式法则中，如果数据维度特别高，那么的采样和计算非常困难，我们需要在一定程度上作出简化，在朴素贝叶斯中，作出了条件独立性假设。在 Markov 假设中，给定数据的维度是以时间顺序出现的，给定当前时间的维度，那么下一个维度与之前的维度独立。在 HMM 中，采用了齐次 Markov 假设。在 Markov 假设之上，更一般的，加入条件独立性假设，对维度划分集合 <span class="math inline">\(A,B,C\)</span>，使得 <span class="math inline">\(X_A\perp X_B|X_C\)</span>。</p>
<p>概率图模型采用图的特点表示上述的条件独立性假设，节点表示随机变量，边表示条件概率。概率图模型可以分为三大理论部分：</p>
<ol type="1">
<li>表示：
<ol type="1">
<li>有向图（离散）：贝叶斯网络</li>
<li>高斯图（连续）：高斯贝叶斯和高斯马尔可夫网路</li>
<li>无向图（离散）：马尔可夫网络</li>
</ol></li>
<li>推断
<ol type="1">
<li>精确推断</li>
<li>近似推断
<ol type="1">
<li>确定性近似（如变分推断）</li>
<li>随机近似（如 MCMC）</li>
</ol></li>
</ol></li>
<li>学习
<ol type="1">
<li>参数学习
<ol type="1">
<li>完备数据</li>
<li>隐变量：E-M 算法</li>
</ol></li>
<li>结构学习</li>
</ol></li>
</ol>
<h2 id="有向图-贝叶斯网络">有向图-贝叶斯网络</h2>
<p>已知联合分布中，各个随机变量之间的依赖关系，那么可以通过拓扑排序（根据依赖关系）可以获得一个有向图。而如果已知一个图，也可以直接得到联合概率分布的因子分解：<br>
<span class="math display">\[
p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{parent(i)})
\]</span><br>
那么实际的图中条件独立性是如何体现的呢？在局部任何三个节点，可以有三种结构：</p>
<ol type="1">
<li></li>
</ol>
<p><pre class="mermaid"> graph TB;<br>
A((A))--&gt;B((B));<br>
B--&gt;C((C));</pre></p>
<p><span class="math display">\[
   \begin{gather*}
   p(A,B,C)=p(A)p(B|A)p(C|B)=p(A)p(B|A)p(C|B,A)\\
   \Longrightarrow p(C|B)=p(C|B,A)\\
   \Leftrightarrow p(C|B)p(A|B)=p(C|A,B)p(A|B)=p(C,A|B)\\
   \Longrightarrow C\perp A|B
   \end{gather*}
   \]</span></p>
<ol start="2" type="1">
<li></li>
</ol>
<p><pre class="mermaid"> graph TB;<br>
B((B))--&gt;A((A));<br>
B--&gt;C((C));</pre></p>
<p><span class="math display">\[
   \begin{gather*}
   p(A,B,C)=p(A|B)p(B)p(C|B)=p(B)p(A|B)p(C|A,B)\\
   \Longrightarrow p(C|B)=p(C|B,A)\\
   \Leftrightarrow p(C|B)p(A|B)=p(C|A,B)p(A|B)=p(C,A|B)\\
   \Longrightarrow C\perp A|B
   \end{gather*}
   \]</span></p>
<ol start="3" type="1">
<li></li>
</ol>
<p><pre class="mermaid"> graph TB;<br>
A((A))--&gt;B((B));<br>
C((C))--&gt;B</pre></p>
<p><span class="math display">\[
   \begin{gather*}
   p(A,B,C)=p(A)p(C)p(B|C,A)=p(A)p(C|A)p(B|C,A)\\
   \Longrightarrow p(C)=p(C|A)\\
   \Leftrightarrow C\perp A\\
   \end{gather*}
   \]</span></p>
<p>对这种结构，<span class="math inline">\(A,C\)</span> 不与 <span class="math inline">\(B\)</span> 条件独立。</p>
<p>从整体的图来看，可以引入 D 划分的概念。对于类似上面图 1和图 2的关系，引入集合A，B，那么满足 <span class="math inline">\(A\perp B|C\)</span> 的 <span class="math inline">\(C\)</span> 集合中的点与 <span class="math inline">\(A,B\)</span> 中的点的关系都满足图 1，2，满足图3 关系的点都不在 <span class="math inline">\(C\)</span> 中。D 划分应用在贝叶斯定理中：<br>
<span class="math display">\[
p(x_i|x_{-i})=\frac{p(x)}{\int p(x)dx_{i}}=\frac{\prod\limits_{j=1}^pp(x_j|x_{parents(j)})}{\int\prod\limits_{j=1}^pp(x_j|x_{parents(j)})dx_i}
\]</span><br>
可以发现，上下部分可以分为两部分，一部分是和 <span class="math inline">\(x_i\)</span> 相关的，另一部分是和 <span class="math inline">\(x_i\)</span> 无关的，而这个无关的部分可以相互约掉。于是计算只涉及和 <span class="math inline">\(x_i\)</span> 相关的部分。</p>
<p>与 <span class="math inline">\(x_i\)</span> 相关的部分可以写成：<br>
<span class="math display">\[
p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)
\]</span><br>
这些相关的部分又叫做 Markov 毯。</p>
<p>实际应用的模型中，对这些条件独立性作出了假设，从单一到混合，从有限到无限（时间，空间）可以分为：</p>
<ol type="1">
<li>朴素贝叶斯，单一的条件独立性假设 <span class="math inline">\(p(x|y)=\prod\limits_{i=1}^pp(x_i|y)\)</span>，在 D 划分后，所有条件依赖的集合就是单个元素。</li>
<li>高斯混合模型：混合的条件独立。引入多类别的隐变量 <span class="math inline">\(z_1, z_2,\cdots,z_k\)</span>， <span class="math inline">\(p(x|z)=\mathcal{N}(\mu,\Sigma)\)</span>，条件依赖集合为多个元素。</li>
<li>与时间相关的条件依赖
<ol type="1">
<li>Markov 链</li>
<li>高斯过程（无限维高斯分布）</li>
</ol></li>
<li>连续：高斯贝叶斯网络</li>
<li>组合上面的分类
<ul>
<li>GMM 与时序结合：动态模型
<ul>
<li>HMM（离散）</li>
<li>线性动态系统 LDS（Kalman 滤波）</li>
<li>粒子滤波（非高斯，非线性）</li>
</ul></li>
</ul></li>
</ol>
<h2 id="无向图-马尔可夫网络马尔可夫随机场">无向图-马尔可夫网络（马尔可夫随机场）</h2>
<p>无向图没有了类似有向图的局部不同结构，在马尔可夫网络中，也存在 D 划分的概念。直接将条件独立的集合 <span class="math inline">\(x_A\perp x_B|x_C\)</span> 划分为三个集合。这个也叫全局 Markov。对局部的节点，<span class="math inline">\(x\perp (X-Neighbour(\mathcal{x}))|Neighbour(x)\)</span>。这也叫局部 Markov。对于成对的节点：<span class="math inline">\(x_i\perp x_j|x_{-i-j}\)</span>，其中 <span class="math inline">\(i,j\)</span> 不能相邻。这也叫成对 Markov。事实上上面三个点局部全局成对是相互等价的。</p>
<p>有了这个条件独立性的划分，还需要因子分解来实际计算。引入团的概念：</p>
<blockquote>
<p>团，最大团：图中节点的集合，集合中的节点之间相互都是连接的叫做团，如果不能再添加节点，那么叫最大团。</p>
</blockquote>
<p>利用这个定义进行的 <span class="math inline">\(x\)</span> 所有维度的联合概率分布的因子分解为，假设有 <span class="math inline">\(K\)</span> 个团，<span class="math inline">\(Z\)</span> 就是对所有可能取值求和：<br>
<span class="math display">\[
\begin{align*}p(x)=\frac{1}{Z}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
Z=\sum\limits_{x\in\mathcal{X}}\prod\limits_{i=1}^{K}\phi(x_{ci})
\end{align*}
\]</span><br>
其中 <span class="math inline">\(\phi(x_{ci})\)</span> 叫做势函数，它必须是一个正值，可以记为：<br>
<span class="math display">\[
\phi(x_{ci})=\exp(-E(x_{ci}))
\]</span><br>
这个分布叫做 Gibbs 分布（玻尔兹曼分布）。于是也可以记为：<span class="math inline">\(p(x)=\frac{1}{Z}\exp(-\sum\limits_{i=1}^KE(x_{ci}))\)</span>。这个分解和条件独立性等价（Hammesley-Clifford 定理），这个分布的形式也和指数族分布形式上相同，于是满足最大熵原理。</p>
<h2 id="两种图的转换-道德图">两种图的转换-道德图</h2>
<p>我们常常想将有向图转为无向图，从而应用更一般的表达式。</p>
<ol type="1">
<li><p>链式：</p>
<pre class="mermaid">   graph TB;
 A((A))-->B((B));
 B-->C((C));</pre>
<p>直接去掉箭头，<span class="math inline">\(p(a,b,c)=p(a)p(b|a)p(c|b)=\phi(a,b)\phi(b,c)\)</span>：</p>
<pre class="mermaid">   graph TB;
 A((A))---B((B));
 B---C((C));</pre></li>
<li><p>V 形：</p>
<pre class="mermaid">   graph TB;
 B((B))-->A((A));
 B-->C((C));</pre>
<p>由于 <span class="math inline">\(p(a,b,c)=p(b)p(a|b)p(c|b)=\phi(a,b)\phi(b,c)\)</span>，直接去掉箭头：</p>
<pre class="mermaid">   graph TB;
 B((B))---A((A));
 B---C((C));</pre></li>
<li><p>倒 V 形：</p>
<pre class="mermaid">   graph TB;
 A((A))-->B((B));
 C((C))-->B</pre>
<p>由于 <span class="math inline">\(p(a,b,c)=p(a)p(c)p(b|a,c)=\phi(a,b,c)\)</span>，于是在 <span class="math inline">\(a,c\)</span> 之间添加线：</p>
<pre class="mermaid">   graph TD;
 a((a))---b((b));
 b---c((c));
 a---c;</pre>
<p>观察着三种情况可以概括为：</p>
<ol type="1">
<li>将每个节点的父节点两两相连</li>
<li>将有向边替换为无向边</li>
</ol></li>
</ol>
<h2 id="更精细的分解-因子图">更精细的分解-因子图</h2>
<p>对于一个有向图，可以通过引入环的方式，可以将其转换为无向图（Tree-like graph），这个图就叫做道德图。但是我们上面的 BP 算法只对无环图有效，通过因子图可以变为无环图。</p>
<p>考虑一个无向图：</p>
<pre class="mermaid">graph TD;
    a((a))---b((b));
    b---c((c));
    a---c;</pre>
<p>可以将其转为：</p>
<pre class="mermaid">graph TD;
    a((a))---f;
    f---b((b));
    f---c((c))</pre>
<p>其中 <span class="math inline">\(f=f(a,b,c)\)</span>。因子图不是唯一的，这是由于因式分解本身就对应一个特殊的因子图，将因式分解：<span class="math inline">\(p(x)=\prod\limits_{s}f_s(x_s)\)</span> 可以进一步分解得到因子图。</p>
<h2 id="推断">推断</h2>
<p>推断的主要目的是求各种概率分布，包括边缘概率，条件概率，以及使用 MAP 来求得参数。通常推断可以分为：</p>
<ol type="1">
<li>精确推断
<ol type="1">
<li>Variable Elimination(VE)</li>
<li>Belief Propagation(BP, Sum-Product Algo)，从 VE 发展而来</li>
<li>Junction Tree，上面两种在树结构上应用，Junction Tree 在图结构上应用</li>
</ol></li>
<li>近似推断
<ol type="1">
<li>Loop Belief Propagation（针对有环图）</li>
<li>Mente Carlo Interference：例如 Importance Sampling，MCMC</li>
<li>Variational Inference</li>
</ol></li>
</ol>
<h3 id="推断-变量消除ve">推断-变量消除（VE）</h3>
<p>变量消除的方法是在求解概率分布的时候，将相关的条件概率先行求和或积分，从而一步步地消除变量，例如在马尔可夫链中：</p>
<pre class="mermaid">graph LR;
    a((a))-->b((b));
    b-->c((c));
    c-->d((d))</pre>
<p><span class="math display">\[
p(d)=\sum\limits_{a,b,c}p(a,b,c,d)=\sum\limits_cp(d|c)\sum\limits_bp(c|b)\sum\limits_ap(b|a)p(a)
\]</span></p>
<p>变量消除的缺点很明显：</p>
<ol type="1">
<li>计算步骤无法存储</li>
<li>消除的最优次序是一个 NP-hard 问题</li>
</ol>
<h3 id="推断-信念传播bp">推断-信念传播（BP）</h3>
<p>为了克服 VE 的第一个缺陷-计算步骤无法存储。我们进一步地对上面的马尔可夫链进行观察：</p>
<pre class="mermaid">graph LR;
    a((a))-->b((b));
    b-->c((c));
    c-->d((d));
    d-->e((e));</pre>
<p>要求 <span class="math inline">\(p(e)\)</span>，当然使用 VE，从 <span class="math inline">\(a\)</span> 一直消除到 <span class="math inline">\(d\)</span>，记 <span class="math inline">\(\sum\limits_ap(a)p(b|a)=m_{a\to b(b)}\)</span>，表示这是消除 <span class="math inline">\(a\)</span> 后的关于 <span class="math inline">\(b\)</span> 的概率，类似地，记 <span class="math inline">\(\sum\limits_bp(c|b)m_{a\to b}(b)=m_{b\to c}(c)\)</span>。于是 <span class="math inline">\(p(e)=\sum\limits_dp(e|d)m_{b\to c}(c)\)</span>。进一步观察，对 <span class="math inline">\(p(c)\)</span>：<br>
<span class="math display">\[
p(c)=[\sum\limits_bp(c|b)\sum\limits_ap(b|a)p(a)]\cdot[\sum\limits_dp(d|c)\sum\limits_ep(e)p(e|d)]
\]</span><br>
我们发现了和上面计算 <span class="math inline">\(p(e)\)</span> 类似的结构，这个式子可以分成两个部分，一部分是从 <span class="math inline">\(a\)</span> 传播过来的概率，第二部分是从 $ e$ 传播过来的概率。</p>
<p>一般地，对于图（只对树形状的图）：</p>
<pre class="mermaid">graph TD;
    a((a))---b((b));
    b---c((c));
    b---d((d));</pre>
<p>这四个团（对于无向图是团，对于有向图就是概率为除了根的节点为1），有四个节点，三个边：<br>
<span class="math display">\[
p(a,b,c,d)=\frac{1}{Z}\phi_a(a)\phi_b(b)\phi_c(c)\phi_d(d)\cdot\phi_{ab}(a,b)\phi_{bc}(c,b)\phi_{bd}(d,b)
\]</span><br>
套用上面关于有向图的观察，如果求解边缘概率 <span class="math inline">\(p(a)\)</span>，定义 <span class="math inline">\(m_{c\to b}(b)=\sum\limits_c\phi_c(c)\phi_{bc}(bc)\)</span>，<span class="math inline">\(m_{d\to b}(b)=\sum\limits_d\phi_d(d)\phi_{bd}(bd)\)</span>，<span class="math inline">\(m_{b\to a}(a)=\sum\limits_b\phi_{ba}(ba)\phi_b(b)m_{c\to b}(b)_{d\to b}m(b)\)</span>，这样概率就一步步地传播到了 <span class="math inline">\(a\)</span>：<br>
<span class="math display">\[
p(a)=\phi_a(a)m_{b\to a}(a)
\]</span><br>
写成一般的形式，对于相邻节点 <span class="math inline">\(i,j\)</span>：<br>
<span class="math display">\[
m_{j\to i}(i)=\sum\limits_j\phi_j(j)\phi_{ij}(ij)\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}(j)
\]</span><br>
这个表达式，就可以保存计算过程了，只要对每条边的传播分别计算，对于一个无向树形图可以递归并行实现：</p>
<ol type="1">
<li>任取一个节点 <span class="math inline">\(a\)</span> 作为根节点</li>
<li>对这个根节点的邻居中的每一个节点，收集信息（计算入信息）</li>
<li>对根节点的邻居，分发信息（计算出信息）</li>
</ol>
<h3 id="推断-max-product-算法">推断-Max-Product 算法</h3>
<p>在推断任务中，MAP 也是常常需要的，MAP 的目的是寻找最佳参数：<br>
<span class="math display">\[
(\hat{a},\hat{b},\hat{c},\hat{d})=\mathop{argmax}_{a,b,c,d}p(a,b,c,d|E)
\]</span><br>
类似 BP，我们采用信息传递的方式来求得最优参数，不同的是，我们在所有信息传递中，传递的是最大化参数的概率，而不是将所有可能求和：<br>
<span class="math display">\[
m_{j\to i}=\max\limits_{j}\phi_j\phi_{ij}\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}
\]</span><br>
于是对于上面的图：<br>
<span class="math display">\[
\max_a p(a,b,c,d)=\max_a\phi_a\phi_{ab}m_{c\to b}m_{d\to b}
\]</span><br>
这个算法是 Sum-Product 算法的改进，也是在 HMM 中应用给的 Viterbi 算法的推广。</p>
<h1 id="期望最大">期望最大</h1>
<p>期望最大算法的目的是解决具有隐变量的混合模型的参数估计（极大似然估计）。MLE 对 <span class="math inline">\(p(x|\theta)\)</span> 参数的估计记为：<span class="math inline">\(\theta_{MLE}=\mathop{argmax}\limits_\theta\log p(x|\theta)\)</span>。EM 算法对这个问题的解决方法是采用迭代的方法：<br>
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz=\mathbb{E}_{z|x,\theta^t}[\log p(x,z|\theta)]
\]</span><br>
这个公式包含了迭代的两步：</p>
<ol type="1">
<li>E step：计算 <span class="math inline">\(\log p(x,z|\theta)\)</span> 在概率分布 <span class="math inline">\(p(z|x,\theta^t)\)</span> 下的期望</li>
<li>M step：计算使这个期望最大化的参数得到下一个 EM 步骤的输入</li>
</ol>
<blockquote>
<p>求证：<span class="math inline">\(\log p(x|\theta^t)\le\log p(x|\theta^{t+1})\)</span></p>
<p>证明：<span class="math inline">\(\log p(x|\theta)=\log p(z,x|\theta)-\log p(z|x,\theta)\)</span>，对左右两边求积分：<br>
<span class="math display">\[
  Left:\int_zp(z|x,\theta^t)\log p(x|\theta)dz=\log p(x|\theta)
  \]</span></p>
<p><span class="math display">\[
  Right:\int_zp(z|x,\theta^t)\log p(x,z|\theta)dz-\int_zp(z|x,\theta^t)\log p(z|x,\theta)dz=Q(\theta,\theta^t)-H(\theta,\theta^t)
  \]</span></p>
<p>所以：<br>
<span class="math display">\[
  \log p(x|\theta)=Q(\theta,\theta^t)-H(\theta,\theta^t)
  \]</span><br>
由于 <span class="math inline">\(Q(\theta,\theta^t)=\int_zp(z|x,\theta^t)\log p(x,z|\theta)dz\)</span>，而 <span class="math inline">\(\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz\)</span>，所以 <span class="math inline">\(Q(\theta^{t+1},\theta^t)\ge Q(\theta^t,\theta^t)\)</span>。要证 <span class="math inline">\(\log p(x|\theta^t)\le\log p(x|\theta^{t+1})\)</span>，需证：<span class="math inline">\(H(\theta^t,\theta^t)\ge H(\theta^{t+1},\theta^t)\)</span>：<br>
<span class="math display">\[
  \begin{align*}H(\theta^{t+1},\theta^t)-H(\theta^{t},\theta^t)&amp;=\int_zp(z|x,\theta^{t})\log p(z|x,\theta^{t+1})dz-\int_zp(z|x,\theta^t)\log p(z|x,\theta^{t})dz\\
  &amp;=\int_zp(z|x,\theta^t)\log\frac{p(z|x,\theta^{t+1})}{p(z|x,\theta^t)}=-KL(p(z|x,\theta^t),p(z|x,\theta^{t+1}))\le0
  \end{align*}
  \]</span><br>
综合上面的结果：<br>
<span class="math display">\[
  \log p(x|\theta^t)\le\log p(x|\theta^{t+1})
  \]</span></p>
</blockquote>
<p>根据上面的证明，我们看到，似然函数在每一步都会增大。进一步的，我们看 EM 迭代过程中的式子是怎么来的：<br>
<span class="math display">\[
\log p(x|\theta)=\log p(z,x|\theta)-\log p(z|x,\theta)=\log \frac{p(z,x|\theta)}{q(z)}-\log \frac{p(z|x,\theta)}{q(z)}
\]</span><br>
分别对两边求期望 <span class="math inline">\(\mathbb{E}_{q(z)}\)</span>：<br>
<span class="math display">\[
\begin{align*}
&amp;Left:\int_zq(z)\log p(x|\theta)dz=\log p(x|\theta)\\
&amp;Right:\int_zq(z)\log \frac{p(z,x|\theta)}{q(z)}dz-\int_zq(z)\log \frac{p(z|x,\theta)}{q(z)}dz=ELBO+KL(q(z),p(z|x,\theta))
\end{align*}
\]</span><br>
上式中，Evidence Lower Bound(ELBO)，是一个下界，所以 <span class="math inline">\(\log p(x|\theta)\ge ELBO\)</span>，等于号取在 KL 散度为0是，即：<span class="math inline">\(q(z)=p(z|x,\theta)\)</span>，EM 算法的目的是将 ELBO 最大化，根据上面的证明过程，在每一步 EM 后，求得了最大的ELBO，并根据这个使 ELBO 最大的参数代入下一步中：<br>
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_{\theta}ELBO=\mathop{argmax}_\theta\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz
\]</span><br>
由于 $ q(z)=p(z|x,^t)$ 的时候，这一步的最大值才能取等号，所以：<br>
<span class="math display">\[
\begin{gather*}
\hat{\theta}=\mathop{argmax}_{\theta}ELBO=\mathop{argmax}_\theta\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz=\mathop{argmax}_\theta\int_zp(z|x,\theta^t)\log\frac{p(x,z|\theta)}{p(z|x,\theta^t)}d z\\
=\mathop{argmax}_\theta\int_z p(z|x,\theta^t)\log p(x,z|\theta)
\end{gather*}
\]</span><br>
这个式子就是上面 EM 迭代过程中的式子。</p>
<p>从 Jensen 不等式出发，也可以导出这个式子：<br>
<span class="math display">\[
\begin{gather*}
\log p(x|\theta)=\log\int_zp(x,z|\theta)dz=\log\int_z\frac{p(x,z|\theta)q(z)}{q(z)}dz\\
=\log \mathbb{E}_{q(z)}[\frac{p(x,z|\theta)}{q(z)}]\ge \mathbb{E}_{q(z)}[\log\frac{p(x,z|\theta)}{q(z)}]
\end{gather*}
\]</span><br>
其中，右边的式子就是 ELBO，等号在 $ p(x,z|)=Cq(z)$ 时成立。于是：<br>
<span class="math display">\[
\begin{gather*}
\int_zq(z)dz=\frac{1}{C}\int_zp(x,z|\theta)dz=\frac{1}{C}p(x|\theta)=1\\
\Rightarrow q(z)=\frac{1}{p(x|\theta)}p(x,z|\theta)=p(z|x,\theta)
\end{gather*}
\]</span><br>
我们发现，这个过程就是上面的最大值取等号的条件。</p>
<h2 id="广义-em">广义 EM</h2>
<p>EM 模型解决了概率生成模型的参数估计的问题，通过引入隐变量 <span class="math inline">\(z\)</span>，来学习 <span class="math inline">\(\theta\)</span>，具体的模型对 <span class="math inline">\(z\)</span> 有不同的假设。对学习任务 <span class="math inline">\(p(x|\theta)\)</span>，就是学习任务 <span class="math inline">\(\frac{p(x,z|\theta)}{p(z|x,\theta)}\)</span>。在这个式子中，我们假定了在 E 步骤中，<span class="math inline">\(q(z)=p(z|x,\theta)\)</span>，但是这个<span class="math inline">\(p(z|x,\theta)\)</span> 如果无法求解，那么必须使用采样（MCMC）或者变分推断等方法来近似推断这个后验。我们观察 KL 散度的表达式，为了最大化 ELBO，在固定的 <span class="math inline">\(\theta\)</span> 时，我们需要最小化 KL 散度，于是：<br>
<span class="math display">\[
\hat{q}(z)=\mathop{argmin}_qKL(p,q)=\mathop{argmax}_qELBO
\]</span><br>
这就是广义 EM 的基本思路：</p>
<ol type="1">
<li><p>E step：<br>
<span class="math display">\[
\hat{q}^{t+1}(z)=\mathop{argmax}_q\int_zq^t(z)\log\frac{p(x,z|\theta)}{q^t(z)}dz,fixed\ \theta
\]</span></p></li>
<li><p>M step：<br>
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_\theta \int_zq^{t+1}(z)\log\frac{p(x,z|\theta)}{q^{t+1}(z)}dz,fixed\ \hat{q}
\]</span></p></li>
</ol>
<p>对于上面的积分：<br>
<span class="math display">\[
ELBO=\int_zq(z)\log\frac{p(x,z|\theta)}{q(z)}dz=\mathbb{E}_{q(z)}[p(x,z|\theta)]+Entropy(q(z))
\]</span><br>
因此，我们看到，广义 EM 相当于在原来的式子中加入熵这一项。</p>
<h2 id="em-的推广">EM 的推广</h2>
<p>EM 算法类似于坐标上升法，固定部分坐标，优化其他坐标，再一遍一遍的迭代。如果在 EM 框架中，无法求解 <span class="math inline">\(z\)</span> 后验概率，那么需要采用一些变种的 EM 来估算这个后验。</p>
<ol type="1">
<li>基于平均场的变分推断，VBEM/VEM</li>
<li>基于蒙特卡洛的EM，MCEM</li>
</ol>
<h1 id="高斯混合模型">高斯混合模型</h1>
<p>为了解决高斯模型的单峰性的问题，我们引入多个高斯模型的加权平均来拟合多峰数据：<br>
<span class="math display">\[
p(x)=\sum\limits_{k=1}^K\alpha_k\mathcal{N}(\mu_k,\Sigma_k)
\]</span><br>
引入隐变量 <span class="math inline">\(z\)</span>，这个变量表示对应的样本 <span class="math inline">\(x\)</span> 属于哪一个高斯分布，这个变量是一个离散的随机变量：<br>
<span class="math display">\[
p(z=i)=p_i,\sum\limits_{i=1}^kp(z=i)=1
\]</span><br>
作为一个生成式模型，高斯混合模型通过隐变量 <span class="math inline">\(z\)</span> 的分布来生成样本。用概率图来表示：</p>
<pre class="mermaid">graph LR;
    z((z))-->x((x))</pre>
<p>其中，节点 <span class="math inline">\(z\)</span> 就是上面的概率，<span class="math inline">\(x\)</span> 就是生成的高斯分布。于是对 <span class="math inline">\(p(x)\)</span>：<br>
<span class="math display">\[
p(x)=\sum\limits_zp(x,z)=\sum\limits_{k=1}^Kp(x,z=k)=\sum\limits_{k=1}^Kp(z=k)p(x|z=k)
\]</span><br>
因此：<br>
<span class="math display">\[
p(x)=\sum\limits_{k=1}^Kp_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span></p>
<h2 id="极大似然估计">极大似然估计</h2>
<p>样本为 <span class="math inline">\(X=(x_1,x_2,\cdots,x_N)\)</span>，$ (X,Z)$ 为完全参数，参数为 <span class="math inline">\(\theta=\{p_1,p_2,\cdots,p_K,\mu_1,\mu_2,\cdots,\mu_K\Sigma_1,\Sigma_2,\cdots,\Sigma_K\}\)</span>。我们通过极大似然估计得到 <span class="math inline">\(\theta\)</span> 的值：<br>
<span class="math display">\[
\begin{align*}\theta_{MLE}&amp;=\mathop{argmax}\limits_{\theta}\log p(X)=\mathop{argmax}_{\theta}\sum\limits_{i=1}^N\log p(x_i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log \sum\limits_{k=1}^Kp_k\mathcal{N}(x_i|\mu_k,\Sigma_k)
\end{align*}
\]</span><br>
这个表达式直接通过求导，由于连加号的存在，无法得到解析解。因此需要使用 EM 算法。</p>
<h2 id="em-求解-gmm">EM 求解 GMM</h2>
<p>EM 算法的基本表达式为：<span class="math inline">\(\theta^{t+1}=\mathop{argmax}\limits_{\theta}\mathbb{E}_{z|x,\theta_t}[p(x,z|\theta)]\)</span>。套用 GMM 的表达式，对数据集来说：<br>
<span class="math display">\[
\begin{align*}Q(\theta,\theta^t)&amp;=\sum\limits_z[\log\prod\limits_{i=1}^Np(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_z[\sum\limits_{i=1}^N\log p(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)
\end{align*}
\]</span><br>
对于中间的那个求和号，展开，第一项为：<br>
<span class="math display">\[
\begin{align*}
\sum\limits_z\log p(x_1,z_1|\theta)\prod\limits_{i=1}^Np(z_i|x_i,\theta^t)&amp;=\sum\limits_z\log p(x_1,z_1|\theta)p(z_1|x_1,\theta^t)\prod\limits_{i=2}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{z_1}\log p(x_1,z_1|\theta)
p(z_1|x_1,\theta^t)\sum\limits_{z_2,\cdots,z_K}\prod\limits_{i=2}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{z_1}\log p(x_1,z_1|\theta)p(z_1|x_1,\theta^t)\end{align*}
\]</span><br>
类似地，<span class="math inline">\(Q\)</span> 可以写为：<br>
<span class="math display">\[
Q(\theta,\theta^t)=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p(x_i,z_i|\theta)p(z_i|x_i,\theta^t)
\]</span><br>
对于 <span class="math inline">\(p(x,z|\theta)\)</span>：<br>
<span class="math display">\[
p(x,z|\theta)=p(z|\theta)p(x|z,\theta)=p_z\mathcal{N}(x|\mu_z,\Sigma_z)
\]</span><br>
对 <span class="math inline">\(p(z|x,\theta^t)\)</span>：<br>
<span class="math display">\[
p(z|x,\theta^t)=\frac{p(x,z|\theta^t)}{p(x|\theta^t)}=\frac{p_z^t\mathcal{N}(x|\mu_z^t,\Sigma_z^t)}{\sum\limits_kp_k^t\mathcal{N}(x|\mu_k^t,\Sigma_k^t)}
\]</span><br>
代入 <span class="math inline">\(Q\)</span>：<br>
<span class="math display">\[
Q=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p_{z_i}\mathcal{N(x_i|\mu_{z_i},\Sigma_{z_i})}\frac{p_{z_i}^t\mathcal{N}(x_i|\mu_{z_i}^t,\Sigma_{z_i}^t)}{\sum\limits_kp_k^t\mathcal{N}(x_i|\mu_k^t,\Sigma_k^t)}
\]</span><br>
下面需要对 <span class="math inline">\(Q\)</span> 值求最大值：<br>
<span class="math display">\[
Q=\sum\limits_{k=1}^K\sum\limits_{i=1}^N[\log p_k+\log \mathcal{N}(x_i|\mu_k,\Sigma_k)]p(z_i=k|x_i,\theta^t)
\]</span></p>
<ol type="1">
<li><p><span class="math inline">\(p_k^{t+1}\)</span>：<br>
<span class="math display">\[
p_k^{t+1}=\mathop{argmax}_{p_k}\sum\limits_{k=1}^K\sum\limits_{i=1}^N[\log p_k+\log \mathcal{N}(x_i|\mu_k,\Sigma_k)]p(z_i=k|x_i,\theta^t)\ s.t.\ \sum\limits_{k=1}^Kp_k=1
\]</span><br>
即：<br>
<span class="math display">\[
p_k^{t+1}=\mathop{argmax}_{p_k}\sum\limits_{k=1}^K\sum\limits_{i=1}^N\log p_kp(z_i=k|x_i,\theta^t)\ s.t.\ \sum\limits_{k=1}^Kp_k=1
\]</span><br>
引入 Lagrange 乘子：<span class="math inline">\(L(p_k,\lambda)=\sum\limits_{k=1}^K\sum\limits_{i=1}^N\log p_kp(z_i=k|x_i,\theta^t)-\lambda(1-\sum\limits_{k=1}^Kp_k)\)</span>。所以：<br>
<span class="math display">\[
\begin{gather*}
\frac{\partial}{\partial p_k}L=\sum\limits_{i=1}^N\frac{1}{p_k}p(z_i=k|x_i,\theta^t)+\lambda=0\\
\Rightarrow \sum\limits_k\sum\limits_{i=1}^N\frac{1}{p_k}p(z_i=k|x_i,\theta^t)+\lambda\sum\limits_kp_k=0\\
\Rightarrow\lambda=-N
\end{gather*}
\]</span></p>
<p>于是有：<br>
<span class="math display">\[
p_k^{t+1}=\frac{1}{N}\sum\limits_{i=1}^Np(z_i=k|x_i,\theta^t)
\]</span></p></li>
<li><p><span class="math inline">\(\mu_k,\Sigma_k\)</span>，这两个参数是无约束的，直接求导即可。</p></li>
</ol>
<h1 id="变分推断">变分推断</h1>
<p>我们已经知道概率模型可以分为，频率派的优化问题和贝叶斯派的积分问题。从贝叶斯角度来看推断，对于 <span class="math inline">\(\hat{x}\)</span> 这样的新样本，需要得到：<br>
<span class="math display">\[
p(\hat{x}|X)=\int_\theta p(\hat{x},\theta|X)d\theta=\int_\theta p(\theta|X)p(\hat{x}|\theta,X)d\theta
\]</span><br>
如果新样本和数据集独立，那么推断就是概率分布依参数后验分布的期望。</p>
<p>我们看到，推断问题的中心是参数后验分布的求解，推断分为：</p>
<ol type="1">
<li>精确推断</li>
<li>近似推断-参数空间无法精确求解
<ol type="1">
<li>确定性近似-如变分推断</li>
<li>随机近似-如 MCMC，MH，Gibbs</li>
</ol></li>
</ol>
<h2 id="基于平均场假设的变分推断">基于平均场假设的变分推断</h2>
<p>我们记 <span class="math inline">\(Z\)</span> 为隐变量和参数的集合，<span class="math inline">\(Z_i\)</span> 为第 <span class="math inline">\(i\)</span> 维的参数，于是，回顾一下 EM 中的推导：<br>
<span class="math display">\[
\log p(X)=\log p(X,Z)-\log p(Z|X)=\log\frac{p(X,Z)}{q(Z)}-\log\frac{p(Z|X)}{q(Z)}
\]</span><br>
左右两边分别积分：<br>
<span class="math display">\[
\begin{gather*}
Left:\int_Zq(Z)\log p(X)dZ=\log p(X)\\
Right:\int_Z[\log \frac{p(X,Z)}{q(Z)}-\log \frac{p(Z|X)}{q(Z)}]q(Z)dZ=ELBO+KL(q,p)
\end{gather*}
\]</span><br>
第二个式子可以写为变分和 KL 散度的和：<br>
<span class="math display">\[
L(q)+KL(q,p)
\]</span><br>
由于这个式子是常数，于是寻找 <span class="math inline">\(q\simeq p\)</span> 就相当于对 <span class="math inline">\(L(q)\)</span> 最大值。<br>
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span><br>
假设 <span class="math inline">\(q(Z)\)</span> 可以划分为 <span class="math inline">\(M\)</span> 个组（平均场近似）：<br>
<span class="math display">\[
q(Z)=\prod\limits_{i=1}^Mq_i(Z_i)
\]</span><br>
因此，在 <span class="math inline">\(L(q)=\int_Zq(Z)\log p(X,Z)dZ-\int_Zq(Z)\log{q(Z)}\)</span> 中，看 <span class="math inline">\(p(Z_j)\)</span> ，第一项：<br>
<span class="math display">\[
\begin{align*}\int_Zq(Z)\log p(X,Z)dZ&amp;=\int_Z\prod\limits_{i=1}^Mq_i(Z_i)\log p(X,Z)dZ\\
&amp;=\int_{Z_j}q_j(Z_j)\int_{Z-Z_{j}}\prod\limits_{i\ne j}q_i(Z_i)\log p(X,Z)dZ\\
&amp;=\int_{Z_j}q_j(Z_j)\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]dZ_j
\end{align*}
\]</span></p>
<p>第二项：<br>
<span class="math display">\[
\int_Zq(Z)\log q(Z)dZ=\int_Z\prod\limits_{i=1}^Mq_i(Z_i)\sum\limits_{i=1}^M\log q_i(Z_i)dZ
\]</span><br>
展开求和项第一项为：<br>
<span class="math display">\[
\int_Z\prod\limits_{i=1}^Mq_i(Z_i)\log q_1(Z_1)dZ=\int_{Z_1}q_1(Z_1)\log q_1(Z_1)dZ_1
\]</span><br>
所以：<br>
<span class="math display">\[
\int_Zq(Z)\log q(Z)dZ=\sum\limits_{i=1}^M\int_{Z_i}q_i(Z_i)\log q_i(Z_i)dZ_i=\int_{Z_j}q_j(Z_j)\log q_j(Z_j)dZ_j+Const
\]</span><br>
两项相减，令 <span class="math inline">\(\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]=\log \hat{p}(X,Z_j)\)</span> 可以得到：<br>
<span class="math display">\[
-\int_{Z_j}q_j(Z_j)\log\frac{q_j(Z_j)}{\hat{p}(X,Z_j)}dZ_j\le 0
\]</span><br>
于是最大的 <span class="math inline">\(q_j(Z_j)=\hat{p}(X,Z_j)\)</span> 才能得到最大值。我们看到，对每一个 <span class="math inline">\(q_j\)</span>，都是固定其余的 <span class="math inline">\(q_i\)</span>，求这个值，于是可以使用坐标上升的方法进行迭代求解，上面的推导针对单个样本，但是对数据集也是适用的。</p>
<p>基于平均场假设的变分推断存在一些问题：</p>
<ol type="1">
<li>假设太强，<span class="math inline">\(Z\)</span> 非常复杂的情况下，假设不适用</li>
<li>期望中的积分，可能无法计算</li>
</ol>
<h2 id="sgvi">SGVI</h2>
<p>从 <span class="math inline">\(Z\)</span> 到 <span class="math inline">\(X\)</span> 的过程叫做生成过程或译码，反过来的额过程叫推断过程或编码过程，基于平均场的变分推断可以导出坐标上升的算法，但是这个假设在一些情况下假设太强，同时积分也不一定能算。我们知道，优化方法除了坐标上升，还有梯度上升的方式，我们希望通过梯度上升来得到变分推断的另一种算法。</p>
<p>我们的目标函数：<br>
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span><br>
假定 <span class="math inline">\(q(Z)=q_\phi(Z)\)</span>，是和 <span class="math inline">\(\phi\)</span> 这个参数相连的概率分布。于是 <span class="math inline">\(\mathop{argmax}_{q(Z)}L(q)=\mathop{argmax}_{\phi}L(\phi)\)</span>，其中 <span class="math inline">\(L(\phi)=\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]\)</span>，这里 <span class="math inline">\(x^i\)</span> 表示第 <span class="math inline">\(i\)</span> 个样本。<br>
<span class="math display">\[
\begin{align*}\nabla_\phi L(\phi)&amp;=\nabla_\phi\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]\\
&amp;=\nabla_\phi\int q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz+\int q_\phi(z)\nabla_\phi [\log p_\theta(x^i,z)-\log q_\phi(z)]dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz-\int q_\phi(z)\nabla_\phi \log q_\phi(z)dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz-\int \nabla_\phi q_\phi(z)dz\\
&amp;=\int\nabla_\phi q_\phi(z)[\log p_\theta(x^i,z)-\log q_\phi(z)]dz\\
&amp;=\int q_\phi(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))dz\\
&amp;=\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))]
\end{align*}
\]</span><br>
这个期望可以通过蒙特卡洛采样来近似，从而得到梯度，然后利用梯度上升的方法来得到参数：<br>
<span class="math display">\[
\begin{gather*}
z^l\sim q_\phi(z)\\
\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))]\sim \frac{1}{L}\sum\limits_{l=1}^L(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))
\end{gather*}
\]</span><br>
但是由于求和符号中存在一个对数项，于是直接采样的方差很大，需要采样的样本非常多。为了解决方差太大的问题，我们采用 Reparameterization 的技巧。</p>
<p>考虑：<br>
<span class="math display">\[
\nabla_\phi L(\phi)=\nabla_\phi\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]
\]</span><br>
我们取：<span class="math inline">\(z=g_\phi(\varepsilon,x^i),\varepsilon\sim p(\varepsilon)\)</span>，于是对后验：<span class="math inline">\(z\sim q_\phi(z|x^i)\)</span>，有 <span class="math inline">\(|q_\phi(z|x^i)dz|=|p(\varepsilon)d\varepsilon|\)</span>。代入上面的梯度中：<br>
<span class="math display">\[
\begin{align*}
\nabla_\phi L(\phi)&amp;=\nabla_\phi\mathbb{E}_{q_\phi}[\log p_\theta(x^i,z)-\log q_\phi(z)]\\
&amp;=\nabla_\phi L(\phi)=\nabla_\phi\int[\log p_\theta(x^i,z)-\log q_\phi(z)]q_\phi dz\\
&amp;=\nabla_\phi\int[\log p_\theta(x^i,z)-\log q_\phi(z)]p_\varepsilon d\varepsilon\\
&amp;=\mathbb{E}_{p(\varepsilon)}[\nabla_\phi[\log p_\theta(x^i,z)-\log q_\phi(z)]]\\
&amp;=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log q_\phi(z)]\nabla_\phi z]\\
&amp;=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log q_\phi(z)]\nabla_\phi g_\phi(\varepsilon,x^i)]
\end{align*}
\]</span><br>
对这个式子进行蒙特卡洛采样，然后计算期望，得到梯度。</p>
<h1 id="马尔可夫链蒙特卡洛">马尔可夫链蒙特卡洛</h1>
<p>MCMC 是一种随机的近似推断，其核心就是基于采样的随机近似方法蒙特卡洛方法。对于采样任务来说，有下面一些常用的场景：</p>
<ol type="1">
<li>采样作为任务，用于生成新的样本</li>
<li>求和/求积分</li>
</ol>
<p>采样结束后，我们需要评价采样出来的样本点是不是好的样本集：</p>
<ol type="1">
<li>样本趋向于高概率的区域</li>
<li>样本之间必须独立</li>
</ol>
<p>具体采样中，采样是一个困难的过程：</p>
<ol type="1">
<li>无法采样得到归一化因子，即无法直接对概率 $ p(x)=(x)$ 采样，常常需要对 CDF 采样，但复杂的情况不行</li>
<li>如果归一化因子可以求得，但是对高维数据依然不能均匀采样（维度灾难），这是由于对 <span class="math inline">\(p\)</span> 维空间，总的状态空间是 <span class="math inline">\(K^p\)</span> 这么大，于是在这种情况下，直接采样也不行</li>
</ol>
<p>因此需要借助其他手段，如蒙特卡洛方法中的拒绝采样，重要性采样和 MCMC。</p>
<h2 id="蒙特卡洛方法">蒙特卡洛方法</h2>
<p>蒙特卡洛方法旨在求得复杂概率分布下的期望值：<span class="math inline">\(\mathbb{E}_{z|x}[f(z)]=\int p(z|x)f(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\)</span>，也就是说，从概率分布中取 <span class="math inline">\(N\)</span> 个点，从而近似计算这个积分。采样方法有：</p>
<ol type="1">
<li><p>概率分布采样，首先求得概率密度的累积密度函数 CDF，然后求得 CDF 的反函数，在0到1之间均匀采样，代入反函数，就得到了采样点。但是实际大部分概率分布不能得到 CDF。</p></li>
<li><p>Rejection Sampling 拒绝采样：对于概率分布 <span class="math inline">\(p(z)\)</span>，引入简单的提议分布 <span class="math inline">\(q(z)\)</span>，使得 <span class="math inline">\(\forall z_i,Mq(z_i)\ge p(z_i)\)</span>。我们先在 $ q(z)$ 中采样，定义接受率：<span class="math inline">\(\alpha=\frac{p(z^i)}{Mq(z^i)}\le1\)</span>。算法描述为：</p>
<ol type="1">
<li>取 <span class="math inline">\(z^i\sim q(z)\)</span>。</li>
<li>在均匀分布中选取 <span class="math inline">\(u\)</span>。</li>
<li>如果 <span class="math inline">\(u\le\alpha\)</span>，则接受 <span class="math inline">\(z^i\)</span>，否则，拒绝这个值。</li>
</ol></li>
<li><p>Importance Sampling：直接对期望：<span class="math inline">\(\mathbb{E}_{p(z)}[f(z)]\)</span> 进行采样。<br>
<span class="math display">\[
\mathbb{E}_{p(z)}[f(z)]=\int p(z)f(z)dz=\int \frac{p(z)}{q(z)}f(z)q(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span><br>
于是采样在 $ q(z)$ 中采样，并通过权重计算和。重要值采样对于权重非常小的时候，效率非常低。重要性采样有一个变种 Sampling-Importance-Resampling，这种方法，首先和上面一样进行采样，然后在采样出来的 <span class="math inline">\(N\)</span> 个样本中，重新采样，这个重新采样，使用每个样本点的权重作为概率分布进行采样。</p></li>
</ol>
<h2 id="mcmc">MCMC</h2>
<p>马尔可夫链式一种时间状态都是离散的随机变量序列。我们关注的主要是齐次的一阶马尔可夫链。马尔可夫链满足：<span class="math inline">\(p(X_{t+1}|X_1,X_2,\cdots,X_t)=p(X_{t+1}|X_t)\)</span>。这个式子可以写成转移矩阵的形式 <span class="math inline">\(p_{ij}=p(X_{t+1}=j|X_t=i)\)</span>。我们有：<br>
<span class="math display">\[
\pi_{t+1}(x^*)=\int\pi_i(x)p_{x\to x^*}dx
\]</span><br>
如果存在 <span class="math inline">\(\pi=(\pi(1),\pi(2),\cdots),\sum\limits_{i=1}^{+\infty}\pi(i)=1\)</span>，有上式成立，这个序列就叫马尔可夫链 <span class="math inline">\(X_t\)</span> 的平稳分布，平稳分布就是表示在某一个时刻后，分布不再改变。MCMC 就是通过构建马尔可夫链概率序列，使其收敛到平稳分布 <span class="math inline">\(p(z)\)</span>。引入细致平衡：<span class="math inline">\(\pi(x)p_{x\to x^*}=\pi(x^*)p_{x^*\to x}\)</span>。如果一个分布满足细致平衡，那么一定满足平稳分布（反之不成立）：<br>
<span class="math display">\[
\int\pi(x)p_{x\to x^*}dx=\int\pi(x^*)p_{x^*\to x}dx=\pi(x^*)
\]</span><br>
细致平衡条件将平稳分布的序列和马尔可夫链的转移矩阵联系在一起了，通过转移矩阵可以不断生成样本点。假定随机取一个转移矩阵 <span class="math inline">\((Q=Q_{ij})\)</span>，作为一个提议矩阵。我们有：<br>
<span class="math display">\[
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=p(z^*)\cdot Q_{z^*\to z}\alpha(z^*,z)
\]</span><br>
取 ：<br>
<span class="math display">\[
\alpha(z,z^*)=\min\{1,\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}\}
\]</span><br>
则<br>
<span class="math display">\[
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=\min\{p(z)Q_{z\to z^*},p(z^*)Q_{z^*\to z}\}=p(z^*)\cdot Q_{z^*\to z}\alpha(z^*,z)
\]</span><br>
于是，迭代就得到了序列，这个算法叫做 Metropolis-Hastings 算法：</p>
<ol type="1">
<li>通过在0，1之间均匀分布取点 <span class="math inline">\(u\)</span></li>
<li>生成 <span class="math inline">\(z^*\sim Q(z^*|z^{i-1})\)</span></li>
<li>计算 <span class="math inline">\(\alpha\)</span> 值</li>
<li>如果 <span class="math inline">\(\alpha\ge u\)</span>，则 <span class="math inline">\(z^i=z^*\)</span>，否则 <span class="math inline">\(z^{i}=z^{i-1}\)</span></li>
</ol>
<p>这样取的样本就服从 <span class="math inline">\(p(z)=\frac{\hat{p}(z)}{z_p}\sim \hat{p}(z)\)</span>。</p>
<p>下面介绍另一种采样方式 Gibbs 采样，如果 <span class="math inline">\(z\)</span> 的维度非常高，那么通过固定被采样的维度其余的维度来简化采样过程：<span class="math inline">\(z_i\sim p(z_i|z_{-i})\)</span>：</p>
<ol type="1">
<li>给定初始值 <span class="math inline">\(z_1^0,z_2^0,\cdots\)</span></li>
<li>在 <span class="math inline">\(t+1\)</span> 时刻，采样 <span class="math inline">\(z_i^{t+1}\sim p(z_i|z_{-i})\)</span>，从第一个维度一个个采样。</li>
</ol>
<p>Gibbs 采样方法是一种特殊的 MH 采样，可以计算 Gibbs 采样的接受率：<br>
<span class="math display">\[
\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}=\frac{p(z_i^*|z^*_{-i})p(z^*_{-i})p(z_i|z_{-i}^*)}{p(z_i|z_{-i})p(z_{-i})p(z_i^*|z_{-i})}
\]</span><br>
对于每个 Gibbs 采样步骤，<span class="math inline">\(z_{-i}=z_{-i}^*\)</span>，这是由于每个维度 <span class="math inline">\(i\)</span> 采样的时候，其余的参量保持不变。所以上式为1。于是 Gibbs 采样过程中，相当于找到了一个步骤，使得所有的接受率为 1。</p>
<h2 id="平稳分布">平稳分布</h2>
<p>定义随机矩阵：<br>
<span class="math display">\[
Q=\begin{pmatrix}Q_{11}&amp;Q_{12}&amp;\cdots&amp;Q_{1K}\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\Q_{k1}&amp;Q_{k2}&amp;\cdots&amp;Q_{KK}\end{pmatrix}
\]</span><br>
这个矩阵每一行或者每一列的和都是1。随机矩阵的特征值都小于等于1。假设只有一个特征值为 <span class="math inline">\(\lambda_i=1\)</span>。于是在马尔可夫过程中：<br>
<span class="math display">\[
q^{t+1}(x=j)=\sum\limits_{i=1}^Kq^t(x=i)Q_{ij}\\
\Rightarrow q^{t+1}=q^t\cdot Q=q^1Q^t
\]</span><br>
于是有：<br>
<span class="math display">\[
q^{t+1}=q^1A\Lambda^t A^{-1}
\]</span><br>
如果 <span class="math inline">\(m\)</span> 足够大，那么，<span class="math inline">\(\Lambda^m=diag(0,0,\cdots,1,\cdots,0)\)</span>，则：<span class="math inline">\(q^{m+1}=q^{m}\)</span> ，则趋于平稳分布了。马尔可夫链可能具有平稳分布的性质，所以我们可以构建马尔可夫链使其平稳分布收敛于需要的概率分布（设计转移矩阵）。</p>
<p>在采样过程中，需要经历一定的时间（燃烧期/混合时间）才能达到平稳分布。但是 MCMC 方法有一些问题：</p>
<ol type="1">
<li>无法判断是否已经收敛</li>
<li>燃烧期过长（维度太高，并且维度之间有关，可能无法采样到某些维度），例如在 GMM 中，可能无法采样到某些峰。于是在一些模型中，需要对隐变量之间的关系作出约束，如 RBM 假设隐变量之间无关。</li>
<li>样本之间一定是有相关性的，如果每个时刻都取一个点，那么每个样本一定和前一个相关，这可以通过间隔一段时间采样。</li>
</ol>
<h2 id="隐马尔可夫模型">隐马尔可夫模型</h2>
<p>隐马尔可夫模型是一种概率图模型。我们知道，机器学习模型可以从频率派和贝叶斯派两个方向考虑，在频率派的方法中的核心是优化问题，而在贝叶斯派的方法中，核心是积分问题，也发展出来了一系列的积分方法如变分推断，MCMC 等。概率图模型最基本的模型可以分为有向图（贝叶斯网络）和无向图（马尔可夫随机场）两个方面，例如 GMM，在这些基本的模型上，如果样本之间存在关联，可以认为样本中附带了时序信息，从而样本之间不独立全同分布的，这种模型就叫做动态模型，隐变量随着时间发生变化，于是观测变量也发生变化：</p>
<pre class="mermaid">graph LR;
    z1-->z2-->z3;</pre>
<p>根据状态变量的特点，可以分为：</p>
<ol type="1">
<li>HMM，状态变量（隐变量）是离散的</li>
<li>Kalman 滤波，状态变量是连续的，线性的</li>
<li>粒子滤波，状态变量是连续，非线性的</li>
</ol>
<h2 id="hmm">HMM</h2>
<p>HMM 用概率图表示为：</p>
<pre class="mermaid">graph TD;
t1-->t2;
subgraph four
    t4-->x4((x4))
end
subgraph three
    t3-->x3((x3))
end
subgraph two
    t2-->x2((x2))
end
subgraph one
    t1-->x1((x1))
end

t2-->t3;
t3-->t4;</pre>
<p>上图表示了四个时刻的隐变量变化。用参数 <span class="math inline">\(\lambda=(\pi,A,B)\)</span> 来表示，其中 <span class="math inline">\(\pi\)</span> 是开始的概率分布，<span class="math inline">\(A\)</span> 为状态转移矩阵，<span class="math inline">\(B\)</span> 为发射矩阵。</p>
<p>下面使用 $ o_t$ 来表示观测变量，<span class="math inline">\(O\)</span> 为观测序列，<span class="math inline">\(V=\{v_1,v_2,\cdots,v_M\}\)</span> 表示观测的值域，<span class="math inline">\(i_t\)</span> 表示状态变量，<span class="math inline">\(I\)</span> 为状态序列，<span class="math inline">\(Q=\{q_1,q_2,\cdots,q_N\}\)</span> 表示状态变量的值域。定义 <span class="math inline">\(A=(a_{ij}=p(i_{t+1}=q_j|i_t=q_i))\)</span> 表示状态转移矩阵，<span class="math inline">\(B=(b_j(k)=p(o_t=v_k|i_t=q_j))\)</span> 表示发射矩阵。</p>
<p>在 HMM 中，有两个基本假设：</p>
<ol type="1">
<li><p>齐次 Markov 假设（未来只依赖于当前）：<br>
<span class="math display">\[
p(i_{t+1}|i_t,i_{t-1},\cdots,i_1,o_t,o_{t-1},\cdots,o_1)=p(i_{t+1}|i_t)
\]</span></p></li>
<li><p>观测独立假设：<br>
<span class="math display">\[
p(o_t|i_t,i_{t-1},\cdots,i_1,o_{t-1},\cdots,o_1)=p(o_t|i_t)
\]</span></p></li>
</ol>
<p>HMM 要解决三个问题：</p>
<ol type="1">
<li>Evaluation：<span class="math inline">\(p(O|\lambda)\)</span>，Forward-Backward 算法</li>
<li>Learning：<span class="math inline">\(\lambda=\mathop{argmax}\limits_{\lambda}p(O|\lambda)\)</span>，EM 算法（Baum-Welch）</li>
<li>Decoding：<span class="math inline">\(I=\mathop{argmax}\limits_{I}p(I|O,\lambda)\)</span>，Vierbi 算法
<ol type="1">
<li>预测问题：<span class="math inline">\(p(i_{t+1}|o_1,o_2,\cdots,o_t)\)</span></li>
<li>滤波问题：<span class="math inline">\(p(i_t|o_1,o_2,\cdots,o_t)\)</span></li>
</ol></li>
</ol>
<h3 id="evaluation">Evaluation</h3>
<p><span class="math display">\[
p(O|\lambda)=\sum\limits_{I}p(I,O|\lambda)=\sum\limits_{I}p(O|I,\lambda)p(I|\lambda)
\]</span></p>
<p><span class="math display">\[
p(I|\lambda)=p(i_1,i_2,\cdots,i_t|\lambda)=p(i_t|i_1,i_2,\cdots,i_{t-1},\lambda)p(i_1,i_2,\cdots,i_{t-1}|\lambda)
\]</span></p>
<p>根据齐次 Markov 假设：<br>
<span class="math display">\[
p(i_t|i_1,i_2,\cdots,i_{t-1},\lambda)=p(i_t|i_{t-1})=a_{i_{t-1}i_t}
\]</span><br>
所以：<br>
<span class="math display">\[
p(I|\lambda)=\pi_1\prod\limits_{t=2}^Ta_{i_{t-1},i_t}
\]</span><br>
又由于：<br>
<span class="math display">\[
p(O|I,\lambda)=\prod\limits_{t=1}^Tb_{i_t}(o_t)
\]</span><br>
于是：<br>
<span class="math display">\[
p(O|\lambda)=\sum\limits_{I}\pi_{i_1}\prod\limits_{t=2}^Ta_{i_{t-1},i_t}\prod\limits_{t=1}^Tb_{i_t}(o_t)
\]</span><br>
我们看到，上面的式子中的求和符号是对所有的观测变量求和，于是复杂度为 <span class="math inline">\(O(N^T)\)</span>。</p>
<p>下面，记 <span class="math inline">\(\alpha_t(i)=p(o_1,o_2,\cdots,o_t,i_t=q_i|\lambda)\)</span>，所以，<span class="math inline">\(\alpha_T(i)=p(O,i_T=q_i|\lambda)\)</span>。我们看到：<br>
<span class="math display">\[
p(O|\lambda)=\sum\limits_{i=1}^Np(O,i_T=q_i|\lambda)=\sum\limits_{i=1}^N\alpha_T(i)
\]</span><br>
对 <span class="math inline">\(\alpha_{t+1}(j)\)</span>：<br>
<span class="math display">\[
\begin{align*}\alpha_{t+1}(j)&amp;=p(o_1,o_2,\cdots,o_{t+1},i_{t+1}=q_j|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_1,o_2,\cdots,o_{t+1},i_{t+1}=q_j,i_t=q_i|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_{t+1}|o_1,o_2,\cdots,i_{t+1}=q_j,i_t=q_i|\lambda)p(o_1,\cdots,o_t,i_t=q_i,i_{t+1}=q_j|\lambda)
\end{align*}
\]</span><br>
利用观测独立假设：<br>
<span class="math display">\[
\begin{align*}\alpha_{t+1}(j)&amp;=\sum\limits_{i=1}^Np(o_{t+1}|i_{t+1}=q_j)p(o_1,\cdots,o_t,i_t=q_i,i_{t+1}=q_j|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_{t+1}|i_{t+1}=q_j)p(i_{t+1}=q_j|o_1,\cdots,o_t,i_t=q_i,\lambda)p(o_1,\cdots,o_t,i_t=q_i|\lambda)\\
&amp;=\sum\limits_{i=1}^Nb_{j}(o_t)a_{ij}\alpha_t(i)
\end{align*}
\]</span><br>
上面利用了齐次 Markov 假设得到了一个递推公式，这个算法叫做前向算法。</p>
<p>还有一种算法叫做后向算法，定义 <span class="math inline">\(\beta_t(i)=p(o_{t+1},o_{t+1},\cdots，o_T|i_t=i,\lambda)\)</span>：<br>
<span class="math display">\[
\begin{align*}p(O|\lambda)&amp;=p(o_1,\cdots,o_T|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_1,o_2,\cdots,o_T,i_1=q_i|\lambda)\\
&amp;=\sum\limits_{i=1}^Np(o_1,o_2,\cdots,o_T|i_1=q_i,\lambda)\pi_i\\
&amp;=\sum\limits_{i=1}^Np(o_1|o_2,\cdots,o_T,i_1=q_i,\lambda)p(o_2,\cdots,o_T|i_1=q_i,\lambda)\pi_i\\
&amp;=\sum\limits_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)
\end{align*}
\]</span><br>
对于这个 <span class="math inline">\(\beta_1(i)\)</span>：<br>
<span class="math display">\[
\begin{align*}\beta_t(i)&amp;=p(o_{t+1},\cdots,o_T|i_t=q_i)\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1},o_{t+2},\cdots,o_T,i_{t+1}=q_j|i_t=q_i)\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1},\cdots,o_T|i_{t+1}=q_j,i_t=q_i)p(i_{t+1}=q_j|i_t=q_i)\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1},\cdots,o_T|i_{t+1}=q_j)a_{ij}\\
&amp;=\sum\limits_{j=1}^Np(o_{t+1}|o_{t+2},\cdots,o_T,i_{t+1}=q_j)p(o_{t+2},\cdots,o_T|i_{t+1}=q_j)a_{ij}\\
&amp;=\sum\limits_{j=1}^Nb_j(o_{t+1})a_{ij}\beta_{t+1}(j)
\end{align*}
\]</span><br>
于是后向地得到了第一项。</p>
<h3 id="learning">Learning</h3>
<p>为了学习得到参数的最优值，在 MLE 中：<br>
<span class="math display">\[
\lambda_{MLE}=\mathop{argmax}_\lambda p(O|\lambda)
\]</span><br>
我们采用 EM 算法（在这里也叫 Baum Welch 算法），用上标表示迭代：<br>
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}_{\theta}\int_z\log p(X,Z|\theta)p(Z|X,\theta^t)dz
\]</span><br>
其中，<span class="math inline">\(X\)</span> 是观测变量，<span class="math inline">\(Z\)</span> 是隐变量序列。于是：<br>
<span class="math display">\[
\lambda^{t+1}=\mathop{argmax}_\lambda\sum\limits_I\log p(O,I|\lambda)p(I|O,\lambda^t)\\
=\mathop{argmax}_\lambda\sum\limits_I\log p(O,I|\lambda)p(O,I|\lambda^t)
\]</span><br>
这里利用了 <span class="math inline">\(p(O|\lambda^t)\)</span> 和<span class="math inline">\(\lambda\)</span> 无关。将 Evaluation 中的式子代入：<br>
<span class="math display">\[
\sum\limits_I\log p(O,I|\lambda)p(O,I|\lambda^t)=\sum\limits_I[\log \pi_{i_1}+\sum\limits_{t=2}^T\log a_{i_{t-1},i_t}+\sum\limits_{t=1}^T\log b_{i_t}(o_t)]p(O,I|\lambda^t)
\]</span><br>
对 <span class="math inline">\(\pi^{t+1}\)</span>：<br>
<span class="math display">\[
\begin{align*}\pi^{t+1}&amp;=\mathop{argmax}_\pi\sum\limits_I[\log \pi_{i_1}p(O,I|\lambda^t)]\\
&amp;=\mathop{argmax}_\pi\sum\limits_I[\log \pi_{i_1}\cdot p(O,i_1,i_2,\cdots,i_T|\lambda^t)]
\end{align*}
\]</span><br>
上面的式子中，对 <span class="math inline">\(i_2,i_2,\cdots,i_T\)</span> 求和可以将这些参数消掉：<br>
<span class="math display">\[
\pi^{t+1}=\mathop{argmax}_\pi\sum\limits_{i_1}[\log \pi_{i_1}\cdot p(O,i_1|\lambda^t)]
\]</span><br>
上面的式子还有对 <span class="math inline">\(\pi\)</span> 的约束 <span class="math inline">\(\sum\limits_i\pi_i=1\)</span>。定义 Lagrange 函数：<br>
<span class="math display">\[
L(\pi,\eta)=\sum\limits_{i=1}^N\log \pi_i\cdot p(O,i_1=q_i|\lambda^t)+\eta(\sum\limits_{i=1}^N\pi_i-1)
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial L}{\partial\pi_i}=\frac{1}{\pi_i}p(O,i_1=q_i|\lambda^t)+\eta=0
\]</span><br>
对上式求和：<br>
<span class="math display">\[
\sum\limits_{i=1}^Np(O,i_1=q_i|\lambda^t)+\pi_i\eta=0\Rightarrow\eta=-p(O|\lambda^t)
\]</span><br>
所以：<br>
<span class="math display">\[
\pi_i^{t+1}=\frac{p(O,i_1=q_i|\lambda^t)}{p(O|\lambda^t)}
\]</span></p>
<h3 id="decoding">Decoding</h3>
<p>Decoding 问题表述为：<br>
<span class="math display">\[
I=\mathop{argmax}\limits_{I}p(I|O,\lambda)
\]</span><br>
我们需要找到一个序列，其概率最大，这个序列就是在参数空间中的一个路径，可以采用动态规划的思想。</p>
<p>定义：<br>
<span class="math display">\[
\delta_{t}(j)=\max\limits_{i_1,\cdots,i_{t-1}}p(o_1,\cdots,o_t,i_1,\cdots,i_{t-1},i_t=q_i)
\]</span><br>
于是：<br>
<span class="math display">\[
\delta_{t+1}(j)=\max\limits_{1\le i\le N}\delta_t(i)a_{ij}b_j(o_{t+1})
\]</span><br>
这个式子就是从上一步到下一步的概率再求最大值。记这个路径为：<br>
<span class="math display">\[
\psi_{t+1}(j)=\mathop{argmax}\limits_{1\le i\le N}\delta_t(i)a_{ij}
\]</span></p>
<h2 id="小结-5">小结</h2>
<p>HMM 是一种动态模型，是由混合树形模型和时序结合起来的一种模型（类似 GMM + Time）。对于类似 HMM 的这种状态空间模型，普遍的除了学习任务（采用 EM ）外，还有推断任务，推断任务包括：</p>
<ol type="1">
<li><p>译码 Decoding：<span class="math inline">\(p(z_1,z_2,\cdots,z_t|x_1,x_2,\cdots,x_t)\)</span></p></li>
<li><p>似然概率：<span class="math inline">\(p(X|\theta)\)</span></p></li>
<li><p>滤波：$ p(z_t|x_1,,x_t)$，Online<br>
<span class="math display">\[
p(z_t|x_{1:t})=\frac{p(x_{1:t},z_t)}{p(x_{1:t})}=C\alpha_t(z_t)
\]</span></p></li>
<li><p>平滑：<span class="math inline">\(p(z_t|x_1,\cdots,x_T)\)</span>，Offline<br>
<span class="math display">\[
p(z_t|x_{1:T})=\frac{p(x_{1:T},z_t)}{p(x_{1:T})}=\frac{\alpha_t(z_t)p(x_{t+1:T}|x_{1:t},z_t)}{p(x_{1:T})}
\]</span><br>
根据概率图的条件独立性，有：<br>
<span class="math display">\[
p(z_t|x_{1:T})=\frac{\alpha_t(z_t)p(x_{t+1:T}|z_t)}{p(x_{1:T})}=C\alpha_t(z_t)\beta_t(z_t)
\]</span><br>
这个算法叫做前向后向算法。</p></li>
<li><p>预测：<span class="math inline">\(p(z_{t+1},z_{t+2}|x_1,\cdots,x_t),p(x_{t+1},x_{t+2}|x_1,\cdots,x_t)\)</span><br>
<span class="math display">\[
p(z_{t+1}|x_{1:t})=\sum_{z_t}p(z_{t+1},z_t|x_{1:t})=\sum\limits_{z_t}p(z_{t+1}|z_t)p(z_t|x_{1:t})
\]</span></p>
<p><span class="math display">\[
p(x_{t+1}|x_{1:t})=\sum\limits_{z_{t+1}}p(x_{t+1},z_{t+1}|x_{1:t})=\sum\limits_{z_{t+1}}p(x_{t+1}|z_{t+1})p(z_{t+1}|x_{1:t})
\]</span></p></li>
</ol>
<h1 id="线性动态系统">线性动态系统</h1>
<p>HMM 模型适用于隐变量是离散的值的时候，对于连续隐变量的 HMM，常用线性动态系统描述线性高斯模型的态变量，使用粒子滤波来表述非高斯非线性的态变量。</p>
<p>LDS 又叫卡尔曼滤波，其中，线性体现在上一时刻和这一时刻的隐变量以及隐变量和观测之间：<br>
<span class="math display">\[
\begin{align*}
z_t&amp;=A\cdot z_{t-1}+B+\varepsilon\\
x_t&amp;=C\cdot z_t+D+\delta\\
\varepsilon&amp;\sim\mathcal{N}(0,Q)\\
\delta&amp;\sim\mathcal{N}(0,R)
\end{align*}
\]</span><br>
类比 HMM 中的几个参数：<br>
<span class="math display">\[
\begin{align*}
p(z_t|z_{t-1})&amp;\sim\mathcal{N}(A\cdot z_{t-1}+B,Q)\\
p(x_t|z_t)&amp;\sim\mathcal{N}(C\cdot z_t+D,R)\\
z_1&amp;\sim\mathcal{N}(\mu_1,\Sigma_1)
\end{align*}
\]</span><br>
在含时的概率图中，除了对参数估计的学习问题外，在推断任务中，包括译码，证据概率，滤波，平滑，预测问题，LDS 更关心滤波这个问题：<span class="math inline">\(p(z_t|x_1,x_2,\cdots,x_t)\)</span>。类似 HMM 中的前向算法，我们需要找到一个递推关系。<br>
<span class="math display">\[
p(z_t|x_{1:t})=p(x_{1:t},z_t)/p(x_{1:t})=Cp(x_{1:t},z_t)
\]</span><br>
对于 <span class="math inline">\(p(x_{1:t},z_t)\)</span>：<br>
<span class="math display">\[
\begin{align*}p(x_{1:t},z_t)&amp;=p(x_t|x_{1:t-1},z_t)p(x_{1:t-1},z_t)=p(x_t|z_t)p(x_{1:t-1},z_t)\\
&amp;=p(x_t|z_t)p(z_t|x_{1:t-1})p(x_{1:t-1})=Cp(x_t|z_t)p(z_t|x_{1:t-1})\\
\end{align*}
\]</span><br>
我们看到，右边除了只和观测相关的常数项，还有一项是预测任务需要的概率。对这个值：<br>
<span class="math display">\[
\begin{align*}
p(z_t|x_{1:t-1})&amp;=\int_{z_{t-1}}p(z_t,z_{t-1}|x_{1:t-1})dz_{t-1}\\
&amp;=\int_{z_{t-1}}p(z_t|z_{t-1},x_{1:t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}\\
&amp;=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}
\end{align*}
\]</span><br>
我们看到，这又化成了一个滤波问题。于是我们得到了一个递推公式：</p>
<ol type="1">
<li><span class="math inline">\(t=1\)</span>，<span class="math inline">\(p(z_1|x_1)\)</span>，称为 update 过程，然后计算 <span class="math inline">\(p(z_2|x_1)\)</span>，通过上面的积分进行，称为 prediction 过程。</li>
<li><span class="math inline">\(t=2\)</span>，<span class="math inline">\(p(z_2|x_2,x_1)\)</span> 和 <span class="math inline">\(p(z_3|x_1,x_2)\)</span></li>
</ol>
<p>我们看到，这个过程是一个 Online 的过程，对于我们的线性高斯假设，这个计算过程都可以得到解析解。</p>
<ol type="1">
<li><p>Prediction：<br>
<span class="math display">\[
p(z_t|x_{1:t-1})=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}=\int_{z_{t-1}}\mathcal{N}(Az_{t-1}+B,Q)\mathcal{N}(\mu_{t-1},\Sigma_{t-1})dz_{t-1}
\]</span><br>
其中第二个高斯分布是上一步的 Update 过程，所以根据线性高斯模型，直接可以写出这个积分：<br>
<span class="math display">\[
p(z_t|x_{1:t-1})=\mathcal{N}(A\mu_{t-1}+B,Q+A\Sigma_{t-1}A^T)
\]</span></p></li>
<li><p>Update:<br>
<span class="math display">\[
p(z_t|x_{1:t})\propto p(x_t|z_t)p(z_t|x_{1:t-1})
\]</span><br>
同样利用线性高斯模型，也可以直接写出这个高斯分布。</p></li>
</ol>
<h1 id="粒子滤波">粒子滤波</h1>
<p>Kalman 滤波根据线性高斯模型可以求得解析解，但是在非线性，非高斯的情况，是无法得到解析解的，对这类一般的情况，我们叫做粒子滤波，我们需要求得概率分布，需要采用采样的方式。</p>
<p>我们希望应用 Monte Carlo 方法来进行采样，对于一个概率分布，如果我们希望计算依这个分布的某个函数 <span class="math inline">\(f(z)\)</span> 的期望，可以利用某种抽样方法，在这个概率分布中抽取 <span class="math inline">\(N\)</span> 个样本，则 <span class="math inline">\(\mathbb{E}[f(z)]\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\)</span>。但是如果这个概率十分复杂，那么采样比较困难。对于复杂的概率分布，我们可以通过一个简单的概率分布 <span class="math inline">\(q(z)\)</span> 作为桥梁（重要值采样）:<br>
<span class="math display">\[
\mathbb{E}[f(z)]=\int_zf(z)p(z)dz=\int_zf(z)\frac{p(z)}{q(z)}q(z)dz=\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span><br>
于是直接通过对 <span class="math inline">\(q(z)\)</span> 采样，然后对每一个采样的样本应用权重就得到了期望的近似，当然为了概率分布的特性，我们需要对权重进行归一化。</p>
<p>在滤波问题中，需要求解 <span class="math inline">\(p(z_t|x_{1:t})\)</span>，其权重为：<br>
<span class="math display">\[
w_t^i=\frac{p(z_t^i|x_{1:t})}{q(z_t^i|x_{1:t})},i=1,2,\cdots,N
\]</span><br>
于是在每一个时刻 <span class="math inline">\(t\)</span>，都需要采样 <span class="math inline">\(N\)</span> 个点，但是即使采样了这么多点，分子上面的那一项也十分难求，于是希望找到一个关于权重的递推公式。为了解决这个问题，引入序列重要性采样（SIS）。</p>
<h2 id="sis">SIS</h2>
<p>在 SIS 中，解决的问题是 <span class="math inline">\(p(z_{1:t}|x_{1:t})\)</span>。<br>
<span class="math display">\[
w_t^i\propto\frac{p(z_{1:t}|x_{1:t})}{q(z_{1:t}|x_{1:t})}
\]</span><br>
根据 LDS 中的推导：<br>
<span class="math display">\[
\begin{align*}p(z_{1:t}|x_{1:t})\propto p(x_{1:t},z_{1:t})&amp;=p(x_t|z_{1:t},x_{1:t-1})p(z_{1:t},x_{1:t-1})\\
&amp;=p(x_t|z_t)p(z_t|x_{1:t-1},z_{1:t-1})p(x_{1:t-1},z_{1:t-1})\\
&amp;=p(x_t|z_t)p(z_t|z_{t-1})p(x_{1:t-1},z_{1:t-1})\\
&amp;\propto p(x_t|z_t)p(z_t|z_{t-1})p(z_{1:t-1}|x_{1:t-1})
\end{align*}
\]</span><br>
于是分子的递推式就得到了。对于提议分布的分母，可以取：<br>
<span class="math display">\[
q(z_{1:t}|x_{1:t})=q(z_t|z_{1:t-1},x_{1:t})q(z_{1:t-1}|x_{1:t-1})
\]</span><br>
所以有：<br>
<span class="math display">\[
w_t^i\propto\frac{p(z_{1:t}|x_{1:t})}{q(z_{1:t}|x_{1:t})}\propto \frac{p(x_t|z_t)p(z_t|z_{t-1})p(z_{1:t-1}|x_{1:t-1})}{q(z_t|z_{1:t-1},x_{1:t})q(z_{1:t-1}|x_{1:t-1})}=\frac{p(x_t|z_t)p(z_t|z_{t-1})}{q(z_t|z_{1:t-1},x_{1:t})}w_{t-1}^i
\]</span><br>
我们得到的对权重的算法为：</p>
<ol type="1">
<li><span class="math inline">\(t-1\)</span> 时刻，采样完成并计算得到权重</li>
<li>t 时刻，根据 <span class="math inline">\(q(z_t|z_{1:t-1},x_{1:t})\)</span> 进行采样得到 <span class="math inline">\(z_t^i\)</span>。然后计算得到 <span class="math inline">\(N\)</span> 个权重。</li>
<li>最后对权重归一化。</li>
</ol>
<p>SIS 算法会出现权值退化的情况，在一定时间后，可能会出现大部分权重都逼近0的情况，这是由于空间维度越来越高，需要的样本也越来越多。解决这个问题的方法有：</p>
<ol type="1">
<li>重采样，以权重作为概率分布，重新在已经采样的样本中采样，然后所有样本的权重相同，这个方法的思路是将权重作为概率分布，然后得到累积密度函数，在累积密度上取点（阶梯函数）。</li>
<li>选择一个合适的提议分布，<span class="math inline">\(q(z_t|z_{1:t-1},x_{1:t})=p(z_t|z_{t-1})\)</span>，于是就消掉了一项，并且采样的概率就是 <span class="math inline">\(p(z_t|z_{t-1})\)</span>，这就叫做生成与测试方法。</li>
</ol>
<p>采用重采样的 SIS 算法就是基本的粒子滤波算法。如果像上面那样选择提议分布，这个算法叫做 SIR 算法。</p>
<h1 id="条件随机场">条件随机场</h1>
<p>我们知道，分类问题可以分为硬分类和软分类两种，其中硬分类有 SVM，PLA，LDA 等。软分类问题大体上可以分为概率生成和概率判别模型，其中较为有名的概率判别模型有 Logistic 回归，生成模型有朴素贝叶斯模型。Logistic 回归模型的损失函数为交叉熵，这类模型也叫对数线性模型，一般地，又叫做最大熵模型，这类模型和指数族分布的概率假设是一致的。对朴素贝叶斯假设，如果将其中的单元素的条件独立性做推广到一系列的隐变量，那么，由此得到的模型又被称为动态模型，比较有代表性的如 HMM，从概率意义上，HMM也可以看成是 GMM 在时序上面的推广。</p>
<p>我们看到，一般地，如果将最大熵模型和 HMM相结合，那么这种模型叫做最大熵 Markov 模型（MEMM）：</p>
<pre class="mermaid">graph LR;
    x4((x4))-->y4
        x2((x2))-->y2
            x1((x1))-->y1
                x3((x3))-->y3
    y1-->y2;
    y2-->y3;
y3-->y4;</pre>
<p>这个图就是将 HMM 的图中观测变量和隐变量的边方向反向，应用在分类中，隐变量就是输出的分类，这样 HMM 中的两个假设就不成立了，特别是观测之间不是完全独立的了。</p>
<p>HMM 是一种生成式模型，其建模对象为 <span class="math inline">\(p(X,Y|\lambda)\)</span>，根据 HMM 的概率图，<span class="math inline">\(p(X,Y|\lambda)=\prod\limits_{t=1}^Tp(x_t,y_t|\lambda,y_{t-1})\)</span>。我们看到，观测独立性假设是一个很强的假设，如果我们有一个文本样本，那么观测独立性假设就假定了所有的单词之间没有关联。</p>
<p>在 MEMM 中，建模对象是 <span class="math inline">\(p(Y|X,\lambda)\)</span>，我们看概率图，给定 <span class="math inline">\(y_t\)</span>，<span class="math inline">\(x_t,x_{t-1}\)</span> 是不独立的，这样，观测独立假设就不成立了。根据概率图，<span class="math inline">\(p(Y|X,\lambda)=\prod\limits_{t=1}^Tp(y_t|y_{t-1},X,\lambda)\)</span>。</p>
<p>MEMM 的缺陷是其必须满足局域的概率归一化（Label Bias Problem），我们看到，在上面的概率图中，<span class="math inline">\(p(y_t|y_{t-1},x_t)\)</span>， 这个概率，如果 <span class="math inline">\(p(y_t|y_{t-1})\)</span> 非常接近1，那么事实上，观测变量是什么就不会影响这个概率了。</p>
<p>对于这个问题，我们将 <span class="math inline">\(y\)</span> 之间的箭头转为直线转为无向图（线性链条件随机场），这样就只要满足全局归一化了（破坏齐次 Markov 假设）。</p>
<pre class="mermaid">graph LR;
    x4((x4))-->y4
        x2((x2))-->y2
            x1((x1))-->y1
                x3((x3))-->y3
    y1---y2;
    y2---y3;
y3---y4;</pre>
<h2 id="crf-的-pdf">CRF 的 PDF</h2>
<p>线性链的 CRF 的 PDF 为 <span class="math inline">\(p(Y|X)=\frac{1}{Z}\exp\sum\limits_{t=1}^T(F_t(y_{t-1},y_t,x_{1:T}))\)</span>，两两形成了最大团，其中 <span class="math inline">\(y_0\)</span> 是随意外加的一个元素。作为第一个简化，我们假设每个团的势函数相同 <span class="math inline">\(F_t=F\)</span>。</p>
<p>对于这个 <span class="math inline">\(F\)</span>，我们进一步，可以将其写为 $ F(y_{t-1},y_t,X)=<em>{y</em>{t-1},X}+<em>{y</em>{t},X}+<em>{y_t,y</em>{t-1},X}$这三个部分，分别表示状态函数已经转移函数，由于整体的求和，可以简化为 $ F(y_{t-1},y_t,X)=<em>{y</em>{t},X}+<em>{y_t,y</em>{t-1},X}$。</p>
<p>我们可以设计一个表达式将其参数化：<br>
<span class="math display">\[
\begin{align*}
\Delta_{y_t,y_{t-1},X}&amp;=\sum\limits_{k=1}^K\lambda_kf_k(y_{t-1},y_t,X)\\
\Delta_{y_{t},X}&amp;=\sum\limits_{l=1}^L\eta_lg_l(y_t,X)
\end{align*}
\]</span><br>
其中 $g,f $ 叫做特征函数，对于 <span class="math inline">\(y\)</span> 有 <span class="math inline">\(S\)</span> 种元素，那么 <span class="math inline">\(K\le S^2,L\le S\)</span>。</p>
<p>代入概率密度函数中：<br>
<span class="math display">\[
p(Y|X)=\frac{1}{Z}\exp\sum\limits_{t=1}^T[\sum\limits_{k=1}^K\lambda_kf_k(y_{t-1},y_t,X)+\sum\limits_{l=1}^L\eta_lg_l(y_t,X)]
\]</span><br>
对于单个样本，将其写成向量的形式。定义 <span class="math inline">\(y=(y_1,y_2,\cdots,y_T)^T,x=(x_1,x_2,\cdots,x_T)^T,\lambda=(\lambda_1,\lambda_2,\cdots,\lambda_K)^T,\eta=(\eta_1,\eta_2,\cdots,\eta_L)^T\)</span>。并且有 <span class="math inline">\(f=(f_1,f_2,\cdots,f_K)^T,g=(g_1,g_2,\cdots,g_L)^T\)</span>。于是：<br>
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z}\exp\sum\limits_{t=1}^T[\lambda^Tf(y_{t-1},y_t,x)+\eta^Tg(y_t,x)]
\]</span><br>
不妨记：<span class="math inline">\(\theta=(\lambda,\eta)^T,H=(\sum\limits_{t=1}^Tf,\sum\limits_{t=1}^Tg)^T\)</span>：<br>
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z(x,\theta)}\exp[\theta^TH(y_t,y_{t-1},x)]
\]</span><br>
上面这个式子是一个指数族分布，于是 <span class="math inline">\(Z\)</span> 是配分函数。</p>
<p>CRF 需要解决下面几个问题：</p>
<ol type="1">
<li><p>Learning：参数估计问题，对 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(T\)</span> 维样本，<span class="math inline">\(\hat{\theta}=\mathop{argmax}\limits_{\theta}\prod\limits_{i=1}^Np(y^i|x^i)\)</span>，这里用上标表示样本的编号。</p></li>
<li><p>Inference：</p>
<ol type="1">
<li>边缘概率：<br>
<span class="math display">\[
p(y_t|x)
\]</span></li>
</ol></li>
<li><p>条件概率：一般在生成模型中较为关注，CRF 中不关注</p></li>
<li><p>MAP 推断：<br>
<span class="math display">\[
    \hat{y}=\mathop{argmax}p(y|x)
    \]</span></p></li>
</ol>
<h2 id="边缘概率">边缘概率</h2>
<p>边缘概率这个问题描述为，根据学习任务得到的参数，给定了 <span class="math inline">\(p(Y=y|X=x)\)</span>，求解 <span class="math inline">\(p(y_t=i|x)\)</span>。根据无向图可以给出：<br>
<span class="math display">\[
p(y_t=i|x)=\sum\limits_{y_{1:t-1},y_{t+1:T}}p(y|x)=\sum\limits_{y_{1:t-1}}\sum\limits_{y_{t+1:T}}\frac{1}{Z}\prod\limits_{t&#39;=1}^T\phi_{t&#39;}(y_{t&#39;-1},y_{t&#39;},x)
\]</span><br>
我们看到上面的式子，直接计算的复杂度很高，这是由于求和的复杂度在 <span class="math inline">\(O(S^T)\)</span>，求积的复杂度在 <span class="math inline">\(O(T)\)</span>，所以整体复杂度为 <span class="math inline">\(O(TS^T)\)</span>。我们需要调整求和符号的顺序，从而降低复杂度。</p>
<p>首先，将两个求和分为：<br>
<span class="math display">\[
\begin{align*}&amp;p(y_t=i|x)=\frac{1}{Z}\Delta_l\Delta_r\\
&amp;\Delta_l=\sum\limits_{y_{1:t-1}}\phi_{1}(y_0,y_1,x)\phi_2(y_1,y_2,x)\cdots\phi_{t-1}(y_{t-2},y_{t-1},x)\phi_t(y_{t-1},y_t=i,x)\\
&amp;\Delta_r=\sum\limits_{y_{t+1:T}}\phi_{t+1}(y_t=i,y_{t+1},x)\phi_{t+2}(y_{t+1},y_{t+2},x)\cdots\phi_T(y_{T-1},y_T,x)
\end{align*}
\]</span><br>
对于 <span class="math inline">\(\Delta_l\)</span>，从左向右，一步一步将 <span class="math inline">\(y_t\)</span> 消掉：<br>
<span class="math display">\[
\Delta_l=\sum\limits_{y_{t-1}}\phi_t(y_{t-1},y_t=i,x)\sum\limits_{y_{t-2}}\phi_{t-1}(y_{t-2},y_{t-1},x)\cdots\sum\limits_{y_0}\phi_1(y_0,y_1,x)
\]</span><br>
引入：<br>
<span class="math display">\[
\alpha_t(i)=\Delta_l
\]</span><br>
于是：<br>
<span class="math display">\[
\alpha_{t}(i)=\sum\limits_{j\in S}\phi_t(y_{t-1}=j,y_t=i,x)\alpha_{t-1}(j)
\]</span><br>
这样我们得到了一个递推式。</p>
<p>类似地，<span class="math inline">\(\Delta_r=\beta_t(i)=\sum\limits_{j\in S}\phi_{t+1}(y_t=i,y_{t+1}=j,x)\beta_{t+1}(j)\)</span>。这个方法和 HMM 中的前向后向算法类似，就是概率图模型中精确推断的变量消除算法（信念传播）。</p>
<h2 id="参数估计">参数估计</h2>
<p>在进行各种类型的推断之前，还需要对参数进行学习：<br>
<span class="math display">\[
\begin{align*}\hat{\theta}&amp;=\mathop{argmax}_{\theta}\prod\limits_{i=1}^Np(y^i|x^i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log p(y^i|x^i)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N[-\log Z(x^i,\lambda,\eta)+\sum\limits_{t=1}^T[\lambda^Tf(y_{t-1},y_t,x)+\eta^Tg(y_t,x)]]
\end{align*}
\]</span><br>
上面的式子中，第一项是对数配分函数，根据指数族分布的结论：<br>
<span class="math display">\[
\nabla_\lambda(\log Z(x^i,\lambda,\eta))=\mathbb{E}_{p(y^i|x^i)}[\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)]
\]</span><br>
其中，和 <span class="math inline">\(\eta\)</span> 相关的项相当于一个常数。求解这个期望值：<br>
<span class="math display">\[
\mathbb{E}_{p(y^i|x^i)}[\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)]=\sum\limits_{y}p(y|x^i)\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)
\]</span><br>
第一个求和号的复杂度为 <span class="math inline">\(O(S^T)\)</span>，重新排列求和符号：<br>
<span class="math display">\[
\begin{align*}\mathbb{E}_{p(y^i|x^i)}[\sum\limits_{t=1}^Tf(y_{t-1},y_t,x^i)]&amp;=\sum\limits_{t=1}^T\sum\limits_{y_{1:t-2}}\sum\limits_{y_{t-1}}\sum\limits_{y_t}\sum\limits_{y_{t+1:T}}p(y|x^i)f(y_{t-1},y_t,x^i)\\
&amp;=\sum\limits_{t=1}^T\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)
\end{align*}
\]</span><br>
和上面的边缘概率类似，也可以通过前向后向算法得到上面式子中的边缘概率。</p>
<p>于是：<br>
<span class="math display">\[
\nabla_\lambda L=\sum\limits_{i=1}^N\sum\limits_{t=1}^T[f(y_{t-1},y_t,x^i)-\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)]
\]</span><br>
利用梯度上升算法可以求解。对于 <span class="math inline">\(\eta\)</span> 也是类似的过程。</p>
<h2 id="译码">译码</h2>
<p>译码问题和 HMM 中的 Viterbi 算法类似，同样采样动态规划的思想一层一层求解最大值。</p>
<h1 id="高斯网络">高斯网络</h1>
<p>高斯图模型（高斯网络）是一种随机变量为连续的有向或者无向图。有向图版本的高斯图是高斯贝叶斯网络，无向版本的叫高斯马尔可夫网络。</p>
<p>高斯网络的每一个节点都是高斯分布：<span class="math inline">\(\mathcal{N}(\mu_i,\Sigma_i)\)</span>，于是所有节点的联合分布就是一个高斯分布，均值为 <span class="math inline">\(\mu\)</span>，方差为 <span class="math inline">\(\Sigma\)</span>。</p>
<p>对于边缘概率，我们有下面三个结论：</p>
<ol type="1">
<li><p>对于方差矩阵，可以得到独立性条件：<span class="math inline">\(x_i\perp x_j\Leftrightarrow\sigma_{ij}=0\)</span>，这个叫做全局独立性。</p></li>
<li><p>我们看方差矩阵的逆（精度矩阵或信息矩阵）：<span class="math inline">\(\Lambda=\Sigma^{-1}=(\lambda_{ij})_{pp}\)</span>，有定理：</p>
<blockquote>
<p><span class="math inline">\(x_i\perp x_j|(X-\{x_i,x_j\})\Leftrightarrow\lambda_{ij}=0\)</span></p>
</blockquote>
<p>因此，我们使用精度矩阵来表示条件独立性。</p></li>
<li><p>对于任意一个无向图中的节点 <span class="math inline">\(x_i\)</span>，<span class="math inline">\(x_i|(X-x_i)\sim \mathcal{N}(\sum\limits_{j\ne i}\frac{\lambda_{ij}}{\lambda_{ii}}x_j,\lambda_{ii}^{-1})\)</span></p>
<p>也就是其他所有分量的线性组合，即所有与它有链接的分量的线性组合。</p></li>
</ol>
<h2 id="高斯贝叶斯网络-gbn">高斯贝叶斯网络 GBN</h2>
<p>高斯贝叶斯网络可以看成是 LDS 的一个推广，LDS 的假设是相邻时刻的变量之间的依赖关系，因此是一个局域模型，而高斯贝叶斯网络，每一个节点的父亲节点不一定只有一个，因此可以看成是一个全局的模型。根据有向图的因子分解：<br>
<span class="math display">\[
p(x)=\prod\limits_{i=1}^pp(x_i|x_{Parents(i)})
\]</span><br>
对里面每一项，假设每一个特征是一维的，可以写成线性组合：<br>
<span class="math display">\[
p(x_i|x_{Parents(i)})=\mathcal{N}(x_i|\mu_i+W_i^Tx_{Parents(i)},\sigma^2_i)
\]</span><br>
将随机变量写成：<br>
<span class="math display">\[
x_i=\mu_i+\sum\limits_{j\in x_{Parents(i)}}w_{ij}(x_j-\mu_j)+\sigma_i\varepsilon_i,\varepsilon_i\sim \mathcal{N}(0,1)
\]</span><br>
写成矩阵形式，并且对 <span class="math inline">\(w\)</span> 进行扩展：<br>
<span class="math display">\[
x-\mu=W(x-\mu)+S\varepsilon
\]</span><br>
其中，<span class="math inline">\(S=diag(\sigma_i)\)</span>。所以有：<span class="math inline">\(x-\mu=(\mathbb{I}-W)^{-1}S\varepsilon\)</span></p>
<p>由于：<br>
<span class="math display">\[
Cov(x)=Cov(x-\mu)
\]</span><br>
可以得到协方差矩阵。</p>
<h2 id="高斯马尔可夫网络-gmn">高斯马尔可夫网络 GMN</h2>
<p>对于无向图版本的高斯网络，可以写成：<br>
<span class="math display">\[
p(x)=\frac{1}{Z}\prod\limits_{i=1}^p\phi_i(x_i)\prod\limits_{i,j\in X}\phi_{i,j}(x_i,x_j)
\]</span><br>
为了将高斯分布和这个式子结合，我们写出高斯分布和变量相关的部分：<br>
<span class="math display">\[
\begin{align*}p(x)&amp;\propto \exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))\\
&amp;=\exp(-\frac{1}{2}(x^T\Lambda x-2\mu^T\Lambda x+\mu^T\Lambda\mu))\\
&amp;=\exp(-\frac{1}{2}x^T\Lambda x+(\Lambda\mu)^Tx)
\end{align*}
\]</span><br>
可以看到，这个式子与无向图分解中的两个部分对应，我们记 <span class="math inline">\(h=\Lambda\mu\)</span>为 Potential Vector。其中和 <span class="math inline">\(x_i\)</span> 相关的为：<span class="math inline">\(x_i:-\frac{1}{2}\lambda_{ii}x_i^2+h_ix_i\)</span>，与 <span class="math inline">\(x_i,x_j\)</span> 相关的是：<span class="math inline">\(x_i,x_j:-\lambda_{ij}x_ix_j\)</span>，这里利用了精度矩阵为对称矩阵的性质。我们看到，这里也可以看出，<span class="math inline">\(x_i,x_j\)</span> 构成的一个势函数，只和 <span class="math inline">\(\lambda_{ij}\)</span> 有关，于是 $x_ix_j|(X-{x_i,x_j})_{ij}=0 $。</p>
<h1 id="贝叶斯线性回归">贝叶斯线性回归</h1>
<p>我们知道，线性回归当噪声为高斯分布的时候，最小二乘损失导出的结果相当于对概率模型应用 MLE，引入参数的先验时，先验分布是高斯分布，那么 MAP的结果相当于岭回归的正则化，如果先验是拉普拉斯分布，那么相当于 Lasso 的正则化。这两种方案都是点估计方法。我们希望利用贝叶斯方法来求解参数的后验分布。</p>
<p>线性回归的模型假设为：<br>
<span class="math display">\[
\begin{align*}f(x)=w^Tx
\\y=f(x)+\varepsilon\\
\varepsilon\sim\mathcal{N}(0,\sigma^2)
\end{align*}
\]</span><br>
在贝叶斯方法中，需要解决推断和预测两个问题。</p>
<h2 id="推断-1">推断</h2>
<p>引入高斯先验：<br>
<span class="math display">\[
p(w)=\mathcal{N}(0,\Sigma_p)
\]</span><br>
对参数的后验分布进行推断：<br>
<span class="math display">\[
p(w|X,Y)=\frac{p(w,Y|X)}{p(Y|X)}=\frac{p(Y|w,X)p(w|X)}{\int p(Y|w,X)p(w|X)dw}
\]</span><br>
分母和参数无关，由于 <span class="math inline">\(p(w|X)=p(w)\)</span>，代入先验得到：<br>
<span class="math display">\[
p(w|X,Y)\propto \prod\limits_{i=1}^N\mathcal{N}(y_i|w^Tx_i,\sigma^2)\cdot\mathcal{N}(0,\Sigma_p)
\]</span><br>
高斯分布取高斯先验的共轭分布依然是高斯分布，于是可以得到后验分布也是一个高斯分布。第一项：<br>
<span class="math display">\[
\begin{align*}\prod\limits_{i=1}^N\mathcal{N}(y_i|w^Tx_i,\sigma^2)&amp;=\frac{1}{(2\pi)^{N/2}\sigma^N}\exp(-\frac{1}{2\sigma^2}\sum\limits_{i=1}^N(y_i-w^Tx_i)^2)\\
&amp;=\frac{1}{(2\pi)^{N/2}\sigma^N}\exp(-\frac{1}{2}(Y-Xw)^T(\sigma^{-2}\mathbb{I})(Y-Xw))
\\&amp;=\mathcal{N}(Xw,\sigma^2\mathbb{I})
\end{align*}
\]</span><br>
代入上面的式子：<br>
<span class="math display">\[
p(w|X,Y)\propto\exp(-\frac{1}{2\sigma^2}(Y-Xw)^T\sigma^{-2}\mathbb{I}(Y-Xw)-\frac{1}{2}w^T\Sigma_p^{-1}w)
\]</span><br>
假定最后得到的高斯分布为：<span class="math inline">\(\mathcal{N}(\mu_w,\Sigma_w)\)</span>。对于上面的分布，采用配方的方式来得到最终的分布，指数上面的二次项为：<br>
<span class="math display">\[
-\frac{1}{2\sigma^2}w^TX^TXw-\frac{1}{2}w^T\Sigma_p^{-1}w
\]</span><br>
于是：<br>
<span class="math display">\[
\Sigma_w^{-1}=\sigma^{-2}X^TX+\Sigma_p^{-1}=A
\]</span><br>
一次项：<br>
<span class="math display">\[
\frac{1}{2\sigma^2}2Y^TXw=\sigma^{-2}Y^TXw
\]</span><br>
于是：<br>
<span class="math display">\[
\mu_w^T\Sigma_w^{-1}=\sigma^{-2}Y^TX\Rightarrow\mu_w=\sigma^{-2}A^{-1}X^TY
\]</span></p>
<h2 id="预测">预测</h2>
<p>给定一个 <span class="math inline">\(x^*\)</span>，求解 <span class="math inline">\(y^*\)</span>，所以 <span class="math inline">\(f(x^*)=x^{*T}w\)</span>，代入参数后验，有 <span class="math inline">\(x^{*T}w\sim \mathcal{N}(x^{*T}\mu_w,x^{*T}\Sigma_wx^*)\)</span>，添上噪声项：<br>
<span class="math display">\[
\begin{align*}
p(y^*|X,Y,x^*)&amp;=\int_wp(y^*|w,X,Y,x^*)p(w|X,Y,x^*)dw\\&amp;=\int_wp(y^*|w,x^*)p(w|X,Y)dw\\
&amp;=\mathcal{N}(x^{*T}\mu_w,x^{*T}\Sigma_wx^*+\sigma^2)
\end{align*}
\]</span></p>
<h1 id="高斯过程回归">高斯过程回归</h1>
<p>将一维高斯分布推广到多变量中就得到了高斯网络，将多变量推广到无限维，就得到了高斯过程，高斯过程是定义在连续域（时间空间）上的无限多个高维随机变量所组成的随机过程。</p>
<p>在时间轴上的任意一个点都满足高斯分布吗，将这些点的集合叫做高斯过程的一个样本。</p>
<blockquote>
<p>对于时间轴上的序列 <span class="math inline">\(\xi_t\)</span>，如果 <span class="math inline">\(\forall n\in N^+，t_i\in T\)</span>，有 <span class="math inline">\(\xi_{t_1-t_n}\sim \mathcal{N}(\mu_{t_1-t_n},\Sigma_{t_1-t_n})\)</span>， 那么 <span class="math inline">\(\{\xi_t\}_{t\in T}\)</span> 是一个高斯过程。</p>
<p>高斯过程有两个参数（高斯过程存在性定理），均值函数 <span class="math inline">\(m(t)=\mathbb{E}[\xi_t]\)</span> 和协方差函数 <span class="math inline">\(k(s,t)=\mathbb{E}[(\xi_s-\mathbb{E}[\xi_s])(\xi_t-\mathbb{E}[\xi_t])]\)</span>。</p>
</blockquote>
<p>我们将贝叶斯线性回归添加核技巧的这个模型叫做高斯过程回归，高斯过程回归分为两种视角：</p>
<ol type="1">
<li>权空间的视角-核贝叶斯线性回归，相当于 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(t\)</span>，在每个时刻的高斯分布来源于权重，根据上面的推导，预测的函数依然是高斯分布。</li>
<li>函数空间的视角-高斯分布通过函数 <span class="math inline">\(f(x)\)</span> 来体现。</li>
</ol>
<h2 id="核贝叶斯线性回归">核贝叶斯线性回归</h2>
<p>贝叶斯线性回归可以通过加入核函数的方法来解决非线性函数的问题，将 <span class="math inline">\(f(x)=x^Tw\)</span> 这个函数变为 <span class="math inline">\(f(x)=\phi(x)^Tw\)</span>（当然这个时候，$ _p$ 也要变为更高维度的），变换到更高维的空间，有：<br>
<span class="math display">\[
\begin{align*}f(x^*)\sim \mathcal{N}(\phi(x^*)^{T}\sigma^{-2}A^{-1}\Phi^TY,\phi(x^*)^{T}A^{-1}\phi(x^*))\\
A=\sigma^{-2}\Phi^T\Phi+\Sigma_p^{-1}
\end{align*}
\]</span><br>
其中，<span class="math inline">\(\Phi=(\phi(x_1),\phi(x_2),\cdots,\phi(x_N))^T\)</span>。</p>
<p>为了求解 <span class="math inline">\(A^{-1}\)</span>，可以利用 Woodbury Formula，<span class="math inline">\(A=\Sigma_p^{-1},C=\sigma^{-2}\mathbb{I}\)</span>：<br>
<span class="math display">\[
(A+UCV)^{-1}=A^{-1}-A^{-1}U(C^{-1}+VA^{-1}U)^{-1}VA^{-1}
\]</span><br>
所以 <span class="math inline">\(A^{-1}=\Sigma_p-\Sigma_p\Phi^T(\sigma^2\mathbb{I}+\Phi\Sigma_p\Phi^T)^{-1}\Phi\Sigma_p\)</span></p>
<p>也可以用另一种方法：<br>
<span class="math display">\[
\begin{align*}
A&amp;=\sigma^{-2}\Phi^T\Phi+\Sigma_p^{-1}\\
\Leftrightarrow A\Sigma_p&amp;=\sigma^{-2}\Phi^T\Phi\Sigma_p+\mathbb{I}\\
\Leftrightarrow A\Sigma_p\Phi^T&amp;=\sigma^{-2}\Phi^T\Phi\Sigma_p\Phi^T+\Phi^T=\sigma^{-2}\Phi^T(k+\sigma^2\mathbb{I})\\
\Leftrightarrow \Sigma_p\Phi^T&amp;=\sigma^{-2}A^{-1}\Phi^T(k+\sigma^2\mathbb{I})\\
\Leftrightarrow \sigma^{-2}A^{-1}\Phi^T&amp;=\Sigma_p\Phi^T(k+\sigma^2\mathbb{I})^{-1}\\
\Leftrightarrow \phi(x^*)^T\sigma^{-2}A^{-1}\Phi^T&amp;=\phi(x^*)^T\Sigma_p\Phi^T(k+\sigma^2\mathbb{I})^{-1}
\end{align*}
\]</span><br>
上面的左边的式子就是变换后的均值，而右边的式子就是不含 <span class="math inline">\(A^{-1}\)</span> 的式子，其中 <span class="math inline">\(k=\Phi\Sigma_p\Phi^T\)</span>。</p>
<p>根据 <span class="math inline">\(A^{-1}\)</span> 得到方差为：<br>
<span class="math display">\[
\phi(x^*)^T\Sigma_p\phi(x^*)-\phi(x^*)^T\Sigma_p\Phi^T(\sigma^2\mathbb{I}+k)^{-1}\Phi\Sigma_p\phi(x^*)
\]</span><br>
上面定义了：<br>
<span class="math display">\[
k=\Phi\Sigma_p\Phi^T
\]</span><br>
我们看到，在均值和方差中，含有下面四项：<br>
<span class="math display">\[
\phi(x^*)^T\Sigma_p\Phi^T,\phi(x^*)^T\Sigma_p\phi(x^*),\phi(x^*)^T\Sigma_p\Phi^T,\Phi\Sigma_p\phi(x^*)
\]</span><br>
展开后，可以看到，有共同的项：<span class="math inline">\(k(x,x&#39;)=\phi(x)^T\Sigma_p\phi(x‘)\)</span>。由于 <span class="math inline">\(\Sigma_p\)</span> 是正定对称的方差矩阵，所以，这是一个核函数。</p>
<p>对于高斯过程中的协方差：<br>
<span class="math display">\[
k(t,s)=Cov[f(x),f(x&#39;)]=\mathbb{E}[\phi(x)^Tww^T\phi(x&#39;)]=\phi(x)^T\mathbb{E}[ww^T]\phi(x&#39;)=\phi(x)^T\Sigma_p\phi(x&#39;)
\]</span><br>
我们可以看到，这个就对应着上面的核函数。因此我们看到 <span class="math inline">\(\{f(x)\}\)</span> 组成的组合就是一个高斯过程。</p>
<h2 id="函数空间的观点">函数空间的观点</h2>
<p>相比权重空间，我们也可以直接关注 <span class="math inline">\(f\)</span> 这个空间，对于预测任务，这就是类似于求：<br>
<span class="math display">\[
p(y^*|X,Y,x^*)=\int_fp(y^*|f,X,Y,x^*)p(f|X,Y,x^*)df
\]</span><br>
对于数据集来说，取 <span class="math inline">\(f(X)\sim\mathcal{N}(\mu(X),k(X,X)),Y=f(X)+\varepsilon\sim\mathcal{N}(\mu(X),k(X,X)+\sigma^2\mathbb{I})\)</span>。预测任务的目的是给定一个新数据序列 <span class="math inline">\(X^*=(x_1^*,\cdots,x_M^*)^T\)</span>，得到 <span class="math inline">\(Y^*=f(X^*)+\varepsilon\)</span>。我们可以写出：<br>
<span class="math display">\[
\begin{pmatrix}Y\\f(X^*)\end{pmatrix}\sim\mathcal{N}\left(\begin{pmatrix}\mu(X)\\\mu(X^*)\end{pmatrix},\begin{pmatrix}k(X,X)+\sigma^2\mathbb{I}&amp;k(X,X^*)\\k(X^*,X)&amp;k(X^*,X^*)\end{pmatrix}\right)
\]</span><br>
根据高斯分布的方法：<br>
<span class="math display">\[
\begin{align*}x=\begin{pmatrix}x_a\\x_b\end{pmatrix}\sim\mathcal{N}\left(\begin{pmatrix}\mu_a\\\mu_b\end{pmatrix},\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\right)\\
x_b|x_a\sim\mathcal{N}(\mu_{b|a},\Sigma_{b|a})\\
\mu_{b|a}=\Sigma_{ba}\Sigma_{aa}^{-1}(x_a-\mu_a)+\mu_b\\
\Sigma_{b|a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{align*}
\]</span><br>
可以直接写出：<br>
<span class="math display">\[
\begin{gather*}
p(f(X^*)|X,Y,X^*)=p(f(X^*)|Y)\\
=\mathcal{N}(k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{-1}(Y-\mu(X))+\mu(X^*),\\
k(X^*,X^*)-k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{1}k(X,X^*))
\end{gather*}
\]</span><br>
所以对于 <span class="math inline">\(Y=f(X^*)+\varepsilon\)</span>：<br>
<span class="math display">\[
\begin{gather*}
\mathcal{N}(k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{-1}(Y-\mu(X))+\mu(X^*),\\
k(X^*,X^*)-k(X^*,X)[k(X,X)+\sigma^2\mathbb{I}]^{1}k(X,X^*)+\sigma^2\mathbb{I})
\end{gather*}
\]</span><br>
我们看到，函数空间的观点更加简单易于求解。</p>
<h1 id="受限玻尔兹曼机">受限玻尔兹曼机</h1>
<p>玻尔兹曼机是一种存在隐节点的无向图模型。在图模型中最简单的是朴素贝叶斯模型（朴素贝叶斯假设），引入单个隐变量后，发展出了 GMM，如果单个隐变量变成序列的隐变量，就得到了状态空间模型（引入齐次马尔可夫假设和观测独立假设就有HMM，Kalman Filter，Particle Filter），为了引入观测变量之间的关联，引入了一种最大熵模型-MEMM，为了克服 MEMM 中的局域问题，又引入了 CRF，CRF 是一个无向图，其中，破坏了齐次马尔可夫假设，如果隐变量是一个链式结构，那么又叫线性链 CRF。</p>
<p>在无向图的基础上，引入隐变量得到了玻尔兹曼机，这个图模型的概率密度函数是一个指数族分布。对隐变量和观测变量作出一定的限制，就得到了受限玻尔兹曼机（RBM）。</p>
<p>我们看到，不同的概率图模型对下面几个特点作出假设：</p>
<ol type="1">
<li>方向-边的性质</li>
<li>离散/连续/混合-点的性质</li>
<li>条件独立性-边的性质</li>
<li>隐变量-节点的性质</li>
<li>指数族-结构特点</li>
</ol>
<p>将观测变量和隐变量分别记为 <span class="math inline">\(v,h,h=\{h_1,\cdots,h_m\},v=\{v_1,\cdots,v_n\}\)</span>。我们知道，无向图根据最大团的分解，可以写为玻尔兹曼分布的形式 <span class="math inline">\(p(x)=\frac{1}{Z}\prod\limits_{i=1}^K\psi_i(x_{ci})=\frac{1}{Z}\exp(-\sum\limits_{i=1}^KE(x_{ci}))\)</span>，这也是一个指数族分布。</p>
<p>一个玻尔兹曼机存在一系列的问题，在其推断任务中，想要精确推断，是无法进行的，想要近似推断，计算量过大。为了解决这个问题，一种简化的玻尔兹曼机-受限玻尔兹曼机作出了假设，所有隐变量内部以及观测变量内部没有连接，只在隐变量和观测变量之间有连接，这样一来：<br>
<span class="math display">\[
p(x)=p(h,v)=\frac{1}{Z}\exp(-E(v,h))
\]</span><br>
其中能量函数 <span class="math inline">\(E(v,h)\)</span> 可以写出三个部分，包括与节点集合相关的两项以及与边 <span class="math inline">\(w\)</span> 相关的一项，记为：<br>
<span class="math display">\[
E(v,h)=-(h^Twv+\alpha^T v+\beta^T h)
\]</span><br>
所以：<br>
<span class="math display">\[
p(x)=\frac{1}{Z}\exp(h^Twv)\exp(\alpha^T v)\exp(\beta^T h)=\frac{1}{Z}\prod_{i=1}^m\prod_{j=1}^n\exp(h_iw_{ij}v_j)\prod_{j=1}^n\exp(\alpha_jv_j)\prod_{i=1}^m\exp(\beta_ih_i)
\]</span><br>
上面这个式子也和 RBM 的因子图一一对应。</p>
<h2 id="推断-2">推断</h2>
<p>推断任务包括求后验概率 $ p(v|h),p(h|v)$ 以及求边缘概率 <span class="math inline">\(p(v)\)</span>。</p>
<h3 id="phv"><span class="math inline">\(p(h|v)\)</span></h3>
<p>对于一个无向图，满足局域的 Markov 性质，即 <span class="math inline">\(p(h_1|h-\{h_1\},v)=p(h_1|Neighbour(h_1))=p(h_1|v)\)</span>。我们可以得到：<br>
<span class="math display">\[
p(h|v)=\prod_{i=1}^mp(h_i|v)
\]</span><br>
考虑 Binary RBM，所有的隐变量只有两个取值 <span class="math inline">\(0,1\)</span>：<br>
<span class="math display">\[
p(h_l=1|v)=\frac{p(h_l=1,h_{-l},v)}{p(h_{-l},v)}=\frac{p(h_l=1,h_{-l},v)}{p(h_l=1,h_{-l},v)+p(h_l=0,h_{-l},v)}
\]</span><br>
将能量函数写成和 <span class="math inline">\(l\)</span> 相关或不相关的两项：<br>
<span class="math display">\[
E(v,h)=-(\sum\limits_{i=1,i\ne l}^m\sum\limits_{j=1}^nh_iw_{ij}v_j+h_l\sum\limits_{j=1}^nw_{lj}v_j+\sum\limits_{j=1}^n\alpha_j v_j+\sum\limits_{i=1,i\ne l}^m\beta_ih_i+\beta_lh_l)
\]</span><br>
定义：<span class="math inline">\(h_lH_l(v)=h_l\sum\limits_{j=1}^nw_{lj}v_j+\beta_lh_l,\overline{H}(h_{-l},v)=\sum\limits_{i=1,i\ne l}^m\sum\limits_{j=1}^nh_iw_{ij}v_j+\sum\limits_{j=1}^n\alpha_j v_j+\sum\limits_{i=1,i\ne l}^m\beta_ih_i\)</span>。</p>
<p>代入，有：<br>
<span class="math display">\[
p(h_l=1|v)=\frac{\exp(H_l(v)+\overline{H}(h_{-l},v))}{\exp(H_l(v)+\overline{H}(h_{-l},v))+\exp(\overline{H}(h_{-l},v))}=\frac{1}{1+\exp(-H_l(v))}=\sigma(H_l(v))
\]</span><br>
于是就得到了后验概率。对于 <span class="math inline">\(v\)</span> 的后验是对称的，所以类似的可以求解。</p>
<h3 id="pv"><span class="math inline">\(p(v)\)</span></h3>
<p><span class="math display">\[
\begin{align*}p(v)&amp;=\sum\limits_hp(h,v)=\sum\limits_h\frac{1}{Z}\exp(h^Twv+\alpha^Tv+\beta^Th)\\
&amp;=\exp(\alpha^Tv)\frac{1}{Z}\sum\limits_{h_1}\exp(h_1w_1v+\beta_1h_1)\cdots\sum\limits_{h_m}\exp(h_mw_mv+\beta_mh_m)\\
&amp;=\exp(\alpha^Tv)\frac{1}{Z}(1+\exp(w_1v+\beta_1))\cdots(1+\exp(w_mv+\beta_m))\\
&amp;=\frac{1}{Z}\exp(\alpha^Tv+\sum\limits_{i=1}^m\log(1+\exp(w_iv+\beta_i)))
\end{align*}
\]</span></p>
<p>其中，<span class="math inline">\(\log(1+\exp(x))\)</span> 叫做 Softplus 函数。</p>
<h1 id="谱聚类">谱聚类</h1>
<p>聚类问题可以分为两种思路：</p>
<ol type="1">
<li>Compactness，这类有 K-means，GMM 等，但是这类算法只能处理凸集，为了处理非凸的样本集，必须引入核技巧。</li>
<li>Connectivity，这类以谱聚类为代表。</li>
</ol>
<p>谱聚类是一种基于无向带权图的聚类方法。这个图用 <span class="math inline">\(G=(V,E)\)</span> 表示，其中 <span class="math inline">\(V=\{1,2,\cdots,N\}\)</span>，<span class="math inline">\(E=\{w_{ij}\}\)</span>，这里 <span class="math inline">\(w_{ij}\)</span> 就是边的权重，这里权重取为相似度，<span class="math inline">\(W=(w_{ij})\)</span> 是相似度矩阵，定义相似度（径向核）：<br>
<span class="math display">\[
\begin{gather*}
w_{ij}=k(x_i,x_j)=\exp(-\frac{||x_i-x_j||_2^2}{2\sigma^2}),(i,j)\in E\\
w_{ij}=0,(i,j)\notin E
\end{gather*}
\]</span><br>
下面定义图的分割，这种分割就相当于聚类的结果。定义 <span class="math inline">\(w(A,B)\)</span>：<br>
<span class="math display">\[
A\subset V,B\subset V,A\cap B=\emptyset,w(A,B)=\sum\limits_{i\in A,j\in B}w_{ij}
\]</span><br>
假设一共有 <span class="math inline">\(K\)</span> 个类别，对这个图的分割 <span class="math inline">\(CUT(V)=CUT(A_1,A_2,\cdots,A_K)=\sum\limits_{k=1}^Kw(A_k,\overline{A_k})=\sum\limits_{k=1}^K[w(A_k,V)-w(A_k,A_k)]\)</span></p>
<p>于是，我们的目标就是 <span class="math inline">\(\min\limits_{A_k}CUT(V)\)</span>。</p>
<p>为了平衡每一类内部的权重不同，我们做归一化的操作，定义每一个集合的度，首先，对单个节点的度定义：<br>
<span class="math display">\[
d_i=\sum\limits_{j=1}^Nw_{ij}
\]</span><br>
其次，每个集合：<br>
<span class="math display">\[
\Delta_k=degree(A_k)=\sum\limits_{i\in A_k}d_i
\]</span><br>
于是：<br>
<span class="math display">\[
N(CUT)=\sum\limits_{k=1}^K\frac{w(A_k,\overline{A_k})}{\sum\limits_{i\in A_k}d_i}
\]</span><br>
所以目标函数就是最小化这个式子。</p>
<p>谱聚类的模型就是：<br>
<span class="math display">\[
\{\hat{A}_k\}_{k=1}^K=\mathop{argmin}_{A_k}N(CUT)
\]</span><br>
引入指示向量：<br>
<span class="math display">\[
\left\{
\begin{align*}y_i\in \{0,1\}^K\\
\sum\limits_{j=1}^Ky_{ij}=1\end{align*}
\right.
\]</span><br>
其中，<span class="math inline">\(y_{ij}\)</span> 表示第 <span class="math inline">\(i\)</span> 个样本属于 <span class="math inline">\(j\)</span> 个类别，记：<span class="math inline">\(Y=(y_1,y_2,\cdots,y_N)^T\)</span>。所以：<br>
<span class="math display">\[
\hat{Y}=\mathop{argmin}_YN(CUT)
\]</span><br>
将 <span class="math inline">\(N(CUT)\)</span> 写成对角矩阵的形式，于是：<br>
<span class="math display">\[
\begin{align*}N(CUT)&amp;=Trace[diag(\frac{w(A_1,\overline{A_1})}{\sum\limits_{i\in A_1}d_i},\frac{w(A_2,\overline{A_2})}{\sum\limits_{i\in A_2}d_i},\cdots,\frac{w(A_K,\overline{A_K})}{\sum\limits_{i\in A_K}d_i})]\\
&amp;=Trace[diag(w(A_1,\overline{A_1}),w(A_2,\overline{A_2}),\cdots,w(A_K,\overline{A_K}))\cdot diag(\sum\limits_{i\in A_1}d_i,\cdots,\sum\limits_{i\in A_K}d_i)^{-1}]\\
&amp;=Trace[O\cdot P^{-1}]
\end{align*}
\]</span><br>
我们已经知道 <span class="math inline">\(Y,w\)</span> 这两个矩阵，我们希望求得 <span class="math inline">\(O,P\)</span>。</p>
<p>由于：<br>
<span class="math display">\[
Y^TY=\sum\limits_{i=1}^Ny_iy_i^T
\]</span><br>
对于 <span class="math inline">\(y_iy_i^T\)</span>，只在对角线上的 <span class="math inline">\(k\times k\)</span> 处为 1，所以：<br>
<span class="math display">\[
Y^TY=diag(N_1,N_2,\cdots,N_K)
\]</span><br>
其中，<span class="math inline">\(N_i\)</span> 表示有 <span class="math inline">\(N_i\)</span> 个样本属于 <span class="math inline">\(i\)</span>，即 <span class="math inline">\(N_k=\sum\limits_{k\in A_k}1\)</span>。</p>
<p>引入对角矩阵，根据 <span class="math inline">\(d_i\)</span> 的定义， <span class="math inline">\(D=diag(d_1,d_2,\cdots,d_N)=diag(w_{NN}\mathbb{I}_{N1})\)</span>，于是：<br>
<span class="math display">\[
P=Y^TDY
\]</span><br>
对另一项 <span class="math inline">\(O=diag(w(A_1,\overline{A_1}),w(A_2,\overline{A_2}),\cdots,w(A_K,\overline{A_K})\)</span>：<br>
<span class="math display">\[
O=diag(w(A_i,V))-diag(w(A_i,A_i))=diag(\sum\limits_{j\in A_i}d_j)-diag(w(A_i,A_i))
\]</span><br>
其中，第一项已知，第二项可以写成 <span class="math inline">\(Y^TwY\)</span>，这是由于：<br>
<span class="math display">\[
Y^TwY=\sum\limits_{i=1}^N\sum\limits_{j=1}^Ny_iy_j^Tw_{ij}
\]</span><br>
于是这个矩阵的第 <span class="math inline">\(lm\)</span> 项可以写为：<br>
<span class="math display">\[
\sum\limits_{i\in A_l,j\in A_m}w_{ij}
\]</span><br>
这个矩阵的对角线上的项和 <span class="math inline">\(w(A_i,A_i)\)</span> 相同，所以取迹后的取值不会变化。</p>
<p>所以：<br>
<span class="math display">\[
N(CUT)=Trace[(Y^T(D-w))Y)\cdot(Y^TDY)^{-1}]
\]</span><br>
其中，$ L=D-w$ 叫做拉普拉斯矩阵。</p>
<h1 id="前馈神经网络">前馈神经网络</h1>
<p>机器学习我们已经知道可以分为两大流派：</p>
<ol type="1">
<li><p>频率派，这个流派的方法叫做统计学习，根据具体问题有下面的算法：</p>
<ol type="1">
<li><p>正则化，L1，L2 等</p></li>
<li><p>核化，如核支撑向量机</p></li>
<li><p>集成化，AdaBoost，RandomForest</p></li>
<li><p>层次化，神经网络，神经网络有各种不同的模型，有代表性的有：</p>
<ol type="1">
<li>多层感知机</li>
<li>Autoencoder</li>
<li>CNN</li>
<li>RNN</li>
</ol>
<p>这几种模型又叫做深度神经网络。</p></li>
</ol></li>
<li><p>贝叶斯派，这个流派的方法叫概率图模型，根据图特点分为：</p>
<ol type="1">
<li>有向图-贝叶斯网络，加入层次化后有深度有向网络，包括
<ol type="1">
<li>Sigmoid Belief Network</li>
<li>Variational Autoencoder</li>
<li>GAN</li>
</ol></li>
<li>无向图-马尔可夫网络，加入层次化后有深度玻尔兹曼机。</li>
<li>混合，加入层次化后有深度信念网络</li>
</ol>
<p>这几个加入层次化后的模型叫做深度生成网络。</p></li>
</ol>
<p>从广义来说，深度学习包括深度生成网络和深度神经网络。</p>
<h2 id="from-pla-to-dl">From PLA to DL</h2>
<ul>
<li>1958，PLA</li>
<li>1969，PLA 不能解决 XOR 等非线性数据</li>
<li>1981，MLP，多层感知机的出现解决了上面的问题</li>
<li>1986，BP 算法应用在 MLP 上，RNN</li>
<li>1989，CNN，Univeral Approximation Theorem，但是于此同时，由于深度和宽度的相对效率不知道，并且无法解决 BP 算法的梯度消失问题</li>
<li>1993，1995，SVM + kernel，AdaBoost，RandomForest，这些算法的发展，DL 逐渐没落</li>
<li>1997，LSTM</li>
<li>2006，基于 RBM 的 深度信念网络和深度自编码</li>
<li>2009，GPU的发展</li>
<li>2011，在语音方面的应用</li>
<li>2012，ImageNet</li>
<li>2013，VAE</li>
<li>2014，GAN</li>
<li>2016，AlphaGo</li>
<li>2018，GNN</li>
</ul>
<p>DL 不是一个新的东西，其近年来的大发展主要原因如下：</p>
<ol type="1">
<li>数据量变大</li>
<li>分布式计算的发展</li>
<li>硬件算力的发展</li>
</ol>
<h2 id="非线性问题">非线性问题</h2>
<p>对于非线性的问题，有三种方法：</p>
<ol type="1">
<li>非线性转换，将低维空间转换到高维空间（Cover 定理），从而变为一个线性问题。</li>
<li>核方法，由于非线性转换是变换为高维空间，因此可能导致维度灾难，并且可能很难得到这个变换函数，核方法不直接寻找这个转换，而是寻找一个内积。</li>
<li>神经网络方法，将复合运算变为基本的线性运算的组合。</li>
</ol>
<h1 id="配分函数">配分函数</h1>
<p>在学习和推断中，对于一个概率的归一化因子很难处理，这个归一化因子和配分函数相关。假设一个概率分布：<br>
<span class="math display">\[
p(x|\theta)=\frac{1}{Z(\theta)}\hat{p}(x|\theta),Z(\theta)=\int\hat{p}(x|\theta)dx
\]</span></p>
<h2 id="包含配分函数的-mle">包含配分函数的 MLE</h2>
<p>在学习任务中，采用最大似然：<br>
<span class="math display">\[
\begin{align*}
\hat{\theta}&amp;=\mathop{argmax}_{\theta}p(x|\theta)=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log p(x_i|\theta)\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log \hat{p}(x|\theta)-N\log Z(\theta)\\
&amp;=\mathop{argmax}_{\theta}\frac{1}{N}\sum\limits_{i=1}^N\log \hat{p}(x|\theta)-\log Z(\theta)=\mathop{argmax}_\theta l(\theta)
\end{align*}
\]</span><br>
求导：<br>
<span class="math display">\[
\begin{align*}\nabla_\theta\log Z(\theta)&amp;=\frac{1}{Z(\theta)}\nabla_\theta Z(\theta)\\
&amp;=\frac{p(x|\theta)}{\hat{p}(x|\theta)}\int\nabla_\theta \hat{p}(x|\theta)dx\\
&amp;=\int\frac{p(x|\theta)}{\hat{p}(x|\theta)}\nabla_\theta\hat{p}(x|\theta)dx\\
&amp;=\mathbb{E}_{p(x|\theta)}[\nabla_\theta\log\hat{p}(x|\theta)]
\end{align*}
\]</span><br>
由于这个表达式和未知的概率相关，于是无法直接精确求解，需要近似采样，如果没有这一项，那么可以采用梯度下降，但是存在配分函数就无法直接采用梯度下降了。</p>
<p>上面这个期望值，是对模型假设的概率分布，定义真实概率分布为 <span class="math inline">\(p_{data}\)</span>，于是，<span class="math inline">\(l(\theta)\)</span> 中的第一项的梯度可以看成是从这个概率分布中采样出来的 <span class="math inline">\(N\)</span> 个点求和平均，可以近似期望值。<br>
<span class="math display">\[
\nabla_\theta l(\theta)=\mathbb{E}_{p_{data}}[\nabla_\theta\log\hat{p}(x|\theta)]-\mathbb{E}_{p(x|\theta)}[\nabla_\theta\log\hat{p}(x|\theta)]
\]</span><br>
于是，相当于真实分布和模型假设越接近越好。上面这个式子第一项叫做正相，第二项叫做负相。为了得到负相的值，需要采用各种采样方法，如 MCMC。</p>
<p>采样得到 <span class="math inline">\(\hat{x}_{1-m}\sim p_{model}(x|\theta^t)\)</span>，那么：<br>
<span class="math display">\[
\theta^{t+1}=\theta^t+\eta(\sum\limits_{i=1}^m\nabla_\theta \log \hat{p}(x_i|\theta^t)-\sum\limits_{i=1}^m\nabla_\theta\log \hat{p}(\hat{x_i}|\theta^t))
\]</span><br>
这个算法也叫做基于 MCMC 采样的梯度上升。每次通过采样得到的样本叫做幻想粒子，如果这些幻想粒子区域的概率高于实际分布，那么最大化参数的结果就是降低这些部分的概率。</p>
<h2 id="对比散度-cd-learning">对比散度-CD Learning</h2>
<p>上面对于负相的采样，最大的问题是，采样到达平稳分布的步骤数量是未知的。对比散度的方法，是对上述的采样是的初始值作出限制，直接采样 <span class="math inline">\(\hat{x}_i=x_i\)</span>，这样可以缩短采样的混合时间。这个算法叫做 CD-k 算法，<span class="math inline">\(k\)</span> 就是初始化后进行的演化时间，很多时候，即使 <span class="math inline">\(k=1\)</span> 也是可以的。</p>
<p>我们看 MLE 的表达式：<br>
<span class="math display">\[
\begin{align*}\hat{\theta}&amp;=\mathop{argmax}_{\theta}p(x|\theta)=\mathop{argmax}_{\theta}\frac{1}{N}\sum\limits_{i=1}^N\log p(x_i|\theta)=\mathbb{E}_{p_{data}}[\log p_{model}(x|\theta)]\\
&amp;=\mathop{argmax}_\theta\int p_{data}\log p_{model}dx\\
&amp;=\mathop{argmax}_\theta\int p_{data}\log \frac{p_{model}}{p_{data}}dx\\
&amp;=\mathop{argmin}_\theta KL(p_{data}||p_{model})
\end{align*}
\]</span><br>
对于 CD-k 的采样过程，可以将初始值这些点表示为：<br>
<span class="math display">\[
p^0=p_{data}
\]</span><br>
而我们的模型需要采样过程达到平稳分布：<br>
<span class="math display">\[
p^\infty=p_{model}
\]</span><br>
因此，我们需要的是 <span class="math inline">\(KL(p^0||p^\infty)\)</span>。定义 CD：<br>
<span class="math display">\[
KL(p^0||p^\infty)-KL(p^k||p^\infty)
\]</span><br>
这就是 CD-k 算法第 <span class="math inline">\(k\)</span> 次采样的目标函数。</p>
<h2 id="rbm-的学习问题">RBM 的学习问题</h2>
<p>RBM 的参数为：<br>
<span class="math display">\[
\begin{align*}
h=(h_1,\cdots,h_m)^T\\
v=(v_1,\cdots,v_n)^T\\
w=(w_{ij})_{mn}\\
\alpha=(\alpha_1,\cdots,\alpha_n)^T\\
\beta=(\beta_1,\cdots,\beta_m)^T
\end{align*}
\]</span><br>
学习问题关注的概率分布为：<br>
<span class="math display">\[
\begin{align*}
\log p(v)&amp;=\log\sum\limits_{h}p(h,v)\\
&amp;=\log\sum\limits_h\frac{1}{Z}\exp(-E(v,h))\\
&amp;=\log\sum\limits_{h}\exp(-E(v,h))-\log\sum\limits_{v,h}\exp(-E(h,v))
\end{align*}
\]</span><br>
对上面这个式子求导第一项：<br>
<span class="math display">\[
\begin{align*}
\frac{\partial \log\sum\limits_{h}\exp(-E(v,h))}{\partial\theta}&amp;=-\frac{\sum\limits_h\exp(-E(v,h))\frac{\partial E(v,h)}{\partial\theta}}{\sum\limits_{h}\exp(-E(v,h))}\\
&amp;=-\sum\limits_h\frac{\exp(-E(v,h))\frac{\partial E(v,h)}{\partial\theta}}{\sum\limits_{h}\exp(-E(v,h))}\\&amp;=-\sum\limits_hp(h|v)\frac{\partial E(v,h)}{\partial\theta}
\end{align*}
\]</span><br>
第二项：<br>
<span class="math display">\[
\frac{\partial \log\sum\limits_{v,h}\exp(-E(h,v))}{\partial\theta}=-\sum\limits_{h,v}\frac{\exp(-E(v,h))\frac{\partial E(v,h)}{\partial\theta}}{\sum\limits_{h,v}\exp(-E(v,h))}=-\sum\limits_{v,h}p(v,h)\frac{\partial E(v,h)}{\partial\theta}
\]</span><br>
所以有：<br>
<span class="math display">\[
\frac{\partial}{\partial\theta}\log p(v)=-\sum\limits_hp(h|v)\frac{\partial E(v,h)}{\partial\theta}+\sum\limits_{v,h}p(v,h)\frac{\partial E(v,h)}{\partial\theta}
\]</span><br>
将 RBM 的模型假设代入：<br>
<span class="math display">\[
E(v,h)=-(h^Twv+\alpha^Tv+\beta^Th)
\]</span></p>
<ol type="1">
<li><p><span class="math inline">\(w_{ij}\)</span>：<br>
<span class="math display">\[
\frac{\partial}{\partial w_{ij}}E(v,h)=-h_iv_j
\]</span><br>
于是：<br>
<span class="math display">\[
\frac{\partial}{\partial\theta}\log p(v)=\sum\limits_{h}p(h|v)h_iv_j-\sum\limits_{h,v}p(h,v)h_iv_j
\]</span><br>
第一项：<br>
<span class="math display">\[
\sum\limits_{h_1,h_2,\cdots,h_m}p(h_1,h_2,\cdots,h_m|v)h_iv_j=\sum\limits_{h_i}p(h_i|v)h_iv_j=p(h_i=1|v)v_j
\]</span><br>
这里假设了 <span class="math inline">\(h_i\)</span> 是二元变量。</p>
<p>第二项：<br>
<span class="math display">\[
\sum\limits_{h,v}p(h,v)h_iv_j=\sum\limits_{h,v}p(v)p(h|v)h_iv_j=\sum\limits_vp(v)p(h_i=1|v)v_j
\]</span><br>
这个求和是指数阶的，于是需要采样解决，我么使用 CD-k 方法。</p>
<p>对于第一项，可以直接使用训练样本得到，第二项采用 CD-k 采样方法，首先使用样本 <span class="math inline">\(v^0=v\)</span>，然后采样得到 <span class="math inline">\(h^0\)</span>，然后采样得到 <span class="math inline">\(v^1\)</span>，这样顺次进行，最终得到 <span class="math inline">\(v^k\)</span>，对于每个样本都得到一个 <span class="math inline">\(v^k\)</span>，最终采样得到 <span class="math inline">\(N\)</span> 个 $v^k $，于是第二项就是：<br>
<span class="math display">\[
p(h_i=1|v^k)v_j^k
\]</span><br>
具体的算法为：</p>
<ol type="1">
<li>对每一个样本中的 <span class="math inline">\(v\)</span>，进行采样：
<ol type="1">
<li>使用这个样本初始化采样</li>
<li>进行 <span class="math inline">\(k\)</span> 次采样（0-k-1）：
<ol type="1">
<li><span class="math inline">\(h_i^l\sim p(h_i|v^l)\)</span></li>
<li><span class="math inline">\(v_i^{l+1}\sim p(v_i|h^l)\)</span></li>
</ol></li>
<li>将这些采样出来的结果累加进梯度中</li>
</ol></li>
<li>重复进行上述过程，最终的梯度除以 <span class="math inline">\(N\)</span></li>
</ol></li>
</ol>
<h1 id="近似推断">近似推断</h1>
<p>这一讲中的近似推断具体描述在深度生成模型中的近似推断。推断的目的有下面几个部分：</p>
<ol type="1">
<li>推断本身，根据结果（观测）得到原因（隐变量）。</li>
<li>为参数的学习提供帮助。</li>
</ol>
<p>但是推断本身是一个困难的额任务，计算复杂度往往很高，对于无向图，由于节点之间的联系过多，那么因子分解很难进行，并且相互之间都有耦合，于是很难求解，仅仅在某些情况如 RBM 中可解，在有向图中，常常由于条件独立性问题，如两个节点之间条件相关（explain away），于是求解这些节点的条件概率就很困难，仅仅在某些概率假设情况下可解如高斯模型，于是需要近似推断。</p>
<p>事实上，我们常常讲推断问题变为优化问题，即：<br>
<span class="math display">\[
Log-likehood:\sum\limits_{v\in V}\log p(v)
\]</span><br>
对上面这个问题，由于：<br>
<span class="math display">\[
\log p(v)=\log\frac{p(v,h)}{p(h|v)}=\log\frac{p(v,h)}{q(h|v)}+\log\frac{q(h|v)}{p(h|v)}
\]</span><br>
左右两边对 <span class="math inline">\(h\)</span> 积分：<br>
<span class="math display">\[
\int_h\log p(v)\cdot q(h|v)dh=\log p(v)
\]</span><br>
右边积分有：<br>
<span class="math display">\[
\mathbb{E}_{q(h|v)}[\log\frac{p(v,h)}{q(h|v)}]+KL(q(h|v)||p(h|v))=\mathbb{E}_{q(h|v)}[\log p(v,h)]+H(q)+KL(q||p)
\]</span><br>
其中前两项是 ELBO，于是这就变成一个优化 ELBO 的问题。</p>
<h1 id="总结">总结</h1>
<h2 id="math">Math</h2>
<ol type="1">
<li><p>MLE<br>
<span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits _{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span></p></li>
<li><p>MAP<br>
<span class="math display">\[
\theta_{MAP}=\mathop{argmax}\limits _{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot p(\theta)
\]</span></p></li>
<li><p>Gaussian Distribution<br>
<span class="math display">\[
\begin{align*}&amp;p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}\\
&amp;\Delta=(x-\mu)^{T}\Sigma^{-1}(x-\mu)=\sum\limits _{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu)=\sum\limits _{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}}
\end{align*}
\]</span></p></li>
<li><p>已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma), y\sim Ax+b\)</span>，有：<br>
<span class="math display">\[
\begin{align*}y\sim\mathcal{N}(A\mu+b, A\Sigma A^T)
\end{align*}
\]</span></p></li>
<li><p>记 <span class="math inline">\(x=(x_1, x_2,\cdots,x_p)^T=(x_{a,m\times 1}, x_{b,n\times1})^T,\mu=(\mu_{a,m\times1}, \mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)</span>，已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma)\)</span>，则：<br>
<span class="math display">\[
\begin{align*}&amp;x_a\sim\mathcal{N}(\mu_a,\Sigma_{aa})\\
&amp;x_b|x_a\sim\mathcal{N}(\mu_{b|a},\Sigma_{b|a})\\
&amp;\mu_{b|a}=\Sigma_{ba}\Sigma_{aa}^{-1}(x_a-\mu_a)+\mu_b\\
&amp;\Sigma_{b|a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{align*}
\]</span></p></li>
</ol>
<h2 id="linear-regression">Linear Regression</h2>
<h3 id="model">Model</h3>
<ol type="1">
<li><p>Dataset:<br>
<span class="math display">\[
\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}
\]</span></p></li>
<li><p>Notation:<br>
<span class="math display">\[
X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T
\]</span></p></li>
<li><p>Model:<br>
<span class="math display">\[
f(w)=w^Tx
\]</span></p></li>
</ol>
<h3 id="loss-function">Loss Function</h3>
<ol type="1">
<li>最小二乘误差/高斯噪声的MLE<br>
<span class="math display">\[
L(w)=\sum\limits_{i=1}^N||w^Tx_i-y_i||^2_2
\]</span></li>
</ol>
<h3 id="闭式解">闭式解</h3>
<p><span class="math display">\[
\begin{align*}\hat{w}=(X^TX)^{-1}X^TY=X^+Y\\
X=U\Sigma V^T\\
X^+=V\Sigma^{-1}U^T
\end{align*}
\]</span></p>
<h3 id="正则化-1">正则化</h3>
<p><span class="math display">\[
\begin{align*}
L1-Gaussian \ priori&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||_1,\lambda\gt0\\
L2-Laplasian\ priori-Sparsity&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||^2_2,\lambda \gt 0
\end{align*}
\]</span></p>
<h2 id="linear-classification">Linear Classification</h2>
<h3 id="hard">Hard</h3>
<h4 id="pca">PCA</h4>
<ol type="1">
<li><p>Idea: 在线性模型上加入激活函数</p></li>
<li><p>Loss Function:</p></li>
</ol>
<p><span class="math display">\[
L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i
\]</span></p>
<ol start="3" type="1">
<li>Parameters:</li>
</ol>
<p><span class="math display">\[
w^{t+1}\leftarrow w^{t}+\lambda y_ix_i
\]</span></p>
<h4 id="fisher">Fisher</h4>
<ol type="1">
<li><p>Idea: 投影，类内小，类间大。</p></li>
<li><p>Loss Function:<br>
<span class="math display">\[
\begin{align*}&amp;J(w)=\frac{w^TS_bw}{w^TS_ww}\\
&amp;S_b=(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^T\\
&amp;S_w=S_1+S_2
\end{align*}
\]</span></p></li>
<li><p>闭式解，投影方向:<br>
<span class="math display">\[
S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})
\]</span></p></li>
</ol>
<h3 id="soft">Soft</h3>
<h4 id="判别模型">判别模型</h4>
<h5 id="logistic-regression">Logistic Regression</h5>
<ol type="1">
<li><p>Idea，激活函数:<br>
<span class="math display">\[
\begin{align*}p(C_1|x)&amp;=\frac{1}{1+\exp(-a)}\\
a&amp;=w^Tx
\end{align*}
\]</span></p></li>
<li><p>Loss Function(交叉熵):<br>
<span class="math display">\[
\hat{w}=\mathop{argmax}_wJ(w)=\mathop{argmax}_w\sum\limits_{i=1}^N(y_i\log p_1+(1-y_i)\log p_0)
\]</span></p></li>
<li><p>解法，SGD<br>
<span class="math display">\[
J&#39;(w)=\sum\limits_{i=1}^N(y_i-p_1)x_i
\]</span></p></li>
</ol>
<h4 id="生成模型">生成模型</h4>
<h5 id="gda">GDA</h5>
<ol type="1">
<li><p>Model</p>
<ol type="1">
<li><span class="math inline">\(y\sim Bernoulli(\phi)\)</span></li>
<li><span class="math inline">\(x|y=1\sim\mathcal{N}(\mu_1,\Sigma)\)</span></li>
<li><span class="math inline">\(x|y=0\sim\mathcal{N}(\mu_0,\Sigma)\)</span></li>
</ol></li>
<li><p>MAP<br>
<span class="math display">\[
\begin{align*}
&amp;\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)\\
&amp;=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log \mathcal{N}(\mu_1,\Sigma)+y_i\log\phi+(1-y_i)\log(1-\phi))
\end{align*}
\]</span></p></li>
<li><p>解<br>
<span class="math display">\[
\begin{align*}\phi&amp;=\frac{N_1}{N}\\
\mu_1&amp;=\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1}\\
\mu_0&amp;=\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0}\\
\Sigma&amp;=\frac{N_1S_1+N_2S_2}{N}
\end{align*}
\]</span></p></li>
</ol>
<h5 id="naive-bayesian">Naive Bayesian</h5>
<ol type="1">
<li><p>Model, 对单个数据点的各个维度作出限制<br>
<span class="math display">\[
x_i\perp x_j|y,\forall\  i\ne j
\]</span></p>
<ol type="1">
<li><span class="math inline">\(x_i\)</span> 为连续变量：<span class="math inline">\(p(x_i|y)=\mathcal{N}(\mu_i,\sigma_i^2)\)</span></li>
<li><span class="math inline">\(x_i\)</span> 为离散变量：类别分布（Categorical）：<span class="math inline">\(p(x_i=i|y)=\theta_i,\sum\limits_{i=1}^K\theta_i=1\)</span></li>
<li><span class="math inline">\(p(y)=\phi^y(1-\phi)^{1-y}\)</span></li>
</ol></li>
<li><p>解：和GDA相同</p></li>
</ol>
<h2 id="dimension-reduction">Dimension Reduction</h2>
<p>中心化：<br>
<span class="math display">\[
\begin{align*}S
&amp;=\frac{1}{N}X^T(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})^TX\\
&amp;=\frac{1}{N}X^TH^2X=\frac{1}{N}X^THX
\end{align*}
\]</span></p>
<h3 id="pca-1">PCA</h3>
<ol type="1">
<li><p>Idea: 坐标变换，寻找线性无关的新基矢，取信息损失最小的前几个维度</p></li>
<li><p>Loss Function:<br>
<span class="math display">\[
\begin{align*}J
&amp;=\sum\limits_{j=1}^qu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align*}
\]</span></p></li>
<li><p>解：</p>
<ol type="1">
<li><p>特征分解法<br>
<span class="math display">\[
S=U\Lambda U^T
\]</span></p></li>
<li><p>SVD for X/S<br>
<span class="math display">\[
\begin{align*}HX=U\Sigma V^T\\
S=\frac{1}{N}V\Sigma^T\Sigma V^T
\\new\ co=HX\cdot V\end{align*}
\]</span></p></li>
<li><p>SVD for T<br>
<span class="math display">\[
\begin{align*}T=HXX^TH=U\Sigma\Sigma^TU^T\\
new\ co=U\Sigma
\end{align*}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="p-pca-1">p-PCA</h3>
<ol type="1">
<li><p>Model:<br>
<span class="math display">\[
\begin{align*}
z&amp;\sim\mathcal{N}(\mathbb{O}_{q1},\mathbb{I}_{qq})\\
x&amp;=Wz+\mu+\varepsilon\\
\varepsilon&amp;\sim\mathcal{N}(0,\sigma^2\mathbb{I}_{pp})
\end{align*}
\]</span></p></li>
<li><p>Learning: E-M</p></li>
<li><p>Inference:<br>
<span class="math display">\[
p(z|x)=\mathcal{N}(W^T(WW^T+\sigma^2\mathbb{I})^{-1}(x-\mu),\mathbb{I}-W^T(WW^T+\sigma^2\mathbb{I})^{-1}W)
\]</span></p></li>
</ol>
<h2 id="svm">SVM</h2>
<ol type="1">
<li>强对偶关系：凸优化+（松弛）Slater 条件-&gt;强对偶。</li>
<li>参数求解：KKT条件
<ol type="1">
<li>可行域</li>
<li>互补松弛+梯度为0</li>
</ol></li>
</ol>
<h3 id="hard-margin">Hard-margin</h3>
<ol type="1">
<li><p>Idea: 最大化间隔</p></li>
<li><p>Model:<br>
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\ y_i(w^Tx_i+b)\ge1,i=1,2,\cdots,N
\]</span></p></li>
<li><p>对偶问题<br>
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\ s.t.\ \lambda_i\ge0
\]</span></p></li>
<li><p>模型参数<br>
<span class="math display">\[
\begin{gather*}
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)=0
\end{gather*}
\]</span></p></li>
</ol>
<h3 id="soft-margin">Soft-margin</h3>
<ol type="1">
<li><p>Idea:允许少量错误</p></li>
<li><p>Model:<br>
<span class="math display">\[
\begin{gather*}
error=\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}\\
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\ y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\end{gather*}
\]</span></p></li>
</ol>
<h3 id="kernel">Kernel</h3>
<p>对称的正定函数都可以作为正定核。</p>
<h2 id="exp-family">Exp Family</h2>
<ol type="1">
<li><p>表达式<br>
<span class="math display">\[
p(x|\eta)=h(x)\exp(\eta^T\phi(x)-A(\eta))=\frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))
\]</span></p></li>
<li><p>对数配分函数<br>
<span class="math display">\[
\begin{align*} 
A&#39;(\eta)=\mathbb{E}_{p(x|\eta)}[\phi(x)]\\
A&#39;&#39;(\eta)=Var_{p(x|\eta)}[\phi(x)]
\end{align*}
\]</span></p></li>
<li><p>指数族分布满足最大熵定理</p></li>
</ol>
<h2 id="pgm">PGM</h2>
<h3 id="representation">Representation</h3>
<ol type="1">
<li><p>有向图<br>
<span class="math display">\[
p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{parent(i)})
\]</span><br>
D-separation<br>
<span class="math display">\[
p(x_i|x_{-i})=\frac{p(x)}{\int p(x)dx_{i}}=\frac{\prod\limits_{j=1}^pp(x_j|x_{parents(j)})}{\int\prod\limits_{j=1}^pp(x_j|x_{parents(j)})dx_i}=\frac{p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)}{\int p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)dx_i}
\]</span></p></li>
<li><p>无向图<br>
<span class="math display">\[
\begin{align*}p(x)=\frac{1}{Z}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
Z=\sum\limits_{x\in\mathcal{X}}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
\phi(x_{ci})=\exp(-E(x_{ci}))
\end{align*}
\]</span></p></li>
<li><p>有向转无向</p>
<ol type="1">
<li>将每个节点的父节点两两相连</li>
<li>将有向边替换为无向边</li>
</ol></li>
</ol>
<h3 id="learning-1">Learning</h3>
<p>参数学习-EM</p>
<ol type="1">
<li><p>目的：解决具有隐变量的混合模型的参数估计（极大似然估计）</p></li>
<li><p>参数：<br>
<span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits_\theta\log p(x|\theta)
\]</span></p></li>
<li><p>迭代求解：<br>
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log [p(x,z|\theta)]p(z|x,\theta^t)dz=\mathbb{E}_{z|x,\theta^t}[\log p(x,z|\theta)]
\]</span></p></li>
<li><p>原理<br>
<span class="math display">\[
\log p(x|\theta^t)\le\log p(x|\theta^{t+1})
\]</span></p></li>
<li><p>广义EM</p>
<ol type="1">
<li><p>E step：<br>
<span class="math display">\[
\hat{q}^{t+1}(z)=\mathop{argmax}_q\int_zq^t(z)\log\frac{p(x,z|\theta)}{q^t(z)}dz,fixed\ \theta
\]</span></p></li>
<li><p>M step：<br>
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_\theta \int_zq^{t+1}(z)\log\frac{p(x,z|\theta)}{q^{t+1}(z)}dz,fixed\ \hat{q}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="inference">Inference</h3>
<ol type="1">
<li><p>精确推断</p>
<ol type="1">
<li><p>VE</p></li>
<li><p>BP<br>
<span class="math display">\[
m_{j\to i}(i)=\sum\limits_j\phi_j(j)\phi_{ij}(ij)\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}(j)
\]</span></p></li>
<li><p>MP<br>
<span class="math display">\[
m_{j\to i}=\max\limits_{j}\phi_j\phi_{ij}\prod\limits_{k\in Neighbour(j)-i}m_{k\to j}
\]</span></p></li>
</ol></li>
<li><p>近似推断</p>
<ol type="1">
<li><p>确定性近似，VI</p>
<ol type="1">
<li><p>变分表达式<br>
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span></p></li>
<li><p>平均场近似下的 VI-坐标上升<br>
<span class="math display">\[
\begin{gather*}
\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]=\log \hat{p}(X,Z_j)\\
q_j(Z_j)=\hat{p}(X,Z_j)
\end{gather*}
\]</span></p></li>
<li><p>SGVI-变成优化问题，重参数法<br>
<span class="math display">\[
\begin{gather*}
\mathop{argmax}_{q(Z)}L(q)=\mathop{argmax}_{\phi}L(\phi)\\
\nabla_\phi L(\phi)=\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log p_\theta(x^i,z)-\log q_\phi(z))]\\
=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log q_\phi(z)]\nabla_\phi g_\phi(\varepsilon,x^i)]\\
z=g_\phi(\varepsilon,x^i),\varepsilon\sim p(\varepsilon)
\end{gather*}
\]</span></p></li>
</ol></li>
<li><p>随机性近似</p>
<ol type="1">
<li><p>蒙特卡洛方法采样</p>
<ol type="1">
<li><p>CDF 采样</p></li>
<li><p>拒绝采样， <span class="math inline">\(q(z)\)</span>，使得 <span class="math inline">\(\forall z_i,Mq(z_i)\ge p(z_i)\)</span>，拒绝因子：<span class="math inline">\(\alpha=\frac{p(z^i)}{Mq(z^i)}\le1\)</span></p></li>
<li><p>重要性采样<br>
<span class="math display">\[
\mathbb{E}_{p(z)}[f(z)]=\int p(z)f(z)dz=\int \frac{p(z)}{q(z)}f(z)q(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span></p></li>
<li><p>重要性重采样：重要性采样+重采样</p></li>
</ol></li>
<li><p>MCMC：构建马尔可夫链概率序列，使其收敛到平稳分布 <span class="math inline">\(p(z)\)</span>。</p>
<ol type="1">
<li><p>转移矩阵（提议分布）<br>
<span class="math display">\[
\begin{gather*}
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=p(z^*)\cdot Q_{z^*\to z}\alpha(z^*,z)\\
\alpha(z,z^*)=\min\{1,\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}\}
\end{gather*}
\]</span></p></li>
<li><p>算法（MH）：</p>
<ol type="1">
<li>通过在0，1之间均匀分布取点 <span class="math inline">\(u\)</span></li>
<li>生成 <span class="math inline">\(z^*\sim Q(z^*|z^{i-1})\)</span></li>
<li>计算 <span class="math inline">\(\alpha\)</span> 值</li>
<li>如果 <span class="math inline">\(\alpha\ge u\)</span>，则 <span class="math inline">\(z^i=z^*\)</span>，否则 <span class="math inline">\(z^{i}=z^{i-1}\)</span></li>
</ol></li>
</ol></li>
<li><p>Gibbs 采样：给定初始值 <span class="math inline">\(z_1^0,z_2^0,\cdots\)</span>在 <span class="math inline">\(t+1\)</span> 时刻，采样 <span class="math inline">\(z_i^{t+1}\sim p(z_i|z_{-i})\)</span>，从第一个维度一个个采样。</p></li>
</ol></li>
</ol></li>
</ol>
<h2 id="gmm">GMM</h2>
<ol type="1">
<li><p>Model<br>
<span class="math display">\[
p(x)=\sum\limits_{k=1}^Kp_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span></p></li>
<li><p>求解-EM<br>
<span class="math display">\[
\begin{align*}Q(\theta,\theta^t)&amp;=\sum\limits_z[\log\prod\limits_{i=1}^Np(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_z[\sum\limits_{i=1}^N\log p(x_i,z_i|\theta)]\prod \limits_{i=1}^Np(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p(x_i,z_i|\theta)p(z_i|x_i,\theta^t)\\
&amp;=\sum\limits_{i=1}^N\sum\limits_{z_i}\log p_{z_i}\mathcal{N(x_i|\mu_{z_i},\Sigma_{z_i})}\frac{p_{z_i}^t\mathcal{N}(x_i|\mu_{z_i}^t,\Sigma_{z_i}^t)}{\sum\limits_kp_k^t\mathcal{N}(x_i|\mu_k^t,\Sigma_k^t)}
\end{align*}
\]</span></p>
<p><span class="math display">\[
p_k^{t+1}=\frac{1}{N}\sum\limits_{i=1}^Np(z_i=k|x_i,\theta^t)
\]</span></p></li>
</ol>
<h2 id="序列模型-hmmldsparticle">序列模型-HMM，LDS，Particle</h2>
<ol type="1">
<li><p>假设：</p>
<ol type="1">
<li><p>齐次 Markov 假设（未来只依赖于当前）：<br>
<span class="math display">\[
p(i_{t+1}|i_t,i_{t-1},\cdots,i_1,o_t,o_{t-1},\cdots,o_1)=p(i_{t+1}|i_t)
\]</span></p></li>
<li><p>观测独立假设：<br>
<span class="math display">\[
p(o_t|i_t,i_{t-1},\cdots,i_1,o_{t-1},\cdots,o_1)=p(o_t|i_t)
\]</span></p></li>
</ol></li>
<li><p>参数<br>
<span class="math display">\[
\lambda=(\pi,A,B)
\]</span></p></li>
</ol>
<h3 id="离散线性隐变量-hmm">离散线性隐变量-HMM</h3>
<ol type="1">
<li><p>Evaluation：<span class="math inline">\(p(O|\lambda)\)</span>，Forward-Backward 算法<br>
<span class="math display">\[
\begin{gather*}
p(O|\lambda)=\sum\limits_{i=1}^Np(O,i_T=q_i|\lambda)=\sum\limits_{i=1}^N\alpha_T(i)=\sum\limits_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)\\
\alpha_{t+1}(j)=\sum\limits_{i=1}^Nb_{j}(o_t)a_{ij}\alpha_t(i)\\
\beta_t(i)=\sum\limits_{j=1}^Nb_j(o_{t+1})a_{ij}\beta_{t+1}(j)
\end{gather*}
\]</span></p></li>
<li><p>Learning：<span class="math inline">\(\lambda=\mathop{argmax}\limits_{\lambda}p(O|\lambda)\)</span>，EM 算法（Baum-Welch）<br>
<span class="math display">\[
\begin{align*}
\lambda^{t+1}&amp;=\mathop{argmax}_\lambda\sum\limits_I\log p(O,I|\lambda)p(O,I|\lambda^t)\\&amp;=\sum\limits_I[\log \pi_{i_1}+\sum\limits_{t=2}^T\log a_{i_{t-1},i_t}+\sum\limits_{t=1}^T\log b_{i_t}(o_t)]p(O,I|\lambda^t)
\end{align*}
\]</span></p></li>
<li><p>Decoding：<span class="math inline">\(I=\mathop{argmax}\limits_{I}p(I|O,\lambda)\)</span>，Viterbi 算法-动态规划<br>
<span class="math display">\[
\begin{gather*}
\delta_{t}(j)=\max\limits_{i_1,\cdots,i_{t-1}}p(o_1,\cdots,o_t,i_1,\cdots,i_{t-1},i_t=q_i)\\\delta_{t+1}(j)=\max\limits_{1\le i\le N}\delta_t(i)a_{ij}b_j(o_{t+1})\\\psi_{t+1}(j)=\mathop{argmax}\limits_{1\le i\le N}\delta_t(i)a_{ij}
\end{gather*}
\]</span></p></li>
</ol>
<h3 id="连续线性隐变量-lds">连续线性隐变量-LDS</h3>
<ol type="1">
<li><p>Model<br>
<span class="math display">\[
\begin{align*}
p(z_t|z_{t-1})&amp;\sim\mathcal{N}(A\cdot z_{t-1}+B,Q)\\
p(x_t|z_t)&amp;\sim\mathcal{N}(C\cdot z_t+D,R)\\
z_1&amp;\sim\mathcal{N}(\mu_1,\Sigma_1)
\end{align*}
\]</span></p></li>
<li><p>滤波<br>
<span class="math display">\[
\begin{align*}
p(z_t|x_{1:t})&amp;=p(x_{1:t},z_t)/p(x_{1:t})\propto p(x_{1:t},z_t)\\&amp;=p(x_t|z_t)p(z_t|x_{1:t-1})p(x_{1:t-1})\propto p(x_t|z_t)p(z_t|x_{1:t-1})
\end{align*}
\]</span></p></li>
<li><p>递推求解-线性高斯模型</p>
<ol type="1">
<li><p>Prediction<br>
<span class="math display">\[
\begin{align*}
p(z_t|x_{1:t-1})&amp;=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}\\&amp;=\int_{z_{t-1}}\mathcal{N}(Az_{t-1}+B,Q)\mathcal{N}(\mu_{t-1},\Sigma_{t-1})dz_{t-1}
\end{align*}
\]</span></p></li>
<li><p>Update:<br>
<span class="math display">\[
p(z_t|x_{1:t})\propto p(x_t|z_t)p(z_t|x_{1:t-1}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="连续非线性隐变量-粒子滤波">连续非线性隐变量-粒子滤波</h3>
<p>通过采样(SIR)解决：<br>
<span class="math display">\[
\mathbb{E}[f(z)]=\int_zf(z)p(z)dz=\int_zf(z)\frac{p(z)}{q(z)}q(z)dz=\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span></p>
<ol type="1">
<li><p>采样<br>
<span class="math display">\[
\begin{gather*}
w_t^i\propto\frac{p(x_t|z_t)p(z_t|z_{t-1})}{q(z_t|z_{1:t-1},x_{1:t})}w_{t-1}^i\\
q(z_t|z_{1:t-1},x_{1:t})=p(z_t|z_{t-1})
\end{gather*}
\]</span></p></li>
<li><p>重采样</p></li>
</ol>
<h2 id="crf">CRF</h2>
<ol type="1">
<li><p>PDF<br>
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z(x,\theta)}\exp[\theta^TH(y_t,y_{t-1},x)]
\]</span></p></li>
<li><p>边缘概率<br>
<span class="math display">\[
\begin{gather*}
p(y_t=i|x)=\sum\limits_{y_{1:t-1}}\sum\limits_{y_{t+1:T}}\frac{1}{Z}\prod\limits_{t&#39;=1}^T\phi_{t&#39;}(y_{t&#39;-1},y_{t&#39;},x)\\
p(y_t=i|x)=\frac{1}{Z}\Delta_l\Delta_r\\
\Delta_l=\sum\limits_{y_{1:t-1}}\phi_{1}(y_0,y_1,x)\phi_2(y_1,y_2,x)\cdots\phi_{t-1}(y_{t-2},y_{t-1},x)\phi_t(y_{t-1},y_t=i,x)\\
\Delta_r=\sum\limits_{y_{t+1:T}}\phi_{t+1}(y_t=i,y_{t+1},x)\phi_{t+2}(y_{t+1},y_{t+2},x)\cdots\phi_T(y_{T-1},y_T,x)
\end{gather*}
\]</span></p>
<p><span class="math display">\[
\begin{gather*}
\alpha_t(i)=\Delta_l=\sum\limits_{j\in S}\phi_t(y_{t-1}=j,y_t=i,x)\alpha_{t-1}(j)\\
\Delta_r=\beta_t(i)=\sum\limits_{j\in S}\phi_{t+1}(y_t=i,y_{t+1}=j,x)\beta_{t+1}(j)
\end{gather*}
\]</span></p></li>
<li><p>学习<br>
<span class="math display">\[
\nabla_\lambda L=\sum\limits_{i=1}^N\sum\limits_{t=1}^T[f(y_{t-1},y_t,x^i)-\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)]
\]</span></p></li>
</ol>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>ML Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory consistency model and Cache coherence</title>
    <url>/2025/11/17/Memory-consistency-model-and-Cache-coherence/</url>
    <content><![CDATA[<h1 id="内存一致性模型与缓存一致性的关系">内存一致性模型与缓存一致性的关系</h1>
<p>刚开始接触缓存一致性以及内存一致性模型的时候，时常会对其产生误解，对两者的概念比较模糊，在这里借用《A Primer on Memory Consistency and Cache Coherence》中的介绍来对其进行区分。</p>
<p>该书中使用<strong>SWMR(Single Writer Multiple Reader)不变量</strong>以及<strong>数据值（Data Value）不变量</strong>来定义缓存一致性，前者指的是对于同一时刻，同一个内存地址，要么只有一个核心对其拥有读写权限，要么有零个或者多个对于该地址只有只读权限。而后者则指的是，任何对于内存的修改都会被传播给其他副本，以至于副本保存的总是其最新的值。</p>
<p>而内存一致性（模型）则是定义在缓存一致性之上的，程序员需要依据内存一致性模型来编写出正确的多线程程序，而缓存一致性主要是为处理器流水线提供一个存储系统的抽象层，对于程序员来说时透明的，如下图所示：</p>
<p><img src="/2025/11/17/Memory-consistency-model-and-Cache-coherence/consistency_and_conherence.webp" alt="内存一致性模型与缓存一致性"></p>
<div class="admonition admonition-summary">
<p class="admonition-title">Summary</p>
<ul>
<li>Cache coherence于Memory consistency并不等效</li>
<li>Memory consistency的具体实现可以将Cache coherence作为一个有用的黑盒</li>
</ul>
</div>
<p>除此之外，依据缓存一致性于内存一致性模型之间是否能够被清晰地划分开来，可以将缓存一致性协议分为两类：</p>
<ul>
<li><strong>Consistency-agnostic coherence</strong>:在第一类协议中，一个写操作在返回之前就已经对所有其他内核可见。由于写操作是同步传播的，这类协议提供的接口与无缓存的原子内存系统完全一致。因此，任何与一致性协议交互的子系统——例如处理器核心流水线——都可以假设自己在与一个没有缓存的原子内存系统交互。从一致性保证的角度看，这种一致性接口带来了良好的“关注点分离”。缓存一致性协议完全屏蔽了缓存的存在，呈现出仿佛缓存被移除、只有主存位于一致性盒子中的原子内存假象（见上图），而处理器核心流水线负责执行一致性模型中规定的所有排序要求。</li>
<li><strong>Consistency-directed coherence</strong>:在第二类（较新的）协议中，写操作异步传播——即一个写操作可以在尚未对所有处理器可见之前就返回，因此其他处理器在真实时间上有可能观察到过期（stale）的值。然而，为了正确实现内存一致性，这类协议必须保证最终对外可见的写入顺序严格遵循一致性模型规定的排序规则。回到上图的抽象模型，这种类型中流水线与一致性协议共同负责执行一致性模型规定的排序要求。这类协议最初为提高通用 GPU（GP-GPU）的吞吐量而出现。</li>
</ul>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>基于我个人的理解而言，<strong>缓存一致性</strong>指的是同一个地址的数据存在多个本地的备份，其中一个备份被修改了，其他的备份需要知道。<br>
而<strong>内存一致性（模型）</strong> 更多的是一种约定，描述了该多核处理器对于不同地址数据进行访问时，不同核心所看到的执行顺序并不一样。</p>
</div>
<h1 id="缓存一致性介绍">缓存一致性介绍</h1>
<p>在现代的多核系统中，为了弥补主存与处理器速度之间的差距，通常会在每个处理器核心上配备一个或多个级别的缓存（Cache）。而缓存的核心作用就是为处理器提供其所需数据的高速备份，从而提高整体系统的性能。然而，当多个处理器核心同时访问和修改共享数据时，同一个数据就会存在多个备份，当其中一个备份的数据被其对应的处理器修改之后，另一个备份并不知情，这就会导致不同处理器看到的数据是不一致的，从而引发一系列的问题。</p>
<p>如下所展示的一个简单的缓存一致性问题的例子：假设全局变量A的初始值为0，且仅处于主存当中。</p>
<ol type="1">
<li>CPU1读取变量A的值，触发cache miss，从主存中将A的值（0）加载到自己的缓存中。</li>
<li>CPU4读取变量A的值，触发cache miss，从主存中将A的值（0）加载到自己的缓存中。</li>
<li>CPU4将变量A的值修改为4，这时候有两者情况，如果是写回（write back）策略，则仅仅是将A的cache值修改为4，并且标记该缓存行为“脏”（dirty），此时主存中的A的值仍然是0；如果是写穿（write through）策略，则不仅将A的cache值修改为4，主存中的A的值也会被更新为4。</li>
<li>CPU1再次读取变量A的值，这时候如果没有任何缓存一致性协议的介入，CPU1将会继续读取到自己缓存中的A的值0，而不是最新的值4。</li>
</ol>
<p>经过上述四步之后，全局的共享变量A，在不同位置上的值如下图所示：</p>
<pre class="mermaid">graph TB

    subgraph CPUs
        CPU1((CPU1))
        CPU2((CPU2))
        CPU3((CPU3))
        CPU4((CPU4))
    end

    Cache1[Cache<br>A=0]
    Cache2[Cache]
    Cache3[Cache]
    Cache4[Cache<br>A=4]

    Bus[===== BUS =====]
    Mem["Main Memory<br>A=0 (write back) <br>or 4 (write through)"]

    CPU1 --- Cache1
    CPU2 --- Cache2
    CPU3 --- Cache3
    CPU4 --- Cache4

    Cache1 --- Bus
    Cache2 --- Bus
    Cache3 --- Bus
    Cache4 --- Bus

    Bus --- Mem

    Note1[/"1. read A<br>4. read A"/]
    Note2[/"2. read A<br>3. write A=4"/]

    Note1 -.-> CPU1
    Note2 -.-> CPU4</pre>
<p>而由上述的缓存一致性问题，又会导致程序不按照预想的逻辑运行。</p>
<p>例如有如下一个程序，其有两个线程, 分别被安排在CPU1和CPU2上运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run on CPU1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    data = <span class="number">1</span>;          <span class="comment">// 操作2</span></span><br><span class="line">    flag = <span class="number">1</span>;          <span class="comment">// 操作3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run on CPU2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">0</span>); <span class="comment">// 操作1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data); <span class="comment">// 操作4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于该程序，我们的期望逻辑是：<code>thread2</code>一直等待，直到<code>thread1</code>将数据<code>data</code>准备好，并且将标志位<code>flag</code>置为之后，<code>thread2</code>才会继续执行并打印出数据<code>data</code>的值。</p>
<p>但是如下流程图所示，由于缓存一致性问题，<code>thread2</code>可能永远看不到<code>flag</code>被置为1的操作，从而导致它一直处于自旋等待的状态，永远无法打印出数据<code>data</code>的值。</p>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant CPU1 as CPU1 / thread1
    participant C1 as CPU1 Cache
    participant MEM as Main Memory
    participant C2 as CPU2 Cache
    participant CPU2 as CPU2 / thread2

    Note over CPU1,CPU2: 初始：flag=0, data=0

    %% CPU2 先开始自旋读取 flag（操作1）
    CPU2->>C2: load flag
    alt 第一次访问，miss
        C2->>MEM: read flag
        MEM-->>C2: flag = 0
    end
    C2-->>CPU2: flag = 0

    loop while(flag == 0)
        CPU2->>C2: load flag 
        Note right of C2: CPU2 一直命中本地 cache，<br>读取到的都是旧值 flag=0
        C2-->>CPU2: flag = 0
    end

    %% 另一方面，CPU1 执行写 data=1, flag=1
    CPU1->>C1: store data = 1  
    Note right of C1: data=1 写入 CPU1 的 cache，<br>可能稍后再写回内存

    CPU1->>C1: store flag = 1  
    Note right of C1: flag=1 也只更新在 CPU1 cache 中，<br>没有触发对 CPU2 cache 的失效/更新

    C1->>MEM: write-back (可选) data=1, flag=1
    Note over C1,MEM: 即使内存已是 1，<br>但 CPU2 的 cache 里 flag 仍是 0

    %% 因为没有 cache coherence，CPU2 永远看不到 flag=1
    loop while(flag == 0) 继续自旋
        CPU2->>C2: load flag
        C2-->>CPU2: flag = 0
    end

    Note over CPU2: CPU2 一直认为 flag==0，<br>甚至永远无法执行 printf</pre>
<p>从上述的两个例子中，我们不难看出缓存一致性的重要性，而为了解决缓存一致性的问题，当前主要有两种解决方案：<strong>总线嗅探（snopping-based）方案</strong>和<strong>目录式（Directory-based）方案</strong>。</p>
<p><strong>Snoopying-based方案:</strong> 每个缓存控制器都会监听（嗅探）总线上的所有读写请求，当某个处理器对某个地址发起读写请求时，其他缓存控制器会检查自己是否缓存了该地址的数据，如果缓存了，则根据请求的类型（读或写）采取相应的操作，例如无效化自己的缓存行或者更新自己的缓存行，从而确保所有缓存中的数据是一致的。<br>
<strong>Directory-based方案:</strong> 每个内存块都有一个目录，记录了哪些缓存中存储了该内存块的副本。当某个处理器需要访问某个内存块时，它会先查询目录，目录会告诉它哪些缓存中有该内存块的副本，然后处理器可以直接与这些缓存进行通信，确保数据的一致性。这种方案通常适用于大规模多处理器系统，因为它减少了总线上的通信量。</p>
<h1 id="内存一致性模型介绍">内存一致性模型介绍</h1>
<p>内存一致性模型（Memory Consistency Model）定义了在多处理器系统中，多个处理器对共享内存的读写操作的可见性和顺序性规则。它规定了一个处理器对内存的写操作何时对其他处理器可见，以及多个处理器对同一内存位置的读写操作之间的顺序关系。</p>
<p>仍然拿上面的缓存一致性的例子来介绍内存一致性，其程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run on CPU1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    data = <span class="number">1</span>;   <span class="comment">// S1    </span></span><br><span class="line">    flag = <span class="number">1</span>;   <span class="comment">// S2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run on CPU2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">0</span>); <span class="comment">// L1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data); <span class="comment">// L2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于该程序，如果存在缓存一致性问题，则<code>thread2</code>可能一直在自旋，导致无法打印出数据<code>data</code>的值。但是是不是如果没有缓存一致性问题，该程序就能按照预期来工作呢？<strong>答案是否定的</strong>。</p>
<p>我们可以假设缓存一致性的问题已经解决了或者假设两个CPU没有缓存，为了简单，我们就假设系统为一个多核无缓存的系统，其系统框图如下：</p>
<pre class="mermaid">graph TB

    subgraph CPUs
        CPU1((CPU1))
        CPU2((CPU2))
        CPU3((CPU3))
        CPU4((CPU4))
    end

    Bus[===== BUS =====]
    Mem["Main Memory"]

    CPU1 --- Bus
    CPU2 --- Bus
    CPU3 --- Bus
    CPU4 --- Bus

    Bus --- Mem

    Note1[/"1. data = 1<br>2. flag = 1"/]
    Note2[/"3. while(flag == 0)<br>4. print data"/]

    Note1 -.-> CPU1
    Note2 -.-> CPU4</pre>
<p>在不考虑所谓的内存一致性模型的前提下，我们对于上述程序的期望就是最终输出<code>1</code>。但是实际上，基于该CPU的内存模型，程序最终既可能输出<code>1</code>，也可能输出<code>0</code>。</p>
<p>其根本原因在于，对于CPU4而言，其可能先看到<code>flag = 1</code>，然后才看到<code>data = 1</code>。但是这并不是错误，而是由CPU的设计与实现方案所导致的。究其原因，其主要还是由于当代CPU为了提升性能，通常会重排序内存访问（Reorder Memory Accesses），即允许处理器在执行内存操作时，不严格按照程序中指令的顺序进行，而是根据数据依赖关系和硬件资源的可用性，动态调整内存操作的执行顺序。而上述输出0的情况，就是由于<code>store-store reordering</code>所导致的(CPU1中的<code>S1</code>与<code>S2</code> reorder)。</p>
<p>而<strong>内存一致性模型</strong>的作用就是用于规范多线程程序的访存行为，从而使得程序能够按照预期的逻辑来运行。</p>
<div class="admonition admonition-question">
<p class="admonition-title">CPU存在哪些可能的内存访问重排序？
</p>
<p>尽管现代内核可能对许多内存访问进行重排序，但我们只需要考虑两个内存操作的重排序就足够了。多数情况下，我们只需讨论内核针对两个不同地址的内存操作进行重排序的情形，因为顺序执行模型（即冯·诺依曼模型）通常要求对同一地址的操作必须按程序原有顺序执行。我们根据被重排序的内存操作是加载（load）还是存储（store），将可能的重排序情况分为三类。</p>
<ul>
<li><strong>store-store reordering</strong>: 如果一个核心有一个非FIFO的写缓存区(store buffer), 那么它可能会允许store-store重排序。也就是说，后面的store操作可能会比前面的store操作更早地被提交到内存系统中。需要注意的是，即使核心是按照程序的顺序执行的，这种重排序仍然可能发生。而对于单线程来说，对不同地址的store操作进行重排序是没有影响的。</li>
<li><strong>load-load reordering</strong>: 当代的动态调度核心可能会按照不同的顺序执行指令。以上面的程序为例，CPU2可能会对<code>L1</code>和<code>L2</code>进行重排序，因为对于单线程来说，这样的重排序是没有影响的。但是对于多线程，这种排序可能会导致<code>L2、S1、S2、L1</code>的执行顺序，从而导致输出是0。</li>
<li><strong>load-store and store-load reordering</strong>: 乱序核心也可以重新排序来自同一线程的加载和存储（针对于不同地址的加载和存储），从而导致不确定的结果</li>
</ul>
<div class="admonition admonition-example">
<p class="admonition-title">store-load 重排序示例
</p>
<p>下面的程序展示了store-load重排序的一个例子：</p>
<p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r1 = <span class="number">0</span>, r2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run on CPU1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> {</span><br><span class="line"> x = <span class="number">1</span>; <span class="comment">// S1</span></span><br><span class="line"> r1 = y; <span class="comment">// L1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// run on CPU2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> {</span><br><span class="line"> y = <span class="number">1</span>; <span class="comment">// S2</span></span><br><span class="line"> r2 = x; <span class="comment">// L2</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>上述程序的可能的输出结果：</p>
<ul>
<li>（r1 == 1, r2 == 1）—— 执行顺序为 S1, S2, L1, L2</li>
<li>（r1 == 0, r2 == 1）—— 执行顺序为 S1, L1, S2, L2</li>
<li>（r1 == 1, r2 == 0）—— 执行顺序为 S2, L2, S1, L1</li>
<li>（r1 == 0, r2 == 0）—— 执行顺序为 L1, L2, S1, S2</li>
</ul>
<p>其中最后一个结果就是由于store-load重排序所导致的。</p>
</div>
</div>
<h1 id="内存一致性模型分类">内存一致性模型分类</h1>
<h2 id="顺序一致性sequential-consistency-sc">顺序一致性（Sequential Consistency, SC）</h2>
<p>SC模型最早由Lamport提出，SC定义每个单独的核心的执行顺序（访存顺序）必须按照程序指定的顺序执行，但是不同核心之间的全局执行顺序（访存）可以是任意的。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>需要注意的是，在SC模型当中，不同核心看到的内存操作顺序应该是一致的。</p>
</div>
<p>如下执行流程图（以上面的代码为例）显示怎么样才算是符合SC模型的执行流程的：</p>
<pre class="mermaid">sequenceDiagram
    participant P1 as Program Order {p} of Core C1
    participant M  as Memory Order {m}
    participant P2 as Program Order {p} of Core C2

    %% ===================== (a) SC Execution 1 =====================
    rect rgb(240,255,255)
    autonumber 1
    Note over P1,P2: (a) SC Execution 1<br>Outcome: (r1, r2) = (0, 1)

    P1->>M: S1: x = 1 
    P1->>M: L1: r1 = y 
    P2->>M: S2: y = 1 
    P2->>M: L2: r2 = x 
    end

    %% ===================== (b) SC Execution 2 =====================
    rect rgb(240,240,255)
    autonumber 1
    Note over P1,P2: (b) SC Execution 2<br>Outcome: (r1, r2) = (1, 0)

    P2->>M: S2: y = 1 
    P2->>M: L2: r2 = x 
    P1->>M: S1: x = 1 
    P1->>M: L1: r1 = y 
    end

    %% ===================== (c) SC Execution 3 =====================
    rect rgb(240,255,240)
    autonumber 1
    Note over P1,P2: (c) SC Execution 3<br>Outcome: (r1, r2) = (1, 1)

    P1->>M: S1: x = 1 
    P2->>M: S2: y = 1 
    P1->>M: L1: r1 = y 
    P2->>M: L2: r2 = x 
    end

    %% ===================== (d) NOT an SC Execution =====================
    rect rgb(255,240,240)
    autonumber 1
    Note over P1,P2: (d) NOT an SC Execution<br> Outcome: (r1, r2) = (0, 0)

    %% 这里先按程序顺序画事件
    P2->>M: L2: r2 = x 
    P1->>M: S1: x = 1 
    P1->>M: L1: r1 = y 
    P2->>M: S2: y = 1 
    end</pre>
<p>其中前三个就是符合SC模型的执行流程，因此在SC模型的CPU下，该三个结果都是正确的，但是第四个则不是。</p>
<p>SC模型的优势就是简单，但是其缺点也很明显，那就是性能较低，因为SC模型限制了处理器对内存操作的重排序能力，从而限制了处理器的优化空间。所以先打处理器的内存模型基本都偏离了SC模型。</p>
<h2 id="放宽的内存一致性模型relaxed-consistency-models">放宽的内存一致性模型（Relaxed Consistency Models）</h2>
<p>上述的SC模型严格地限制了<code>store-load</code>、<code>store-store</code>、<code>load-load</code>和<code>load-store</code>这四种内存读写的重排序（即使这些操作之间没有控制、数据和流水线上面的依赖）。</p>
<p>而<strong>宽松内存模型（Relaxed Consistency Models）</strong> 的关键思想是允许乱序执行<code>store</code>和<code>load</code>操作，而依据具体放宽松了哪一对<code>store</code>和<code>load</code>的操作，可以将其分为如下几种类型：</p>
<ul>
<li><strong>Total Store Order (TSO)</strong>: 允许<code>store-load</code>重排序，但禁止<code>store-store</code>、<code>load-load</code>和<code>load-store</code>重排序（引入fifo属性的store buffer就会导致这种情况）。</li>
<li><strong>Partial Store Order (PSO)</strong>: 允许<code>store-load</code>和<code>store-store</code>重排序，但禁止<code>load-load</code>和<code>load-store</code>重排序（引入非fifo属性的store buffer就会导致这种情况）。</li>
<li><strong>Relaxed Memory Order (RMO)</strong>: 允许所有四种类型的重排序。</li>
</ul>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>这些顺序放松但依旧保证了在本CPU与程序代码一致的存取顺序，但在其它CPU节点看来顺序就可能被打乱了。</p>
</div>
<h3 id="tso模型示例">TSO模型示例</h3>
<p>如下一个示例展示了，对于同一个线程来说，其看到的内存顺序是没有重排序的，但是对于另一个线程来说，其看到的则是<code>store</code>被延后到<code>load</code>后面了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>;      <span class="comment">// S1</span></span><br><span class="line">    r1 = x;     <span class="comment">// L1</span></span><br><span class="line">    r2 = y;     <span class="comment">// L2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">    y = <span class="number">1</span>;      <span class="comment">// S2</span></span><br><span class="line">    r3 = y;     <span class="comment">// L3</span></span><br><span class="line">    r4 = x;     <span class="comment">// L4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在TSO模型下，很多人可能认为最终会出现<code>(r1, r2, r3, r4) = (0, 0, 0, 0)</code>的结果。但是事实上并不会，这是因为<code>r1</code>和<code>r3</code> load的是本地CPU的值，因此会使用Write Buffer Bypass机制，直接从Write Buffer中读取到最新的值1，因此r1与r3的值最终都会是1。产生这种结果的执行流程图如下图所示。</p>
<p><img src="/2025/11/17/Memory-consistency-model-and-Cache-coherence/tso.webp" alt="TSO执行"></p>
<p>再来看另一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span> &#123;</span><br><span class="line">    a = <span class="number">1</span>;      <span class="comment">// S1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span> &#123;</span><br><span class="line">    b = <span class="number">1</span>;      <span class="comment">// S2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// L1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// L2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// L3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// L4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个例子，如果<code>thread3</code>看到的结果是<code>(a, b) = (1, 0)</code>，那么<code>thread4</code>看到的结果就不可能是<code>(a, b) = (0, 1)</code>。因为在TSO模型下，<code>store-store</code>操作是不能重排序的，因此<code>S1</code>必须在<code>S2</code>之前被提交到内存中，从而使得<code>thread4</code>不可能看到<code>b = 1</code>而<code>a = 0</code>的结果。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>从这个例子当中，可以看出来，如果允许<code>load-load</code>重排序的话，那么最终就会导致不同线程看到完全不一样的顺序，内存模型就会很复杂。</p>
</div>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>内存一致性模型</tag>
        <tag>缓存一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>Poems</title>
    <url>/2022/01/02/Poem/</url>
    <content><![CDATA[<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">千秋岁·赴蓬莱宴</div><div class="poem-author">周北北</div><div class="poem-main"><p>赴蓬莱宴，白鹿云中驾。<br>
扬鹤氅，拂烟霭。<br>
苍灵亲酿酒，惬引三白口。<br>
观杏坛，含英百卉生奇彩。<br>
忆书生风骨，词魄剔俗韵。<br>
游四海，心自在。<br>
匠心息壤种，矢志金针度。<br>
冬去也，满门桃李欢相祝。</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">猫毛上的眼泪</div><div class="poem-author">周北北</div><div class="poem-main"><p>我的眼泪滴在了猫的毛上<br>
它舔了舔，是咸的<br>
这样，它就能懂我的悲伤<br>
真好，起码有人能懂我的悲伤</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">无名</div><div class="poem-author">周北北</div><div class="poem-main"><p>竹间拂剑御清风，日复其中，年复其中。<br>
倏见星瀚绕皓月，月也相拥，人也相拥。<br>
天下桃李闻讯来，祝辞一封，樽酒一通。<br>
今宵朝南仰天笑，师者青葱，团圆中秋。</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">端午闲记</div><div class="poem-author">周北北</div><div class="poem-main"><p>端午值仲夏，天清暖风扬。<br>
粽籽分甜咸，入口皆蜜糖。<br>
阖家欢庆乐，蒲酒话吉祥。<br>
千载同瞬息，一笑向旭阳。</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">坡底韵·春日早起有感</div><div class="poem-author">周北北</div><div class="poem-main"><p>清晨暖风拂入家，大展青春好年华。<br>
随波逐流身心乏，独慕枝头傲梅花。<br>
目光聚焦真学问，轻装上阵披晚霞。<br>
纷扰世界何足惧，静心轻抿一口茶 。</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">水调歌头·寿刘尊师</div><div class="poem-author">周北北</div><div class="poem-main"><p>花园山论剑，远瞩万叠烟。<br>
峭途迢递，跳珠滴氅，辨鹤几时喧。<br>
金枝耐冬高挂，邂逅白须老叟，相笑叹桃鲜。<br>
终待剑出鞘，拏云志无边。<br>
绿卿立，白珺净，澧源渊。<br>
少年秉性，衍素心岁岁难迁。<br>
杏雨一朝栉沐，桃李一世顶戴，必薪火绵绵。<br>
羽翼腾空起，何捕酒中仙。</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">树影寄思</div><div class="poem-author">周北北</div><div class="poem-main"><p>夕阳慵懒，树梢花盏。<br>
在窗台停驻斑驳浅影。<br>
清风如穆，蝉鸣悦耳。<br>
一只小虫飞向远山褶痕。<br>
有丝涟漪，突然想你，不知为何。<br>
大抵是窗前那棵似唤相思。<br>
如若是真，都怪那棵树。<br>
如若是假，也怪那棵树。</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">星遇</div><div class="poem-author">周北北</div><div class="poem-main"><p>茫茫人海中<br>
我们是一枚星与另一枚星的遥望<br>
中间隔满光年的霜<br>
是风把两粒微尘带入一场晚霞<br>
我记得你眉间渐暖的薄雾<br>
你数过我眼里不肯坠落的珠光<br>
你我的手心长出了春天<br>
我们不再只是星星<br>
也是两颗厚重的树<br>
把根须埋进彼此的领地<br>
在无人看见的泥土深处<br>
紧紧缠绕<br>
从此晴日共享叶脉间的光<br>
雨季分担年轮里的潮<br>
我们不在云端相爱<br>
只把故事写进寻常<br>
任由电波穿越晨昏线<br>
唤醒灼热的烫<br>
当我偶尔仍想逃往宇宙<br>
你总在最近处<br>
推开一片温厚的土壤<br>
其实浪漫并非虚构远方<br>
恰是新生的年轮<br>
朝向彼此生长<br>
若某天世俗的尺前来衡量<br>
就让他们看<br>
脉络如何在寂静中交汇成河床<br>
又起风了<br>
并肩站立的树影<br>
写下一页页岁月的诗行</p>
</div></div></div>
<p><br><br><br><br><br></p>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">title</div><div class="poem-author">周北北</div><div class="poem-main">
</div></div></div>
]]></content>
      <categories>
        <category>OTHERS</category>
      </categories>
      <tags>
        <tag>Poem</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch Abstract</title>
    <url>/2022/07/22/PyTorch-Abstract/</url>
    <content><![CDATA[<p>简单的PyTorch教程，来自官网教程<a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">60分钟PyTorch教程</a>、<a href="https://pytorch.org/tutorials/beginner/pytorch_with_examples.html">通过例子学PyTorch</a>和<a href="https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">迁移学习教程</a>。</p>
<p><strong>目录</strong></p>
<ul>
<li>60分钟PyTorch教程
<ul>
<li>什么是PyTorch？
<ul>
<li><a href="http://fancyerii.github.io/books/pytorch/#tensor">Tensor</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#operation">Operation</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#tensor的变换">Tensor的变换</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#tensor与numpy的互相转换">Tensor与Numpy的互相转换</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#cuda-tensor">CUDA Tensor</a></li>
</ul></li>
<li>Autograd: 自动求导
<ul>
<li><a href="http://fancyerii.github.io/books/pytorch/#从自动求导看tensor">从自动求导看Tensor</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#梯度">梯度</a></li>
</ul></li>
<li>PyTorch神经网络简介
<ul>
<li><a href="http://fancyerii.github.io/books/pytorch/#定义网络">定义网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#测试网络">测试网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#损失函数">损失函数</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#计算梯度">计算梯度</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#更新参数">更新参数</a></li>
</ul></li>
<li>训练一个分类器
<ul>
<li><a href="http://fancyerii.github.io/books/pytorch/#如何进行数据处理">如何进行数据处理</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#训练的步骤">训练的步骤</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#数据处理">数据处理</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#定义卷积网络">定义卷积网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#在测试数据集上进行测试">在测试数据集上进行测试</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#gpu上训练">GPU上训练</a></li>
</ul></li>
</ul></li>
<li>通过例子学PyTorch
<ul>
<li><a href="http://fancyerii.github.io/books/pytorch/#使用numpy实现三层神经网络">使用Numpy实现三层神经网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#使用tensor来实现三层神经网络">使用Tensor来实现三层神经网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#实现autograd来实现三层神经网络">实现autograd来实现三层神经网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#使用自定义的relu函数">使用自定义的ReLU函数</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#和tensorflow的对比">和Tensorflow的对比</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#使用nn模块来实现三层神经网络">使用nn模块来实现三层神经网络</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#使用optim包">使用optim包</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#自定义nn模块">自定义nn模块</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#流程控制和参数共享">流程控制和参数共享</a></li>
</ul></li>
<li>迁移学习示例
<ul>
<li><a href="http://fancyerii.github.io/books/pytorch/#加载数据">加载数据</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#可视化图片">可视化图片</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#训练模型">训练模型</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#可视化预测结果的函数">可视化预测结果的函数</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#fine-tuning所有参数">fine-tuning所有参数</a></li>
<li><a href="http://fancyerii.github.io/books/pytorch/#fine-tuning最后一层参数">fine-tuning最后一层参数</a></li>
</ul></li>
</ul>
<h2 id="分钟pytorch教程">60分钟PyTorch教程</h2>
<h3 id="什么是pytorch">什么是PyTorch？</h3>
<p>PyTorch是一个基于Python的科学计算包，它主要有两个用途：</p>
<ul>
<li>类似Numpy但是能利用GPU加速</li>
<li>一个非常灵活和快速的用于深度学习的研究平台</li>
</ul>
<h4 id="tensor">Tensor</h4>
<p>Tensor类似与NumPy的ndarray，但是可以用GPU加速。使用前我们需要导入torch包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import torch</span><br></pre></td></tr></table></figure>
<p>下面的代码构造一个5×35×3的未初始化的矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.empty(5, 3)</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">tensor([[-1.9998e+05,  4.5818e-41,  3.4318e-37],</span><br><span class="line">[ 0.0000e+00,  0.0000e+00,  0.0000e+00],</span><br><span class="line">[ 0.0000e+00,  0.0000e+00,  1.2877e+29],</span><br><span class="line">[ 2.0947e-30,  0.0000e+00,  0.0000e+00],</span><br><span class="line">[ 0.0000e+00,  0.0000e+00, -4.5328e+05]])</span><br></pre></td></tr></table></figure>
<p>我们可以使用rand随机初始化一个矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.rand(5, 3)</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">#输出：</span><br><span class="line">tensor([[ 0.9656,  0.5782,  0.0482],</span><br><span class="line">[ 0.7462,  0.5838,  0.1844],</span><br><span class="line">[ 0.8262,  0.4507,  0.6128],</span><br><span class="line">[ 0.2961,  0.8956,  0.3092],</span><br><span class="line">[ 0.4973,  0.2203,  0.9200]])</span><br></pre></td></tr></table></figure>
<p>下面的代码构造一个用零初始化的矩阵，它的类型(dtype)是long：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.zeros(5, 3, dtype=torch.long)</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">#输出：</span><br><span class="line">tensor([[ 0,  0,  0],</span><br><span class="line">[ 0,  0,  0],</span><br><span class="line">[ 0,  0,  0],</span><br><span class="line">[ 0,  0,  0],</span><br><span class="line">[ 0,  0,  0]])</span><br></pre></td></tr></table></figure>
<p>我们也可以使用Python的数组来构造Tensor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([5.5, 3])</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>我们可以从已有的tensor信息(size和dtype)来构造tensor。但也可以用不同的dtype来构造。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = x.new_ones(5, 3, dtype=torch.double)      # new_* methods take in sizes</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)    # override dtype!</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>我们可以是用size函数来看它的shape：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(x.size())</span><br><span class="line">#输出：</span><br><span class="line">torch.Size([5, 3])</span><br></pre></td></tr></table></figure>
<p>注意torch.Size其实是一个tuple，因此它支持所有的tuple操作。</p>
<h4 id="operation">Operation</h4>
<p>接下来我们来学习一些PyTorch的Operation。Operation一般可以使用函数的方式使用，但是为了方便使用，PyTorch重载了一些常见的运算符，因此我们可以这样来进行Tensor的加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = torch.rand(5, 3)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure>
<p>我们也可以用add函数来实现加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure>
<p>我们也可以给加法提供返回值(而不是生成一个新的返回值)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = torch.empty(5, 3)</span><br><span class="line">torch.add(x, y, out=result) # x + y的结果放到result里。</span><br><span class="line">print(result) </span><br></pre></td></tr></table></figure>
<p>我们也可以把相加的结果直接修改第一个被加数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把x加到y</span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p>注意：就地修改tensor的operation以下划线结尾。比如： x.copy_(y), x.t_(), 都会修改x。</p>
<h4 id="tensor的变换">Tensor的变换</h4>
<p>我们也可以使用类似numpy的下标运算来操作PyTorch的Tensor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打印x的第一列</span><br><span class="line">print(x[:, 1])</span><br></pre></td></tr></table></figure>
<p>如果想resize或者reshape一个Tensor，我们可以使用torch.view：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.randn(4, 4)</span><br><span class="line">y = x.view(16)</span><br><span class="line">z = x.view(-1, 8)  # -1的意思是让PyTorch自己推断出第一维的大小。</span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure>
<p>如果一个tensor只有一个元素，可以使用item()函数来把它变成一个Python number：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.randn(1)</span><br><span class="line">print(x)</span><br><span class="line">#输出的是一个Tensor</span><br><span class="line">tensor([-0.6966])</span><br><span class="line"></span><br><span class="line">print(x.item())</span><br><span class="line">#输出的是一个数</span><br><span class="line">-0.6966081857681274</span><br></pre></td></tr></table></figure>
<h4 id="tensor与numpy的互相转换">Tensor与Numpy的互相转换</h4>
<p>Torch Tensor和NumPy数组的转换非常容易。它们会共享内存地址，因此修改一方会影响另一方。把一个Torch Tensor转换成NumPy数组的代码示例为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.ones(5)</span><br><span class="line">print(a)</span><br><span class="line">#tensor([ 1.,  1.,  1.,  1.,  1.])</span><br><span class="line">b = a.numpy()</span><br><span class="line">print(b)</span><br><span class="line">#[1. 1. 1. 1. 1.]</span><br></pre></td></tr></table></figure>
<p>修改一个会影响另外一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.add_(1)</span><br><span class="line">print(a)</span><br><span class="line"># tensor([ 2.,  2.,  2.,  2.,  2.])</span><br><span class="line">print(b)</span><br><span class="line"># [2. 2. 2. 2. 2.]</span><br></pre></td></tr></table></figure>
<p>把把NumPy数组转成Torch Tensor的代码示例为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.ones(5)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, 1, out=a)</span><br><span class="line">print(a)</span><br><span class="line"># [2. 2. 2. 2. 2.]</span><br><span class="line">print(b)</span><br><span class="line"># tensor([ 2.,  2.,  2.,  2.,  2.], dtype=torch.float64)</span><br></pre></td></tr></table></figure>
<p>CPU上的所有类型的Tensor(除了CharTensor)都可以和Numpy数组来回转换。</p>
<h4 id="cuda-tensor">CUDA Tensor</h4>
<p>Tensor可以使用to()方法来移到任意设备上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果有CUDA</span><br><span class="line"># 我们会使用``torch.device``来把tensors放到GPU上</span><br><span class="line">if torch.cuda.is_available():</span><br><span class="line">	device = torch.device(&quot;cuda&quot;)          # 一个CUDA device对象。</span><br><span class="line">	y = torch.ones_like(x, device=device)  # 直接在GPU上创建tensor</span><br><span class="line">	x = x.to(device)                       # 也可以使用``.to(&quot;cuda&quot;)``把一个tensor从CPU移到GPU上</span><br><span class="line">	z = x + y</span><br><span class="line">	print(z)</span><br><span class="line">	print(z.to(&quot;cpu&quot;, torch.double))       # ``.to``也可以在移动的过程中修改dtype</span><br><span class="line">	</span><br><span class="line"># 输出：</span><br><span class="line">tensor([ 0.3034], device=&#x27;cuda:0&#x27;)</span><br><span class="line">tensor([ 0.3034], dtype=torch.float64)	</span><br></pre></td></tr></table></figure>
<h3 id="autograd-自动求导">Autograd: 自动求导</h3>
<p>PyTorch的核心是autograd包。 我们首先简单的了解一些，然后用PyTorch开始训练第一个神经网络。autograd为所有用于Tensor的operation提供自动求导的功能。我们通过一些简单的例子来学习它基本用法。</p>
<h4 id="从自动求导看tensor">从自动求导看Tensor</h4>
<p>torch.Tensor 是这个包的核心类。如果它的属性requires_grad是True，那么PyTorch就会追踪所有与之相关的operation。当完成(正向)计算之后， 我们可以调用backward()，PyTorch会自动的把所有的梯度都计算好。与这个tensor相关的梯度都会累加到它的grad属性里。</p>
<p>如果不想计算这个tensor的梯度，我们可以调用detach()，这样它就不会参与梯度的计算了。为了阻止PyTorch记录用于梯度计算相关的信息(从而节约内存)，我们可以使用 with torch.no_grad()。这在模型的预测时非常有用，因为预测的时候我们不需要计算梯度，否则我们就得一个个的修改Tensor的requires_grad属性，这会非常麻烦。</p>
<p>关于autograd的实现还有一个很重要的Function类。Tensor和Function相互连接从而形成一个有向无环图, 这个图记录了计算的完整历史。每个tensor有一个grad_fn属性来引用创建这个tensor的Function(用户直接创建的Tensor，这些Tensor的grad_fn是None)。</p>
<p>如果你想计算梯度，可以对一个Tensor调用它的backward()方法。如果这个Tensor是一个scalar(只有一个数)，那么调用时不需要传任何参数。如果Tensor多于一个数，那么需要传入和它的shape一样的参数，表示反向传播过来的梯度。</p>
<p>创建tensor时设置属性requires_grad=True，PyTorch就会记录用于反向梯度计算的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.ones(2, 2, requires_grad=True)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<p>然后我们通过operation产生新的tensor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = x + 2</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<p>是通过operation产生的tensor，因此它的grad_fn不是None。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(y.grad_fn)</span><br><span class="line"># &lt;AddBackward0 object at 0x7f35409a68d0&gt;</span><br></pre></td></tr></table></figure>
<p>再通过y得到z和out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z = y * y * 3</span><br><span class="line">out = z.mean()</span><br><span class="line"></span><br><span class="line">print(z, out)</span><br><span class="line"># z = tensor([[ 27.,  27.],[ 27.,  27.]]) </span><br><span class="line"># out = tensor(27.)</span><br></pre></td></tr></table></figure>
<p>requires_grad_()函数会修改一个Tensor的requires_grad。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.randn(2, 2)</span><br><span class="line">a = ((a * 3) / (a - 1))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(True)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure>
<p>输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">&lt;SumBackward0 object at 0x7f35766827f0&gt;</span><br></pre></td></tr></table></figure>
<h4 id="梯度">梯度</h4>
<p>现在我们里反向计算梯度。因为out是一个scalar，因此out.backward()等价于out.backward(torch.tensor(1))。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out.backward()</span><br></pre></td></tr></table></figure>
<p>我们可以打印梯度d(out)/dx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(x.grad)</span><br><span class="line"># tensor([[ 4.5000,  4.5000],</span><br><span class="line">[ 4.5000,  4.5000]])</span><br></pre></td></tr></table></figure>
<p>我们手动计算来验证一下。为了简单，我们把out记为o。 o=14∑izio=14∑izi, zi=3(xi+2)2zi=3(xi+2)2 并且 zi∣∣xi=1=27zi|xi=1=27。</p>
<p>因此，∂o∂xi=32(xi+2)∂o∂xi=32(xi+2)，因此∂o∂xi∣∣xi=1=92=4.5∂o∂xi|xi=1=92=4.5。</p>
<p>我们也可以用autograd做一些很奇怪的事情！比如y和x的关系是while循环的关系(似乎很难用一个函数直接表示y和x的关系？对x不断平方直到超过1000，这是什么函数？)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.randn(3, requires_grad=True)</span><br><span class="line"></span><br><span class="line">y = x * 2</span><br><span class="line">while y.data.norm() &lt; 1000:</span><br><span class="line">	y = y * 2</span><br><span class="line"></span><br><span class="line">print(y)</span><br><span class="line"># tensor([ -692.4808,  1686.1211,   667.7313])</span><br><span class="line">gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)</span><br><span class="line">y.backward(gradients)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br><span class="line"># tensor([  102.4000,  1024.0000,     0.1024])</span><br></pre></td></tr></table></figure>
<p>我们可以使用”with torch.no_grad()”来停止梯度的计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** 2).requires_grad)</span><br><span class="line"></span><br><span class="line">with torch.no_grad():</span><br><span class="line">	print((x ** 2).requires_grad)</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h3 id="pytorch神经网络简介">PyTorch神经网络简介</h3>
<p>神经网络可以通过torch.nn包来创建。我们之前简单的了解了autograd，而nn会使用autograd来定义模型以及求梯度。一个nn.Module对象包括了许多网络层(layer)，并且有一个forward(input)方法来返回output。如下图所示，我们会定义一个卷积网络来识别mnist图片。</p>
<p><img src="/2022/07/22/PyTorch-Abstract/mnist.webp" alt="识别MNIST数据的神经网络"></p>
<p>训练一个神经网络通常需要如下步骤：</p>
<ul>
<li><p>定义一个神经网络，它通常有一些可以训练的参数</p></li>
<li><p>迭代一个数据集(dataset)</p></li>
<li><p>处理网络的输入</p></li>
<li><p>计算loss(会调用Module对象的forward方法)</p></li>
<li><p>计算loss对参数的梯度</p></li>
<li><p>更新参数，通常使用如下的梯度下降方法来更新：</p>
<p>weight = weight - learning_rate * gradient</p></li>
</ul>
<h4 id="定义网络">定义网络</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Net(nn.Module):</span><br><span class="line"></span><br><span class="line">	def __init__(self):</span><br><span class="line">		super(Net, self).__init__()</span><br><span class="line">		# 输入是1个通道的灰度图，输出6个通道(feature map)，使用5x5的卷积核</span><br><span class="line">		self.conv1 = nn.Conv2d(1, 6, 5)</span><br><span class="line">		# 第二个卷积层也是5x5，有16个通道</span><br><span class="line">		self.conv2 = nn.Conv2d(6, 16, 5)</span><br><span class="line">		# 全连接层</span><br><span class="line">		self.fc1 = nn.Linear(16 * 5 * 5, 120)</span><br><span class="line">		self.fc2 = nn.Linear(120, 84)</span><br><span class="line">		self.fc3 = nn.Linear(84, 10)</span><br><span class="line">	</span><br><span class="line">	def forward(self, x):</span><br><span class="line">		# 32x32 -&gt; 28x28 -&gt; 14x14 </span><br><span class="line">		x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2))</span><br><span class="line">		# 14x14 -&gt; 10x10 -&gt; 5x5</span><br><span class="line">		x = F.max_pool2d(F.relu(self.conv2(x)), 2)</span><br><span class="line">		x = x.view(-1, self.num_flat_features(x))</span><br><span class="line">		x = F.relu(self.fc1(x))</span><br><span class="line">		x = F.relu(self.fc2(x))</span><br><span class="line">		x = self.fc3(x)</span><br><span class="line">		return x</span><br><span class="line">	</span><br><span class="line">	def num_flat_features(self, x):</span><br><span class="line">		size = x.size()[1:]  # 除了batch维度之外的其它维度。</span><br><span class="line">		num_features = 1</span><br><span class="line">		for s in size:</span><br><span class="line">		num_features *= s</span><br><span class="line">		return num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br><span class="line"># Net(</span><br><span class="line">(conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">(conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))</span><br><span class="line">(fc1): Linear(in_features=400, out_features=120, bias=True)</span><br><span class="line">(fc2): Linear(in_features=120, out_features=84, bias=True)</span><br><span class="line">(fc3): Linear(in_features=84, out_features=10, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们只需要定义forward函数，而backward函数会自动通过autograd创建。在forward函数里可以使用任何处理Tensor的函数。我们可以使用函数net.parameters()来得到模型所有的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line"># 10</span><br><span class="line">print(params[0].size())  # conv1的weight</span><br><span class="line"># torch.Size([6, 1, 5, 5])</span><br></pre></td></tr></table></figure>
<h4 id="测试网络">测试网络</h4>
<p>接着我们尝试一个随机的32x32的输入来检验(sanity check)网络定义没有问题。注意：这个网络(LeNet)期望的输入大小是32x32。如果使用MNIST数据集(28x28)，我们需要缩放到32x32。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input = torch.randn(1, 1, 32, 32)</span><br><span class="line">out = net(input)</span><br><span class="line">print(out)</span><br><span class="line"># tensor([[-0.0198,  0.0438,  0.0930, -0.0267, -0.0344,  0.0330,  0.0664,</span><br><span class="line">0.1244, -0.0379,  0.0890]])</span><br></pre></td></tr></table></figure>
<p>默认的梯度会累加，因此我们通常在backward之前清除掉之前的梯度值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(1, 10))</span><br></pre></td></tr></table></figure>
<p>注意：torch.nn只支持mini-batches的输入。整个torch.nn包的输入都必须第一维是batch，即使只有一个样本也要弄成batch是1的输入。</p>
<p>比如，nn.Conv2d的输入是一个4D的Tensor，shape是nSamples x nChannels x Height x Width。如果你只有一个样本(nChannels x Height x Width)，那么可以使用input.unsqueeze(0)来增加一个batch维。</p>
<h4 id="损失函数">损失函数</h4>
<p>损失函数的参数是(output, target)对，output是模型的预测，target是实际的值。损失函数会计算预测值和真实值的差别，损失越小说明预测的越准。</p>
<p>PyTorch提供了这里有许多不同的损失函数： http://pytorch.org/docs/nn.html#loss-functions。最简单的一个损失函数是：nn.MSELoss，它会计算预测值和真实值的均方误差。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.arange(1, 11)  # 随便伪造的一个“真实值” </span><br><span class="line">target = target.view(1, -1)  # 把它变成output的shape(1, 10) </span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure>
<p>如果从loss往回走，需要使用tensor的grad_fn属性，我们Negative看到这样的计算图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">-&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">-&gt; MSELoss</span><br><span class="line">-&gt; loss</span><br></pre></td></tr></table></figure>
<p>因此当调用loss.backward()时，PyTorch会计算这个图中所有requires_grad=True的tensor关于loss的梯度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(loss.grad_fn)  # MSELoss</span><br><span class="line">print(loss.grad_fn.next_functions[0][0])  # Add</span><br><span class="line">print(loss.grad_fn.next_functions[0][0].next_functions[0][0])  # Expand</span><br><span class="line"></span><br><span class="line">#输出：</span><br><span class="line">&lt;MseLossBackward object at 0x7f445b3a2dd8&gt;</span><br><span class="line">&lt;AddmmBackward object at 0x7f445b3a2eb8&gt;</span><br><span class="line">&lt;ExpandBackward object at 0x7f445b3a2dd8&gt;</span><br></pre></td></tr></table></figure>
<h4 id="计算梯度">计算梯度</h4>
<p>在调用loss.backward()之前，我们需要清除掉tensor里之前的梯度，否则会累加进去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.zero_grad()     # 清掉tensor里缓存的梯度值。</span><br><span class="line"></span><br><span class="line">print(&#x27;conv1.bias.grad before backward&#x27;)</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(&#x27;conv1.bias.grad after backward&#x27;)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<h4 id="更新参数">更新参数</h4>
<p>更新参数最简单的方法是使用随机梯度下降(SGD)： weight=weight−learningrate∗gradientweight=weight−learningrate∗gradient 我们可以使用如下简单的代码来实现更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">learning_rate = 0.01</span><br><span class="line">for f in net.parameters():</span><br><span class="line">	f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure>
<p>通常我们会使用更加复杂的优化方法，比如SGD, Nesterov-SGD, Adam, RMSProp等等。为了实现这些算法，我们可以使用torch.optim包，它的用法也非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch.optim as optim</span><br><span class="line"></span><br><span class="line"># 创建optimizer，需要传入参数和learning rate</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=0.01)</span><br><span class="line"></span><br><span class="line"># 清除梯度</span><br><span class="line">optimizer.zero_grad()  </span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    # optimizer会自动帮我们更新参数</span><br></pre></td></tr></table></figure>
<p>注意：即使使用optimizer，我们也需要清零梯度。但是我们不需要一个个的清除，而是用optimizer.zero_grad()一次清除所有。</p>
<h3 id="训练一个分类器">训练一个分类器</h3>
<p>介绍了PyTorch神经网络相关包之后我们就可以用这些知识来构建一个分类器了。</p>
<h4 id="如何进行数据处理">如何进行数据处理</h4>
<p>一般地，当我们处理图片、文本、音频或者视频数据的时候，我们可以使用python代码来把它转换成numpy数组。然后再把numpy数组转换成torch.xxxTensor。</p>
<ul>
<li>对于处理图像，常见的lib包括Pillow和OpenCV</li>
<li>对于音频，常见的lib包括scipy和librosa</li>
<li>对于文本，可以使用标准的Python库，另外比较流行的lib包括NLTK和SpaCy</li>
</ul>
<p>对于视觉问题，PyTorch提供了一个torchvision包(需要单独安装)，它对于常见数据集比如Imagenet, CIFAR10, MNIST等提供了加载的方法。并且它也提供很多数据变化的工具，包括torchvision.datasets和torch.utils.data.DataLoader。这会极大的简化我们的工作，避免重复的代码。</p>
<p>在这个教程里，我们使用CIFAR10数据集。它包括十个类别：”airplane”, “automobile”, “bird”, “cat”, “deer”, “dog”, “frog”, “horse”, “ship”,”truck”。图像的对象是3x32x32，也就是3通道(RGB)的32x32的图片。下面是一些样例图片。</p>
<p><img src="/2022/07/22/PyTorch-Abstract/cifar10.webp" alt="cifar10样例"></p>
<h4 id="训练的步骤">训练的步骤</h4>
<ul>
<li>使用torchvision加载和预处理CIFAR10训练和测试数据集。</li>
<li>定义卷积网络</li>
<li>定义损失函数</li>
<li>用训练数据训练模型</li>
<li>用测试数据测试模型</li>
</ul>
<h4 id="数据处理">数据处理</h4>
<p>通过使用torchvision，我们可以轻松的加载CIFAR10数据集。首先我们导入相关的包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torchvision</span><br><span class="line">import torchvision.transforms as transforms</span><br></pre></td></tr></table></figure>
<p>torchvision读取的datasets是PILImage对象，它的取值范围是[0, 1]，我们把它转换到范围[-1, 1]。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">	[transforms.ToTensor(),</span><br><span class="line">	transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])</span><br><span class="line"></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=&#x27;/path/to/data&#x27;, train=True,</span><br><span class="line">	download=True, transform=transform)</span><br><span class="line">	trainloader = torch.utils.data.DataLoader(trainset, batch_size=4,</span><br><span class="line">	shuffle=True, num_workers=2)</span><br><span class="line"></span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=&#x27;/path/to/data&#x27;, train=False,</span><br><span class="line">	download=True, transform=transform)</span><br><span class="line">	testloader = torch.utils.data.DataLoader(testset, batch_size=4,</span><br><span class="line">	shuffle=False, num_workers=2)</span><br><span class="line"></span><br><span class="line">classes = (&#x27;plane&#x27;, &#x27;car&#x27;, &#x27;bird&#x27;, &#x27;cat&#x27;,</span><br><span class="line">	&#x27;deer&#x27;, &#x27;dog&#x27;, &#x27;frog&#x27;, &#x27;horse&#x27;, &#x27;ship&#x27;, &#x27;truck&#x27;)</span><br></pre></td></tr></table></figure>
<p>我们来看几张图片，如<a href="http://fancyerii.github.io/books/pytorch/#pytorch-cifar-sample">下图</a>所示，显示图片的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 显示图片的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def imshow(img):</span><br><span class="line">img = img / 2 + 0.5     #  [-1,1] -&gt; [0,1]</span><br><span class="line">npimg = img.numpy()</span><br><span class="line">plt.imshow(np.transpose(npimg, (1, 2, 0))) # (channel, width, height) -&gt; (width, height, channel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 随机选择一些图片</span><br><span class="line">dataiter = iter(trainloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"># 显示图片</span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"># 打印label</span><br><span class="line">print(&#x27; &#x27;.join(&#x27;%5s&#x27; % classes[labels[j]] for j in range(4)))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/22/PyTorch-Abstract/pytorch-cifar-sample.webp" alt="随机选择的图片"></p>
<h4 id="定义卷积网络">定义卷积网络</h4>
<p>网络结构和上一节的介绍类似，只是输入通道从1变成3。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch.nn as nn</span><br><span class="line">import torch.nn.functional as F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Net(nn.Module):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		super(Net, self).__init__()</span><br><span class="line">		self.conv1 = nn.Conv2d(3, 6, 5)</span><br><span class="line">		self.pool = nn.MaxPool2d(2, 2)</span><br><span class="line">		self.conv2 = nn.Conv2d(6, 16, 5)</span><br><span class="line">		self.fc1 = nn.Linear(16 * 5 * 5, 120)</span><br><span class="line">		self.fc2 = nn.Linear(120, 84)</span><br><span class="line">		self.fc3 = nn.Linear(84, 10)</span><br><span class="line">	</span><br><span class="line">	def forward(self, x):</span><br><span class="line">		x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">		x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">		x = x.view(-1, 16 * 5 * 5)</span><br><span class="line">		x = F.relu(self.fc1(x))</span><br><span class="line">		x = F.relu(self.fc2(x))</span><br><span class="line">		x = self.fc3(x)</span><br><span class="line">		return x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure>
<p>我们这里使用交叉熵损失函数，Optimizer使用带冲量的SGD。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch.optim as optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)</span><br></pre></td></tr></table></figure>
<p>我们遍历DataLoader进行训练。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for epoch in range(2):  # 这里只迭代2个epoch，实际应该进行更多次训练 </span><br><span class="line"></span><br><span class="line">	running_loss = 0.0</span><br><span class="line">	for i, data in enumerate(trainloader, 0):</span><br><span class="line">		# 得到输入</span><br><span class="line">		inputs, labels = data</span><br><span class="line">		</span><br><span class="line">		# 梯度清零 </span><br><span class="line">		optimizer.zero_grad()</span><br><span class="line">		</span><br><span class="line">		# forward + backward + optimize</span><br><span class="line">		outputs = net(inputs)</span><br><span class="line">		loss = criterion(outputs, labels)</span><br><span class="line">		loss.backward()</span><br><span class="line">		optimizer.step()</span><br><span class="line">		</span><br><span class="line">		# 定义统计信息</span><br><span class="line">		running_loss += loss.item()</span><br><span class="line">		if i % 2000 == 1999:</span><br><span class="line">			print(&#x27;[%d, %5d] loss: %.3f&#x27; %</span><br><span class="line">				(epoch + 1, i + 1, running_loss / 2000))</span><br><span class="line">		running_loss = 0.0</span><br><span class="line"></span><br><span class="line">print(&#x27;Finished Training&#x27;)</span><br></pre></td></tr></table></figure>
<h4 id="在测试数据集上进行测试">在测试数据集上进行测试</h4>
<p>我们进行了2轮迭代，可以使用测试数据集上的数据来进行测试。首先我们随机抽取几个样本来进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataiter = iter(testloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line">print(&#x27;GroundTruth: &#x27;, &#x27; &#x27;.join(&#x27;%5s&#x27; % classes[labels[j]] for j in range(4)))</span><br></pre></td></tr></table></figure>
<p>随机选择出来的测试样例如下图所示。</p>
<p><img src="/2022/07/22/PyTorch-Abstract/pytorch-classifier-test-sample.webp" alt="随机测试的结果"></p>
<p>我们用模型来预测一下，看看是否正确预测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outputs = net(images)</span><br></pre></td></tr></table></figure>
<p>outputs是10个分类的logits。我们在训练的时候需要用softmax把它变成概率(CrossEntropyLoss帮我们做了)，但是预测的时候没有必要，因为我们只需要知道哪个分类的概率大就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_, predicted = torch.max(outputs, 1)</span><br><span class="line"></span><br><span class="line">print(&#x27;Predicted: &#x27;, &#x27; &#x27;.join(&#x27;%5s&#x27; % classes[predicted[j]]</span><br><span class="line">		for j in range(4)))</span><br><span class="line"></span><br><span class="line"># cat  ship  ship  ship</span><br></pre></td></tr></table></figure>
<p>预测中的四个错了一个，似乎还不错。接下来我们看看在整个测试集合上的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">correct = 0</span><br><span class="line">total = 0</span><br><span class="line">with torch.no_grad():</span><br><span class="line">for data in testloader:</span><br><span class="line">	images, labels = data</span><br><span class="line">	outputs = net(images)</span><br><span class="line">	_, predicted = torch.max(outputs.data, 1)</span><br><span class="line">	total += labels.size(0)</span><br><span class="line">	correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">print(&#x27;Accuracy of the network on the 10000 test images: %d %%&#x27; % (</span><br><span class="line">	100 * correct / total))</span><br><span class="line"></span><br><span class="line"># Accuracy of the network on the 10000 test images: 55 %</span><br></pre></td></tr></table></figure>
<p>看起来比随机的瞎猜要好，因为随机猜的准确率大概是10%的准确率，所以模型确实学到了一些东西。我们也可以看每个分类的准确率：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class_correct = list(0. for i in range(10))</span><br><span class="line">class_total = list(0. for i in range(10))</span><br><span class="line">with torch.no_grad():</span><br><span class="line">	for data in testloader:</span><br><span class="line">		images, labels = data</span><br><span class="line">		outputs = net(images)</span><br><span class="line">		_, predicted = torch.max(outputs, 1)</span><br><span class="line">		c = (predicted == labels).squeeze()</span><br><span class="line">		for i in range(4):</span><br><span class="line">			label = labels[i]</span><br><span class="line">			class_correct[label] += c[i].item()</span><br><span class="line">			class_total[label] += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">	print(&#x27;Accuracy of %5s : %2d %%&#x27; % (</span><br><span class="line">		classes[i], 100 * class_correct[i] / class_total[i]))</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accuracy of plane : 52 %</span><br><span class="line">Accuracy of   car : 66 %</span><br><span class="line">Accuracy of  bird : 49 %</span><br><span class="line">Accuracy of   cat : 34 %</span><br><span class="line">Accuracy of  deer : 30 %</span><br><span class="line">Accuracy of   dog : 45 %</span><br><span class="line">Accuracy of  frog : 72 %</span><br><span class="line">Accuracy of horse : 71 %</span><br><span class="line">Accuracy of  ship : 76 %</span><br><span class="line">Accuracy of truck : 55 %</span><br></pre></td></tr></table></figure>
<h4 id="gpu上训练">GPU上训练</h4>
<p>为了在GPU上训练，我们需要把Tensor移到GPU上。首先我们看看是否有GPU，如果没有，那么我们还是fallback到CPU。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span><br><span class="line">print(device)</span><br><span class="line"># cuda:0</span><br></pre></td></tr></table></figure>
<p>用GPU进行训练：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Net2(nn.Module):</span><br><span class="line">def __init__(self):</span><br><span class="line">super(Net2, self).__init__()</span><br><span class="line">self.conv1 = nn.Conv2d(3, 6, 5).to(device)</span><br><span class="line">self.pool = nn.MaxPool2d(2, 2).to(device)</span><br><span class="line">self.conv2 = nn.Conv2d(6, 16, 5).to(device)</span><br><span class="line">self.fc1 = nn.Linear(16 * 5 * 5, 120).to(device)</span><br><span class="line">self.fc2 = nn.Linear(120, 84).to(device)</span><br><span class="line">self.fc3 = nn.Linear(84, 10).to(device)</span><br><span class="line"></span><br><span class="line">def forward(self, x):</span><br><span class="line">x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">x = x.view(-1, 16 * 5 * 5)</span><br><span class="line">x = F.relu(self.fc1(x))</span><br><span class="line">x = F.relu(self.fc2(x))</span><br><span class="line">x = self.fc3(x)</span><br><span class="line">return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net2()</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)</span><br><span class="line"></span><br><span class="line">for epoch in range(20):</span><br><span class="line"></span><br><span class="line">	running_loss = 0.0</span><br><span class="line">	for i, data in enumerate(trainloader, 0):</span><br><span class="line">		# 得到输入</span><br><span class="line">		inputs, labels = data </span><br><span class="line">		inputs, labels = inputs.to(device), labels.to(device) </span><br><span class="line">		# 梯度清零 </span><br><span class="line">		optimizer.zero_grad()</span><br><span class="line">		</span><br><span class="line">		# forward + backward + optimize</span><br><span class="line">		outputs = net(inputs)</span><br><span class="line">		loss = criterion(outputs, labels)</span><br><span class="line">		loss.backward()</span><br><span class="line">		optimizer.step()</span><br><span class="line">		</span><br><span class="line">		# 定义统计信息</span><br><span class="line">		running_loss += loss.item()</span><br><span class="line">		if i % 2000 == 1999:</span><br><span class="line">			print(&#x27;[%d, %5d] loss: %.3f&#x27; %</span><br><span class="line">				(epoch + 1, i + 1, running_loss / 2000))</span><br><span class="line">			running_loss = 0.0</span><br><span class="line">		</span><br><span class="line">		print(&#x27;Finished Training&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="通过例子学pytorch">通过例子学PyTorch</h2>
<p>下面我们通过使用不同的方法来实现一个简单的三层(一个隐层)的全连接神经网络来熟悉PyTorch的常见用法。</p>
<h3 id="使用numpy实现三层神经网络">使用Numpy实现三层神经网络</h3>
<p>我们需要实现一个全连接的激活为ReLU的网络，它只有一个隐层，没有bias，用于回归预测一个值，loss是计算实际值和预测值的欧氏距离。这里完全使用numpy手动的进行前向和后向计算。numpy数组就是一个n维的数值，它并不知道任何关于深度学习、梯度下降或者计算图的东西，它只是进行数值运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># N是batch size；D_in是输入大小</span><br><span class="line"># H是隐层的大小；D_out是输出大小。</span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 随机产生输入与输出</span><br><span class="line">x = np.random.randn(N, D_in)</span><br><span class="line">y = np.random.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># 随机初始化参数</span><br><span class="line">w1 = np.random.randn(D_in, H)</span><br><span class="line">w2 = np.random.randn(H, D_out)</span><br><span class="line"></span><br><span class="line">learning_rate = 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">	# 前向计算y</span><br><span class="line">	h = x.dot(w1)</span><br><span class="line">	h_relu = np.maximum(h, 0)</span><br><span class="line">	y_pred = h_relu.dot(w2)</span><br><span class="line">	</span><br><span class="line">	# 计算loss</span><br><span class="line">	loss = np.square(y_pred - y).sum()</span><br><span class="line">	print(t, loss)</span><br><span class="line">	</span><br><span class="line">	# 反向计算梯度 </span><br><span class="line">	grad_y_pred = 2.0 * (y_pred - y)</span><br><span class="line">	grad_w2 = h_relu.T.dot(grad_y_pred)</span><br><span class="line">	grad_h_relu = grad_y_pred.dot(w2.T)</span><br><span class="line">	grad_h = grad_h_relu.copy()</span><br><span class="line">	grad_h[h &lt; 0] = 0</span><br><span class="line">	grad_w1 = x.T.dot(grad_h)</span><br><span class="line">	</span><br><span class="line">	# 更新参数</span><br><span class="line">	w1 -= learning_rate * grad_w1</span><br><span class="line">	w2 -= learning_rate * grad_w2</span><br></pre></td></tr></table></figure>
<h3 id="使用tensor来实现三层神经网络">使用Tensor来实现三层神经网络</h3>
<p>和前面一样，我们还是实现一个全连接的Relu激活的网络，它只有一个隐层并且没有bias。loss是预测与真实值的欧氏距离。之前我们用Numpy实现，自己手动前向计算loss，反向计算梯度。这里还是一样，只不过把numpy数组换成了PyTorch的Tensor。但是使用PyTorch的好处是我们可以利用GPU来加速计算，如果想用GPU计算，我们值需要在创建tensor的时候指定device为gpu。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(&quot;cpu&quot;)</span><br><span class="line"># device = torch.device(&quot;cuda:0&quot;) # 如果想在GPU上运算，把这行注释掉。</span><br><span class="line"></span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">x = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line">y = torch.randn(N, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line">w1 = torch.randn(D_in, H, device=device, dtype=dtype)</span><br><span class="line">w2 = torch.randn(H, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line">learning_rate = 1e-6</span><br><span class="line">for t in range(500): </span><br><span class="line">	h = x.mm(w1)</span><br><span class="line">	h_relu = h.clamp(min=0) # 使用clamp(min=0)来实现ReLU</span><br><span class="line">	y_pred = h_relu.mm(w2)</span><br><span class="line">	</span><br><span class="line">	loss = (y_pred - y).pow(2).sum().item()</span><br><span class="line">	print(t, loss)</span><br><span class="line">	</span><br><span class="line">	grad_y_pred = 2.0 * (y_pred - y)</span><br><span class="line">	grad_w2 = h_relu.t().mm(grad_y_pred)</span><br><span class="line">	grad_h_relu = grad_y_pred.mm(w2.t())</span><br><span class="line">	grad_h = grad_h_relu.clone()</span><br><span class="line">	grad_h[h &lt; 0] = 0</span><br><span class="line">	grad_w1 = x.t().mm(grad_h)</span><br><span class="line">	</span><br><span class="line">	w1 -= learning_rate * grad_w1</span><br><span class="line">	w2 -= learning_rate * grad_w2</span><br></pre></td></tr></table></figure>
<h3 id="实现autograd来实现三层神经网络">实现autograd来实现三层神经网络</h3>
<p>还是和前面一样实现一个全连接的网络，只有一个隐层而且没有bias，使用欧氏距离作为损失函数。这个实现使用PyTorch的Tensor来计算前向阶段，然后使用PyTorch的autograd来自动帮我们反向计算梯度。PyTorch的Tensor代表了计算图中的一个节点。如果x是一个Tensor并且x.requires_grad=True，那么x.grad这个Tensor会保存某个scalar(通常是loss)对x的梯度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(&quot;cpu&quot;)</span><br><span class="line"># device = torch.device(&quot;cuda:0&quot;) # 如果有GPU可以注释掉这行</span><br><span class="line"></span><br><span class="line"># N是batch size；D_in是输入大小</span><br><span class="line"># H是隐层的大小；D_out是输出大小。</span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor作为输入和输出</span><br><span class="line"># 输入和输出需要的requires_grad=False(默认)，</span><br><span class="line"># 因为我们不需要计算loss对它们的梯度。</span><br><span class="line">x = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line">y = torch.randn(N, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line"># 创建weight的Tensor，需要设置requires_grad=True </span><br><span class="line">w1 = torch.randn(D_in, H, device=device, dtype=dtype, requires_grad=True)</span><br><span class="line">w2 = torch.randn(H, D_out, device=device, dtype=dtype, requires_grad=True)</span><br><span class="line"></span><br><span class="line">learning_rate = 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">	# Forward阶段: mm实现矩阵乘法，但是它不支持broadcasting。</span><br><span class="line">	# 如果需要broadcasting，可以使用matmul</span><br><span class="line">	# clamp本来的用途是把值clamp到指定的范围，这里实现ReLU。 </span><br><span class="line">	y_pred = x.mm(w1).clamp(min=0).mm(w2)</span><br><span class="line">	</span><br><span class="line">	# pow(2)实现平方计算。 </span><br><span class="line">	# loss.item()得到这个tensor的值。也可以直接打印loss，这会打印很多附加信息。</span><br><span class="line">	loss = (y_pred - y).pow(2).sum()</span><br><span class="line">	print(t, loss.item())</span><br><span class="line">	</span><br><span class="line">	# 使用autograd进行反向计算。它会计算loss对所有对它有影响的</span><br><span class="line">	# requires_grad=True的Tensor的梯度。</span><br><span class="line">	</span><br><span class="line">	loss.backward()</span><br><span class="line">	</span><br><span class="line">	# 手动使用梯度下降更新参数。一定要把更新的代码放到torch.no_grad()里</span><br><span class="line">	# 否则下面的更新也会计算梯度。后面我们会使用torch.optim.SGD，</span><br><span class="line">	# 它会帮我们管理这些用于更新梯度的计算。</span><br><span class="line">	</span><br><span class="line">	with torch.no_grad():</span><br><span class="line">		w1 -= learning_rate * w1.grad</span><br><span class="line">		w2 -= learning_rate * w2.grad</span><br><span class="line">		</span><br><span class="line">		# 手动把梯度清零 </span><br><span class="line">		w1.grad.zero_()</span><br><span class="line">		w2.grad.zero_()</span><br></pre></td></tr></table></figure>
<h3 id="使用自定义的relu函数">使用自定义的ReLU函数</h3>
<p>这里还是那个全连接网络的例子，不过这里我们不使用clamp来实现ReLU，而是我们自己来实现一个MyReLU的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyReLU(torch.autograd.Function):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	为了实现自定义的实现autograd的函数，我们需要基础torch.autograd.Function，</span><br><span class="line">	然后再实现forward和backward两个函数。</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	@staticmethod</span><br><span class="line">	def forward(ctx, input):</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		在forward函数，我们的输入是input，然后我们根据input计算输出。</span><br><span class="line">		# 同时为了下面的backward，</span><br><span class="line">		我们需要使用save_for_backward来保存用于反向计算的数据到ctx里，</span><br><span class="line">		# 这里我们需要保存input。</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		ctx.save_for_backward(input)</span><br><span class="line">		return input.clamp(min=0)</span><br><span class="line">	</span><br><span class="line">	@staticmethod</span><br><span class="line">	def backward(ctx, grad_output):</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		从ctx.saved_tensors里恢复input</span><br><span class="line">		然后用input计算梯度</span><br><span class="line">		&quot;&quot;&quot;</span><br><span class="line">		input, = ctx.saved_tensors</span><br><span class="line">		grad_input = grad_output.clone()</span><br><span class="line">		grad_input[input &lt; 0] = 0</span><br><span class="line">		return grad_input</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dtype = torch.float</span><br><span class="line">device = torch.device(&quot;cpu&quot;)</span><br><span class="line"></span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">x = torch.randn(N, D_in, device=device, dtype=dtype)</span><br><span class="line">y = torch.randn(N, D_out, device=device, dtype=dtype)</span><br><span class="line"></span><br><span class="line">w1 = torch.randn(D_in, H, device=device, dtype=dtype, requires_grad=True)</span><br><span class="line">w2 = torch.randn(H, D_out, device=device, dtype=dtype, requires_grad=True)</span><br><span class="line"></span><br><span class="line">learning_rate = 1e-6</span><br><span class="line">for t in range(500):</span><br><span class="line">	# 为了调用我们自定义的函数，我们需要使用Function.apply方法，把它命名为&#x27;relu&#x27;</span><br><span class="line">	relu = MyReLU.apply</span><br><span class="line">	</span><br><span class="line">	# 我们使用自定义的ReLU来进行Forward计算</span><br><span class="line">	y_pred = relu(x.mm(w1)).mm(w2)</span><br><span class="line">	</span><br><span class="line">	loss = (y_pred - y).pow(2).sum()</span><br><span class="line">	print(t, loss.item())</span><br><span class="line">	</span><br><span class="line">	loss.backward()</span><br><span class="line">	</span><br><span class="line">	with torch.no_grad():</span><br><span class="line">		w1 -= learning_rate * w1.grad</span><br><span class="line">		w2 -= learning_rate * w2.grad</span><br><span class="line">		</span><br><span class="line">		w1.grad.zero_()</span><br><span class="line">		w2.grad.zero_()</span><br></pre></td></tr></table></figure>
<h3 id="和tensorflow的对比">和Tensorflow的对比</h3>
<p>这里我们还是和前面一样，实现一个隐层的全连接神经网络，优化的目标函数是预测值和真实值的欧氏距离。这个实现使用基本的Tensorflow操作来构建一个计算图，然后多次执行这个计算图来训练网络。Tensorflow和PyTorch最大的区别之一就是Tensorflow使用静态计算图和PyTorch使用动态计算图。在Tensorflow里，我们首先构建计算图，然后多次执行它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 首先构建计算图。</span><br><span class="line"></span><br><span class="line"># N是batch大小；D_in是输入大小。</span><br><span class="line"># H是隐单元个数；D_out是输出大小。</span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 输入和输出是placeholder，在用session执行graph的时候</span><br><span class="line"># 我们会feed进去一个batch的训练数据。</span><br><span class="line">x = tf.placeholder(tf.float32, shape=(None, D_in))</span><br><span class="line">y = tf.placeholder(tf.float32, shape=(None, D_out))</span><br><span class="line"></span><br><span class="line"># 创建变量，并且随机初始化。 </span><br><span class="line"># 在Tensorflow里，变量的生命周期是整个session，因此适合用它来保存模型的参数。</span><br><span class="line">w1 = tf.Variable(tf.random_normal((D_in, H)))</span><br><span class="line">w2 = tf.Variable(tf.random_normal((H, D_out)))</span><br><span class="line"></span><br><span class="line"># Forward pass：计算模型的预测值y_pred </span><br><span class="line"># 注意和PyTorch不同，这里不会执行任何计算，</span><br><span class="line"># 而只是定义了计算，后面用session.run的时候才会真正的执行计算。</span><br><span class="line">h = tf.matmul(x, w1)</span><br><span class="line">h_relu = tf.maximum(h, tf.zeros(1))</span><br><span class="line">y_pred = tf.matmul(h_relu, w2)</span><br><span class="line"></span><br><span class="line"># 计算loss </span><br><span class="line">loss = tf.reduce_sum((y - y_pred) ** 2.0)</span><br><span class="line"></span><br><span class="line"># 计算梯度。 </span><br><span class="line">grad_w1, grad_w2 = tf.gradients(loss, [w1, w2])</span><br><span class="line"></span><br><span class="line"># 使用梯度下降来更新参数。assign同样也只是定义更新参数的操作，不会真正的执行。</span><br><span class="line"># 在Tensorflow里，更新操作是计算图的一部分；</span><br><span class="line"># 而在PyTorch里，因为是动态的”实时“的计算，</span><br><span class="line"># 所以参数的更新只是普通的Tensor计算，不属于计算图的一部分。</span><br><span class="line">learning_rate = 1e-6</span><br><span class="line">new_w1 = w1.assign(w1 - learning_rate * grad_w1)</span><br><span class="line">new_w2 = w2.assign(w2 - learning_rate * grad_w2)</span><br><span class="line"></span><br><span class="line"># 计算图构建好了之后，我们需要创建一个session来执行计算图。</span><br><span class="line">with tf.Session() as sess:</span><br><span class="line">	# 首先需要用session初始化变量 </span><br><span class="line">	sess.run(tf.global_variables_initializer())</span><br><span class="line">	</span><br><span class="line">	# 这是fake的训练数据</span><br><span class="line">	x_value = np.random.randn(N, D_in)</span><br><span class="line">	y_value = np.random.randn(N, D_out)</span><br><span class="line">	for _ in range(500):</span><br><span class="line">		# 用session多次的执行计算图。每次feed进去不同的数据。</span><br><span class="line">		# 这里是模拟的，实际应该每次feed一个batch的数据。</span><br><span class="line">		# run的第一个参数是需要执行的计算图的节点，它依赖的节点也会自动执行，</span><br><span class="line">		#　因此我们不需要手动执行forward的计算。</span><br><span class="line">		# run返回这些节点执行后的值，并且返回的是numpy array</span><br><span class="line">		loss_value, _, _ = sess.run([loss, new_w1, new_w2],</span><br><span class="line">				feed_dict=&#123;x: x_value, y: y_value&#125;)</span><br><span class="line">		print(loss_value)</span><br></pre></td></tr></table></figure>
<h3 id="使用nn模块来实现三层神经网络">使用nn模块来实现三层神经网络</h3>
<p>我们接下来使用nn模块来实现这个简单的全连接网络。前面我们通过用Tensor和Operation等low-level API来创建 动态的计算图，这里我们使用更简单的high-level API。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.__version__)</span><br><span class="line"></span><br><span class="line"># N是batch size；D_in是输入大小 # H是隐层的大小；D_out是输出大小。 N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line"># 创建随机的Tensor作为输入和输出 x = torch.randn(N, D_in)</span><br><span class="line">y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line"># 使用nn包来定义网络。nn.Sequential是一个包含其它模块(Module)的模块。 # 每个Linear模块使用线性函数来计算，它会内部创建需要的weight和bias。 model = torch.nn.Sequential(</span><br><span class="line">	torch.nn.Linear(D_in, H),</span><br><span class="line">	torch.nn.ReLU(),</span><br><span class="line">	torch.nn.Linear(H, D_out),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 常见的损失函数在nn包里也有，不需要我们自己实现 loss_fn = torch.nn.MSELoss(size_average=False)</span><br><span class="line"></span><br><span class="line">learning_rate = 1e-4</span><br><span class="line">for t in range(500):</span><br><span class="line"># 前向计算：通过x来计算y。Module对象会重写__call__函数， # 因此我们可以把它当成函数来调用。 y_pred = model(x)</span><br><span class="line"></span><br><span class="line"># 计算loss loss = loss_fn(y_pred, y)</span><br><span class="line">print(t, loss.item())</span><br><span class="line"></span><br><span class="line"># 梯度清空，调用Sequential对象的zero_grad后所有里面的变量都会清零梯度 model.zero_grad()</span><br><span class="line"></span><br><span class="line"># 反向计算梯度。我们通过Module定义的变量都会计算梯度。 loss.backward()</span><br><span class="line"></span><br><span class="line"># 更新参数，所有的参数都在model.paramenters()里 </span><br><span class="line">with torch.no_grad():</span><br><span class="line">	for param in model.parameters():</span><br><span class="line">		param -= learning_rate * param.grad</span><br></pre></td></tr></table></figure>
<h3 id="使用optim包">使用optim包</h3>
<p>前面我们使用nn模块时是自己来更新模型参数的，PyTorch也提供了optim包，我们可以使用里面的Optimizer来自动的更新模型参数。除了最基本的SGD算法，这个包也实现了常见的SGD+momentum, RMSProp, Adam等算法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">x = torch.randn(N, D_in)</span><br><span class="line">y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line">model = torch.nn.Sequential(</span><br><span class="line">	torch.nn.Linear(D_in, H),</span><br><span class="line">	torch.nn.ReLU(),</span><br><span class="line">	torch.nn.Linear(H, D_out),</span><br><span class="line">)</span><br><span class="line">loss_fn = torch.nn.MSELoss(size_average=False)</span><br><span class="line"></span><br><span class="line"># 使用Adam算法，需要提供模型的参数和learning rate learning_rate = 1e-4</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)</span><br><span class="line">for t in range(500): </span><br><span class="line">	y_pred = model(x)</span><br><span class="line">	</span><br><span class="line">	loss = loss_fn(y_pred, y)</span><br><span class="line">	print(t, loss.item())</span><br><span class="line">	</span><br><span class="line">	# 梯度清零，原来调用的是model.zero_grad，现在调用的是optimizer的zero_grad 	optimizer.zero_grad()</span><br><span class="line">	</span><br><span class="line">	loss.backward()</span><br><span class="line">	</span><br><span class="line">	# 调用optimizer.step实现参数更新 	optimizer.step()</span><br></pre></td></tr></table></figure>
<h3 id="自定义nn模块">自定义nn模块</h3>
<p>对于复杂的网络结构，我们可以通过基础Module了自定义nn模块。这样的好处是用一个类来同样管理，而且更容易复用代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TwoLayerNet(torch.nn.Module):</span><br><span class="line">	def __init__(self, D_in, H, D_out):</span><br><span class="line">		&quot;&quot;&quot; 在构造函数里，我们定义两个nn.Linear模块，把它们保存到self里。 &quot;&quot;&quot;</span><br><span class="line">		super(TwoLayerNet, self).__init__()</span><br><span class="line">		self.linear1 = torch.nn.Linear(D_in, H)</span><br><span class="line">		self.linear2 = torch.nn.Linear(H, D_out)</span><br><span class="line">	</span><br><span class="line">	def forward(self, x):</span><br><span class="line">		&quot;&quot;&quot; 在forward函数里，我们需要根据网络结构来实现前向计算。 通常我们会上定义的模块来计算。 &quot;&quot;&quot;</span><br><span class="line">		h_relu = self.linear1(x).clamp(min=0)</span><br><span class="line">		y_pred = self.linear2(h_relu)</span><br><span class="line">		return y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">x = torch.randn(N, D_in)</span><br><span class="line">y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line">model = TwoLayerNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line">criterion = torch.nn.MSELoss(size_average=False)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=1e-4)</span><br><span class="line">for t in range(500): </span><br><span class="line">	y_pred = model(x)</span><br><span class="line">	</span><br><span class="line">	loss = criterion(y_pred, y)</span><br><span class="line">	print(t, loss.item())</span><br><span class="line">	</span><br><span class="line">	optimizer.zero_grad()</span><br><span class="line">	loss.backward()</span><br><span class="line">	optimizer.step()</span><br></pre></td></tr></table></figure>
<h3 id="流程控制和参数共享">流程控制和参数共享</h3>
<p>为了展示PyTorch的动态图的能力，我们这里会实现一个很奇怪模型：这个全连接的网络的隐层个数是个1到4之间的随机数，而且这些网络层的参数是共享的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DynamicNet(torch.nn.Module):</span><br><span class="line">	def __init__(self, D_in, H, D_out):</span><br><span class="line">		&quot;&quot;&quot; 构造3个nn.Linear实例。 &quot;&quot;&quot;</span><br><span class="line">		super(DynamicNet, self).__init__()</span><br><span class="line">		self.input_linear = torch.nn.Linear(D_in, H)</span><br><span class="line">		self.middle_linear = torch.nn.Linear(H, H)</span><br><span class="line">		self.output_linear = torch.nn.Linear(H, D_out)</span><br><span class="line">	</span><br><span class="line">	def forward(self, x):</span><br><span class="line">		# 输入和输出层是固定的，但是中间层的个数是随机的(0,1,2)， 		# 并且中间层的参数是共享的。 		</span><br><span class="line">		# 因为每次计算的计算图是动态(实时)构造的， 		# 所以我们可以使用普通的Python流程控制代码比如for循环 		# 来实现。读者可以尝试一下怎么用TensorFlow来实现。 		# 另外一点就是一个Module可以多次使用，这样就 		# 可以实现参数共享。 		</span><br><span class="line">		h_relu = self.input_linear(x).clamp(min=0)</span><br><span class="line">		for _ in range(random.randint(0, 3)):</span><br><span class="line">		h_relu = self.middle_linear(h_relu).clamp(min=0)</span><br><span class="line">		y_pred = self.output_linear(h_relu)</span><br><span class="line">		return y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N, D_in, H, D_out = 64, 1000, 100, 10</span><br><span class="line"></span><br><span class="line">x = torch.randn(N, D_in)</span><br><span class="line">y = torch.randn(N, D_out)</span><br><span class="line"></span><br><span class="line">model = DynamicNet(D_in, H, D_out)</span><br><span class="line"></span><br><span class="line">criterion = torch.nn.MSELoss(size_average=False)</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=1e-4, momentum=0.9)</span><br><span class="line">for t in range(500): </span><br><span class="line">	y_pred = model(x)</span><br><span class="line">	</span><br><span class="line">	loss = criterion(y_pred, y)</span><br><span class="line">	print(t, loss.item())</span><br><span class="line">	</span><br><span class="line">	optimizer.zero_grad()</span><br><span class="line">	loss.backward()</span><br><span class="line">	optimizer.step()</span><br></pre></td></tr></table></figure>
<h2 id="迁移学习示例">迁移学习示例</h2>
<p>在这个教程里，我们会学习怎么使用迁移学习来训练模型。通常我们的训练数据量不会很大，很难达到像ImageNet那样上百万的标注数据集。我们可以使用迁移学习来解决训练数据不足的问题。迁移学习里，我们根据训练数据的多少通常可以采取如下方法：</p>
<ul>
<li><p>训练数据很少</p>
<p>那么我们通常把一个pretraning的网络的大部分固定住，然后只是把最后一个全连接层换成新的(最后一层通常是不一样的，因为分类的数量不同)，然后只训练这一层</p></li>
<li><p>训练数据较多</p>
<p>我们可以把pretraining的网络的前面一些层固定住，但后面的层不固定，把最后一层换新的，然后训练</p></li>
<li><p>训练数据很多</p>
<p>所有的pretraining的层都可以fine-tuning，只是用pretraining的参数作为初始化参数。</p></li>
</ul>
<p>首先我们引入依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function, division</span><br><span class="line"></span><br><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.optim as optim</span><br><span class="line">from torch.optim import lr_scheduler</span><br><span class="line">import numpy as np</span><br><span class="line">import torchvision</span><br><span class="line">from torchvision import datasets, models, transforms</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line">plt.ion()</span><br></pre></td></tr></table></figure>
<h3 id="加载数据">加载数据</h3>
<p>我们使用torchvision和torch.utils.data包来加载数据。我们要解决的问题是训练一个模型来区分蚂蚁和蜜蜂，每个类别我们大概有120个训练数据，另外每个类有75个验证数据。这是一个很小的训练集，如果直接用一个神经网络来训练，效果会很差。现在我们用迁移学习来解决这个问题。数据可以在<a href="https://download.pytorch.org/tutorial/hymenoptera_data.zip">这里</a>下载，下载后请解压到data目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 训练的时候会做数据增强和归一化</span><br><span class="line"># 而验证的时候只做归一化</span><br><span class="line">data_transforms = &#123;</span><br><span class="line">	&#x27;train&#x27;: transforms.Compose([</span><br><span class="line">		transforms.RandomResizedCrop(224),</span><br><span class="line">		transforms.RandomHorizontalFlip(),</span><br><span class="line">		transforms.ToTensor(),</span><br><span class="line">		transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])</span><br><span class="line">	]),</span><br><span class="line">	&#x27;val&#x27;: transforms.Compose([</span><br><span class="line">		transforms.Resize(256),</span><br><span class="line">		transforms.CenterCrop(224),</span><br><span class="line">		transforms.ToTensor(),</span><br><span class="line">		transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])</span><br><span class="line">	]),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_dir = &#x27;../data/hymenoptera_data&#x27;</span><br><span class="line">image_datasets = &#123;x: datasets.ImageFolder(os.path.join(data_dir, x),</span><br><span class="line">		data_transforms[x]) </span><br><span class="line">	for x in [&#x27;train&#x27;, &#x27;val&#x27;]&#125;</span><br><span class="line">dataloaders = &#123;x: torch.utils.data.DataLoader(image_datasets[x], batch_size=4,</span><br><span class="line">		shuffle=True, num_workers=4)</span><br><span class="line">	for x in [&#x27;train&#x27;, &#x27;val&#x27;]&#125;</span><br><span class="line">dataset_sizes = &#123;x: len(image_datasets[x]) for x in [&#x27;train&#x27;, &#x27;val&#x27;]&#125;</span><br><span class="line">class_names = image_datasets[&#x27;train&#x27;].classes</span><br><span class="line"></span><br><span class="line">device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="可视化图片">可视化图片</h3>
<p>我们来显示几张图片看看，<a href="http://fancyerii.github.io/books/pytorch/#transfer1">下图</a>是一个batch的图片，显示的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def imshow(inp, title=None):</span><br><span class="line">	inp = inp.numpy().transpose((1, 2, 0))</span><br><span class="line">	mean = np.array([0.485, 0.456, 0.406])</span><br><span class="line">	std = np.array([0.229, 0.224, 0.225])</span><br><span class="line">	inp = std * inp + mean</span><br><span class="line">	inp = np.clip(inp, 0, 1)</span><br><span class="line">	plt.imshow(inp)</span><br><span class="line">	if title is not None:</span><br><span class="line">		plt.title(title)</span><br><span class="line">	plt.pause(0.001)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 得到一个batch的数据</span><br><span class="line">inputs, classes = next(iter(dataloaders[&#x27;train&#x27;]))</span><br><span class="line"></span><br><span class="line"># 把batch张图片拼接成一个大图</span><br><span class="line">out = torchvision.utils.make_grid(inputs)</span><br><span class="line"></span><br><span class="line">imshow(out, title=[class_names[x] for x in classes])</span><br></pre></td></tr></table></figure>
<p><img src="/2022/07/22/PyTorch-Abstract/pytorch-transfer1.webp" alt="迁移学习数据示例"></p>
<h3 id="训练模型">训练模型</h3>
<p>现在我们来实现一个用于训练模型的通用函数。这里我们会演示怎么实现：</p>
<ul>
<li>learning rate的自适应</li>
<li>保存最好的模型</li>
</ul>
<p>在下面的函数中，参数scheduler是来自torch.optim.lr_scheduler的LR scheduler对象(_LRScheduler的子类）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def train_model(model, criterion, optimizer, scheduler, num_epochs=25):</span><br><span class="line">	since = time.time()</span><br><span class="line">	</span><br><span class="line">	best_model_wts = copy.deepcopy(model.state_dict())</span><br><span class="line">	best_acc = 0.0</span><br><span class="line">	</span><br><span class="line">	for epoch in range(num_epochs):</span><br><span class="line">		print(&#x27;Epoch &#123;&#125;/&#123;&#125;&#x27;.format(epoch, num_epochs - 1))</span><br><span class="line">		print(&#x27;-&#x27; * 10)</span><br><span class="line">		</span><br><span class="line">		# 每个epoch都分为训练和验证阶段</span><br><span class="line">		for phase in [&#x27;train&#x27;, &#x27;val&#x27;]:</span><br><span class="line">			if phase == &#x27;train&#x27;:</span><br><span class="line">				scheduler.step()</span><br><span class="line">				model.train()  # 训练阶段</span><br><span class="line">			else:</span><br><span class="line">				model.eval()   # 验证阶段</span><br><span class="line">			</span><br><span class="line">			running_loss = 0.0</span><br><span class="line">			running_corrects = 0</span><br><span class="line">			</span><br><span class="line">			# 变量数据集</span><br><span class="line">			for inputs, labels in dataloaders[phase]:</span><br><span class="line">				inputs = inputs.to(device)</span><br><span class="line">				labels = labels.to(device)</span><br><span class="line">			</span><br><span class="line">			# 参数梯度清空</span><br><span class="line">			optimizer.zero_grad()</span><br><span class="line">			</span><br><span class="line">			# forward</span><br><span class="line">			# 只有训练的时候track用于梯度计算的历史信息。</span><br><span class="line">			with torch.set_grad_enabled(phase == &#x27;train&#x27;):</span><br><span class="line">				outputs = model(inputs)</span><br><span class="line">				_, preds = torch.max(outputs, 1)</span><br><span class="line">				loss = criterion(outputs, labels)</span><br><span class="line">				</span><br><span class="line">				# 如果是训练，那么需要backward和更新参数 </span><br><span class="line">				if phase == &#x27;train&#x27;:</span><br><span class="line">					loss.backward()</span><br><span class="line">					optimizer.step()</span><br><span class="line">			</span><br><span class="line">			# 统计</span><br><span class="line">			running_loss += loss.item() * inputs.size(0)</span><br><span class="line">			running_corrects += torch.sum(preds == labels.data)</span><br><span class="line">			</span><br><span class="line">			epoch_loss = running_loss / dataset_sizes[phase]</span><br><span class="line">			epoch_acc = running_corrects.double() / dataset_sizes[phase]</span><br><span class="line">			</span><br><span class="line">			print(&#x27;&#123;&#125; Loss: &#123;:.4f&#125; Acc: &#123;:.4f&#125;&#x27;.format(</span><br><span class="line">				phase, epoch_loss, epoch_acc))</span><br><span class="line">			</span><br><span class="line">			# 保存验证集上的最佳模型</span><br><span class="line">			if phase == &#x27;val&#x27; and epoch_acc &gt; best_acc:</span><br><span class="line">				best_acc = epoch_acc</span><br><span class="line">				best_model_wts = copy.deepcopy(model.state_dict())</span><br><span class="line">			</span><br><span class="line">			print()</span><br><span class="line">	</span><br><span class="line">	time_elapsed = time.time() - since</span><br><span class="line">	print(&#x27;Training complete in &#123;:.0f&#125;m &#123;:.0f&#125;s&#x27;.format(</span><br><span class="line">		time_elapsed // 60, time_elapsed % 60))</span><br><span class="line">	print(&#x27;Best val Acc: &#123;:4f&#125;&#x27;.format(best_acc))</span><br><span class="line">	</span><br><span class="line">	# 加载最优模型</span><br><span class="line">	model.load_state_dict(best_model_wts)</span><br><span class="line">	return model</span><br></pre></td></tr></table></figure>
<h3 id="可视化预测结果的函数">可视化预测结果的函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def visualize_model(model, num_images=6):</span><br><span class="line">	was_training = model.training</span><br><span class="line">	model.eval()</span><br><span class="line">	images_so_far = 0</span><br><span class="line">	fig = plt.figure()</span><br><span class="line">	</span><br><span class="line">	with torch.no_grad():</span><br><span class="line">		for i, (inputs, labels) in enumerate(dataloaders[&#x27;val&#x27;]):</span><br><span class="line">			inputs = inputs.to(device)</span><br><span class="line">			labels = labels.to(device)</span><br><span class="line">			</span><br><span class="line">			outputs = model(inputs)</span><br><span class="line">			_, preds = torch.max(outputs, 1)</span><br><span class="line">			</span><br><span class="line">			for j in range(inputs.size()[0]):</span><br><span class="line">				images_so_far += 1</span><br><span class="line">				ax = plt.subplot(num_images//2, 2, images_so_far)</span><br><span class="line">				ax.axis(&#x27;off&#x27;)</span><br><span class="line">				ax.set_title(&#x27;predicted: &#123;&#125;&#x27;.format(class_names[preds[j]]))</span><br><span class="line">				imshow(inputs.cpu().data[j])</span><br><span class="line">				</span><br><span class="line">				if images_so_far == num_images:</span><br><span class="line">					model.train(mode=was_training)</span><br><span class="line">					return</span><br><span class="line">		model.train(mode=was_training)</span><br></pre></td></tr></table></figure>
<h3 id="fine-tuning所有参数">fine-tuning所有参数</h3>
<p>我们首先加载一个预训练的模型(imagenet上的resnet)，因为我们的类别数和imagenet不同，所以我们需要删掉原来的全连接层，换成新的全连接层。这里我们让所有的模型参数都可以调整，包括新加的全连接层和预训练的层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model_ft = models.resnet18(pretrained=True)</span><br><span class="line">num_ftrs = model_ft.fc.in_features</span><br><span class="line">model_ft.fc = nn.Linear(num_ftrs, 2)</span><br><span class="line"></span><br><span class="line">model_ft = model_ft.to(device)</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"># 所有的参数都可以训练</span><br><span class="line">optimizer_ft = optim.SGD(model_ft.parameters(), lr=0.001, momentum=0.9)</span><br><span class="line"></span><br><span class="line"># 每7个epoch learning rate变为原来的10% </span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=7, gamma=0.1)</span><br><span class="line"></span><br><span class="line">model_ft = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,</span><br><span class="line">	num_epochs=25)</span><br></pre></td></tr></table></figure>
<p>最终我们得到的分类准确率大概在94.7%。</p>
<h3 id="fine-tuning最后一层参数">fine-tuning最后一层参数</h3>
<p>我们用可以固定住前面层的参数，只训练最后一层。这比之前要快将近一倍，因为反向计算梯度只需要计算最后一层。但是前向计算的时间是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model_conv = torchvision.models.resnet18(pretrained=True)</span><br><span class="line">for param in model_conv.parameters():</span><br><span class="line">	param.requires_grad = False</span><br><span class="line"></span><br><span class="line"># 新加的层默认requires_grad=True </span><br><span class="line">num_ftrs = model_conv.fc.in_features</span><br><span class="line">model_conv.fc = nn.Linear(num_ftrs, 2)</span><br><span class="line"></span><br><span class="line">model_conv = model_conv.to(device)</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"># 值训练最后一个全连接层。</span><br><span class="line">optimizer_conv = optim.SGD(model_conv.fc.parameters(), lr=0.001, momentum=0.9)</span><br><span class="line"></span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_conv, step_size=7, gamma=0.1)</span><br><span class="line"></span><br><span class="line">model_conv = train_model(model_conv, criterion, optimizer_conv,</span><br><span class="line">	exp_lr_scheduler, num_epochs=25)</span><br></pre></td></tr></table></figure>
<p>最终我们得到的分类准确率大概在96%。</p>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Python包导入机制</title>
    <url>/2025/12/10/Python%E7%9A%84%E5%8C%85%E5%AF%BC%E5%85%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本文的主要参考文献为<a href="https://docs.python.org/3/reference/import.html">python的官方文档</a>,针对的python版本为<code>3.14.2</code></p>
<p>首先一个语言的导入系统是很重要的，因为它决定了代码的模块化以及可复用性，一个好的模块系统可以让开发者更方便地组织和管理代码，提高代码的可维护性和可读性。而我之所以写这么一篇文章，就是因为一直被python的导入系统折磨，因此才下定决定来搞清楚python的模块系统与导入机制。</p>
<p>对于python来说，我们最常用的导入方式是使用<code>import</code>语句，但是其实除了<code>import</code>语句之外，还有很多其他的导入方式，比如<code>importlib.import_module()</code>以及内置的<code>__import__()</code>函数等。</p>
<p>而<code>import</code>语句主要做了两件事情：</p>
<ol type="1">
<li>搜索指定名称的模块（就是调用<code>__import__()</code>）。</li>
<li>将搜索的结果绑定到一个local的名称上面。</li>
</ol>
<div class="admonition admonition-example">
<p class="admonition-title">Example</p>
<p><code>import spam</code>会产生如下的字节码：<br>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spam = <span class="built_in"><strong>import</strong></span>(<span class="string">'spam'</span>, <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [], <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>import spam.ham</code>会产生如下的字节码：<br>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spam = <span class="built_in"><strong>import</strong></span>(<span class="string">'spam.ham'</span>, <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [], <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>from spam.ham import eggs, sausage as saus</code>会产生如下的字节码：<br>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_temp = <span class="built_in"><strong>import</strong></span>(<span class="string">'spam.ham'</span>, <span class="built_in">globals</span>(), <span class="built_in">locals</span>(), [<span class="string">'eggs'</span>, <span class="string">'sausage'</span>], <span class="number">0</span>)</span><br><span class="line">eggs = _temp.eggs</span><br><span class="line">saus = _temp.sausage</span><br></pre></td></tr></table></figure></p>
</div>
<p>而有关<code>importlib</code>的介绍，暂时还不在本文的考虑范围，本文主要针对于<code>import</code>语句。</p>
<h1 id="packages介绍">Packages介绍</h1>
<p>python中有模块（module）和包（package）的概念，模块是一个包含python代码的.py文件，而包则是一个包含多个模块的目录。包可以包含子包和模块，从而形成一个层次化的命名空间。除此之外，最早python的包是需要在目录下放置一个<code>__init__.py</code>文件来标识该目录是一个包，但是从python3.3版本开始，这个文件已经不是必须的了（使用<code>__init__.py</code>的是Regular packages，而不使用<code>__init__.py</code>的是Namespace packages，前者需要手动在<code>__init__.py</code>中来维护<code>__path__</code>变量，而后者则是导入机制自动维护）。而且包和模块被导入之后，会定义许多"dunder"(double underscore)的变量，比如<code>__name__</code>，<code>__file__</code>，<code>__path__</code>，<code>__package__</code>等，这些变量在模块和包的导入过程中起着重要的作用。</p>
<p>以<code>__path__</code>为例，该变量就是包（package）被导入时才会定义的变量，其内容为一个列表，包含了该包内部各个模块以及子包（subpackage）的搜索路径，而且可以在包的<code>__init__.py</code>文件中进行修改，从而影响包内部模块的导入行为。</p>
<div class="admonition admonition-warning">
<p class="admonition-title">Warning</p>
<p>注意，<code>__path__</code>变量只在包（package）中定义，而在普通的模块（module）中是没有该变量的。</p>
<p>也就是说<code>__path__</code>要么在<code>__init__.py</code>文件中使用，要么import一个包之后，将其作为包的属性来使用。</p>
</div>
<div class="admonition admonition-example">
<p class="admonition-title">__path__的示例
</p>
<p>假设有如下的包结构：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_package/</span><br><span class="line"> |-- <strong>init</strong>.py</span><br><span class="line"> |-- module1.py</span><br><span class="line"> |-- module2.py</span><br></pre></td></tr></table></figure></p>
<p>然后执行如下的python脚本:<br>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_package.__path__)</span><br></pre></td></tr></table></figure><br>
其输出结果会类似于：</p>
<blockquote>
<p>['/path/to/directory/containing/my_package']</p>
</blockquote>
<p>而依据该变量的结果，当你导入<code>module1</code>和<code>module2</code>时，python解释器就知道去哪里寻找这些模块。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module2</span><br></pre></td></tr></table></figure></p>
</div>
<div class="admonition admonition-example">
<p class="admonition-title">修改__path__
</p>
<p>之所以修改__path__，是因为这样可以将其他的目录变成包<code>my_package</code>的一部分,从而实现更灵活的模块组织和导入。</p>
<p>继续使用上面的包结构，我们可以在<code>__init__.py</code>文件中修改<code>__path__</code>变量：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_package/<strong>init</strong>.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个新的路径到__path__</span></span><br><span class="line"><strong>path</strong>.append(os.path.abspath(<span class="string">'../extra_modules'</span>))</span><br></pre></td></tr></table></figure></p>
<p>这样做了之后，如果<code>extra_modules</code>目录下有一些模块，比如<code>module3.py</code>，我们就可以通过<code>my_package</code>来导入它们：</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module3</span><br></pre></td></tr></table></figure></p>
</div>
<h1 id="导入方式介绍">导入方式介绍</h1>
<p>在使用python的导入功能的时候，我们通常使用的方式是使用<code>import</code>语句，其有两种用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line"><span class="keyword">import</span> &lt;module_name/package_name&gt; [<span class="keyword">as</span> &lt;alias_name&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2 </span></span><br><span class="line"><span class="keyword">from</span> &lt;package_name/module_name&gt; <span class="keyword">import</span> &lt;module_name/class_name/function_name&gt; [<span class="keyword">as</span> &lt;alias_name&gt;]</span><br></pre></td></tr></table></figure>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>需要注意的是，如果<code>import package_name</code>后面接的是一个包名，那么实际上导入的是该包的<code>__init__.py</code>文件所定义的内容，如果没有在<code>__init__.py</code>文件中进行特殊处理，<code>package_name</code>目录下的子模块和子包是不会被自动导入的，也无法通过<code>package_name.submodule</code>的方式访问。</p>
</div>
<p>而python的导入机制主要分为两种：绝对导入和相对导入。</p>
<h2 id="绝对导入">绝对导入</h2>
<p>其中绝对导入可以使用上述的两种<code>import</code>用法，具体的使用语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package_name.module_name [<span class="keyword">as</span> alias_name]</span><br><span class="line"><span class="keyword">from</span> package_name.module_name <span class="keyword">import</span> class_name/function_name [<span class="keyword">as</span> alias_name]</span><br></pre></td></tr></table></figure>
<p>绝对导入的特点在于，其包的搜索路径都是依据<code>sys.path</code>变量的，而默认情况下，<code>sys.path</code>变量包含了当前脚本所在的目录、<code>PYTHONPATH</code>环境变量中指定的目录以及Python安装目录下的标准库目录等。</p>
<p>假设有如下的项目结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/project/</span><br><span class="line">  |-- main.py            <span class="comment"># import my_package.module1  </span></span><br><span class="line">  |-- my_package/</span><br><span class="line">      |-- __init__.py</span><br><span class="line">      |-- module1.py     <span class="comment"># import module2</span></span><br><span class="line">      |-- module2.py     <span class="comment"># print(&quot;Hello from module2&quot;)</span></span><br></pre></td></tr></table></figure>
<p>当我们在<code>/project</code>目录下运行<code>python my_package/module1.py</code>时，<code>sys.path</code>中会包含<code>/project/my_package</code>目录，因此可以正常运行。但是当我们在<code>/project</code>目录下运行<code>python main.py</code>时，<code>sys.path</code>中会包含<code>/project</code>目录，而不包含<code>/project/my_package</code>目录，因此<code>module1.py</code>中的<code>import module2</code>语句会导致导入失败,因为无法查找到<code>module2</code>模块。</p>
<p>可行的的解决办法如下：<strong>最推荐的方法是4</strong></p>
<ol type="1">
<li>将<code>/project/my_package</code>添加到<code>PYTHONPATH</code>环境变量中</li>
<li>在<code>module1.py</code>中，将<code>/project/my_package</code>添加到<code>sys.path</code>中，然后才<code>import module2</code></li>
<li>在<code>module1.py</code>中使用绝对导入的方式来导入<code>module2</code>模块，例如<code>from my_package import module2</code>。但是这个会导致<code>python my_package/module1.py</code>无法运行。</li>
<li>在<code>module1.py</code>中使用相对导入的方式来导入<code>module2</code>模块，例如<code>from . import module2</code>。这个同样会导致<code>python my_package/module1.py</code>无法运行。但是可以使用<code>python -m my_package.module1</code>来运行。</li>
</ol>
<h2 id="相对导入">相对导入</h2>
<p>而相对导入只能使用第二种<code>from ... import ...</code>的用法，具体的使用语法如下：其与绝对导入的区别在于，使用相对导入时，模块名称前面会有一个或多个点号（<code>.</code>），单个<code>.</code>表示当前包，两个点号<code>..</code>表示上级包，三个点号<code>...</code>表示上上级包，依此类推。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .module_name <span class="keyword">import</span> class_name/function_name [<span class="keyword">as</span> alias_name]      <span class="comment"># 导入当前包中的模块</span></span><br><span class="line"><span class="keyword">from</span> ..package_name.module_name <span class="keyword">import</span> class_name/function_name [<span class="keyword">as</span> alias_name]  <span class="comment"># 导入上级包中的模块</span></span><br><span class="line"><span class="keyword">from</span> ...package_name.module_name <span class="keyword">import</span> class_name/function_name [<span class="keyword">as</span> alias_name]  <span class="comment"># 导入上上级包中的模块</span></span><br></pre></td></tr></table></figure>
<p>而相对导入的另一个问题在于，既然是相对导入，那么相对于谁呢？答案是相对于当前模块所在的包（package）。因此，相对导入只能在包内部使用，不能在顶层模块中使用。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>其实相对导入其实是相对于该语句所在的模块（或者说文件）的<code>__package__</code>属性来进行导入的。</p>
<blockquote>
<p>The module’s <code>__package__</code> attribute should be set. Its value must be a string, but it can be the same value as its <code>__name__</code>. If the attribute is set to None or is missing, the import system will fill it in with a more appropriate value. When the module is a package, its <code>__package__</code> value should be set to its <code>__name__</code>. When the module is not a package, <code>__package__</code> should be set to the empty string for top-level modules, or for submodules, to the parent package’s name. See PEP 366 for further details.<br>
简单来说，<code>__package__</code>属性其实就是模块或者包所处的包的名称，如果是顶层模块，则该属性值为<code>''</code>，如果是包，则该属性值为自己的名称，如果是包中的模块，则该属性值为其父包的名称。</p>
</blockquote>
<p>而依据上述关于<code>__package__</code>的描述，我们就知道了为什么相对导入只能在包内部使用，而无法在顶层模块中使用，因为顶层模块的<code>__package__</code>属性值为<code>''</code>，相对导入就不知相对于谁了。</p>
</div>
<p>还有一个问题在于对于一个写好的包，其内部其实往往都是使用相对导入的，因为这样可以避免包被移动到其他位置时，导入路径出错的问题。但是有时候我们可能需要直接运行该包内部的某个模块（<code>python my_package/module1.py</code>），这时候就会出现相对导入失败的问题。</p>
<p>出现这个问题的原因在于，使用<code>python my_package/module1.py</code>运行模块时，Python并没有模块的概念，其<code>__package__</code>属性值为<code>None</code>，<code>__name__</code>属性值为<code>"__main__"</code>，这时候相对导入没有参考点，因此无法正常工作。</p>
<p>而如果通过<code>import my_package.module1</code>来导入该模块时，其<code>__package__</code>属性值为<code>"my_package"</code>，<code>__name__</code>属性值为<code>"my_package.module1"</code>，只有像这样，<code>__package__</code>有非空的值，相对导入才能正常工作。</p>
<p>这就出现一个很恼人的现象，一个模块可以被<code>main.py</code>导入并正常工作，但是直接运行该模块（比如需要进行测试之类的），却出现ImportError的问题。</p>
<p>而如果通过新建一个<code>main.py</code>，然后通过<code>import</code>来运行(测试)模块的话，不仅很麻烦，而且由于通过<code>import</code>导入的模块，其<code>__name__</code>属性值为<code>"my_package.module1"</code>，而不是<code>"__main__"</code>，这会导致一些依赖于<code>__name__</code>属性值的代码无法正常工作。</p>
<p>因此，为了解决运行模块的问题，我们可以采用<code>-m</code>选项来运行模块，通过命令行使用<code>python -m my_package.module1</code>来运行模块，这样Python会将模块作为包的一部分来处理，从而正确设置<code>__package__</code>属性，同时其<code>__name__</code>属性值为<code>"__main__"</code>，从而依赖于<code>__name__</code>属性值的代码也能正常工作。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>需要注意的是，<code>python my_package/module1.py</code>和<code>python -m my_package.module1</code>这两种方式运行模块时，模块的搜索路径（<code>sys.path</code>）是不同的。</p>
<ul>
<li>使用<code>python my_package/module1.py</code>运行模块时，Python会将<code>module1.py</code>所在的目录添加到<code>sys.path</code>的开头。</li>
<li>使用<code>python -m my_package.module1</code>运行模块时，Python会将该命令运行的目录添加到<code>sys.path</code>的开头。</li>
</ul>
</div>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>需要注意的是，<code>python -m main</code>这种情况，Python是有模块的概念的，<code>main.py</code>会被当做顶层模块,其<code>__package__</code>属性值为<code>''</code>，而不是<code>None</code>。但是这种情况仍然是不能使用相对导入的。</p>
</div>
<h1 id="实战建议">实战建议</h1>
<p>基于我对于python包导入机制的理解，我总结了如下几点开发建议，以及在实际开发中，推荐使用的目录结构以及导入方法：</p>
<ul>
<li>在同一个包内部相互导入的时候，统一使用相对导入的方法（package与subpackage之间也是使用相对导入）</li>
<li>在不同包之间导入的时候，统一使用绝对导入的方法</li>
<li>在<code>main.py</code>等顶层脚本中，使用绝对导入的方法来导入包和模块</li>
<li>要单独运行一个package内部的模块时，使用<code>python -m package.module</code>的方式来运行</li>
</ul>
<p>而推荐的目录结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/project/</span><br><span class="line">    |-- main.py            <span class="comment"># 使用绝对导入，例如：from my_package1 import module1</span></span><br><span class="line">    |</span><br><span class="line">    |-- my_package1/</span><br><span class="line">    |   |-- __init__.py</span><br><span class="line">    |   |-- module1.py     <span class="comment"># 使用相对导入，例如：from . import module2</span></span><br><span class="line">    |   |-- module2.py     <span class="comment"># print(&quot;Hello from module2&quot;)</span></span><br><span class="line">    |   |-- sub_package/</span><br><span class="line">    |       |-- __init__.py</span><br><span class="line">    |       |-- sub_module1.py  <span class="comment"># 使用相对导入，例如：from .. import module1</span></span><br><span class="line">    |</span><br><span class="line">    |-- my_package2/</span><br><span class="line">    |   |-- __init__.py</span><br><span class="line">    |   |-- moduleA.py     <span class="comment"># 使用绝对导入，例如：from my_package1 import module1</span></span><br><span class="line">    |</span><br><span class="line">    |-- tests/</span><br><span class="line">        |-- test_module1.py  <span class="comment"># 使用绝对导入，例如：from my_package1 import module1</span></span><br></pre></td></tr></table></figure>
<p>然后不同的模块的运行方式如下：（下面所有的命令都是在<code>/project/</code>目录下运行的）</p>
<ul>
<li>运行顶层脚本<code>main.py</code>：<code>python main.py</code> 或者 <code>python -m main</code></li>
<li>运行<code>my_package1</code>包内部的模块<code>module1.py</code>：<code>python -m my_package1.module1</code></li>
<li>运行<code>my_package1</code>包内部的子包<code>sub_package</code>中的模块<code>sub_module1.py</code>：<code>python -m my_package1.sub_package.sub_module1</code></li>
<li>运行<code>my_package2</code>包内部的模块<code>moduleA.py</code>：<code>python -m my_package2.moduleA</code></li>
<li>运行测试模块<code>test_module1.py</code>：<code>python -m tests.test_module1</code></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>SpinalHDL</title>
    <url>/2025/05/28/SpinalHDL/</url>
    <content><![CDATA[<h1 id="scala语法介绍">SCALA语法介绍</h1>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>SpinalHDL</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>RL理论基础</title>
    <url>/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="强化学习基础">强化学习基础</h1>
<h2 id="强化学习概述">强化学习概述</h2>
<p><strong>强化学习（reinforcement learning，RL）</strong> 讨论的问题是智能体（agent）怎么在复杂、不确定的环境（environment）中最大化它能获得的奖励。如图 1.1 所示，强化学习由两部分组成：智能体和环境。在强化学习过程中，智能体与环境一直在交互。智能体在环境中获取某个状态后，它会利用该状态输出一个动作 （action），这个动作也称为决策（decision）。然后这个动作会在环境中被执行，环境会根据智能体采取的动作，输出下一个状态以及当前这个动作带来的奖励。智能体的目的就是尽可能多地从环境中获取奖励。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/a65c51a6551741678eebe3e9ad33c572957836b591114c4ab3b78962b27f25b4.webp" alt="图 1.1 强化学习示意"></p>
<h3 id="强化学习与监督学习">强化学习与监督学习</h3>
<p>我们可以把强化学习与监督学习做一个对比。以图片分类为例，如图 1.2 所示，<strong>监督学习（supervised learning）</strong>假设我们有大量被标注的数据，比如汽车、飞机、椅子这些被标注的图片，这些图片都要满足独立同分布，即它们之间是没有关联关系的。假设我们训练一个分类器，比如神经网络。为了分辨输入的图片中是汽车还是飞机，在训练过程中，需要把正确的标签信息传递给神经网络。当神经网络做出错误的预测时，比如输入汽车的图片，它预测出来是飞机，我们就会直接告诉它，该预测是错误的，正确的标签应该是汽车。最后我们根据类似错误写出一个损失函数（loss function），通过反向传播（back propagation）来训练神经网络。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/cefd394cb8ae4fb5b8f1e99204c0ee7c0a63a8d2338f4b899886d6a82a457309.webp" alt="图 1.2 监督学习"></p>
<p>所以在监督学习过程中，有两个假设：</p>
<ul>
<li>输入的数据（标注的数据）都应是没有关联的。因为如果输入的数据有关联，学习器（learner）是不好学习的。</li>
<li>需要告诉学习器正确的标签是什么，这样它可以通过正确的标签来修正自己的预测。</li>
</ul>
<blockquote>
<p>通常假设样本空间中全体样本服从一个未知分布，我们获得的每个样本都是独立地从这个分布上采样获得的，即独立同分布(independent and identically distributed，简称 i.i.d.)。</p>
</blockquote>
<p>在强化学习中，监督学习的两个假设其实都不能得到满足。以雅达利（Atari） 游戏 Breakout 为例，如图 1.3 所示，这是一个打砖块的游戏，控制木板左右移 动从而把球反弹到上面来消除砖块。在玩游戏的过程中，我们可以发现智能体得到的观测（observation）不是独立同分布的，上一帧与下一帧间其实有非常强的 连续性。我们得到的数据是相关的时间序列数据，不满足独立同分布。另外，我 们并没有立刻获得反馈，游戏没有告诉我们哪个动作是正确动作。比如现在把木板往右移，这只会使得球往上或者往左一点儿，我们并不会得到即时的反馈。因 此，强化学习之所以困难，是因为智能体不能得到即时的反馈，然而我们依然希望智能体在这个环境中学习。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/7453f6746ab14c69998d29c7e18b510366d976a0a6c942fdbe285af3ee6819c4.webp" alt="图 1.3 雅达利游戏Breakout"></p>
<p>如图 1.4 所示，强化学习的训练数据就是一个玩游戏的过程。我们从第 1 步开始，采取一个动作，比如我们把木板往右移，接到球。第 2 步我们又做出动作，得到的训练数据是一个玩游戏的序列。比如现在是在第 3 步，我们把这个序列放进网络，希望网络可以输出一个动作，即在当前的状态应该输出往右移或 者往左移。这里有个问题，我们没有标签来说明现在这个动作是正确还是错误的，必须等到游戏结束才可能知道，这个游戏可能 10s 后才结束。现在这个动作到底对最后游戏是否能赢有无帮助，我们其实是不清楚的。这里我们就面临<strong>延迟奖励（delayed reward）</strong> 的问题，延迟奖励使得训练网络非常困难。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/3459c0420ce641ae963cb44d3ca5b54e4484294b94c84f3d893d84c9927d8b2d.webp" alt="图 1.4 强化学习：玩Breakout"></p>
<p>强化学习和监督学习的区别如下。</p>
<ol type="1">
<li><p>强化学习输入的样本是序列数据，而不像监督学习里面样本都是独立的。</p></li>
<li><p>学习器并没有告诉我们每一步正确的动作应该是什么，学习器需要自己去发现哪些动作可以带来 最多的奖励，只能通过不停地尝试来发现最有利的动作。</p></li>
<li><p>智能体获得自己能力的过程，其实是不断地试错探索（trial-and-error exploration）的过程。探索 （exploration）和利用（exploitation）是强化学习里面非常核心的问题。其中，探索指尝试一些新的动作， 这些新的动作有可能会使我们得到更多的奖励，也有可能使我们“一无所有”；利用指采取已知的可以获 得最多奖励的动作，重复执行这个动作，因为我们知道这样做可以获得一定的奖励。因此，我们需要在探 索和利用之间进行权衡，这也是在监督学习里面没有的情况。</p></li>
<li><p>在强化学习过程中，没有非常强的监督者（supervisor），只有<strong>奖励信号（reward signal）</strong>，并且奖励信号是延迟的，即环境会在很久以后告诉我们之前我们采取的动作到底是不是有效的。因为我们没有得到即时反馈，所以智能体使用强化学习来学习就非常困难。当我们采取一个动作后，如果我们使用监督学习，我们就可以立刻获得一个指导，比如，我们现在采取了一个错误的动作，正确的动作应该是什么。而在强化学习里面，环境可能会告诉我们这个动作是错误的，但是它并没有告诉我们正确的动作是什么。而且更困难的是，它可能是在一两分钟过后告诉我们这个动作是错误的。所以这也是强化学习和监督学习不同的地方。</p></li>
</ol>
<p>通过与监督学习的比较，我们可以总结出强化学习的一些特征。</p>
<ol type="1">
<li><p>强化学习会试错探索，它通过探索环境来获取对环境的理解。</p></li>
<li><p>强化学习智能体会从环境里面获得延迟的奖励。</p></li>
<li><p>在强化学习的训练过程中，时间非常重要。因为我们得到的是有时间关联的数据（sequential data）， 而不是独立同分布的数据。在机器学习中，如果观测数据有非常强的关联，会使得训练非常不稳定。这也 是为什么在监督学习中，我们希望数据尽量满足独立同分布，这样就可以消除数据之间的相关性。</p></li>
<li><p>智能体的动作会影响它随后得到的数据，这一点是非常重要的。在训练智能体的过程中，很多时 候我们也是通过正在学习的智能体与环境交互来得到数据的。所以如果在训练过程中，智能体不能保持稳 定，就会使我们采集到的数据非常糟糕。我们通过数据来训练智能体，如果数据有问题，整个训练过程就 会失败。所以在强化学习里面一个非常重要的问题就是，怎么让智能体的动作一直稳定地提升。</p></li>
</ol>
<h3 id="强化学习的例子">强化学习的例子</h3>
<p>为什么我们关注强化学习，其中非常重要的一个原因就是强化学习得到的模型可以有超人类的表现。 监督学习获取的监督数据，其实是人来标注的，比如 ImageNet 的图片的标签都是人类标注的。因此我们 可以确定监督学习算法的上限（upper bound）就是人类的表现，标注结果决定了它的表现永远不可能超 越人类。但是对于强化学习，它在环境里面自己探索，有非常大的潜力，它可以获得超越人类的能力的表 现，比如 DeepMind 的 AlphaGo 这样一个强化学习的算法可以把人类顶尖的棋手打败。</p>
<p>这里给大家举一些在现实生活中强化学习的例子。</p>
<ol type="1">
<li><p>在自然界中，羚羊其实也在做强化学习。它刚刚出生的时候，可能都不知道怎么站立，然后它通过试错，一段时间后就可以跑得很快，可以适应环境。</p></li>
<li><p>我们也可以把股票交易看成强化学习的过程。我们可以不断地买卖股票，然后根据市场给出的反馈来学会怎么去买卖可以让我们的奖励最大化。</p></li>
<li><p>玩雅达利游戏或者其他电脑游戏，也是一个强化学习的过程，我们可以通过不断试错来知道怎么 玩才可以通关。</p></li>
</ol>
<p>图 1.5 所示为强化学习的一个经典例子，即雅达利的 Pong 游戏。游戏中右边的选手把球拍到左边， 然后左边的选手需要把球拍到右边。训练好的强化学习智能体和正常的选手有区别：强化学习的智能体会一直做无意义的振动，而正常的选手不会做出这样的动作。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/a503ade5195c4bcda969fb755ed788203857d734a4cf43ca9e386083db3a8c5d.webp" alt="图 1.5 Pong游戏"></p>
<p>在 Pong 游戏里面，其实只有两个动作：往上或者往下。如图 1.6 所示，如果强化学习通过学习一个策略网络来进行分类，那么策略网络会输入当前帧的图片，输出所有决策的可能性，比如往上移动的概率。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/97aca2777d8847d395e1d87fb54c14c4376958567fb4459992b5523188247678.webp" alt="图 1.6 强化学习玩 Pong"></p>
<p>如图 1.7 所示，对于监督学习，我们可以直接告诉智能体正确动作的标签是什么。但在 Pong 游戏中， 我们并不知道它的正确动作的标签是什么。</p>
<center>基于策略的智能体（policy-based agent）</center>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/76de6614f56544228ad049de75fc102f433de8f754da4df2a9b2178b217eaa53.webp" alt="图 1.7 监督学习玩 Pong"></p>
<p>在强化学习里面，我们让智能体尝试玩 Pong 游戏，对动作进行采样，直到游戏结束，然后对每个动作进行惩罚。图 1.8 所示为预演（rollout）的一个过程。预演是指我们从当前帧对动作进行采样，生成很多局游戏。我们将当前的智能体与环境交互，会得到一系列观测。每一个观测可看成一个轨迹（trajectory）。 轨迹就是当前帧以及它采取的策略，即状态和动作的序列：</p>
<p><span class="math display">\[
\tau=\left(s_{0}, a_{0}, s_{1}, a_{1}, \ldots\right)
\]</span></p>
<p>最后结束时，我们会知道到底有没有把这个球拍到对方区域，对方有没有接住，我们是赢了还是输了。我们可以通过观测序列以及最终奖励（eventual reward）来训练智能体，使它尽可能地采取可以获得最终奖励的动作。一场游戏称为一个<strong>回合（episode）</strong> 或者<strong>试验（trial）</strong>。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/b35afcf432014d58b9d190f2c7551d7be28ee003a6e54c46a4694d08ff6da783.webp" alt="图 1.8 可能的预演序列"></p>
<h3 id="强化学习的历史">强化学习的历史</h3>
<p>强化学习是有一定的历史的，早期的强化学习，我们称其为标准强化学习。最近业界把强化学习与深度学习结合起来，就形成了<strong>深度强化学习（deep reinforcement learning）</strong>，因此，深度强化学习 = 深度学习 + 强化学习。我们可将标准强化学习和深度强化学习类比于传统的计算机视觉和深度计算机视觉。</p>
<p>如图 1.9a 所示，传统的计算机视觉由两个过程组成。</p>
<ol type="1">
<li>给定一张图片，我们先要提取它的特征，使用一些设计好的特征，比如方向梯度直方图（histogram of oriental gradient，HOG）、可变现的组件模型（deformable part model，DPM）。</li>
<li>提取这些特征后，我们再单独训练一个分类器。这个分类器可以是支持向量机（support vector machine，SVM）或 Boosting，然后就可以辨别这张图片是狗还是猫。</li>
</ol>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ef68670d4f5a4d6482af3cb3dbc60e47ae95a369cbc94a01a0613a8b2b1275b2.webp" alt="（a）传统的计算机视觉"></p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/47f2c7b88afd4cf689849a0ea629f49cae58049332904ab0acb5e31d4001da13.webp" alt="（b）深度计算机视觉"></p>
<center>图 1.9 传统的计算机视觉与深度计算机视觉的区别</center>
<p>2012年，Krizhevsky等人提出了AlexNet，AlexNet在ImageNet分类比赛中取得冠军，迅速引起了人们对于卷积神经网络的广泛关注。</p>
<p>大家就把特征提取以及分类两者合到一块儿去了，就是训练一个神经网络。这个神经网络既可以做特征提取，也可以做分类，它可以实现端到端训练，如图 1.9b 所示，它的参数可以在每一个阶段都得到极大的优化，这是一个非常重要的突破。</p>
<p>我们可以把神经网络放到强化学习里面。</p>
<ul>
<li>标准强化学习：比如 TD-Gammon 玩 Backgammon 游戏的过程，其实就是设计特征，然后训练价值函数的过程，如图 1.10a 所示。标准强化学习先设计很多特征，这些特征可以描述现在整个状态。得到这些特征后，我们就可以通过训练一个分类网络或者分别训练一个价值估计函数来采取动作。</li>
<li>深度强化学习：自从我们有了深度学习，有了神经网络，就可以把智能体玩游戏的过程改进成一个端到端训练（end-to-end training）的过程，如图 1.10b 所示。我们不需要设计特征，直接输入状态就可以输出动作。我们可以用一个神经网络来拟合价值函数或策略网络，省去特征工程（feature engineering）的过程。</li>
</ul>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/8942d835f27f4d6598db72ee0d5dfd142b0c0548b55a40afba2a6e13b0984823.webp" alt="（a）标准强化学习"></p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1978d45c6e68436da807fe9315801864c001a6888ffe4316b9b85384e112dd32.webp" alt="（b）深度强化学习"></p>
<center>图 1.10 标准强化学习与深度强化学习的区别 </center>
<h2 id="序列决策">序列决策</h2>
<h3 id="智能体与环境">智能体与环境</h3>
<p>接下来我们介绍序列决策（sequential decision making） 过程。强化学习研究的问题是智能体与环 境交互的问题，图 1.12 左边的智能体一直在与图 1.12 右边的<br>
环境进行交互。智能体把它的动作输出给环境，环境取得这个动作后会进行下一步，把下一步的观测与这个动作带来的奖励返还给智能体。这样的交 互会产生很多观测，智能体的目的是从这些观测之中学到能最大化奖励的策略。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/11c10bff7611437aa6255a1387cc82afd4db16058e51490c89d3181af5c876da.webp" alt="图 1.12 智能体与环境"></p>
<h3 id="奖励">奖励</h3>
<p>奖励是由环境给的一种标量的反馈信号（scalar feedback signal），这种信号可显示智能体在某一步采取某个策略的表现如何。强化学习的目的就是最大化智能体可以获得的奖励，智能体在环境里面存在的目的就是最大化它的期望的累积奖励（expected cumulative reward）。不同的环境中，奖励也是不同的。这里给大家举一些奖励的例子。</p>
<ol type="1">
<li>比如一个象棋选手，他的目的是赢棋，在最后棋局结束的时候，他就会得到一个正奖励（赢）或 者负奖励（输）。</li>
<li>在股票管理里面，奖励由股票获取的奖励与损失决定。</li>
<li>在玩雅达利游戏的时候，奖励就是增加或减少的游戏的分数，奖励本身的稀疏程度决定了游戏的难度。</li>
</ol>
<h3 id="序列决策-1">序列决策</h3>
<p>在一个强化学习环境里面，智能体的目的就是选取一系列的动作来最大化奖励，所以这些选取的动作 必须有长期的影响。但在这个过程里面，智能体的奖励其实是被延迟了的，就是我们现在选取的某一步动作，可能要等到很久后才知道这一步到底产生了什么样的影响。如图 1.13 所示，在玩雅达利的 Pong 游戏 时，我们可能只有到最后游戏结束时，才知道球到底有没有被击打过去。过程中我们采取的上升（up）或 下降（down）动作，并不会直接产生奖励。强化学习里面一个重要的课题就是近期奖励和远期奖励的权衡 （trade-off），研究怎么让智能体取得更多的远期奖励。</p>
<p>在与环境的交互过程中，智能体会获得很多观测。针对每一个观测，智能体会采取一个动作，也会得到一个奖励。所以历史是观测、动作、奖励的序列：</p>
<p><span class="math display">\[
H_{t}=o_{1}, a_{1}, r_{1}, \ldots, o_{t}, a_{t}, r_{t}
\]</span></p>
<p>智能体在采取当前动作的时候会依赖于它之前得到的历史，所以我们可以把整个游戏的状态看成关于这个历史的函数：</p>
<p><span class="math display">\[
s_{t}=f\left(H_{t}\right)
\]</span></p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/269c542dad614f14a25174948fc3070ed9b283cbf3cf46608b4b4016343ed4a7.webp" alt="图 1.13 Pong游戏"></p>
<div class="admonition admonition-question">
<p class="admonition-title">状态和观测有什么关系？
</p>
<p><strong>状态</strong>是对世界的完整描述，不会隐藏世界的信息。<strong>观测</strong>是对状态的部分描述，可能会遗漏一些信息。在深度强化学习中，我们几乎总是用实值的向量、矩阵或者更高阶的张量来表示状态和观测。例如， 我们可以用 RGB 像素值的矩阵来表示一个视觉的观测，可以用机器人关节的角度和速度来表示一个机器人的状态。</p>
<p>环境有自己的函数<span class="math inline">\(s_{t}^{e}=f^{e}\left(H_{t}\right)\)</span>来更新状态，在智能体的内部也有一个函数<span class="math inline">\(s_{t}^{a}=f^{a}\left(H_{t}\right)\)</span>来更新状态。当智能体的状态与环境的状态等价的时候，即当智能体能够观察到环境的所有状态时，我们称这个环境是 <strong>完全可观测的（fully observed）</strong>。在这种情况下面，强化学习通常被建模成一个 <strong>马尔可夫决策过程（Markov decision process，MDP）</strong> 的问题(可以使用一个五元组表示<span class="math inline">\((S,A,T,R,\gamma)\)</span>)。在马尔可夫决策过程中，<span class="math inline">\(o_t = s_t^e = s_t^a\)</span>。</p>
<p>但是有一种情况是智能体得到的观测并不能包含环境运作的所有状态，因为在强化学习的设定里面，环境的状态才是真正的所有状态。比如智能体在玩 black jack 游戏，它能看到的其实是牌面上的牌。或者在 玩雅达利游戏的时候，观测到的只是当前电视上面这一帧的信息，我们并没有得到游戏内部里面所有的运作状态。也就是当智能体只能看到部分的观测，我们就称这个环境是 <strong>部分可观测的（partially observed）</strong> 。 在这种情况下，强化学习通常被建模成 <strong>部分可观测马尔可夫决策过程（partially observable Markov decision process, POMDP）</strong> 的问题。部分可观测马尔可夫决策过程是马尔可夫决策过程的一种泛化。部分可观测马尔可夫决策过程依然具有马尔可夫性质，但是假设智能体无法感知环境的状态，只能知道部分观测值。比如在自动驾驶中，智能体只能感知传感器采集的有限的环境信息。部分可观测马尔可夫决策过程可以用一个七元组描述：<span class="math inline">\((S,A,T,R,\Omega,O,\gamma)\)</span>。其中<span class="math inline">\(S\)</span>表示状态空间，为隐变量，<span class="math inline">\(A\)</span>为动作空间，<span class="math inline">\(T(s&#39;|s,a)\)</span>为状态转移概率，<span class="math inline">\(R\)</span>为奖励函数，<span class="math inline">\(\Omega(o|s,a)\)</span>为观测概率，<span class="math inline">\(O\)</span>为观测空间，<span class="math inline">\(\gamma\)</span>为折扣系数。</p>
</div>
<h2 id="动作空间">动作空间</h2>
<p>不同的环境允许不同种类的动作。在给定的环境中，有效动作的集合经常被称为 <strong>动作空间（action space）</strong>。像雅达利游戏和围棋（Go）这样的环境有 <strong>离散动作空间（discrete action space）</strong>，在这个动作空间里，智能体的动作数量是有限的。在其他环境，比如在物理世界中控制一个智能体，在这个环境中就有 <strong>连续动作空间（continuous action space）</strong>。在连续动作空间中，动作是实值的向量。</p>
<p>例如，走迷宫机器人如果只有往东、往南、往西、往北这 4 种移动方式，则其动作空间为离散动作空间；如果机器人可以向 360 。中的任意角度进行移动，则其动作空间为连续动作空间。</p>
<h2 id="agnet的组成成分和类型">Agnet的组成成分和类型</h2>
<p><strong>部分可观测马尔可夫决策过程(Partially Observable Markov Decision Processes, POMDP)</strong> 是一个马尔可夫决策过程的泛化。POMDP依然具有一个强化学习 agent，它可能有一个或多个如下的组成成分。</p>
<ul>
<li><strong>策略（policy）</strong>。智能体会用策略来选取下一步的动作。</li>
<li><strong>价值函数（value function）</strong>。我们用价值函数来对当前状态进行评估。价值函数用于评估智能体进入某个状态后，可以对后面的奖励带来多大的影响。价值函数值越大，说明智能体进入这个状态越有利。</li>
<li><strong>模型（model）</strong>。模型表示智能体对环境的状态进行理解，它决定了环境中世界的运行方式。下面我们深入了解这 3 个组成部分的细节。</li>
</ul>
<h3 id="策略">策略</h3>
<p>策略是智能体用来决定下一步动作的函数。策略可以是一个确定性的函数，也可以是一个随机的函数。确定性策略就是给定一个状态，智能体会输出一个动作；而随机策略则是给定一个状态，智能体会输出一个动作的概率分布。</p>
<p><strong>随机策略（stochastic policy）</strong> 就是<span class="math inline">\(\pi\)</span>函数, 即<span class="math inline">\(\pi(a \mid s) = p(a_t = a \mid s_t = s)\)</span>。输入当前的状态，输出一个概率。<br>
这个概率是智能体所有动作的概率，然后对这个概率分布进行采用，可得到智能体将采取的动作。比如在雅达利游戏里面，如往上移动的概率是 0.7，往下移动的概率是 0.3，就可以通过采样得到最终所要实施的动作。</p>
<p><strong>确定性策略（deterministic policy）</strong> 就是智能体直接采用最优可能的动作，即<span class="math inline">\(a^{*}=\underset{a}{\arg \max} \pi(a \mid s)\)</span></p>
<h3 id="价值函数">价值函数</h3>
<p>价值函数的值是对未来奖励的预测，我们用它来评估状态的好坏。<br>
价值函数里面有一个折扣因子（discount factor），我们希望在尽可能短的时间里面得到尽可能多的奖励。比如现在给我们两个选择：10天后给我们100块钱或者现在给我们100块钱。我们肯定更希望现在就给我们 100 块钱，因为我们可以把这 100 块钱存在银行里面，这样就会有一些利息。因此，我们可以把折扣因子放到价值函数的定义里面，价值函数的定义为</p>
<p><span class="math display">\[
V_{\pi}(s) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid s_{t}=s\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} r_{t+k+1} \mid s_{t}=s\right], \text{对于所有的} s \in S
\]</span></p>
<p>其中，价值函数的下标是<span class="math inline">\(\pi\)</span>函数，因此价值函数其实反映了在<span class="math inline">\(\pi\)</span>策略下，某一个状态平均可以得到多少奖励。期望<span class="math inline">\(E_{\pi}\)</span>是指在策略 <span class="math inline">\(\pi\)</span> 下的期望。<span class="math inline">\(G_t\)</span> 是从时间 <span class="math inline">\(t\)</span> 开始到结束的轨迹的 <strong>折扣化回报（Discounted Return）</strong> (由于从<span class="math inline">\(s\)</span>状态开始，直到结束，轨迹有很多种，因此对其求均值)。<span class="math inline">\(\gamma\)</span> 是折扣因子，<span class="math inline">\(\gamma \in [0,1]\)</span>。如果 <span class="math inline">\(\gamma=0\)</span>，那么我们只考虑当前的奖励；如果 <span class="math inline">\(\gamma=1\)</span>，那么我们就考虑所有的奖励。</p>
<p>我们还有一种价值函数：Q 函数。Q 函数里面包含两个变量：状态和动作。其定义为</p>
<p><span class="math display">\[
Q_{\pi}(s, a) \doteq \mathbb{E}_{\pi}\left[G_{t} \mid s_{t}=s, a_{t}=a\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} r_{t+k+1} \mid s_{t}=s, a_{t}=a\right]
\]</span></p>
<p>所以我们未来可以获得奖励的期望取决于当前的状态和当前的动作。Q函数是强化学习算法里面要学习的一个函数。因为当我们得到 Q 函数后，进入某个状态要采取的最优动作可以通过 Q 函数得到。</p>
<h3 id="模型">模型</h3>
<p>第3个组成部分是模型，模型决定了下一步的状态。下一步的状态取决于当前的状态以及当前采取的动作。它由状态转移概率和奖励函数两个部分组成。状态转移概率即</p>
<p><span class="math display">\[
p_{s s^{\prime}}^{a}=p\left(s_{t+1}=s^{\prime} \mid s_{t}=s, a_{t}=a\right)
\]</span></p>
<p>奖励函数是指我们在当前状态采取了某个动作，可以得到多大的奖励，即</p>
<p><span class="math display">\[
R(s,a)=\mathbb{E}\left[r_{t+1} \mid s_{t}=s, a_{t}=a\right]
\]</span></p>
<p>当我们有了策略、价值函数和模型3个组成部分后，就形成了一个马尔可夫决策过程（Markov decision process）。如图 1.15 所示，这个决策过程可视化了状态之间的转移以及采取的动作。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/d3fdeedcc36f47dda8b20690e679329fa800110926474c3dbe8416b1c7cf38e4.webp" alt="图 1.15 马尔可夫决策过程"></p>
<p>我们来看一个走迷宫的例子。如图 1.16 所示，要求智能体从起点（start）开始，然后到达终点（goal）的位置。每走一步，我们就会得到 -1 的奖励。我们可以采取的动作是往上、下、左、右走。我们用现在智能体所在的位置来描述当前状态。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/dcc3fc0b0fcd401db01d7c877bbd6f949a3ea241ea014f28b4b0b971c2a66705.webp" alt="图 1.16 走迷宫的例子"></p>
<p>我们可以用不同的强化学习方法来解这个环境。</p>
<p>如果我们采取 <strong>基于策略的强化学习（policy-based RL）</strong> 方法，当学习好了这个环境后，在每一个状态，我们都会得到一个最佳的动作。如图 1.17 所示，比如我们现在在起点位置，我们知道最佳动作是往右走；在第二格的时候，得到的最佳动作是往上走；第三格是往右走......通过最佳的策略，我们可以最快地到达终点。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/9cf6d3bfd9154dfda42de3496dc9df88156976ffcbb646d28406a63d7c18cd48.webp" alt="图 1.17 使用基于策略的强化学习方法得到的结果"></p>
<p>如果换成 <strong>基于价值的强化学习（value-based RL）</strong> 方法，利用价值函数作为导向，我们就会得到另外一种表征，每一个状态会返回一个价值。如图 1.18 所示，比如我们在起点位置的时候，价值是-16，因为我们最快可以 16 步到达终点。因为每走一步会减1，所以这里的价值是 -16。<br>
当我们快接近终点的时候，这个数字变得越来越大。在拐角的时候，比如现在在第二格，价值是-15，智能体会看上、下两格，它看到上面格子的价值变大了，变成 -14 了，下面格子的价值是 -16，那么智能体就会采取一个往上走的动作。所以通过学习的价值的不同，我们可以抽取出现在最佳的策略。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/cbd05c38521643d39645d7d8bfa0d5f3ae3d519c0df64b12a9d90e5d4da62bc8.webp" alt="图 1.18 使用基于价值的强化学习方法得到的结果"></p>
<h3 id="智能体类型">智能体类型</h3>
<p><strong>1.基于价值的智能体与基于策略的智能体</strong>：</p>
<p>根据智能体学习的事物不同，我们可以把智能体进行归类。<strong>基于价值的智能体（value-based agent）</strong> 显式地学习价值函数，隐式地学习它的策略。策略是其从学到的价值函数里面推算出来的。<strong>基于策略的智能体（policy-based agent）</strong> 直接学习策略，我们给它一个状态，它就会输出对应动作的概率。基于策略的智能体并没有学习价值函数。把基于价值的智能体和基于策略的智能体结合起来就有了 <strong>演员-评论员智能体（actor-critic agent）</strong> 。这一类智能体把策略和价值函数都学习了，然后通过两者的交互得到最佳的动作。</p>
<div class="admonition admonition-question">
<p class="admonition-title">基于价值的智能体与基于策略的智能体有什么区别？
</p>
<p>对于一个状态转移概率已知的马尔可夫决策过程，我们可以使用动态规划算法来求解。</p>
<p>从决策方式来看，强化学习又可以划分为基于策略的方法和基于价值的方法。决策方式是智能体在给定状态下从动作集合中选择一个动作的依据，它是静态的，不随状态变化而变化。</p>
<p>在 <strong>基于策略的强化学习</strong> 方法中，智能体会制定一套动作策略（确定在给定状态下需要采取何种动作），并根据这个策略进行操作。强化学习算法直接对策略进行优化，使制定的策略能够获得最大的奖励。</p>
<p>在 <strong>基于价值的强化学习</strong> 方法中，智能体不需要制定显式的策略，它维护一个价值表格或价值函数，并通过这个价值表格或价值函数来选取价值最大的动作。</p>
<p>基于价值迭代的方法只能应用在不连续的、离散的环境下（如围棋或某些游戏领域），对于动作集合规模庞大、动作连续的场景（如机器人控制领域），其很难学习到较好的结果（此时基于策略迭代的方法能够根据设定的策略来选择连续的动作）。</p>
</div>
<p>基于价值的强化学习算法有 <strong>Q学习（Q-learning）</strong> 、 <strong>Sarsa</strong> 等，而基于策略的强化学习算法有 <strong>策略梯度（Policy Gradient，PG）</strong> 算法等。此外，演员-评论员算法同时使用策略和价值评估来做出决策。其中，智能体会根据策略做出动作，而价值函数会对做出的动作给出价值，这样可以在原有的策略梯度算法的基础上加速学习过程，取得更好的效果。</p>
<p><strong>2.基于模型的智能体与无模型的智能体</strong>：</p>
<p>在马尔可夫决策过程(MDP)中,有五个关键元素: <span class="math inline">\(S, A, P, R, \gamma\)</span> 。<span class="math inline">\(S\)</span> 和 <span class="math inline">\(A\)</span> 表示环境的状态空间和动作空间; <span class="math inline">\(P\)</span> 表示状态转移函数, <span class="math inline">\(p(s′|s, a)\)</span> 给出了智能体在状态 <span class="math inline">\(s\)</span> 下执行动作 <span class="math inline">\(a\)</span> ,并转移到状态 <span class="math inline">\(s′\)</span> 的概率; <span class="math inline">\(R\)</span> 代表奖励函数, <span class="math inline">\(r(s, a)\)</span> 给出了智能体在状态 <span class="math inline">\(s\)</span> 执行动作 <span class="math inline">\(a\)</span> 时环境返回的奖励值; <span class="math inline">\(\gamma\)</span> 表示奖励的折扣因子,用来给不同时刻的奖励赋予权重。如果所有这些环境相关的元素都是已知的,那么模型就是已知的。此时可以在环境模型上进行计算,而无须再与真实环境进行交互。在通常情况下,智能体并不知道环境的奖励函数 <span class="math inline">\(R\)</span> 和状态转移函数 <span class="math inline">\(p(s′|s, a)\)</span> ,所以需要通过和环境交互,不断试错 (Trials and Errors),观察环境相关信息并利用反馈的奖励信号来不断学习。在这个不断试错和学习的过程中,可能有某些环境元素是未知的,如奖励函数 <span class="math inline">\(R\)</span> 和状态转移函数 <span class="math inline">\(P\)</span> 。此时,如果智能体尝试通过在环境中不断执行动作获取样本 <span class="math inline">\((s, a, s′, r)\)</span> 来构建对 <span class="math inline">\(R\)</span> 和 <span class="math inline">\(P\)</span> 的估计,则 <span class="math inline">\(p(s′|s, a)\)</span> 和 <span class="math inline">\(r\)</span> 的值可以通过监督学习进行拟合。习得奖励函数 <span class="math inline">\(R\)</span> 和状态转移函数 <span class="math inline">\(P\)</span> 之后,所有的环境元素都已知,则规划方法可以直接用来求解该问题。这种方式即称 为 <strong>基于模型</strong> 的方法。</p>
<p>另一种称为无模型的方法则不尝试对环境建模,而是直接寻找最优策略。例 如,Q-learning 算法对状态-动作对 <span class="math inline">\((s, a)\)</span> 的 Q 值进行估计,通常选择最大 Q 值对应的动作执行, 并利用环境反馈更新 Q 值函数,随着 Q 值收敛,策略随之逐渐收敛达到最优;策略梯度(Policy Gradient)算法不对值函数进行估计,而是将策略参数化,直接在策略空间中搜索最优策略,最大化累积奖励。这两种算法都不关注环境模型,而是直接搜索能最大化奖励的策略。这种不需要对环境建模的方式称为 <strong>无模型的方法</strong> 。可以看到,基于模型和无模型的区别在于,智能体是否利 用环境模型(或称为环境的动力学模型),例如状态转移函数和奖励函数。</p>
<h2 id="学习与规划">学习与规划</h2>
<p>学习（learning）和规划（planning）是序列决策的两个基本问题。</p>
<p>如图 1.21 所示，在强化学习中，环境初始时是未知的，智能体不知道环境如何工作，它通过不断地与环境交互，逐渐改进策略。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/da9b71d02df14ff2895bfc5908a3e45f257ae342cfe04c59844ecd4cf147263c.webp" alt="图 1.21 学习"></p>
<p>如图 1.22 所示，在规划中，环境是已知的，智能体被告知了整个环境的运作规则的详细信息。智能体能够计算出一个完美的模型，并且在不需要与环境进行任何交互的时候进行计算。智能体不需要实时地与环境交互就能知道未来环境，只需要知道当前的状态，就能够开始思考，来寻找最优解。</p>
<p>在图 1.22 所示的游戏中，规则是确定的，我们知道选择左之后环境将会产生什么变化。我们完全可以通过已知的规则，来在内部模拟整个决策过程，无需与环境交互。</p>
<p>一个常用的强化学习问题解决思路是，先学习环境如何工作，也就是了解环境工作的方式，即学习得到一个模型，然后利用这个模型进行规划。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/b50ff38231ca4a6a9e44d277d08ba844d90d2d222b9e4240bb823761cf63e8c9.webp" alt="图 1.22 规划"></p>
<h2 id="探索和利用">探索和利用</h2>
<p>在强化学习里面，探索和利用是两个很核心的问题。</p>
<p><strong>探索</strong> 即我们去探索环境，通过尝试不同的动作来得到最佳的策略（带来最大奖励的策略）。<br>
<strong>利用</strong> 即我们不去尝试新的动作，而是采取已知的可以带来很大奖励的动作。</p>
<p>在刚开始的时候，强化学习智能体不知道它采取了某个动作后会发生什么，所以它只能通过试错去探索，所以探索就是通过试错来理解采取的动作到底可不可以带来好的奖励。利用是指我们直接采取已知的可以带来很好奖励的动作。所以这里就面临一个权衡问题，即怎么通过牺牲一些短期的奖励来理解动作，从而学习到更好的策略。</p>
<p>下面举一些探索和利用的例子。</p>
<p>以选择餐馆为例，<strong>利用</strong> 是指我们直接去我们最喜欢的餐馆，因为我们去过这个餐馆很多次了，所以我们知道这里面的菜都非常可口。</p>
<p><strong>探索</strong> 是指我们用手机搜索一个新的餐馆，然后去尝试它的菜到底好不好吃。我们有可能对这个新的餐馆感到非常不满意，这样钱就浪费了。</p>
<p>以做广告为例，<strong>利用</strong> 是指我们直接采取最优的广告策略。<strong>探索</strong> 是指我们换一种广告策略，看看这个新的广告策略可不可以得到更好的效果。</p>
<p>以挖油为例，<strong>利用</strong> 是指我们直接在已知的地方挖油，这样可以确保挖到油。<br>
<strong>探索</strong> 是指我们在一个新的地方挖油，这样就有很大的概率可能不能发现油田，但也可能有比较小的概率可以发现一个非常大的油田。</p>
<p>以玩游戏为例，<strong>利用</strong> 是指我们总是采取某一种策略。比如，我们玩《街头霸王》游戏的时候，采取的策略可能是蹲在角落，然后一直出脚。这个策略很可能可以奏效，但可能遇到特定的对手就会失效。<strong>探索</strong> 是指我们可能尝试一些新的招式，有可能我们会放出“大招”来，这样就可能“一招毙命”。</p>
<p>与监督学习任务不同，强化学习任务的最终奖励在多步动作之后才能观察到，这里我们不妨先考虑比较简单的情形：最大化单步奖励，即仅考虑一步动作。需注意的是，即便在这样的简单情形下，强化学习仍与监督学习有显著不同，因为智能体需通过试错来发现各个动作产生的结果，而没有训练数据告诉智能体应当采取哪个动作。</p>
<p>想要最大化单步奖励需考虑两个方面：一是需知道每个动作带来的奖励，二是要执行奖励最大的动作。若每个动作对应的奖励是一个确定值，那么尝试遍所有的动作便能找出奖励最大的动作。然而，更一般的情形是，一个动作的奖励值是来自一个概率分布，仅通过一次尝试并不能确切地获得平均奖励值。</p>
<p>实际上，单步强化学习任务对应于一个理论模型，即<span class="math inline">\(K\)</span>-臂赌博机（K-armed bandit）。 <span class="math inline">\(K\)</span>-臂赌博机也被称为多臂赌博机（multi-armed bandit） 。如图 1.23 所示，<span class="math inline">\(K\)</span>-臂赌博机有 <span class="math inline">\(K\)</span>个摇臂，赌徒在投入一个硬币后可选择按下其中一个摇臂，每个摇臂以一定的概率吐出硬币，但这个概率赌徒并不知道。赌徒的目标是通过一定的策略最大化自己的奖励，即获得最多的硬币。</p>
<p>若仅为获知每个摇臂的期望奖励，则可采用仅探索（exploration-only）法：将所有的尝试机会平均分配给每个摇臂（即轮流按下每个摇臂），最后以每个摇臂各自的平均吐币概率作为其奖励期望的近似估计。若仅为执行奖励最大的动作，则可采用仅利用（exploitation-only）法：按下目前最优的（即到目前为止平均奖励最大的）摇臂，若有多个摇臂同为最优，则从中随机选取一个。</p>
<p>显然，仅探索法能很好地估计每个摇臂的奖励，却会失去很多选择最优摇臂的机会；仅利用法则相反，它没有很好地估计摇臂期望奖励，很可能经常选不到最优摇臂。因此，这两种方法都难以使最终的累积奖励最大化。</p>
<p>事实上，探索（估计摇臂的优劣）和利用（选择当前最优摇臂）这两者是矛盾的，因为尝试次数（总投币数）有限，加强了一方则自然会削弱另一方，这就是强化学习所面临的 探索-利用窘境（exploration-exploitation dilemma）。显然，想要累积奖励最大，则必须在探索与利用之间达成较好的折中。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1b50a404fc294191baccd65dcf2654161f549aabbe6f4f7b8b101c53a3915385.webp" alt="图 1.23 K-臂赌博机图示"></p>
<h2 id="强化学习实验">强化学习实验</h2>
<h3 id="gymnasium">Gymnasium</h3>
<p><a href="https://gymnasium.farama.org/">Gymnasium</a> 是一个用于开发和比较强化学习算法的工具包。它提供了多种环境供我们使用。Gymnasium 的设计理念是简单易用，用户可以很方便地创建自己的环境。</p>
<p>Gymanasium主要针对于单agent的强化学习任务，如果想要开发多agent的强化学习任务，可以使用PettingZoo。</p>
<p>Gymnasium的安装可以通过pip命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gymnasium</span><br></pre></td></tr></table></figure>
<p>但是上面的命令不会安装其他的环境，所以我们需要安装一些额外的环境。Gymnasium提供了很多的环境供我们使用，比如经典控制、 Atari 游戏、机器人等。我们可以通过下面的命令安装一些常用的环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gymnasium[atari]</span><br><span class="line">pip install gymnasium[all] <span class="comment">#install all dependencies.</span></span><br></pre></td></tr></table></figure>
<p>gymnasium的使用非常简单，我们只需要创建一个环境，然后通过环境的step函数来进行交互。下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialise the environment</span></span><br><span class="line">env = gym.make(<span class="string">&quot;LunarLander-v3&quot;</span>, render_mode=<span class="string">&quot;human&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reset the environment to generate the first observation</span></span><br><span class="line">observation, info = env.reset(seed=<span class="number">42</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># this is where you would insert your policy</span></span><br><span class="line">    action = env.action_space.sample()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step (transition) through the environment with the action</span></span><br><span class="line">    <span class="comment"># receiving the next observation, reward and if the episode has terminated or truncated</span></span><br><span class="line">    observation, reward, terminated, truncated, info = env.step(action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If the episode has ended then we can reset to start a new episode</span></span><br><span class="line">    <span class="keyword">if</span> terminated <span class="keyword">or</span> truncated:</span><br><span class="line">        observation, info = env.reset()</span><br><span class="line"></span><br><span class="line">env.close()</span><br></pre></td></tr></table></figure>
<p>如图 1.25 gymnasium 库里面有很多经典的控制类游戏。比如 Acrobot需要让一个双连杆机器人立起来；CartPole需要通过控制一辆小车，让杆立起来；MountainCar需要通过前后移动车，让它到达旗帜的位置。在刚开始测试强化学习的时候，我们可以选择这些简单环境，因为强化学习在这些环境中可以在一两分钟之内见到效果。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/66f623874034489b983854989ae32227ba599f3c8bbe42eda8cfdb372292a8c0.webp" alt="图 1.25 经典控制问题"></p>
<p>如图 1.26 所示，CartPole-v0 环境有两个动作：将小车向左移动和将小车向右移动。我们还可以得到观测：小车当前的位置，小车当前往左、往右移的速度，杆的角度以及杆的最高点（顶端）的速度。</p>
<p>观测越详细，我们就可以更好地描述当前所有的状态。这里有奖励的定义，如果能多走一步，我们就会得到一个奖励（奖励值为1），所以我们需要存活尽可能多的时间来得到更多的奖励。当杆的角度大于某一个角度（没能保持平衡），或者小车的中心到达图形界面窗口的边缘，或者累积步数大于200，游戏就结束了，我们就输了。所以智能体的目的是控制杆，让它尽可能地保持平衡以及尽可能保持在环境的中央。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ad0c6b8721694dc096453a95414e9f57e03bf8684e9c4381bbff3f17fdada4d6.webp" alt="图 1.26 CartPole-v0的例子"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym  <span class="comment"># 导入 Gym 的 Python 接口环境包    </span></span><br><span class="line">env = gym.make(<span class="string">&#x27;CartPole-v1&#x27;</span>,render_mode=<span class="string">&quot;human&quot;</span>)  <span class="comment"># 构建实验环境    </span></span><br><span class="line">observation, info = env.reset()  <span class="comment"># 重置一个回合    </span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):    </span><br><span class="line">    action = env.action_space.sample() <span class="comment"># 从动作空间中随机选取一个动作    </span></span><br><span class="line">    observation, reward, terminated, truncated, info = env.step(action) <span class="comment"># 用于提交动作，括号内是具体的动作    </span></span><br><span class="line">    <span class="keyword">if</span> terminated <span class="keyword">or</span> truncated:  <span class="comment"># 检查是否结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">env.close() <span class="comment"># 关闭环境</span></span><br></pre></td></tr></table></figure>
<p>注意：如果绘制了实验的图形界面窗口，那么关闭该窗口的最佳方式是调用 env.close()。试图直接关闭图形界面窗口可能会导致内存不能释放，甚至会导致死机。</p>
<p>当我们执行这段代码时，机器人会驾驶着小车朝某个方向一直跑，直到游戏失败，这是因为我们还没开始训练机器人。</p>
<p>我们想要查看当前 gymnasium 库已经注册了哪些环境，可以使用以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym  <span class="comment"># 导入 Gym 的 Python 接口环境包    </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gym.registry:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>每个环境都定义了自己的观测空间和动作空间。环境 env 的观测空间用 env.observation_space 表示，动作空间用 env.action_space 表示。观测空间和动作空间既可以是离散空间（取值是有限个离散的值），也可以是连续空间（取值是连续的值）。在 Gym 库中，一般离散空间用 gym.spaces.Discrete 类表示，连续空间用 gym.spaces.Box 类表示。</p>
<p>例如，环境MountainCar-v0的观测空间是Box(2,)，表示观测可以用 2 个 float 值表示；环境MountainCar-v0的动作空间是Discrete(3)，表示动作取值自{0,1,2}。对于离散空间，Discrete 类实例的成员 n 表示有几个可能的取值；对于连续空间，Box类实例的成员 low 和 high 表示每个浮点数的取值范围。</p>
<h3 id="blackjack-v1历程">Blackjack-v1历程</h3>
<p>接下来使用一个官方的Blackjack-v1的例程，来了解如何使用Gymnasium库。</p>
<h4 id="构建agent">构建agent</h4>
<p>让我们构建一个Q-learning代理来解决Blackjack！我们需要一些函数来选择一个动作并更新代理的动作值。为了确保代理探索环境，一种可能的解决方案是epsilon贪婪策略，其中我们选择一个百分比为epsilon的随机动作，贪婪动作（当前值为最佳）的概率为1-epsilon。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> gymnasium <span class="keyword">as</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackjackAgent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        env: gym.Env,</span></span><br><span class="line"><span class="params">        learning_rate: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        initial_epsilon: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        epsilon_decay: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        final_epsilon: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        discount_factor: <span class="built_in">float</span> = <span class="number">0.95</span>,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initialize a Reinforcement Learning agent with an empty dictionary</span></span><br><span class="line"><span class="string">        of state-action values (q_values), a learning rate and an epsilon.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            env: The training environment</span></span><br><span class="line"><span class="string">            learning_rate: The learning rate</span></span><br><span class="line"><span class="string">            initial_epsilon: The initial epsilon value</span></span><br><span class="line"><span class="string">            epsilon_decay: The decay for epsilon</span></span><br><span class="line"><span class="string">            final_epsilon: The final epsilon value</span></span><br><span class="line"><span class="string">            discount_factor: The discount factor for computing the Q-value</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.env = env</span><br><span class="line">        self.q_values = defaultdict(<span class="keyword">lambda</span>: np.zeros(env.action_space.n))</span><br><span class="line"></span><br><span class="line">        self.lr = learning_rate</span><br><span class="line">        self.discount_factor = discount_factor</span><br><span class="line"></span><br><span class="line">        self.epsilon = initial_epsilon</span><br><span class="line">        self.epsilon_decay = epsilon_decay</span><br><span class="line">        self.final_epsilon = final_epsilon</span><br><span class="line"></span><br><span class="line">        self.training_error = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_action</span>(<span class="params">self, obs: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">bool</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns the best action with probability (1 - epsilon)</span></span><br><span class="line"><span class="string">        otherwise a random action with probability epsilon to ensure exploration.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># with probability epsilon return a random action to explore the environment</span></span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.epsilon:</span><br><span class="line">            <span class="keyword">return</span> self.env.action_space.sample()</span><br><span class="line">        <span class="comment"># with probability (1 - epsilon) act greedily (exploit)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(np.argmax(self.q_values[obs]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        obs: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">bool</span>],</span></span><br><span class="line"><span class="params">        action: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">        reward: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        terminated: <span class="built_in">bool</span>,</span></span><br><span class="line"><span class="params">        next_obs: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">bool</span>],</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Updates the Q-value of an action.&quot;&quot;&quot;</span></span><br><span class="line">        future_q_value = (<span class="keyword">not</span> terminated) * np.<span class="built_in">max</span>(self.q_values[next_obs])</span><br><span class="line">        temporal_difference = (</span><br><span class="line">            reward + self.discount_factor * future_q_value - self.q_values[obs][action]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.q_values[obs][action] = (</span><br><span class="line">            self.q_values[obs][action] + self.lr * temporal_difference</span><br><span class="line">        )</span><br><span class="line">        self.training_error.append(temporal_difference)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decay_epsilon</span>(<span class="params">self</span>):</span><br><span class="line">        self.epsilon = <span class="built_in">max</span>(self.final_epsilon, self.epsilon - self.epsilon_decay)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="训练agent">训练agent</h4>
<p>为了训练代理，我们将让agent运行一个episode（一个完整的游戏称为一个episode），并在采取的每个动作后更新其Q值。agent必须经历很多episode才能充分探索环境。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hyperparameters</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">n_episodes = <span class="number">100_000</span></span><br><span class="line">start_epsilon = <span class="number">1.0</span></span><br><span class="line">epsilon_decay = start_epsilon / (n_episodes / <span class="number">2</span>)  <span class="comment"># reduce the exploration over time</span></span><br><span class="line">final_epsilon = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;Blackjack-v1&quot;</span>, sab=<span class="literal">False</span>)</span><br><span class="line">env = gym.wrappers.RecordEpisodeStatistics(env, buffer_length=n_episodes)</span><br><span class="line"></span><br><span class="line">agent = BlackjackAgent(</span><br><span class="line">    env=env,</span><br><span class="line">    learning_rate=learning_rate,</span><br><span class="line">    initial_epsilon=start_epsilon,</span><br><span class="line">    epsilon_decay=epsilon_decay,</span><br><span class="line">    final_epsilon=final_epsilon,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>当前的超参数被设置为快速训练一个agent。如果你想收敛到最优策略，尝试将n_episodes增加10倍，并降低learning_rate（例如，降低到0.001）。</p>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> episode <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(n_episodes)):</span><br><span class="line">    obs, info = env.reset()</span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># play one episode</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        action = agent.get_action(obs)</span><br><span class="line">        next_obs, reward, terminated, truncated, info = env.step(action)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update the agent</span></span><br><span class="line">        agent.update(obs, action, reward, terminated, next_obs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># update if the environment is done and the current obs</span></span><br><span class="line">        done = terminated <span class="keyword">or</span> truncated</span><br><span class="line">        obs = next_obs</span><br><span class="line"></span><br><span class="line">    agent.decay_epsilon()</span><br></pre></td></tr></table></figure>
<p>使用matplotlib可视化训练过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_moving_avgs</span>(<span class="params">arr, window, convolution_mode</span>):</span><br><span class="line">    <span class="keyword">return</span> np.convolve(</span><br><span class="line">        np.array(arr).flatten(),</span><br><span class="line">        np.ones(window),</span><br><span class="line">        mode=convolution_mode</span><br><span class="line">    ) / window</span><br><span class="line"></span><br><span class="line"><span class="comment"># Smooth over a 500 episode window</span></span><br><span class="line">rolling_length = <span class="number">500</span></span><br><span class="line">fig, axs = plt.subplots(ncols=<span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].set_title(<span class="string">&quot;Episode rewards&quot;</span>)</span><br><span class="line">reward_moving_average = get_moving_avgs(</span><br><span class="line">    env.return_queue,</span><br><span class="line">    rolling_length,</span><br><span class="line">    <span class="string">&quot;valid&quot;</span></span><br><span class="line">)</span><br><span class="line">axs[<span class="number">0</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(reward_moving_average)), reward_moving_average)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].set_title(<span class="string">&quot;Episode lengths&quot;</span>)</span><br><span class="line">length_moving_average = get_moving_avgs(</span><br><span class="line">    env.length_queue,</span><br><span class="line">    rolling_length,</span><br><span class="line">    <span class="string">&quot;valid&quot;</span></span><br><span class="line">)</span><br><span class="line">axs[<span class="number">1</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(length_moving_average)), length_moving_average)</span><br><span class="line"></span><br><span class="line">axs[<span class="number">2</span>].set_title(<span class="string">&quot;Training Error&quot;</span>)</span><br><span class="line">training_error_moving_average = get_moving_avgs(</span><br><span class="line">    agent.training_error,</span><br><span class="line">    rolling_length,</span><br><span class="line">    <span class="string">&quot;same&quot;</span></span><br><span class="line">)</span><br><span class="line">axs[<span class="number">2</span>].plot(<span class="built_in">range</span>(<span class="built_in">len</span>(training_error_moving_average)), training_error_moving_average)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/training.webp" alt="Blackjack-v1训练过程"></p>
<h1 id="强化学习理论与建模">强化学习理论与建模</h1>
<p>本章将介绍马尔可夫决策过程。在介绍马尔可夫决策过程之前，我们先介绍它的简化版本：<strong>马尔可夫过程（Markov process，MP）</strong> 以及 <strong>马尔可夫奖励过程（Markov reward process，MRP）</strong>。通过与这两种过程的比较，我们可以更容易理解马尔可夫决策过程。其次，我们会介绍 马尔可夫决策过程中的 <strong>策略评估（policy evaluation）</strong>，就是当给定决策后，我们怎么去计算它的价值函数。最后，我们会介绍马尔可夫决策过程的控制，具体有 <strong>策略迭代（policy iteration）</strong> 和 <strong>价值迭代（value iteration）</strong> 两种算法。在马尔可夫决策过程中，它的环境是全部可观测的。但是很多时候环境里面有些量是不可观测的，但是这个部分观测的问题也可以转换成马尔可夫决策过程的问题。</p>
<h2 id="马尔可夫过程">马尔可夫过程</h2>
<h3 id="马尔可夫的性质">马尔可夫的性质</h3>
<p>在随机过程中，<strong>马尔可夫性质（Markov property)</strong> 是指一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。以离散随机过程为例，假设随机变量 <span class="math inline">\(X_0,X_1,\cdots,X_T\)</span> 构成一个随机过程。这些随机变量的所有可能取值的集合被称为<strong>状态空间（state space）</strong>。如果 <span class="math inline">\(X_{t+1}\)</span> 对于过去状态的条件概率分布仅是 <span class="math inline">\(X_t\)</span> 的一个函数，则</p>
<p><span class="math display">\[
p\left(X_{t+1}=x_{t+1} \mid X_{0:t}=x_{0: t}\right)=p\left(X_{t+1}=x_{t+1} \mid X_{t}=x_{t}\right)
\]</span></p>
<p>其中 <span class="math inline">\(X_{0:t}\)</span> 表示 <span class="math inline">\(X_0,X_1,\cdots,X_t\)</span> 的联合分布，<span class="math inline">\(x_{0:t}\)</span> 为在状态空间中的状态序列 <span class="math inline">\(x_0,x_1,\cdots,x_t\)</span> 。马尔可夫性质也可以描述为给定当前状态时，将来的状态与过去状态是条件独立的。如果某一个过程满足马尔可夫性质，那么未来的转移与过去的是独立的，它只取决于现在。马尔可夫性质是所有马尔可夫过程的基础。</p>
<h3 id="马尔可夫链">马尔可夫链</h3>
<p>马尔可夫过程是一组具有马尔可夫性质的随机变量序列 <span class="math inline">\(s_1,\cdots,s_t\)</span> ，其中下一个时刻的状态 <span class="math inline">\(s_{t+1}\)</span> 只取决于当前状态 <span class="math inline">\(s_t\)</span> ( <strong>1-order markov chain</strong> )。我们设状态的历史为 <span class="math inline">\(h_{t}=\left\{s_{1}, s_{2}, s_{3}, \ldots, s_{t}\right\}\)</span>（包含了之前的所有状态），则马尔可夫过程满足条件：</p>
<p><span class="math display">\[
p\left(s_{t+1} \mid s_{t}\right) =p\left(s_{t+1} \mid h_{t}\right) 
\]</span></p>
<p>从当前 <span class="math inline">\(s_t\)</span> 转移到 <span class="math inline">\(s_{t+1}\)</span> 就等价于从它之前是所有状态转移到 <span class="math inline">\(s_{t+1}\)</span>。</p>
<p>离散时间的马尔可夫过程也称为 <strong>马尔可夫链（Markov chain）</strong> 。马尔可夫链是最简单的马尔可夫过程，其状态是有限的。例如，图 2.2 里面有4个状态，这4个状态在 <span class="math inline">\(s_1, s_2, s_3, s_4\)</span> 之间互相转移。比如从<span class="math inline">\(s_1\)</span>开始，<span class="math inline">\(s_1\)</span> 有0.1的概率继续留存在 <span class="math inline">\(s_1\)</span> 状态，有0.2的概率转移到 <span class="math inline">\(s_2\)</span> ，有0.7的概率转移到 <span class="math inline">\(s_4\)</span> 。如果 <span class="math inline">\(s_4\)</span> 是我们的当前状态，它有0.3的概率转移到 <span class="math inline">\(s_2\)</span> ，有0.2的概率转移到 <span class="math inline">\(s_3\)</span> ，有0.5的概率留在当前状态。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/a696173ff7384ae4bda6c2937d605f9231247e06f0e64b218d60568daf445206.webp" alt="图 2.2 马尔可夫链示例"><br>
我们可以用 <strong>状态转移矩阵（state transition matrix）</strong> <span class="math inline">\(\boldsymbol{P}\)</span> 来描述状态转移 <span class="math inline">\(p\left(s_{t+1}=s^{\prime} \mid s_{t}=s\right)\)</span><br>
<span class="math display">\[
\boldsymbol{P}=\left(\begin{array}{cccc}    
    p\left(s_{1} \mid s_{1}\right) &amp; p\left(s_{2} \mid s_{1}\right) &amp; \ldots &amp; p\left(s_{N} \mid s_{1}\right) \\    
    p\left(s_{1} \mid s_{2}\right) &amp; p\left(s_{2} \mid s_{2}\right) &amp; \ldots &amp; p\left(s_{N} \mid s_{2}\right) \\    
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    
    p\left(s_{1} \mid s_{N}\right) &amp; p\left(s_{2} \mid s_{N}\right) &amp; \ldots &amp; p\left(s_{N} \mid s_{N}\right)    
    \end{array}\right)
\]</span></p>
<p>状态转移矩阵类似于条件概率（conditional probability），它表示当我们知道当前我们在状态 <span class="math inline">\(s_t\)</span>时，到达下面所有状态的概率。所以它的每一行描述的是从一个节点到达所有其他节点的概率。</p>
<h3 id="隐马尔可夫模型">隐马尔可夫模型</h3>
<p>本小结关于隐马尔可夫模型的内容主要参考斯坦福的<a href="https://web.stanford.edu/~jurafsky/slp3/">《Speech and Language Processing》</a>的课件里面，关于<a href="https://web.stanford.edu/~jurafsky/slp3/A.pdf">HMM的附录</a>部分和一个<a href="https://sm1les.com/2019/04/10/hidden-markov-model/">在线blog</a></p>
<p>当我们需要计算可观察事件序列的发生概率的时候，马尔可夫链是很有用的。但是，在很多情况下，我们所感兴趣的事件是隐藏的（我们没有办法直接观察到），例如，我们通常无法直接观察到一个句子当中各个词的词性（part-of-speech）标签，但是我们可以直接观察到单词，我们需要总单词序列中推导出词性标签，该标签就是隐藏的，因为我们无法直接观察到。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Part-of-Speech Tagging
</p>
<p>词性标注是自然语言处理中的一个重要任务，它的目标是为句子中的每个单词分配一个词性标签。</p>
<p>词性标注的输入一个tokenized的单词序列<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>，输出是一个标签序列<span class="math inline">\(y_1,y_2,\cdots,y_n\)</span>。其中输出的每一个<span class="math inline">\(y_i\)</span>都对应到一个输入的<span class="math inline">\(x_i\)</span>。如下图所示</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/part_of_speech_tagging.webp" alt="part-of-speech tagging"></p>
</div>
<p>隐马尔可夫模型（Hidden Markov Model, HMM）使我们可以同时处理可观测事件（比如输入的单词）和隐藏事件（比如词性标签），其中隐藏事件我们虽然不能直接观察，但是在模型中，我们认为它们是造成观察结果的潜在因素（causal factors）</p>
<p>隐马尔可夫模型（如下图所示）通常由以下几个部分组成：</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/HMM.webp" alt="HMM示意图"></p>
<p><span class="math inline">\(Q = \{q_1,q_2,\cdots,q_N\}\)</span>是所有可能的状态(隐藏状态)的集合，其中<span class="math inline">\(N\)</span>是可能的状态数。</p>
<p><span class="math inline">\(V = \{v_1,v_2,\cdots,v_M\}\)</span>是所有可能的观测的集合，其中<span class="math inline">\(M\)</span>是可能的观测数。</p>
<p><span class="math inline">\(I = (i_1,i_2,\cdots,i_T)\)</span>是长度为<span class="math inline">\(T\)</span>的状态序列，而<span class="math inline">\(O = (o_1,o_2,\cdots,o_T)\)</span>是对应的观测序列</p>
<p><span class="math inline">\(A = [a_{ij}]_{N\times N}\)</span>是状态转移矩阵，其中<span class="math inline">\(a_{ij} = P(i_{t+1} = q_j | i_t = q_i)\)</span>表示在时刻<span class="math inline">\(t\)</span>处于状态<span class="math inline">\(q_i\)</span>的条件下，在时刻<span class="math inline">\(t+1\)</span>处于状态<span class="math inline">\(q_j\)</span>的概率。</p>
<p><span class="math inline">\(B = [b_{jk}]_{N\times M}\)</span>是观测概率矩阵，其中<span class="math inline">\(b_{jk} = P(o_t = v_k | i_t = q_j)\)</span>表示在时刻<span class="math inline">\(t\)</span>处于状态<span class="math inline">\(q_j\)</span>的条件下，观测到<span class="math inline">\(v_k\)</span>的概率。</p>
<p><span class="math inline">\(\pi = (\pi_1,\pi_2,\cdots,\pi_N)\)</span>是初始状态概率向量，其中<span class="math inline">\(\pi_i = P(i_1 = q_i)\)</span>表示在时刻<span class="math inline">\(t=1\)</span>处于状态<span class="math inline">\(q_i\)</span>的概率。</p>
<p>隐马尔可夫模型由初始状态概率向量<span class="math inline">\(\pi\)</span>、状态转移概率矩阵<span class="math inline">\(A\)</span>和观测概率矩阵<span class="math inline">\(B\)</span>决定。<span class="math inline">\(\pi\)</span>和<span class="math inline">\(A\)</span>决定状态序列，<span class="math inline">\(B\)</span>决定观测序列。因此，隐马尔可夫模型<span class="math inline">\(\lambda\)</span>可以用三元符号表示，即：</p>
<p><span class="math display">\[
\lambda = (A,B, \pi)
\]</span></p>
<p><span class="math inline">\(A,B,\pi\)</span>称为隐马尔可夫模型的三要素。</p>
<p>从定义可知，隐马尔可夫模型做了两个基本假设：</p>
<ol type="1">
<li>齐次马尔可夫性假设，即假设隐藏的马尔可夫链在任意时刻<span class="math inline">\(t\)</span>的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关<span class="math inline">\(P(i_t\vert i_{t-1},o_{t-1},...,i_1,o_1)=P(i_t\vert i_{t-1})\)</span></li>
<li>观测独立性假设，即假设任意时刻的观测只依赖于该时刻的马尔可夫链的状态，与其他观测及状态无关：<span class="math inline">\(P(o_t\vert i_T,o_T,i_{T-1},o_{T-1},...,i_t,i_{t-1},o_{t-1},...,i_1,o_1)=P(o_t\vert i_t)\)</span></li>
</ol>
<h3 id="马尔可夫过程示例">马尔可夫过程示例</h3>
<p>图 2.2 所示为一个马尔可夫过程的例子，这里有七个状态。比如从 <span class="math inline">\(s_1\)</span>开始，它有0.4的概率到 <span class="math inline">\(s_2\)</span>，有 0.6 的概率留在当前的状态。 <span class="math inline">\(s_2\)</span> 有 0.4 的概率到 <span class="math inline">\(s_1\)</span>，有 0.4 的概率到 <span class="math inline">\(s_3\)</span>，另外有 0.2 的概率留在当前状态。所以给定状态转移的马尔可夫链后，我们可以对这个链进行采样，这样就会得到一串轨迹。例如，假设我们从状态 <span class="math inline">\(s_3\)</span>开始，可以得到3个轨迹：</p>
<ul>
<li><span class="math inline">\(s_3, s_4, s_5, s_6, s_6\)</span></li>
<li><span class="math inline">\(s_3, s_2, s_3, s_2, s_1\)</span></li>
<li><span class="math inline">\(s_3, s_4, s_4, s_5, s_5\)</span></li>
</ul>
<p>通过对状态的采样，我们可以生成很多这样的轨迹。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/172f2e4caf414bae8c400b47555ba922db67173061114ef0b30b69b451a14b16.webp" alt="图 2.3 马尔可夫过程的例子"></p>
<h2 id="马尔可夫奖励过程">马尔可夫奖励过程</h2>
<p><strong>马尔可夫奖励过程（Markov reward process, MRP）</strong> 是马尔可夫链加上奖励函数。在马尔可夫奖励过程中，状态转移矩阵和状态都与马尔可夫链一样，只是多了 <strong>奖励函数（reward function）</strong> 。奖励函数<span class="math inline">\(R\)</span>是一个期望，表示当我们到达某一个状态的时候，可以获得多大的奖励。这里另外定义了折扣因子<span class="math inline">\(\gamma\)</span>。如果状态数是有限的，那么<span class="math inline">\(R\)</span>可以是一个向量。</p>
<h3 id="回报与价值函数">回报与价值函数</h3>
<p>这里我们进一步定义一些概念。<strong>范围（horizon）</strong> 是指一个回合的长度（每个回合最大的时间步数），它是由有限个步数决定的。<br>
<strong>回报（return）</strong> 可以定义为奖励的逐步叠加，假设时刻<span class="math inline">\(t\)</span>后的奖励序列为<span class="math inline">\(r_{t+1},r_{t+2},r_{t+3},\cdots,\)</span> (其中关于为什么使用<span class="math inline">\(t+1\)</span>而不是<span class="math inline">\(t\)</span>，主要是为了体现<span class="math inline">\(r_{t+1}\)</span>是进入<span class="math inline">\(s_t\)</span>之后获得的瞬时奖励)，则回报为</p>
<p><span class="math display">\[
G_{t}=r_{t+1}+\gamma r_{t+2}+\gamma^{2} r_{t+3}+\gamma^{3} r_{t+4}+\ldots+\gamma^{T-t-1} r_{T}
\]</span></p>
<p>其中，<span class="math inline">\(T\)</span>是最终时刻，<span class="math inline">\(\gamma\)</span>是折扣因子，越往后得到的奖励，折扣越多。这说明我们更希望得到现有的奖励，对未来的奖励要打折扣。当我们有了回报之后，就可以定义状态的价值了，就是 <strong>状态价值函数（state-value function）</strong>。对于马尔可夫奖励过程，状态价值函数被定义成回报的期望，即</p>
<p><span class="math display">\[
\begin{align*}    
    V^{t}(s) &amp;=\mathbb{E}\left[G_{t} \mid s_{t}=s\right] \\    
    &amp;=\mathbb{E}\left[r_{t+1}+\gamma r_{t+2}+\gamma^{2} r_{t+3}+\ldots+\gamma^{T-t-1} r_{T} \mid s_{t}=s\right]    
\end{align*}
\]</span></p>
<p>其中，<span class="math inline">\(G_t\)</span>是之前定义的 <strong>折扣回报（discounted return）</strong>。我们对<span class="math inline">\(G_t\)</span>取了一个期望，因为<span class="math inline">\(G_t\)</span>表示的是一个特定的状态转移的回报，但是由于状态转移不是固定的，因此会有很多种状态转移，因此通过取期望来表示从该状态出发，能获得回报的期望，用于表示该状态的价值。</p>
<p>我们使用折扣因子的原因如下。第一，有些马尔可夫过程是带环的，它并不会终结，我们想避免无穷的奖励。第二，我们并不能建立完美的模拟环境的模型，我们对未来的评估不一定是准确的，我们不一定完全信任模型，因为这种不确定性，所以我们对未来的评估增加一个折扣。我们想把这个不确定性表示出来，希望尽可能快地得到奖励，而不是在未来某一个点得到奖励。第三，如果奖励是有实际价值的，我们可能更希望立刻就得到奖励，而不是后面再得到奖励（现在的钱比以后的钱更有价值）。最后，我们也更想得到即时奖励。有些时候可以把折扣因子设为 0（<span class="math inline">\(\gamma = 0\)</span>），我们就只关注当前的奖励。我们也可以把折扣因子设为 1（<span class="math inline">\(\gamma = 1\)</span>），对未来的奖励并没有打折扣，未来获得的奖励与当前获得的奖励是一样的权重。折扣因子可以作为强化学习智能体的一个 <strong>超参数（hyperparameter）</strong> 来进行调整，通过调整折扣因子，我们可以得到不同动作的智能体。</p>
<p>在马尔可夫奖励过程里面，我们如何计算价值呢？如图 2.4 所示，马尔可夫奖励过程依旧是状态转移，其奖励函数可以定义为：智能体进入第一个状态<span class="math inline">\(s_1\)</span>的时候会得到<span class="math inline">\(5\)</span>的奖励，进入第七个状态<span class="math inline">\(s_7\)</span>的时候会得到<span class="math inline">\(10\)</span>的奖励，进入其他状态都没有奖励。我们可以用向量来表示奖励函数，即</p>
<p><span class="math display">\[
\boldsymbol{R}=[5,0,0,0,0,0,10]
\]</span></p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/db2837c5a12044e6babd69091120215bfff94a5ecd024de3b827b8bfd39de631.webp" alt="图 2.4 马尔可夫奖励过程的例子"></p>
<p>我们对 4 步的回合（<span class="math inline">\(\gamma = 0.5\)</span>）来采样回报<span class="math inline">\(G\)</span>。</p>
<ol type="1">
<li><span class="math inline">\(s_{4}, s_{5}, s_{6}, s_{7} \text{的回报}: 0+0.5\times 0+0.25 \times 0+ 0.125\times 10=1.25\)</span></li>
<li><span class="math inline">\(s_{4}, s_{5}, s_{6}, s_{7} \text{的回报}: 0+0.5\times 0+0.25 \times 0+ 0.125\times 10=1.25\)</span></li>
<li><span class="math inline">\(s_{4}, s_{5}, s_{6}, s_{6} \text{的回报}: 0+0.5\times 0 +0.25 \times 0+0.125 \times 0=0\)</span></li>
</ol>
<p>我们现在可以计算每一个轨迹得到的奖励，比如我们对轨迹<span class="math inline">\(s_4,s_5,s_6,s_7\)</span>的奖励进行计算，这里折扣因子是<span class="math inline">\(0.5\)</span>。在 <span class="math inline">\(s_4\)</span>的时候，奖励为0。下一个状态<span class="math inline">\(s_5\)</span>的时候，因为我们已经到了下一步，所以要把<span class="math inline">\(s_5\)</span>进行折扣，<span class="math inline">\(s_5\)</span>的奖励也是0。然后是<span class="math inline">\(s_6\)</span>，奖励也是0，折扣因子应该是0.25。到达<span class="math inline">\(s_7\)</span>后，我们获得了一个奖励，但是因为状态<span class="math inline">\(s_7\)</span>的奖励是未来才获得的奖励，所以我们要对之进行3次折扣。最终这个轨迹的回报就是<span class="math inline">\(1.25\)</span>。类似地，我们可以得到其他轨迹的回报。</p>
<p>这里就引出了一个问题，当我们有了一些轨迹的实际回报时，怎么计算它的价值函数呢？</p>
<p>比如我们想知道<span class="math inline">\(s_4\)</span>的价值，即当我们进入<span class="math inline">\(s_4\)</span>后，它的价值到底如何？一个可行的做法就是我们可以生成很多轨迹，然后把轨迹都叠加起来。比如我们可以从<span class="math inline">\(s_4\)</span>开始，采样生成很多轨迹，把这些轨迹的回报都计算出来，然后将其取平均值作为我们进入<span class="math inline">\(s_4\)</span>的价值。这其实是一种计算价值函数的办法，也就是通过 <strong>蒙特卡洛（Monte Carlo，MC）采样</strong> 的方法计算<span class="math inline">\(s_4\)</span>的价值。</p>
<h3 id="贝尔曼方程">贝尔曼方程</h3>
<p>但是这里我们采取了另外一种计算方法，从价值函数里面推导出 <strong>贝尔曼方程（Bellman equation）</strong> ：</p>
<p><span class="math display">\[
V(s)=\underbrace{R(s)}_{\text {即时奖励}}+\underbrace{\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s\right) V\left(s^{\prime}\right)}_{\text {未来奖励的折扣总和}}
\]</span></p>
<p>其中，</p>
<ul>
<li><span class="math inline">\(V(s)\)</span> 是状态 <span class="math inline">\(s\)</span> 的价值函数</li>
<li><span class="math inline">\(R(s)\)</span> 是进入状态 <span class="math inline">\(s\)</span> 后获得的即时奖励</li>
<li><span class="math inline">\(s^{\prime}\)</span> 是未来所有可能的状态</li>
<li><span class="math inline">\(p\left(s^{\prime} \mid s\right)\)</span> 是从状态 <span class="math inline">\(s\)</span> 转移到状态 <span class="math inline">\(s^{\prime}\)</span> 的概率</li>
<li><span class="math inline">\(\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s\right) V\left(s^{\prime}\right)\)</span> 是未来所有可能状态的平均的折扣价值</li>
</ul>
<p>贝尔曼方程定义了当前状态与未来状态之间的关系。未来奖励的折扣总和加上即时奖励，就组成了贝尔曼方程。</p>
<h4 id="全期望公式">全期望公式</h4>
<p>在推到贝尔曼方程之间，我们先仿照 <strong>全期望公式（law of total ecpectation）</strong> 的证明过程来证明：</p>
<p><span class="math display">\[
\mathbb{E}[V(s_{t+1})|s_t]=\mathbb{E}[\mathbb{E}[G_{t+1}|s_{t+1}]|s_t]=\mathbb{E}[G_{t+1}|s_t]
\]</span></p>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">
全期望公式也被称为叠期望公式（law of iterated expectation），它是指在给定一个随机变量的条件下，另一个随机变量的期望值等于在第一个随机变量的条件下的期望，然后第二个随机变量的期望值。全期望公式可以用来计算复杂的期望值，它可以将一个复杂的期望值分解成多个简单的期望值，从而简化计算。</p></div>
<p>如果<span class="math inline">\(A_i\)</span>是样本空间的有限或可数的划分（partition），则全期望公式可以定义为</p>
<p><span class="math display">\[
\mathbb{E}[X]=\sum_{i} \mathbb{E}\left[X \mid A_{i}\right] p\left(A_{i}\right)
\]</span></p>
<div class="admonition admonition-note">
<p class="admonition-title">证明
</p>
<p>为了符号简洁且易读，我们去掉了下标，令<span class="math inline">\(s = s_t, g^\prime = G_{t+1}, s^\prime = s_{t+1}\)</span>。因此我们可以重写回报的期望为</p>
<p><span class="math display">\[
\begin{aligned}    
V(s_{t+1}) = \mathbb{E}\left[G_{t+1} \mid s_{t+1}\right] &amp;=\mathbb{E}\left[g^{\prime} \mid s^{\prime}\right] \\    
&amp;=\sum_{g^{\prime}} g^{\prime}~p\left(g^{\prime} \mid s^{\prime}\right)    
\end{aligned}
\]</span></p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>如果<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>都是离散随机变量，则条件期望(conditional expectation) <span class="math inline">\(\mathbb{E}[X|Y=y]\)</span>定义为</p>
<p><span class="math display">\[
\mathbb{E}[X \mid Y=y]=\sum_{x} x p(X=x \mid Y=y)
\]</span></p>
</div>
<p>令<span class="math inline">\(s_t = s\)</span>，我们对上式求期望(给定<span class="math inline">\(s\)</span>下对<span class="math inline">\(s_{t+1}\)</span>)可得</p>
<p><span class="math display">\[
\begin{aligned}    
\mathbb{E}\left[\mathbb{E}\left[G_{t+1} \mid s_{t+1}\right] \mid s_{t}\right] &amp;=\mathbb{E} \left[\mathbb{E}\left[g^{\prime} \mid s^{\prime}\right] \mid s\right] \\    
&amp;=\mathbb{E} \left[\sum_{g^{\prime}} g^{\prime}~p\left(g^{\prime} \mid s^{\prime}\right)\mid s\right]\\    
&amp;=\sum_{s^{\prime}} \sum_{g^{\prime}} g^{\prime} p\left(g^{\prime} \mid s^{\prime}, s\right) p\left(s^{\prime} \mid s\right) \\    
&amp;=\sum_{s^{\prime}} \sum_{g^{\prime}} \frac{g^{\prime} p\left(g^{\prime} \mid s^{\prime}, s\right) p\left(s^{\prime} \mid s\right) p(s)}{p(s)} \\    
&amp;=\sum_{s^{\prime}} \sum_{g^{\prime}} \frac{g^{\prime} p\left(g^{\prime} \mid s^{\prime}, s\right) p\left(s^{\prime}, s\right)}{p(s)} \\    
&amp;=\sum_{s^{\prime}} \sum_{g^{\prime}} \frac{g^{\prime} p\left(g^{\prime}, s^{\prime}, s\right)}{p(s)} \\    
&amp;=\sum_{s^{\prime}} \sum_{g^{\prime}} g^{\prime} p\left(g^{\prime}, s^{\prime} \mid s\right) \\    
&amp;=\sum_{g^{\prime}} \sum_{s^{\prime}} g^{\prime} p\left(g^{\prime}, s^{\prime} \mid s\right) \\    
&amp;=\sum_{g^{\prime}} g^{\prime} p\left(g^{\prime} \mid s\right) \\    
&amp;=\mathbb{E}\left[g^{\prime} \mid s\right]=\mathbb{E}\left[G_{t+1} \mid s_{t}\right]    
\end{aligned}
\]</span></p>
</div>
<h4 id="贝尔曼方程推导">贝尔曼方程推导</h4>
<p>贝尔曼方程的推导过程如下：</p>
<p><span class="math display">\[
\begin{aligned}    
    V(s)&amp;=\mathbb{E}\left[G_{t} \mid s_{t}=s\right]\\    
    &amp;=\mathbb{E}\left[r_{t+1}+\gamma r_{t+2}+\gamma^{2} r_{t+3}+\ldots \mid s_{t}=s\right]  \\    
    &amp;=\mathbb{E}\left[r_{t+1}|s_t=s\right] +\gamma \mathbb{E}\left[r_{t+2}+\gamma r_{t+3}+\gamma^{2} r_{t+4}+\ldots \mid s_{t}=s\right]\\    
    &amp;=R(s)+\gamma \mathbb{E}[G_{t+1}|s_t=s] \\    
    &amp;=R(s)+\gamma \mathbb{E}[V(s_{t+1})|s_t=s]\\    
    &amp;=R(s)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s\right) V\left(s^{\prime}\right)    
    \end{aligned}
\]</span></p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
<p>贝尔曼方程就是当前状态与未来状态的迭代关系，表示当前状态的价值函数可以通过下个状态的价值函数来计算。贝尔曼方程因其提出者、动态规划创始人理查德·贝尔曼（Richard Bellman）而得名 ，也叫作“动态规划方程”。</p>
</div>
<p>贝尔曼方程定义了状态之间的迭代关系，即</p>
<p><span class="math display">\[
V(s)=R(s)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s\right) V\left(s^{\prime}\right)
\]</span></p>
<p>假设有一个马尔可夫链如图 2.5a 所示，贝尔曼方程描述的就是当前状态到未来状态的一个转移。如图 2.5b 所示，假设我们当前在<span class="math inline">\(s_1\)</span><br>
，那么它只可能去到3个未来的状态：有 0.1 的概率留在它当前位置，有 0.2 的概率去到<span class="math inline">\(s_2\)</span>状态，有 0.7 的概率去到<span class="math inline">\(s_4\)</span>状态。所以我们把状态转移概率乘它未来的状态的价值，再加上它的即时奖励（immediate reward），就会得到它当前状态的价值。贝尔曼方程定义的就是当前状态与未来状态的迭代关系。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/c5faaf56f37b49a98bd2e4a23489e6b7d0e57b65c3e743dd97247974f282d423.webp" alt="图 2.5 状态转移"></p>
<p>我们可以把贝尔曼方程写成矩阵的形式：</p>
<p><span class="math display">\[
\left(\begin{array}{c}    
    V\left(s_{1}\right) \\    
    V\left(s_{2}\right) \\    
    \vdots \\    
    V\left(s_{N}\right)    
    \end{array}\right)=\left(\begin{array}{c}    
    R\left(s_{1}\right) \\    
    R\left(s_{2}\right) \\    
    \vdots \\    
    R\left(s_{N}\right)    
    \end{array}\right)+\gamma\left(\begin{array}{cccc}    
    p\left(s_{1} \mid s_{1}\right) &amp; p\left(s_{2} \mid s_{1}\right) &amp; \ldots &amp; p\left(s_{N} \mid s_{1}\right) \\    
    p\left(s_{1} \mid s_{2}\right) &amp; p\left(s_{2} \mid s_{2}\right) &amp; \ldots &amp; p\left(s_{N} \mid s_{2}\right) \\    
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    
    p\left(s_{1} \mid s_{N}\right) &amp; p\left(s_{2} \mid s_{N}\right) &amp; \ldots &amp; p\left(s_{N} \mid s_{N}\right)    
    \end{array}\right)\left(\begin{array}{c}    
    V\left(s_{1}\right) \\    
    V\left(s_{2}\right) \\    
    \vdots \\    
    V\left(s_{N}\right)    
    \end{array}\right)
\]</span></p>
<p>我们当前的状态是向量<span class="math inline">\([V(s_1),V(s_2),\cdots,V(s_N)]^\mathrm{T}\)</span>。每一行来看，向量<span class="math inline">\(V\)</span>乘状态转移矩阵里面的某一行，再加上它当前可以得到的奖励，就会得到它当前的价值。</p>
<p>当我们把贝尔曼方程写成矩阵形式后，可以直接求解：</p>
<p><span class="math display">\[
\begin{aligned}    
    \boldsymbol{V} &amp;= \boldsymbol{\boldsymbol{R}}+ \gamma \boldsymbol{P}\boldsymbol{V} \\    
    \boldsymbol{I}\boldsymbol{V} &amp;= \boldsymbol{R}+ \gamma \boldsymbol{P}\boldsymbol{V} \\    
    (\boldsymbol{I}-\gamma \boldsymbol{P})\boldsymbol{V}&amp;=\boldsymbol{R} \\    
    \boldsymbol{V}&amp;=(\boldsymbol{I}-\gamma \boldsymbol{P})^{-1}\boldsymbol{R}    
    \end{aligned}
\]</span></p>
<p>我们可以直接得到 <strong>解析解（analytic solution）</strong>：</p>
<p><span class="math display">\[
\boldsymbol{V}=(\boldsymbol{I}-\gamma \boldsymbol{P})^{-1} \boldsymbol{R}
\]</span></p>
<p>我们可以通过矩阵求逆把<span class="math inline">\(V\)</span>的价值直接求出来。但是一个问题是这个矩阵求逆的过程的复杂度是<span class="math inline">\(O(N^3)\)</span>。所以当状态非常多的时候，比如从10个状态到1000个状态，或者到100万个状态，当我们有100万个状态的时候，状态转移矩阵就会是一个100万乘100万的矩阵，对这样一个大矩阵求逆是非常困难的。所以这种通过解析解去求解的方法只适用于很小量的马尔可夫奖励过程。</p>
<h3 id="计算马尔可夫奖励过程价值的迭代算法">计算马尔可夫奖励过程价值的迭代算法</h3>
<p>我们可以将迭代的方法应用于状态非常多的马尔可夫奖励过程（large MRP），比如：<strong>动态规划的方法</strong> ，<strong>蒙特卡洛的方法</strong>（通过采样的办法计算它），<strong>时序差分学习（temporal-difference learning，TD learning）</strong> 的方法（时序差分学习是动态规划和蒙特卡洛方法的一个结合）。</p>
<p>首先我们用蒙特卡洛方法来计算价值。如图 2.6 所示，蒙特卡洛方法就是当得到一个马尔可夫奖励过程后，我们可以从某个状态开始，把小船放到状态转移矩阵里面，让它“随波逐流”，这样就会产生一个轨迹。产生一个轨迹之后，就会得到一个奖励，那么直接把折扣的奖励即回报<span class="math inline">\(g\)</span>算出来。算出来之后将它积累起来，得到回报<span class="math inline">\(G_t\)</span>。当积累了一定数量的轨迹之后，我们直接用<span class="math inline">\(G_t\)</span>除以轨迹数量，就会得到某个状态的价值。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/346c92c88e7344eb93e47c3c5b6d794077dc7ae677d64947a6592f85f55e5bba.webp" alt="图 2.6 计算马尔可夫奖励过程价值的蒙特卡洛方法"></p>
<p>比如我们要计算<span class="math inline">\(s_4\)</span>状态的价值，可以从<span class="math inline">\(s_4\)</span>状态开始，随机产生很多轨迹。把小船放到状态转移矩阵里面，然后它就会“随波逐流”，产生轨迹。每个轨迹都会得到一个回报，我们得到大量的回报，比如100个、1000个回报，然后直接取平均值，就可以等价于现在<span class="math inline">\(s_4\)</span>的价值，因为<span class="math inline">\(s_4\)</span>的价值<span class="math inline">\(V(s_4)\)</span>定义了我们未来可能得到多少的奖励。这就是蒙特卡洛采样的方法。</p>
<p>如图 2.7 所示，我们也可以用动态规划的方法，一直迭代贝尔曼方程，直到价值函数收敛，我们就可以得到某个状态的价值。我们通过自举（bootstrapping） 的方法不停地迭代贝尔曼方程，当最后更新的状态与我们上一个状态的区别并不大的时候，更新就可以停止，我们就可以输出最新的<span class="math inline">\(V^\prime(s)\)</span>作为它当前的状态的价值。这里就是把贝尔曼方程变成一个贝尔曼更新（Bellman update），这样就可以得到状态的价值。</p>
<p>动态规划的方法基于后继状态价值的估计来更新现在状态价值的估计（如图 2.7 所示算法中的第 3 行用 <span class="math inline">\(V^\prime(s)\)</span>来更新<span class="math inline">\(V\)</span>）。根据其他估算值来更新估算值的思想，我们称其为自举。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/382da4c14abc40bbae3a54dd38fc4a556d56f69565f34c90809fca446bdf224f.webp" alt="图 2.7 计算马尔可夫奖励过程价值的动态规划算法"></p>
<h3 id="马尔可夫奖励过程的例子">马尔可夫奖励过程的例子</h3>
<p>如图 2.8 所示，如果我们在马尔可夫链上加上奖励，那么到达每个状态，我们都会获得一个奖励。我们可以设置对应的奖励，比如智能体到达状态 <span class="math inline">\(s_1\)</span>时，可以获得 5 的奖励；到达<span class="math inline">\(s_7\)</span> 的时候，可以得到 10 的奖励；到达其他状态没有任何奖励。<br>
因为这里的状态是有限的，所以我们可以用向量<span class="math inline">\(\boldsymbol{R}=[5,0,0,0,0,0,10]\)</span>来表示奖励函数，<span class="math inline">\(R\)</span>表示每个状态的瞬时奖励大小。</p>
<p>我们通过一个形象的例子来理解马尔可夫奖励过程。我们把一艘纸船放到河流之中，它就会随着水流而流动，它自身是没有动力的。所以我们可以把马尔可夫奖励过程看成一个随波逐流的例子，当我们从某一个点开始的时候，纸船就会随着事先定义好的状态转移进行流动，它到达每个状态后，我们都有可能获得一些奖励。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/4150eb00991b44568ef765e797c3b3086c1c28b0fb644683bb21fd3786a048ae.webp" alt="图 2.8 马尔可夫奖励过程的例子"></p>
<h2 id="马尔可夫决策过程">马尔可夫决策过程</h2>
<p>相对于马尔可夫奖励过程，马尔可夫决策过程多了决策（决策是指动作），其他的定义与马尔可夫奖励过程的是类似的。此外，状态转移也多了一个条件，变成了<span class="math inline">\(p\left(s_{t+1}=s^{\prime} \mid s_{t}=s,a_{t}=a\right)\)</span>。未来的状态不仅依赖于当前的状态，也依赖于在当前状态智能体采取的动作。马尔可夫决策过程满足条件：</p>
<p><span class="math display">\[
p\left(s_{t+1} \mid s_{t}, a_{t}\right) =p\left(s_{t+1} \mid h_{t}, a_{t}\right)
\]</span></p>
<p>对于奖励函数，它也多了一个当前的动作，变成了<span class="math inline">\(R\left(s_{t}=s, a_{t}=a\right)=\mathbb{E}\left[r_{t} \mid s_{t}=s, a_{t}=a\right]\)</span> 。当前的状态以及采取的动作会决定智能体在当前可能得到的奖励多少。</p>
<h3 id="马尔可夫决策过程的策略">马尔可夫决策过程的策略</h3>
<p><strong>策略（policy）</strong> 定义了在某一状态下应该采取什么样的行动。直到状态之后，我们可以将当前的状态带入策略函数来得到一个概率，即：</p>
<p><span class="math display">\[
\pi(a \mid s)=p\left(a_{t}=a \mid s_{t}=s\right)
\]</span></p>
<p>概率表示不同采取不同行动的可能性，比如可能有0.7的概率往左走，有0.3的概率往右走。除此之外，策略也可以是一个确定性的函数，即直接输出一个值（只有一个action的概率为1，其他的都为0），或者直接告诉我们接下来应该采取的动作，而不是动作概率。假设概率函数是平稳的（stationary）, 不同时间点，我们所采取的行动都是对策略函数的采样。</p>
<p>已知马尔可夫决策过程和策略<span class="math inline">\(\pi\)</span>，我们可以把一个马尔可夫决策过程转换成马尔可夫奖励过程。在马尔可夫决策过程里面，状态转移函数<span class="math inline">\(P(s^\prime \mid s, a)\)</span>是基于当前的状态以及当前的动作的，因为现在已知策略函数，也就是已知在每一个状态下，可能采取的动作的概率，所以我们就可以直接把动作进行求和，去掉<span class="math inline">\(a\)</span>，这样我们就得到了马尔可夫奖励过程的状态转移，即：</p>
<p><span class="math display">\[
P_{\pi}\left(s^{\prime} \mid s\right)=\sum_{a \in A} \pi(a \mid s) p\left(s^{\prime} \mid s, a\right)
\]</span></p>
<p>对于奖励函数，我们也可以把动作去掉，这样就可以得到类似于马尔可夫奖励过程的奖励函数，即：</p>
<p><span class="math display">\[
r_{\pi}(s)=\sum_{a \in A} \pi(a \mid s) R(s, a)
\]</span></p>
<h3 id="马尔可夫决策过程与马尔可夫奖励过程的区别">马尔可夫决策过程与马尔可夫奖励过程的区别</h3>
<p>马尔可夫决策过程里面的状态转移与马尔可夫奖励过程以及马尔可夫过程的状态转移的差异如图 2.9 所示。马尔可夫过程/马尔可夫奖励过程的状态转移是直接决定的。比如当前状态是<span class="math inline">\(s\)</span>，那么直接通过转移概率决定下一个状态是什么。但对于马尔可夫决策过程，它的中间多了一层动作<span class="math inline">\(a\)</span>，即智能体在当前状态的时候，首先要决定采取某一种动作，这样我们会到达某一个黑色的节点。到达这个黑色的节点后，因为有一定的不确定性，所以当智能体当前状态以及智能体当前采取的动作决定过后，智能体进入未来的状态其实也是一个概率分布。在当前状态与未来状态转移过程中多了一层决策性，这是马尔可夫决策过程与之前的马尔可夫过程/马尔可夫奖励过程很不同的一点。在马尔可夫决策过程中，动作是由智能体决定的，智能体会采取动作来决定未来的状态转移。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/45a8692eb64045fa9a015eab921bc3f19f1c1414223947119b9836e0e657d536.webp" alt="图 2.9 马尔可夫决策过程与马尔可夫过程/马尔可夫奖励过程的状态转移的对比"></p>
<h3 id="马尔可夫决策过程中的价值函数">马尔可夫决策过程中的价值函数</h3>
<p>马尔可夫决策过程中的价值函数可以定义为：</p>
<p><span class="math display">\[
V_{\pi}(s)=\mathbb{E}_{\pi}\left[G_{t} \mid s_{t}=s\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} r_{t+k+1} \mid s_{t}=s\right]
\]</span></p>
<p>其中，期望是基于我们所采取的策略的。当策略古荡之后，我们通过对策略进行采样来得到一个期望，计算除它的价值函数。</p>
<p>这里我们引入了一个 <strong>Q函数（Q-function）</strong>，Q函数也被称为 <strong>动作价值函数（action-value function）</strong>，Q函数定义的是在某一状态下采取某一个动作，能够得到的汇报的期望，即</p>
<p><span class="math display">\[
Q_{\pi}(s, a)=\mathbb{E}_{\pi}\left[G_{t} \mid s_{t}=s, a_{t}=a\right]=\mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k} r_{t+k+1} \mid s_{t}=s, a_{t}=a\right]
\]</span></p>
<p>对Q函数中的动作进行求期望，就可以得到价值函数：</p>
<p><span class="math display">\[
V_{\pi}(s)=\sum_{a \in A} \pi(a \mid s) Q_{\pi}(s, a)
\]</span></p>
<p>此处我们对Q函数的贝尔曼方程进行推导：</p>
<p><span class="math display">\[
\begin{aligned}    
    Q(s,a)&amp;=\mathbb{E}\left[G_{t} \mid s_{t}=s,a_{t}=a\right]\\    
    &amp;=\mathbb{E}\left[r_{t+1}+\gamma r_{t+2}+\gamma^{2} r_{t+3}+\ldots \mid s_{t}=s,a_{t}=a\right]  \\    
    &amp;=\mathbb{E}\left[r_{t+1}|s_{t}=s,a_{t}=a\right] +\gamma \mathbb{E}\left[r_{t+2}+\gamma r_{t+3}+\gamma^{2} r_{t+4}+\ldots \mid s_{t}=s,a_{t}=a\right]\\    
    &amp;=R(s,a)+\gamma \mathbb{E}[G_{t+1}|s_{t}=s,a_{t}=a] \\    
    &amp;=R(s,a)+\gamma \mathbb{E}[V(s_{t+1})|s_{t}=s,a_{t}=a]\\    
    &amp;=R(s,a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s,a\right) V\left(s^{\prime}\right)    
    \end{aligned}
\]</span></p>
<h3 id="贝尔曼期望方程">贝尔曼期望方程</h3>
<p>我们可以把状态价值函数和动作价值函数拆解成两个部分：即使奖励和后续状态的折扣价值(discounted valud of sucessor state)。</p>
<p>通过对状态价值函数的分解，我们就可以得到一个类似于之前马尔可夫奖励过程的贝尔曼方程——贝尔曼期望方程（Bellman expectation equation）：</p>
<p><span class="math display">\[
V_{\pi}(s)=\mathbb{E}_{\pi}\left[r_{t+1}+\gamma V_{\pi}\left(s_{t+1}\right) \mid s_{t}=s\right] \tag{2.6}
\]</span></p>
<p>对于动作价值函数，我们也可以做类似的分解，得到动作价值函数的贝尔曼期望方程：</p>
<p><span class="math display">\[
Q_{\pi}(s, a)=\mathbb{E}_{\pi}\left[r_{t+1}+\gamma Q_{\pi}\left(s_{t+1}, a_{t+1}\right) \mid s_{t}=s, a_{t}=a\right] \tag{2.7}
\]</span></p>
<p>贝尔曼期望方程定义了当前状态与未来状态之间的联系。</p>
<p>我们进一步进行简单的分解，先给出式（2.8）：</p>
<p><span class="math display">\[
V_{\pi}(s)=\sum_{a \in A} \pi(a \mid s) Q_{\pi}(s, a) \tag{2.8}
\]</span></p>
<p>接着，我们再给出式（2.9）：</p>
<p><span class="math display">\[
Q_{\pi}(s, a)=R(s,a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) V_{\pi}\left(s^{\prime}\right) \tag{2.9}
\]</span></p>
<p>式（2.8）和式（2.9）表示了状态价值函数与动作价值函数之间的关系。</p>
<p>我们把式（2.9）代入式（2.8），就可以得到：</p>
<p><span class="math display">\[
V_{\pi}(s)=\sum_{a \in A} \pi(a \mid s)\left(R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) V_{\pi}\left(s^{\prime}\right)\right) \tag{2.10}
\]</span></p>
<p>其矩阵形式为：</p>
<p><span class="math display">\[
R \in \mathbb{R}^{NM \times 1} = 
\left( \begin{array}{c}
R(s_1,a_1)\\
R(s_1,a_2)\\
\vdots\\
R(s_N,a_M)\\
\end{array}\right) 
\]</span></p>
<p><span class="math display">\[
Q \in \mathbb{R}^{NM \times 1} =
\left( \begin{array}{c}
Q(s_1,a_1)\\
Q(s_1,a_2)\\
\vdots\\
Q(s_N,a_M)\\
\end{array}\right)
\]</span></p>
<p><span class="math display">\[
V \in \mathbb{R}^{N \times 1} =
\left( \begin{array}{c}
V(s_1)\\    
V(s_2)\\
\vdots\\
V(s_N)\\
\end{array}\right)
\]</span></p>
<p><span class="math display">\[
P \in \mathbb{R}^{NM \times N} = \left( \begin{array}{c}
p(s_1 \mid s_1, a_1) &amp; p(s_2 \mid s_1, a_1) &amp; \cdots &amp; p(s_N \mid s_1, a_1)\\
p(s_1 \mid s_1, a_2) &amp; p(s_2 \mid s_1, a_2) &amp; \cdots &amp; p(s_N \mid s_1, a_2)\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
p(s_1 \mid s_N, a_M) &amp; p(s_2 \mid s_N, a_M) &amp; \cdots &amp; p(s_N \mid s_N, a_M)
\end{array}\right)
\]</span></p>
<p><span class="math display">\[
\Pi \in \mathbb{R}^{N \times NM} = \left( \begin{array}{c}
\pi(a_1 \mid s_1) &amp; \pi(a_2 \mid s_1) &amp; \cdots &amp; \pi(a_M \mid s_1) &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp;\pi(a_1 \mid s_2) &amp; \pi(a_2 \mid s_2) &amp; \cdots &amp; \pi(a_M \mid s_2) &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \pi(a_1 \mid s_N) &amp; \pi(a_2 \mid s_N) &amp; \cdots &amp; \pi(a_M \mid s_N)\\
\end{array}\right)
\]</span></p>
<p><span class="math display">\[
Q = R + \gamma PV
\]</span></p>
<p><span class="math display">\[
V = \Pi Q = \Pi(R + \gamma PV) = \Pi R + \gamma \Pi PV
\]</span></p>
<p>若记<span class="math inline">\(R^\pi = \Pi R \in \mathbb{R}^{N \times 1}, P^\pi = \Pi P \in \mathbb{R}^{N \times N}\)</span>，则：</p>
<p><span class="math display">\[
V = R^\pi + \gamma P^\pi V
\]</span></p>
<p>其中<span class="math inline">\(R^\pi\)</span>是给定策略<span class="math inline">\(\pi\)</span>下的MDP的等效MRP的奖励函数，<span class="math inline">\(P^\pi\)</span>是给定策略<span class="math inline">\(\pi\)</span>下的MDP的等效MRP的状态转移概率矩阵。</p>
<p>式（2.10）表示了当前状态的价值与未来状态价值之间的关系。</p>
<p>我们把式（2.8）代入式（2.9），就可以得到：</p>
<p><span class="math display">\[
Q_{\pi}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) \sum_{a^{\prime} \in A} \pi\left(a^{\prime} \mid s^{\prime}\right) Q_{\pi}\left(s^{\prime}, a^{\prime}\right) \tag{2.11}
\]</span></p>
<p>式（2.11）表示了当前状态的动作价值与未来状态的动作价值之间的关系。</p>
<p>式(2.10)和式(2.11)是贝尔曼期望方程的另一种形式。</p>
<h3 id="最优策略与最优价值函数">最优策略与最优价值函数</h3>
<p>解决一个强化学习问题，就是找出一个策略，使得在该策略下，能够获得较多的长期回报。对于优先MDP，我们可以通过下面的方式来定义最优策略。首先，如果对于所有的状态<span class="math inline">\(s\)</span>，都有<span class="math inline">\(\pi\)</span>的期望奖励大于<span class="math inline">\(\pi^\prime\)</span>的期望奖励，我们则称策略<span class="math inline">\(\pi\)</span>比较策略<span class="math inline">\(\pi^\prime\)</span>好（better than），即：</p>
<p><span class="math display">\[
\pi \geq \pi^\prime \Leftrightarrow V_{\pi}(s) \geq V_{\pi^\prime}(s), \forall s \in S
\]</span></p>
<p>而实时上，MDP中存在一个策略好比其他策略都要好，我们称这个策略为最优策略（optimal policy）。尽管有可能存在多个最优策略，我们用<span class="math inline">\(\pi_*\)</span>来表示最优策略，它们共享相同的状态价值函数，称作最优状态价值函数（optimal state-value function）<span class="math inline">\(V_*\)</span>，其定义为：</p>
<p><span class="math display">\[
V_*(s) = \max_{\pi} V_{\pi}(s), \forall s \in S
\]</span></p>
<p>最优策略也共享相同的动作价值函数，称作最优动作价值函数（optimal action-value function）<span class="math inline">\(Q_*\)</span>，其定义为：</p>
<p><span class="math display">\[
Q_*(s, a) = \max_{\pi} Q_{\pi}(s, a), \forall s \in S, \forall a \in A
\]</span></p>
<p>在动作价值函数中，对于给定的<span class="math inline">\((s,a)\)</span>，Q函数的返回值表示在<span class="math inline">\(s\)</span>状态下采取<span class="math inline">\(a\)</span>行为，并且在后续过程中采用最优策略能够获得的期望回报。因为其可以写成如下等式：</p>
<p><span class="math display">\[
Q_*(s, a) = \mathbb{E}\left[{R_{t+1} + \gamma V_*(S_{t+1}) \mid S_t = s, A_t = a}\right]
\]</span></p>
<p>因为<span class="math inline">\(V_*\)</span>是某个策略的值函数，它必须满足状态值的自洽条件（贝尔曼方程）。然而，由于它是最优价值函数，<span class="math inline">\(V_*\)</span>的自洽条件可以写成一种特殊形式，而不需要参考任何特定策略。这就是关于<span class="math inline">\(V_*\)</span>的贝尔曼方程，或称 <strong>贝尔曼最优方程</strong> 。直观上，贝尔曼最优方程表达了这样一个事实：在最优策略下，一个状态的价值必须等于从该状态出发采取最佳动作的期望回报：</p>
<p><span class="math display">\[
\begin{align*}
V_*(s) &amp;= \max_{a \in A(s)} Q_{\pi_*}(s,a) \\
&amp;= \max_{a \in A(s)} \mathbb{E}_{\pi_*}[G_t \mid S_t = s, A_t = a] \\
&amp;= \max_{a \in A(s)} \mathbb{E}_{\pi_*}\left[R_{t+1} + \gamma G_{t+1} \mid S_t = s, A_t = a\right] \\
&amp;= \max_{a \in A(s)} \mathbb{E}_{\pi_*}\left[R_{t+1} + \gamma V_*(S_{t+1}) \mid S_t = s, A_t = a\right] \\
&amp;= \max_{a \in A(s)} \sum_{s&#39;,r} p(s&#39;,r|s,a) \left[ r + \gamma V_*(s&#39;) \right] \tag{3.19}\\
\end{align*}
\]</span></p>
<p>同样，对于动作价值函数<span class="math inline">\(Q_*\)</span>，我们也可以得到它的贝尔曼最优方程：</p>
<p><span class="math display">\[
\begin{align*}
Q_*(s,a) &amp;=  \mathbb{E}\left[{R_{t+1} + \gamma V_*(S_{t+1}) \mid S_t = s, A_t = a}\right] \\
&amp;= \mathbb{E}\left[R_{t+1} + \gamma \max_{a&#39;} Q_*(S_{t+1},a&#39;) \mid S_t = s, A_t = a\right] \\
&amp;=\sum_{s&#39;,r} p(s&#39;,r|s,a) \left[ r + \gamma \max_{a&#39;} Q_*(s&#39;,a&#39;) \right] \\
\end{align*}    
\]</span></p>
<p>显式求解贝尔曼最优方程提供了一种寻找最优策略的途径，从而解决强化学习问题。然而，这种解法很少能直接有用。它类似于穷举搜索，需要遍历所有可能性，计算它们发生的概率及其期望回报。</p>
<p>这种解法依赖于三个在实践中很少成立的假设：</p>
<ol type="1">
<li>环境的动态特性被准确知晓；</li>
<li>计算资源足以完成计算；</li>
<li>状态具有马尔可夫性质。</li>
</ol>
<p>在我们感兴趣的任务中，通常无法精确实现这个解法，因为这些假设中的某些往往会被违背。例如，在西洋双陆棋游戏中，虽然第一和第三条假设没有问题，但第二条假设是主要障碍。因为该游戏约有<span class="math inline">\(10^{20}\)</span>个状态，即使用当今最快的计算机也需要数千年才能求解<span class="math inline">\(v_*\)</span>的贝尔曼方程，寻找<span class="math inline">\(q_*\)</span>也同样如此。因此在强化学习中，通常会求取近似解(后续介绍的策略迭代和价值迭代就是)，而非精确解。</p>
<h3 id="预测与控制">预测与控制</h3>
<p>预测（prediction）和控制（control）是马尔可夫决策过程里面的核心问题。</p>
<p>预测（评估一个给定的策略）的输入是马尔可夫决策过程 <span class="math inline">\(S,A,P,R,\gamma\)</span>和策略<span class="math inline">\(\pi\)</span>，输出是价值函数<span class="math inline">\(V_\pi\)</span>。预测是指给定一个马尔可夫决策过程以及一个策略<span class="math inline">\(\pi\)</span>，计算它的价值函数，也就是计算每个状态的价值。</p>
<p>控制（搜索最佳策略）的输入是马尔可夫决策过程<span class="math inline">\(S,A,P,R,\gamma\)</span>，输出是最佳价值函数（optimal value function）<span class="math inline">\(V^*\)</span>和最佳策略（optimal policy）<span class="math inline">\(\pi^*\)</span>。控制就是我们去寻找一个最佳的策略，然后同时输出它的最佳价值函数以及最佳策略。</p>
<p>在马尔可夫决策过程里面，预测和控制都可以通过动态规划解决。要强调的是，这两者的区别就在于，预测问题是给定一个策略，我们要确定它的价值函数是多少。而控制问题是在没有策略的前提下，我们要确定最佳的价值函数以及对应的决策方案。实际上，这两者是递进的关系，在强化学习中，我们通过解决预测问题，进而解决控制问题。</p>
<p>举一个例子来说明预测与控制的区别。首先是预测问题。在图 2.16a 的方格中，我们规定从<span class="math inline">\(A \rightarrow A^\prime\)</span>可以得到 +10 的奖励，从<span class="math inline">\(B \rightarrow B^\prime\)</span>可以得到 +5 的奖励，其他步骤的奖励为 -1。如图 2.16b 所示，现在，我们给定一个策略：在任何状态中，智能体的动作模式都是随机的，也就是上、下、左、右的概率均为0.25。预测问题要做的就是，求出在这种决策模式下，价值函数是什么。图 2.16c 是对应的价值函数。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/d275b70177c4461f9099045cf69f93cb9c71a4c3336c444abc33d91dd14d2e06.webp" alt="图 2.16 网格世界例子：预测"></p>
<p>接着是控制问题。在控制问题中，问题背景与预测问题的相同，唯一的区别就是：不再限制策略。也就是动作模式是未知的，我们需要自己确定。 所以我们通过解决控制问题，求得每一个状态的最优的价值函数，如图 2.17b 所示；也得到了最优的策略，如图 2.17c 所示。</p>
<p>控制问题要做的就是，给定同样的条件，求出在所有可能的策略下最优的价值函数是什么，最优策略是什么。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/404c8738370047d9967659721e685bb88a8deb9694f74570973aac0ea23258ad.webp" alt="图 2.17 网格世界例子：控制"></p>
<h3 id="马尔可夫决策过程控制">马尔可夫决策过程控制</h3>
<p><a href="#策略评估">策略评估</a>是指给定马尔可夫决策过程和策略，我们可以估算出价值函数的值。但是如果我们只有马尔可夫决策过程，那么应该如何找到最佳的策略，从而得到最佳价值函数（optimal value function）呢？</p>
<p>最佳价值函数的定义为：</p>
<p><span class="math display">\[
V^{*}(s)=\max_{\pi} V_{\pi}(s)
\]</span></p>
<p>最佳价值函数是指，我们搜索一种策略<span class="math inline">\(\pi\)</span>，让每个状态的价值最大。<span class="math inline">\(V^*(s)\)</span>就是到达每一个状态，它的值的最大化情况。</p>
<p>使得每个状态的价值都最大化的策略称为 <strong>最优策略（optimal policy）</strong>，记为<span class="math inline">\(\pi^*\)</span>，即</p>
<p><span class="math display">\[
\pi^{*}(s)=\arg \max_{\pi} V_{\pi}(s)
\]</span></p>
<p>最佳策略使得每个状态的价值函数都取得最大值。所以如果我们可以得到一个最佳价值函数，就可以认为某个马尔可夫决策过程的环境可解。在这种情况下，最佳价值函数是一致的，环境中可达到的上限的值是一致的，但这里可能有多个最佳策略，多个最佳策略可以取得相同的最佳价值。</p>
<p>当取得最佳价值函数后，我们可以通过对Q函数进行最大化来得到最佳策略：</p>
<p><span class="math display">\[
\pi^{*}(a\mid s)=
\begin{cases}
    1,\ a = \mathop{\arg\max}\limits_{a \in A} Q_{\pi^{*}}(s, a)\\
    0,\ \text{others}
\end{cases}
\]</span></p>
<p>当Q函数收敛后，因为 Q 函数是关于状态与动作的函数，所以如果在某个状态采取某个动作，可以使得 Q 函数最大化，那么这个动作就是最佳的动作。如果我们能优化出一个 Q 函数<span class="math inline">\(Q^*(s,a)\)</span>，就可以直接在 Q 函数中取一个让 Q 函数值最大化的动作的值，就可以提取出最佳策略。</p>
<p>Q: 怎样进行策略搜索？</p>
<p>A: 最简单的策略搜索方法就是穷举。假设状态和动作都是有限的，那么每个状态我们可以采取<span class="math inline">\(A\)</span>种动作的策略，总共就是<span class="math inline">\(|A|^{|S|}\)</span>个可能的策略。我们可以把策略穷举一遍，算出每种策略的价值函数，对比一下就可以得到最佳策略。</p>
<p>但是穷举非常没有效率，所以我们要采取其他方法。搜索最佳策略有两种常用的方法：策略迭代和价值迭代。</p>
<p>寻找最佳策略的过程就是马尔可夫决策过程的控制过程。马尔可夫决策过程控制就是去寻找一个最佳策略使我们得到一个最大的价值函数值，即</p>
<p><span class="math display">\[
\pi^{*}(s)=\mathop{\arg\max}_{\pi} V_{\pi}(s)
\]</span></p>
<p>对于一个事先定好的马尔可夫决策过程，当智能体采取最佳策略的时候，最佳策略一般都是确定的，而且是稳定的（它不会随着时间的变化而变化）。但最佳策略不一定是唯一的，多种动作可能会取得相同的价值。</p>
<p>我们可以通过<a href="#策略迭代">策略迭代</a>和<a href="#价值迭代">价值迭代</a>来解决马尔可夫决策过程的控制问题。</p>
<h3 id="备份图">备份图</h3>
<p>接下来我们介绍 <strong>备份（backup）</strong> 的概念。备份类似于自举之间的迭代关系，对于某一个状态，它的当前价值是与它的未来价值线性相关的。</p>
<p>我们将与图 2.10 类似的图称为 <strong>备份图（backup diagram）</strong> 或回溯图，因为它们所示的关系构成了更新或备份操作的基础，而这些操作是强化学习方法的核心。这些操作将价值信息从一个状态（或状态-动作对）的后继状态（或状态-动作对）转移回它。</p>
<p>每一个空心圆圈代表一个状态，每一个实心圆圈代表一个状态-动作对。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/dffc7d453d5e4f4fb135ed24b74c92088ef6d313c4604043bc71a2ca6661d186.webp" alt="图 2.10 V_\pi 备份图"></p>
<p>如式(2.12)所示，这里有两层加和。第一层加和是对叶子节点进行加和，往上备份一层，我们就可以把未来的价值（<span class="math inline">\(s^\prime\)</span>的价值）备份到黑色的节点。</p>
<p>第二层加和是对动作进行加和，得到黑色节点的价值后，再往上备份一层，就会得到根节点的价值，即当前状态的价值。</p>
<p><span class="math display">\[
V_{\pi}(s)=\sum_{a \in A} \pi(a \mid s)\left(R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) V_{\pi}\left(s^{\prime}\right)\right) \tag{2.12}
\]</span></p>
<p>图 2.11 所示为状态价值函数的计算分解，图 2.11b 的计算公式为</p>
<p><span class="math display">\[
V_{\pi}(s)=\sum_{a \in A} \pi(a \mid s) Q_{\pi}(s, a) \tag{2.13}
\]</span></p>
<p>图 2.11b 给出了状态价值函数与 Q 函数之间的关系。图 2.11c 计算 Q 函数为</p>
<p><span class="math display">\[
Q_{\pi}(s,a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) V_{\pi}\left(s^{\prime}\right) \tag{2.14}
\]</span></p>
<p>我们将式(2.14)代入式(2.13)可得</p>
<p><span class="math display">\[
V_{\pi}(s)=\sum_{a \in A} \pi(a \mid s)\left(R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) V_{\pi}\left(s^{\prime}\right)\right)
\]</span></p>
<p>所以备份图定义了未来下一时刻的状态价值函数与上一时刻的状态价值函数之间的关联。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/29757b6c05c4465f98a4b7364e43ee8d60aab5b258684aaeb1d2b68bac0d5968.webp" alt="图 2.11 状态价值函数的计算分解"></p>
<p>对于 Q 函数，我们也可以进行这样的一个推导。如图 2.12 所示，现在的根节点是 Q 函数的一个节点。Q 函数对应于黑色的节点。下一时刻的 Q 函数对应于叶子节点，有4个黑色的叶子节点。</p>
<p><span class="math display">\[
Q_{\pi}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) \sum_{a^{\prime} \in A} \pi\left(a^{\prime} \mid s^{\prime}\right) Q_{\pi}\left(s^{\prime}, a^{\prime}\right) \tag{2.15}
\]</span></p>
<p>如式(2.15)所示，这里也有两层加和。第一层加和先把叶子节点从黑色节点推到空心圆圈节点，进入到空心圆圈结点的状态。</p>
<p>当我们到达某一个状态后，再对空心圆圈节点进行加和，这样就把空心圆圈节点重新推回到当前时刻的 Q 函数。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/894385a7bec54988ba80021f2fed5ad1b125c670d75f41c79df88b0812b1c304.webp" alt="图 2.12 行为价值函数的备份图"></p>
<p>图 2.13c 中，</p>
<p><span class="math display">\[
V_{\pi}\left(s^{\prime}\right)=\sum_{a^{\prime} \in A} \pi\left(a^{\prime} \mid s^{\prime}\right) Q_{\pi}\left(s^{\prime}, a^{\prime}\right) \tag{2.16}
\]</span></p>
<p>我们将式(2.16)代入式(2.14)可得未来 Q 函数与当前 Q 函数之间的关联，即</p>
<p><span class="math display">\[
Q_{\pi}(s, a)=R(s, a)+\gamma \sum_{s^{\prime} \in S} p\left(s^{\prime} \mid s, a\right) \sum_{a^{\prime} \in A} \pi\left(a^{\prime} \mid s^{\prime}\right) Q_{\pi}\left(s^{\prime}, a^{\prime}\right)
\]</span></p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/cea128f6f5d845999cf28386ca43beae2c264180be4b4207a533f0806bffbc0a.webp" alt="图 2.13 Q函数的计算分解"></p>
<h3 id="动态规划">动态规划</h3>
<p><strong>动态规划（Dynamic Programming，DP）</strong> 是指一类算法的集合，这些算法可以在已知环境完美模型（即马尔可夫决策过程，MDP）的前提下，用于计算最优策略。尽管经典的动态规划算法由于依赖完美模型的假设以及计算开销巨大，在强化学习中的实用性有限，但它们在理论上仍然具有重要意义。动态规划为理解其它RL方法奠定了基础。事实上，这些方法都可以看作是在试图实现与动态规划类似的效果，只是计算量更小，且不依赖于对环境的完美建模。</p>
<p>在动态规划中，我们通常会假设环境是有限MDP。也就是说，我们假设其状态空间<span class="math inline">\(S\)</span>、动作空间<span class="math inline">\(A\)</span>和奖励<span class="math inline">\(R\)</span>都是有限的，并且环境的动力学性质被一组概率分布<span class="math inline">\(p(s^\prime,r \mid s,a)\)</span>所表示。其中<span class="math inline">\(s \in S, a \in A, r \in R, s ^ \prime \in S ^+\)</span>(<span class="math inline">\(S ^ +\)</span>是 <span class="math inline">\(S\)</span>加上结束状态)</p>
<p>虽然DP的想法也可以用于连续的状态空间和动作空间，但是只有在特殊的情况下，才有精确的解。而一种通常的做法是将连续的状态空间和动作空间量化成离散的，然后应用有限状态DP的方法来求取近似解。</p>
<p>DP和RL的的核心思想都是使用价值函数来寻找好的策略，因此这一章中，我们会介绍如何使用DP来计算价值函数。而只要我们找出了最优的价值函数 <span class="math inline">\(V_*\)</span>或者最优的动作价值函数 <span class="math inline">\(Q_*\)</span>，我们就可以很容易得使用贪心的策略获得最优的策略。其中<span class="math inline">\(V_*\)</span>和<span class="math inline">\(Q_*\)</span>满足如下的贝尔曼最优方程：</p>
<p><span class="math display">\[
\begin{align*}
V_*(s) &amp;= \max_{a \in A} Q_*(s,a) \\    
 &amp;= \max_{a \in A} \mathbb{E} \left[R_{t+1} + \gamma V_*(S_{t+1}) \mid S_t = s, A_t = a\right] \\
 &amp;= \max_{a \in A} \sum_{s^\prime,r} p(s^\prime,r \mid s,a) \left[ r + \gamma V_*(s^\prime) \right] \\
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
Q_*(s,a) &amp;= \mathbb{E} \left[R_{t+1} + \gamma V_*(S_{t+1}) \mid S_t = s, A_t = a\right] \\
&amp;= \mathbb{E} \left[R_{t+1} + \gamma \max_{a^\prime} Q_*(S_{t+1},a^\prime) \mid S_t = s, A_t = a\right] \\
 &amp;= \sum_{s^\prime,r} p(s^\prime,r \mid s,a) \left[ r + \gamma \max_{a^\prime} Q_*(s^\prime,a^\prime) \right] \\
\end{align*}
\]</span></p>
<h4 id="策略评估">策略评估</h4>
<p>已知马尔可夫决策过程以及要采取的策略<span class="math inline">\(\pi\)</span>，计算价值函数<span class="math inline">\(V_\pi(s)\)</span>的过程就是 <strong>策略评估</strong>。策略评估在有些地方也被称为 <strong>（价值）预测[（value）prediction）]</strong>，也就是预测我们当前采取的策略最终会产生多少价值。</p>
<p>考虑如下一个更通用版的贝尔曼方程（<span class="math inline">\(r\)</span>不仅与<span class="math inline">\(s,a\)</span>相关，而且还与<span class="math inline">\(s^\prime\)</span>相关）：</p>
<p><span class="math display">\[
\begin{align*}
V_{\pi}(s) =&amp; \mathbb{E}_{\pi}\left[G_t \mid S_t = s \right] \\ =&amp; \mathbb{E}_{\pi}\left[R_{t+1} + \gamma G_{t+1} \mid S_t = s \right] \\ =&amp; \mathbb{E}_{\pi}\left[R_{t+1} + \gamma V_{\pi}(S_{t+1}) \mid S_t = s \right] \\ =&amp; \sum_{a \in A} \pi(a|s) \sum_{s^\prime,r} p(s^\prime,r \mid s,a) \left[ r + \gamma V_{\pi}(s^\prime) \right]
\end{align*}
\]</span></p>
<p>虽然在策略已知，奖励函数以及状态转移函数已知的情况下，我们可以通过解析解的方式来求解价值函数，但是在实际中，由于运算量太大，因此采用迭代的方案更加合适。</p>
<p>假设有一系列的价值函数的近似<span class="math inline">\(V_0,V_1,\ldots\)</span>，其中<span class="math inline">\(V_0\)</span>是初始的近似值函数，可以任意选择（只要terminal state的价值是0就行），然后接下来的近似函数可以通过一下的迭代公式来计算：</p>
<p><span class="math display">\[
V_{k+1}(s) = \sum_{a \in A} \pi(a|s) \sum_{s^\prime,r} p(s^\prime,r \mid s,a) \left[ r + \gamma V_k(s^\prime) \right]
\]</span></p>
<p>随着迭代的进行，<span class="math inline">\(V_k\)</span>会逐渐收敛到真实的价值函数<span class="math inline">\(V_\pi\)</span>。我们可以通过以下的公式来判断收敛：</p>
<p><span class="math display">\[
\max_{s \in S} |V_{k+1}(s) - V_k(s)| &lt; \epsilon
\]</span></p>
<p>除此之外，其实迭代的具体实现有多种方式，比如我们可以使用 <strong>全局迭代（global iteration）</strong> 的方式来进行迭代，也就是每次都对所有的状态进行更新。也可以使用 <strong>局部迭代（local iteration）</strong> 的方式来进行迭代(也称之为in-place方式)，也就是每次只对一个状态进行更新，而更新另一个状态的价值函数的时候，会使用到上次的更新后的价值函数。局部迭代的方式会更快一些。局部迭代的伪代码如下所示：</p>
<div class="admonition admonition-note">
<p class="admonition-title">**Iterative Policy Evaluation**, for estimating $V \approx v_{\pi}$
</p>
<ul>
<li><strong>Input</strong>: <span class="math inline">\(\pi\)</span>, the policy to be evaluated<br>
</li>
<li><strong>Algorithm parameter</strong>: small threshold <span class="math inline">\(\theta &gt; 0\)</span> determining accuracy of estimation<br>
</li>
<li><strong>Initialize</strong>: <span class="math inline">\(V(s)\)</span> arbitrarily for <span class="math inline">\(s \in \mathcal{S}\)</span>, and <span class="math inline">\(V(\text{terminal}) \gets 0\)</span></li>
</ul>
<p><strong>Loop</strong>:<br>
    <span class="math inline">\(\Delta \gets 0\)</span><br>
    <strong>For each</strong> <span class="math inline">\(s \in \mathcal{S}\)</span>:<br>
        <span class="math inline">\(v \gets V(s)\)</span><br>
        <span class="math inline">\(V(s) \gets \sum\limits_a \pi(a|s) \sum\limits_{s&#39;, r} p(s&#39;, r \mid s, a)\left[r + \gamma V(s&#39;)\right]\)</span><br>
        <span class="math inline">\(\Delta \gets \max(\Delta, |v - V(s)|)\)</span><br>
<strong>Until</strong> <span class="math inline">\(\Delta &lt; \theta\)</span></p>
</div>
<p><strong>策略评估示例1</strong></p>
<p>考虑一个4x4的网格世界，其状态空间<span class="math inline">\(S = \{1,2,\cdots,14\}\)</span>，在每个状态下，都有四种可能的行为<span class="math inline">\(A = \{up, down, right, left\}\)</span>，其奖励满足<span class="math inline">\(R(s^\prime,s,a) = 1 \; s \in S, s^\prime \in S^+, a \in A\)</span>而且状态转移是确定的（deterministical），当采取动作会导致agent移出网格时，agent会停留在原地。例如，<span class="math inline">\(p(6,-1\mid 5, right) = 1\)</span>，<span class="math inline">\(p(7,-1\mid 7,right) = 1\)</span>，<span class="math inline">\(p(10,r \mid 5,right) = 0\)</span>。假设agent采取随机策略，折扣因子<span class="math inline">\(\gamma = 1\)</span>，其状态价值函数的计算过程如下图所示：</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/value_evaluation.webp" alt="价值评估示例"></p>
<p><strong>策略评估示例2</strong></p>
<p>另一个例子来源于<a href="https://cs.stanford.edu/people/karpathy/reinforcejs/gridworld_dp.html">斯坦福大学的一个在线示例</a>，这个网页模拟了DP的价值评估和策略更新的过程。</p>
<p>如图 2.19a 所示，网格世界里面有很多格子，每个格子都代表一个状态。每个格子里面有一个初始值0（初始的状态价值）。每个格子里还有一个箭头，这个箭头是指智能体在当前状态应该采取什么策略。我们这里采取随机的策略，即朝着各个箭头方向运动的概率都是相同的。比如在某个状态，智能体都有上、下、左、右各 0.25 的概率采取某一个动作，所以它的动作是完全随机的。而奖励函数通过格子里面的R表示（需要注意的是，格子里面的R表示的是在该状态采取的任何行动的奖励都是R，而不是到达该状态所能获得的奖励）。我们可以看到有几个格子里面R的值是-1，只有一个格子的R为+1，那些没有写R的表示R为0。奖励的折扣因子<span class="math inline">\(\gamma = 0.9\)</span></p>
<p>在这样的环境里面，我们想计算每一个状态的价值。</p>
<p>如图 2.19b 所示，我们开始策略评估，策略评估是一个不停迭代的过程。当我们初始化的时候，所有的<span class="math inline">\(V(s)\)</span>都是 0。我们现在迭代一次，迭代一次之后，有些状态的值已经产生了变化。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/0f38da364e7947f9b23889d2a6e668924b8a03bb64cb4a94b7e73143593b7e5c.webp" alt="图 2.19 网格世界：动态规划示例"></p>
<p>如图 2.20a 所示，我们再迭代一次，之前有值的状态的周围状态也开始有值。因为周围状态与之前有值的状态是临近的，所以这就相当于把周围的状态转移过来。如图 2.20b 所示，我们逐步迭代，值是一直在变换的。</p>
<p><img src="/2025/05/08/RL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/c282f531c5264022b66b1774707948ffdd850e51475b4991a453a71ae00e48d3.webp" alt="图 2.20 网格世界：策略评估过程示例"></p>
<p>当我们迭代了很多次之后，有些很远的状态的价值函数已经有值了，而且整个过程是一个呈逐渐扩散的过程，这其实也是策略评估的可视化。当我们每一步进行迭代的时候，远的状态就会得到一些值，值从已经有奖励的状态逐渐扩散。当我们执行很多次迭代之后，各个状态的值会逐渐稳定下来，最后值就会确定不变。收敛之后，每个状态的值就是它的状态价值。</p>
<h4 id="策略提升">策略提升</h4>
<p>使用策略评估来计算给定策略的价值函数的目的是为了找出更好的策略。假设在一个确定策略（deterministic policy）<span class="math inline">\(\pi\)</span>下，我们已经计算出了状态价值函数<span class="math inline">\(V_{\pi}(s)\)</span>。对于某些状态<span class="math inline">\(s\)</span>，我们想要知道的是，我们是否应该改变我们的策略，去选择action <span class="math inline">\(a \neq \pi(s)\)</span>？首先，我们知道如果我们在状态<span class="math inline">\(s\)</span>的时候，按照策略<span class="math inline">\(\pi\)</span>来执行的话，能获得的好处——<span class="math inline">\(V_{\pi}(s)\)</span>，但是我们并不知道，如果我们使用新的策略<span class="math inline">\(\pi^\prime\)</span>，效果是否会变得更好。</p>
<p>为了解决这个问题，我们可以假设我们在<span class="math inline">\(s\)</span>的第一步的时候，选择动作<span class="math inline">\(a\)</span>，然后在<span class="math inline">\(s\)</span>的后续步骤中，使用策略<span class="math inline">\(\pi\)</span>。其行为价值函数为：</p>
<p><span class="math display">\[
\begin{align*}
Q_{\pi}(s,a) &amp;=\mathbb{E}\left[R_{t+1} + \gamma V_{\pi}(S_{t+1}) \mid S_t = s, A_t = a\right] \\
&amp;=\sum_{s^\prime,r} p(s^\prime,r \mid s,a) \left[ r + \gamma V_{\pi}(s^\prime) \right]
\end{align*}
\]</span></p>
<p>假设现在有两个确定策略（deterministic policy）<span class="math inline">\(\pi\)</span>和<span class="math inline">\(\pi^\prime\)</span>，如果有(称之为<strong>策略提升定理</strong>)</p>
<p><span class="math display">\[
Q_{\pi}(s,\pi^\prime(s)) \geq V_{\pi}(s) \; for\ all\ s \in S
\]</span></p>
<p>那么是可以证明</p>
<p><span class="math display">\[
V_{\pi^\prime}(s) \geq V_{\pi}(s)
\]</span></p>
<div class="admonition admonition-note">
<p class="admonition-title">证明
</p>
<p><span class="math display">\[
\begin{align*}
V_{\pi}(s) &amp;\leq Q_{\pi}(s, \pi&#39;(s)) \\
&amp;= \mathbb{E} [ R_{t+1} + \gamma V_{\pi}(S_{t+1}) \mid S_t = s, A_t = \pi&#39;(s) ] \\
&amp;= \mathbb{E}_{\pi&#39;} [ R_{t+1} + \gamma V_{\pi}(S_{t+1}) \mid S_t = s ] \\
&amp;\leq \mathbb{E}_{\pi&#39;} [ R_{t+1} + \gamma Q_{\pi}(S_{t+1}, \pi&#39;(S_{t+1})) \mid S_t = s ] \\
&amp;= \mathbb{E}_{\pi&#39;} \left[ R_{t+1} + \gamma \mathbb{E} [ R_{t+2} + \gamma V_{\pi}(S_{t+2}) \mid S_{t+1}, A_{t+1} = \pi&#39;(S_{t+1}) ] \mid S_t = s \right] \\
&amp;= \mathbb{E}_{\pi&#39;} [ R_{t+1} + \gamma R_{t+2} + \gamma^2 V_{\pi}(S_{t+2}) \mid S_t = s ] \\
&amp;\leq \mathbb{E}_{\pi&#39;} [ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \gamma^3 V_{\pi}(S_{t+3}) \mid S_t = s ] \\
&amp;\quad \vdots \\
&amp;\leq \mathbb{E&#39;}_{\pi&#39;} [ R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \gamma^3 R_{t+4} + \cdots \mid S_t = s ] \\
&amp;= V_{\pi&#39;}(s)
\end{align*}
\]</span></p>
</div>
<p>因此如果我们根据<span class="math inline">\(q_{\pi}(s,a)\)</span>的值，并且使用新的贪婪的策略<span class="math inline">\(\pi^\prime\)</span>，其定义如下：</p>
<p><span class="math display">\[
\begin{align*}
\pi&#39;(s) &amp;\doteq \mathop{\arg\max}_{a} Q_{\pi}(s, a) \\
       &amp;= \mathop{\arg\max}_{a} \mathbb{E} \left[ R_{t+1} + \gamma V_{\pi}(S_{t+1}) \mid S_t = s, A_t = a \right] \\
       &amp;= \mathop{\arg\max}_{a} \sum_{s&#39;, r} p(s&#39;, r \mid s, a) \left[ r + \gamma V_{\pi}(s&#39;) \right]
\end{align*}
\]</span></p>
<p>很明显，这个新的贪婪策略<span class="math inline">\(\pi^\prime\)</span>满足上述的策略提升定理的条件，所以这个新的策略所产生的价值函数一定大于或者等于原来的策略所产生的价值函数。这种使用原先策略的动作价值函数，并使用贪婪的方案来选择动作来得到新的策略的方式称为 <strong>策略提升（policy improvement）</strong>。</p>
<p>如果新的贪婪策略<span class="math inline">\(\pi^\prime\)</span>与原来的策略<span class="math inline">\(\pi\)</span>的价值函数相同，即<span class="math inline">\(V_{\pi} = V_{\pi^\prime}\)</span>，结合上述<span class="math inline">\(V_{\pi^\prime}\)</span>的定义，可以得到如下等式：</p>
<p><span class="math display">\[
\begin{align*}
V_{\pi^\prime}(s) &amp;= \max_{a}\mathbb{E} \left[ R_{t+1} + \gamma V_{\pi^\prime}(S_{t+1}) \mid S_t = s, A_t = a \right] \\
&amp;= \max_{a}\sum_{s&#39;, r} p(s&#39;, r \mid s, a) \left[ r + \gamma V_{\pi^\prime}(s&#39;) \right] \\
\end{align*}
\]</span></p>
<p>该等是与贝尔曼最优方程是一样的，因此，<span class="math inline">\(V_{\pi^\prime}\)</span>一定就是<span class="math inline">\(V_*\)</span>，而且<span class="math inline">\(\pi\)</span>与<span class="math inline">\(\pi^\prime\)</span>都是最优策略。因此，策略提升一定会我们一个更好的策略，除非原始的策略就是最优策略。</p>
<p>到目前为止，上述关于策略提升的讨论主要是针对于特殊的情况，即确定策略(deterministic policy)。但是我们也可以将上述的讨论推广到随机策略（stochastic policy）上。上述的结论对于随机策略来说依然成立。</p>
<p>依据贪婪策略<span class="math inline">\(\pi^\prime\)</span>的定义，我们选择使得<span class="math inline">\(Q_\pi(s,a)\)</span>最大的动作，最为新策略<span class="math inline">\(\pi^\prime\)</span>的动作。但是有可能存在多个动作<span class="math inline">\(a\)</span>，都使得<span class="math inline">\(Q_\pi(s,a)\)</span>最大。在确定策略的情况下，随便选一个就行了，但是对于随机策略，我们不需要只选取一个动作，而是可以为这些最大化<span class="math inline">\(Q_\pi(s,a)\)</span>动作中的每一个分配一定的被选中概率，从而构成新的贪婪策略。只要所有非最大化<span class="math inline">\(Q_\pi(s,a)\)</span>的动作被赋予零概率，任何这种分配方式都是允许的。</p>
<h4 id="策略迭代">策略迭代</h4>
<p>一旦一个策略<span class="math inline">\(\pi\)</span>被使用<span class="math inline">\(V_\pi\)</span>改进，生成了一个更优的策略<span class="math inline">\(\pi&#39;\)</span>，我们就可以计算<span class="math inline">\(V_{\pi&#39;}\)</span>，并再次进行改进，得到一个更优的策略<span class="math inline">\(\pi&#39;&#39;\)</span>。如此，我们可以得到一系列单调改进的策略和值函数：</p>
<p><span class="math display">\[
\pi_0 \xrightarrow{E} V_{\pi_0} \xrightarrow{I} \pi_1 \xrightarrow{E} V_{\pi_1} \xrightarrow{I} \pi_2 \xrightarrow{E} \cdots \xrightarrow{I} \pi_* \xrightarrow{E} V_*,
\]</span></p>
<p>其中：</p>
<ul>
<li><span class="math inline">\(\xrightarrow{E}\)</span>表示策略评估（<strong>Evaluation</strong>）；</li>
<li><span class="math inline">\(\xrightarrow{I}\)</span>表示策略改进（<strong>Improvement</strong>）。</li>
</ul>
<p>每一步策略都会是对前一步的严格改进（除非策略已经是最优）。由于有限的马尔可夫决策过程（MDP）只拥有有限个确定性策略，因此这个过程必定在有限步内收敛到一个最优策略<span class="math inline">\(\pi_*\)</span>和最优价值函数<span class="math inline">\(V_*\)</span>。</p>
<p>这种寻找最优策略的方法被称为 <strong>策略迭代（Policy Iteration）</strong>。完整的算法在下方的框中给出。</p>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">
注意：每次策略评估本身是一个迭代计算，它从前一个策略对应的值函数作为初始值开始。这样可以极大地加快策略评估的收敛速度（因为值函数在两个策略之间变化通常较小）。</p></div>
<div class="admonition admonition-note">
<p class="admonition-title">Policy Iteration（using iterative policy evaluation）for estimating $\pi \approx \pi_*$
</p>
<ol type="1">
<li><p><strong>Initialization</strong><br>
 <span class="math inline">\(V(s) \in \mathbb{R}\)</span> and <span class="math inline">\(\pi(s) \in \mathcal{A}(s)\)</span> arbitrarily for all <span class="math inline">\(s \in \mathcal{S}\)</span>；<span class="math inline">\(V(\text{terminal}) \doteq 0\)</span></p></li>
<li><p><strong>Policy Evaluation</strong><br>
 <strong>Loop</strong>:<br>
  <span class="math inline">\(\Delta \leftarrow 0\)</span><br>
  <strong>Loop for each</strong> <span class="math inline">\(s \in \mathcal{S}\)</span>:<br>
   <span class="math inline">\(v \leftarrow V(s)\)</span><br>
   <span class="math inline">\(V(s) \leftarrow \sum_{s&#39;, r} p(s&#39;, r \mid s, \pi(s)) \left[ r + \gamma V(s&#39;) \right]\)</span><br>
   <span class="math inline">\(\Delta \leftarrow \max(\Delta, |v - V(s)|)\)</span><br>
 <strong>until</strong> <span class="math inline">\(\Delta &lt; \theta\)</span>（其中 <span class="math inline">\(\theta\)</span> 是一个决定估计精度的小正数）</p></li>
<li><p><strong>Policy Improvement</strong><br>
 <span class="math inline">\(\textit{policy-stable} \leftarrow \text{true}\)</span><br>
 <strong>For each</strong> <span class="math inline">\(s \in \mathcal{S}\)</span>:<br>
  <span class="math inline">\(\textit{old-action} \leftarrow \pi(s)\)</span><br>
  <span class="math inline">\(\pi(s) \leftarrow \mathop{\arg\max}\limits_a \sum_{s&#39;, r} p(s&#39;, r \mid s, a) \left[ r + \gamma V(s&#39;) \right]\)</span><br>
  <strong>If</strong> <span class="math inline">\(\textit{old-action} \ne \pi(s)\)</span>，<strong>then</strong> <span class="math inline">\(\textit{policy-stable} \leftarrow \text{false}\)</span><br>
 <strong>If</strong> <span class="math inline">\(\textit{policy-stable}\)</span>，then：<br>
  stop and return <span class="math inline">\(V \approx v_*\)</span>，<span class="math inline">\(\pi \approx \pi_*\)</span><br>
 <strong>else</strong> go to step 2</p></li>
</ol>
</div>
<h4 id="价值迭代">价值迭代</h4>
<p>策略迭代的一个确定是，在每一次迭代过程中，都需要进行策略评估，而策略评估本身就是一个迭代过程（需要多次扫描整个状态空间，直到价值函数收敛到<span class="math inline">\(V_\pi\)</span>）。</p>
<p>但是我们是否需要等到策略评估精确收敛之后，再进行策略提升？还是说我们可以在策略评估中只迭代几次就直接退出，然后直接进行策略提升呢？实施证明后者是可行的，即我们可以截断策略评估，其中一个比较特殊的截断方案是，我们在策略评估时，只扫描一次状态空间（每个状态只更新一次），这个算法就是<strong>价值迭代（Value Iteration）</strong>。</p>
<p>结合策略提升和截断的策略评估，我们可以得到如下的更新方程：</p>
<p><span class="math display">\[
\begin{align*}    
V_{k+1}(s) &amp;= \max_{a} \mathbb{E} \left[ R_{t+1} + \gamma V_k(S_{t+1}) \mid S_t = s, A_t = a \right] \\
&amp;= \max_{a} \sum_{s&#39;, r} p(s&#39;, r \mid s, a) \left[ r + \gamma V_k(s&#39;) \right]
\end{align*}
\]</span></p>
<p>另一个理解价值迭代的方法是通过贝尔曼最优方程。可以发现，价值迭代只是简单得将贝尔曼最优方程转换成了更新规则。</p>
<p>最后，让我们考虑价值迭代的终止条件。像策略评估一样，价值迭代通常需要无限次的迭代才能完全收敛到<span class="math inline">\(V_*\)</span>。但是实际上，一旦在迭代过程中，价值函数的变化很小，我们就会停止。下面的框显示了具有这种终止条件的完整算法。</p>
<div class="admonition admonition-note">
<p class="admonition-title">Value Iteration. for estimating $\pi \approx \pi_*$ 
</p>
<p><strong>Algorithm parameter</strong>: a small threshold <span class="math inline">\(\theta &gt; 0\)</span> determining accuracy of estimation<br>
Initialize <span class="math inline">\(V(s)\)</span>, for all <span class="math inline">\(s \in \mathcal{S}^+\)</span>, arbitrarily except that <span class="math inline">\(V(\text{terminal}) = 0\)</span></p>
<p><strong>Loop</strong>:<br>
 <span class="math inline">\(\Delta \leftarrow 0\)</span><br>
 <strong>Loop for each</strong> <span class="math inline">\(s \in \mathcal{S}\)</span>:<br>
  <span class="math inline">\(v \leftarrow V(s)\)</span><br>
  <span class="math inline">\(V(s) \leftarrow \max_a \sum_{s&#39;, r} p(s&#39;, r \mid s, a) \left[ r + \gamma V(s&#39;) \right]\)</span><br>
  <span class="math inline">\(\Delta \leftarrow \max(\Delta, |v - V(s)|)\)</span><br>
<strong>until</strong> <span class="math inline">\(\Delta &lt; \theta\)</span></p>
<p><strong>Output a deterministic policy</strong>, <span class="math inline">\(\pi \approx \pi_*\)</span>, such that<br>
<span class="math inline">\(\pi(s) = \mathop{\arg\max}\limits_a \sum_{s&#39;, r} p(s&#39;, r \mid s, a) \left[ r + \gamma V(s&#39;) \right]\)</span></p>
</div>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>Static Timing Analysis for Nanometer Designs:A Practical Approach(v1)</title>
    <url>/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v1/</url>
    <content><![CDATA[<h1 id="绪论">绪论</h1>
<blockquote>
<p>众所周知，静态时序分析是IC工程师必备知识点，也是秋招中笔试面试的高频考点。<br>
网上不乏优秀视频课，如V3学院尤老师、小梅哥、IC创新学院邸志雄老师的课。<br>
《Static Timing Analysis for Nanometer Designs:A Practical Approach》，可堪称静态时序分析的“圣经”吧！<br>
由于网上找不到此书的翻译，因此笔者决定开坑进行对“圣经”的翻译~！希望可以在加深对静态时序分析的学习同时，完成这一本书的翻译方便大家以后更好地从中学习吧。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-8e02c51213dbc09e2bd57bd6df30a8c5_720w.jpg"></p>
<hr>
<p>本章节概述了纳米级（nanometer）设计下的静态时序仿真过程<br>
本章节解决了如下问题：</p>
<ul>
<li>什么是静态时序分析（static timing analysis）？</li>
<li>噪声（noise）与串扰（crosstalk）会带来什么影响 ？</li>
<li>如何使用静态时序分析？</li>
<li>在整个设计流程中的哪个阶段会应用静态时序分析？</li>
</ul>
<h2 id="纳米级设计">纳米级设计</h2>
<p>在半导体器件中，常使用金属互连线来连接电路中的不同部分，从而实现设计。随着工艺技术的发展，这些互连线逐渐开始影响设计的性能。对于深亚微米或者纳米级别的工艺技术，互连线间的耦合效应会带来噪声与串扰，而这两者都会限制设计的运行速度。虽然噪声与串扰带来的影响在老一代的工艺技术下是可以忽略不计的，但在如今纳米级别下已经不容忽视了。因此，不论是物理设计还是设计验证都应考虑到噪声与串扰的影响。</p>
<h2 id="什么是静态时序分析">什么是静态时序分析？</h2>
<p>静态时序分析（简称STA）是用来验证数字设计时序的技术之一，另外一种验证时序的方法是时序仿真，时序仿真可以同时验证功能和时序。“时序分析”这个术语就是用来指代“静态时序分析“或”时序仿真“这两种方法之一，简单来说，时序分析的目的就是为了解决设计中的各种时序问题。</p>
<p>STA被称为静态的原因是其对于设计的分析是静态地执行的，并不依赖于施加在输入端口上的激励。相比之下，时序仿真则可以被视作动态地执行对设计的分析，具体过程描述如下：施加一组激励，观察在这组激励下电路行为是否符合要求，然后换一组激励再重复以上过程，以此类推。</p>
<p>给定了一个设计、输入时钟以及外部环境，STA的目的就是验证这个设计是否能够运行在预期的速度，即这个设计可以安全地运行在给定的时钟频率下且没有时序违例。</p>
<p>图1-1展示了STA的基本功能：</p>
<p><img src="https://pic1.zhimg.com/80/v2-474d991f3c4610e3ef782fe8cecbc95c_720w.jpg" alt="图1-1"></p>
<p>上图中DUA即为待分析的设计。时序检查是指建立时间与保持时间检查：建立时间检查是用来保证数据可以在给定时钟周期内到达触发器；保持时间检查是用来保证数据在被触发器采样后还能保持一定时间，即保证触发器不要漏采数据。这些时序检查的目的都是为了保证触发器可以发送并且采样到正确的数据。</p>
<p>STA更重要的意义在于：整个设计只需要被分析一次，就可以对所有情况下设计中的全部路径进行所需的时序检查。因此，STA是能够被用来验证设计时序的一种完全且详尽的方法。</p>
<p>DUA通常使用硬件描述语言，例如VHDL或者Verilog HDL；外部环境，包括时钟定义，通常使用SDC或等价格式进行描述；SDC是一种时序约束的规范语言；而时序报告通常以ASCII格式呈现，一般报告中会有许多列，每一列都会显示路径延时的一个属性。</p>
<h2 id="为何使用静态时序分析">为何使用静态时序分析？</h2>
<p>STA是一种可以验证设计中所有时序要求的详尽方法，而其他时序分析方法例如时序仿真则只能验证到被当前激励执行到的那部分时序路径。基于时序仿真的验证完备性取决于施加激励的完备性。如果使用时序仿真来验证一个千万门级别的设计，速度将会非常慢，并且实际上也无法充分验证。因此，想要基于时序仿真的方法来进行详尽的时序验证是非常困难的。</p>
<p>相比之下，STA则提供了一种更快更简单的方法去分析并检查设计中的全部时序路径。鉴于如今的ASIC设计规模已达千万门级别，STA已经成为了详尽地验证设计时序的必要方法。</p>
<p><strong>串扰与噪声</strong></p>
<p>设计的功能和性能会受到噪声的影响，引起噪声的主要原因有：与其他信号的串扰、主要输入端口的噪声、电源等。由于噪声会限制设计所能运行的最高频率，并且也可能导致功能错误，因此一个设计必须保证有足够的鲁棒性，即这个设计可以在原有额定性能的基础上抵御一定的噪声。</p>
<p>基于逻辑仿真的验证是无法处理由串扰、噪声以及片上变化（on-chip variations）所带来的的影响的。</p>
<p>本书中所描述的分析方法不仅包括了传统时序分析技术，还包括了能够验证设计中噪声问题的噪声分析。</p>
<h2 id="设计流程">设计流程</h2>
<p>本节主要介绍了本书其余部分使用的CMOS数字设计流程，同时也简要说明了其在FPGA和异步设计中的适用性。</p>
<h2 id="cmos数字设计">CMOS数字设计</h2>
<p>在CMOS数字设计流程中，STA会在实现的各个阶段里被使用到。图1-2展示了一个基本的流程：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e746817aa9123fa35e2c5c61b32e09bf_720w.jpg" alt="图1-2"></p>
<p>STA很少在RTL级完成，因为在这一抽象层级上，验证设计的功能更为重要，而非时序。 同样，由于块（block）的描述处于行为级，因此时序信息也并非都是可用的。 一旦将RTL级的设计综合到门级，就可以使用STA来验证设计的时序。 STA也可以在执行逻辑优化之前运行，其目标是确定最差或关键的时序路径。 可以在逻辑优化后重新运行STA，以查看是否还有剩余的时序违例路径需要优化，或者确定关键路径。</p>
<p>在物理设计的一开始，时钟树被认为是理想的，即它们具有零延迟。 一旦物理设计开始并且建立了时钟树之后，就可以执行STA来再次检查时序。 实际上，在物理设计过程中，可以在每一步都执行STA以确定最差的路径。</p>
<p>在物理实现中，逻辑单元通过金属互连走线连接。 金属走线的寄生RC（电阻和电容）会影响通过这些走线的信号路径延迟。 在典型的纳米级设计中，大部分延迟和功耗都是由互连线带来的寄生因素所导致的。 因此，对设计的任何分析都应评估互连线对性能（速度，功耗等）的影响。 综上所述，信号走线之间的耦合会导致噪声，并且设计验证必须考虑到噪声对性能的影响。</p>
<p>在逻辑设计阶段，由于没有与布局有关的物理信息，因此可以假设互连线是理想状态的，此阶段会更关注查看导致最差路径的逻辑。 在这个阶段使用的另一种技术是采用线负载模型（wireload model）来估算互连线的长度， 线负载模型会基于逻辑单元的扇出提供一个估计的RC值。</p>
<p>在完成走线的布线之前，设计实现工具会使用布线距离的估算值来获得该路线的寄生RC值。 由于布线尚未完成，因此该阶段称为全局布线（global route）阶段，以将其与最终布线（final route）阶段区分开来。 在物理设计的全局布线阶段，简化的布线用于估计布线长度，而对布线的估计用于确定计算走线延迟所需的电阻和电容值。 在此阶段中，无法考虑耦合效应带来的影响。在实际精细的布线完成后，就可以提取实际的RC值，并且可以分析耦合效应带来的影响。 但是，物理设计工具仍可以使用近似值来帮助缩短计算RC值的运行时间。</p>
<p>提取工具用于从布线设计中提取详细的寄生参数（RC值），这样的提取工具一般具有以下选项：在迭代优化期间以较少的运行时间和较低精确度的RC值来获取寄生参数，以及在最终验证期间以较长的运行时间来提取非常精确的RC值。</p>
<p>总结一下，可以根据以下条件在门级网表上执行静态时序分析：</p>
<p>1.互连线的建模方式：理想互连线，线负载模型，具有近似RC值的全局布线以及具有精确RC值的实际布线。</p>
<p>2.时钟的建模方式：理想时钟（零延迟）或是传播时钟（实际延迟）。</p>
<p>3.是否考虑信号之间的耦合效应以及是否分析串扰噪声。</p>
<p>图1-2似乎暗示着STA是在实现步骤之外完成的，即STA是在综合、逻辑优化和物理设计步骤中的每个步骤之后完成的。 实际上，这些步骤中的每一个都在其功能范围内集成有STA。 例如，逻辑优化步骤中的时序分析引擎可用于识别优化器需要处理的关键路径。 同样，布局工具中集成的时序分析引擎可用于在布局逐步进行过程中保持设计的时序。</p>
<h2 id="fpga设计">FPGA设计</h2>
<p>STA的基本流程在FPGA中仍然有效，即使FPGA中的布线受限于通道，提取寄生参数和执行STA的机制也与CMOS数字设计流程相同。 例如，可以在假设互连为理想状态的情况下执行STA，或使用线负载模型，在时钟树为理想状态或真实状态的情况下执行STA，或者对寄生参数情况采用全局布线或真实布线来执行STA。</p>
<h2 id="异步设计">异步设计</h2>
<p>STA的原理也适用于异步设计，但在异步设计中会更加关注从一个信号到另一个信号的时序，而不是进行有可能不存在的建立时间与保持时间检查。 因此，异步设计中的时序检查一般是点到点时序检查或偏斜检查。 用于分析由耦合效应引起的毛刺的噪声分析适用于任何设计，包括同步设计与异步设计。同样，考虑到耦合响应对时序带来影响的噪声分析，对于异步设计也同样有效。</p>
<h2 id="不同阶段的静态时序分析">不同阶段的静态时序分析</h2>
<p>在逻辑级（未进行物理设计的门级），STA可采用以下模型：</p>
<p>1.理想的互连线或者基于线负载模型的互连线</p>
<p>2.带有延迟和抖动估计值的理想时钟</p>
<p>在物理设计阶段，除了上述模型，STA还可采用以下模型：</p>
<ol type="1">
<li>具有近似估计值的全局布线的互连线、具有近似寄生参数提取值的实际布线的互连线、具有可以签收（signoff）精度寄生参数提取值的实际布线的互连线</li>
</ol>
<p>2.实际的时钟树</p>
<p>3.包括串扰的影响或者不包括串扰的影响</p>
<h2 id="静态时序分析的局限性">静态时序分析的局限性</h2>
<p>虽然时序分析和噪声分析在所有可能的情况下都可以很好地分析设计中的时序问题，但在最新的技术中仍然无法完全使用STA替代仿真， 这是因为时序验证的某些方面还无法完全被STA捕获并得到验证。</p>
<p>静态时序分析的局限性包括以下几点：</p>
<ol type="1">
<li><p>复位顺序：检查所有触发器在异步或同步复位后是否都复位为所需的逻辑值，这是无法使用静态时序分析来检查的。 芯片可能不会退出复位状态。 这是因为某些声明（例如信号的初始值）没有被综合，仅在仿真过程中被验证。</p></li>
<li><p>未知态X的处理：STA技术仅处理逻辑0和逻辑1（或高电平/低电平）的逻辑域，或者是上升沿和下降沿的逻辑域。 设计中的未知态X导致不确定的值在整个设计中传播，这也是无法使用STA进行检查。 即使STA内的噪声分析可以分析整个设计中的毛刺，但作为纳米级设计中基于仿真的时序验证的一部分，毛刺分析和传播的范围也与对未知态X的处理大为不同。</p></li>
<li><p>PLL设置：PLL的配置可能未被正确加载或设置。</p></li>
<li><p>跨异步时钟域：STA不检查是否使用了正确的时钟同步器，需要其他工具来确保在任何跨异步时钟域的地方都有正确的时钟同步器。</p></li>
<li><p>IO接口时序：可能仅根据STA约束无法规定IO接口要求。例如，设计人员可能使用SDRAM仿真模型为DDR接口选择详细的电路级仿真。仿真是为了确保可以以足够的余量读取和写入存储器，并且在必要时可以控制DLL（如果有）来对齐信号。</p></li>
<li><p>模拟模块和数字模块之间的接口：由于STA不处理模拟模块，因此验证方法需要确保这两种类型的模块之间的连接正确。</p></li>
<li><p>伪路径（false path）：静态时序分析会验证通过逻辑路径的时序是否满足所有约束，如果通过逻辑路径的时序不符合要求的规范，则标记违例。在许多情况下，即使逻辑可能永远无法传播通过该路径，STA也会将该逻辑路径标记为时序违例路径。 当系统应用程序从不使用此类路径时，或者在时序违例路径的敏感列表中使用了互斥的条件时，可能会发生这种情况。 这种时序路径被称为伪路径，因为这种时序路径实际上不会被执行。当在设计中指定了正确的时序约束（包括伪路径和多周期路径约束）时，STA结果的质量会更好。 在大多数情况下，设计人员可以利用设计的固有知识并指定约束条件，以便在STA期间消除伪路径。</p></li>
<li><p>FIFO指针不同步：当两个预期要同步的有限状态机实际上不同步时，STA无法检测到该问题。在功能仿真过程中，两个有限状态机可能始终保持同步变化。但是，在考虑了延迟之后，一个有限状态机有可能与另一个就不同步了，这很可能是因为一个有限状态机比另一个更早退出复位状态，而STA无法检测到这种情况。</p></li>
<li><p>时钟同步逻辑：STA无法检测到时钟生成逻辑与时钟定义不匹配的问题。 STA会假设时钟生成器将提供时钟定义中指定的波形。 对时钟生成器逻辑的优化可能很糟糕，比如会导致在未适当约束的路径之一上插入较大的延迟，又或者，添加的逻辑改变了时钟的占空比。而STA无法检测到这些潜在情况中的任何一个。</p></li>
<li><p>跨时钟周期的功能行为：STA无法建模或仿真跨时钟周期变化的功能行为。</p></li>
</ol>
<p>尽管存在诸如此类的问题，STA依然适合被广泛用于验证设计的时序，而时序仿真可作为备用方法来检查极端情况，并且能够更简单地验证设计的功能正确。</p>
<h2 id="功耗考虑">功耗考虑</h2>
<p>功耗是设计实现中的重要考虑因素，大多数设计需要在电路板和系统的功耗预算内运行。若需要符合标准并且考虑到芯片运行在电路板和系统上的热预算，可能还会出现功耗方面的考虑。对总功率（total power）和待机功率（standby power）通常存在独立的限制，待机功率限制通常适用于手持式或电池供电的设备。</p>
<p>在大多数实际设计中，功耗和时序通常是密不可分的。设计人员希望使用更快（或更高速度）的单元来满足速度方面的考虑，但可能会受到功耗的限制。 在选择工艺技术和单元库时，功耗是一个重要的考虑因素。</p>
<h2 id="可靠性考虑">可靠性考虑</h2>
<p>设计实现必须满足可靠性要求。如1.4.1节中所述，金属互连走线具有寄生RC值，从而限制了设计的性能。除寄生效应外，在设计金属互连走线宽度时也应当要考虑可靠性因素。例如，高速时钟信号需要足够宽，以满足诸如电迁移之类的可靠性考虑。</p>
<h2 id="本书大纲">本书大纲</h2>
<p>尽管表面上静态时序分析似乎是一个非常简单的概念，但该分析背后有很多背景知识。基本概念的范围从准确地表示单元延迟到计算具有最小悲观度的最坏路径延迟。计算单元延迟、组合逻辑块的延时、时钟关系、多个时钟域和门控时钟的概念构成了静态时序分析的重要基础，为设计编写正确的SDC确实是一个挑战。</p>
<p>这本书是按照自底向上（bottom-up）的顺序编写的，即首先介绍简单的概念，在随后的章节中介绍更高级的主题。</p>
<p>●本书首先介绍了准确计算单元延迟（第3章）。</p>
<p>●估计或计算精确的互连延迟及其有效表示方法是第4章的主题。</p>
<p>●在第5章中讨论如何计算由单元和互连线组成的路径延迟。</p>
<p>●信号完整性（即信号在相邻网络上的相互影响）及其对路径延迟的影响是第6章的主题。</p>
<p>●第7章介绍了时钟定义和路径例外来准确表示DUA的环境。</p>
<p>●第8章介绍了在STA中执行时序检查的详细信息。</p>
<p>●第9章将讨论跨各种接口的IO时序建模。</p>
<p>●最后，第10章将介绍高级时序检查，如片上变化（on-chip variation）、时钟门控（clock gating）检查，电源管理和统计时序分析。</p>
<p>●附录提供了SDC（用于表示时序约束），SDF（用于表示单元和网络延迟）和SPEF（用于表示寄生参数）的详细说明。</p>
<p>第7章至第10章介绍的是STA验证的核心，前面的章节为更好地了解STA打下了扎实的基础。</p>
<h1 id="sta概念上">STA概念上</h1>
<blockquote>
<p>本章节介绍CMOS技术的基础知识以及执行静态时序分析所涉及的术语。</p>
</blockquote>
<h2 id="cmos逻辑设计">CMOS逻辑设计</h2>
<h2 id="cmos逻辑设计-1">CMOS逻辑设计</h2>
<h2 id="基本mos结构">基本MOS结构</h2>
<p>MOS晶体管（NMOS和PMOS）的物理实现如图2-1所示。源极（source）和漏极（drain）区域之间的距离（channel length）是MOS晶体管的长度，用于构建MOS晶体管的最小长度即为CMOS技术工艺的最小特征尺寸（feature size）。例如，0.25um技术允许制造具有0.25um或更大沟道长度的MOS晶体管。 通过缩小沟道的几何形状，晶体管的尺寸会变小，这样就可以在同样的面积上封装更多的晶体管。 正如我们将在后面章节看到的那样，更小的晶体管尺寸同样还可以使设计以更高的速度运行。</p>
<p><img src="https://pic1.zhimg.com/80/v2-070e61013ed37659190f2d60e30460b4_720w.jpg" alt="图2-1"></p>
<h2 id="cmos逻辑门">CMOS逻辑门</h2>
<p>CMOS逻辑门使用NMOS和PMOS晶体管搭建而成。图2-2给出了CMOS反相器（inverter）的示例。CMOS反相器有两种稳定状态，具体取决于输入的电平状态。 当输入A为低电平（Vss或逻辑0）时，NMOS晶体管截止，而PMOS晶体管导通，导致输出Z的电平被上拉至逻辑为1的Vdd。当输入A为高电平（Vdd或逻辑1）时，NMOS晶体管导通，而PMOS晶体管截止，导致输出Z的电平被下拉至逻辑为0的Vss。在上述两种状态中的任何一种状态下，CMOS反相器都是稳定的，不会从输入端A或电源Vdd汲取任何电流。</p>
<p><img src="https://pic2.zhimg.com/80/v2-29854db71935530a41bbc14294e8e2f1_720w.jpg" alt="图2-2"></p>
<p>CMOS反相器的特性可以扩展到任何CMOS逻辑门。在CMOS逻辑门中，输出节点通过上拉结构（由PMOS晶体管构成）连接至Vdd，并通过下拉结构（由NMOS晶体管构成）连接至Vss。例如，图2-3展示了一个两输入CMOS与非门（nand）。在该例中，上拉结构由两个并联的PMOS晶体管组成，下拉结构由两个串联的NMOS晶体管组成。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e56ce42dd76f7ec56ac66d4e2a2705fc_720w.jpg" alt="图2-3"></p>
<p>对于任何CMOS逻辑门，上拉和下拉结构是互补的。对于逻辑0或逻辑1的输入，如果上拉结构开启，则下拉结构将关闭；类似地，如果上拉结构关闭，则下拉结构将开启。下拉和上拉结构由CMOS门实现的逻辑功能控制。例如，在CMOS与非门中，控制下拉结构的功能是“A&amp;B”，即当A和B都为逻辑1时下拉被接通。类似地，控制上拉结构的功能是“ <img src="https://www.zhihu.com/equation?tex=%5Cbar%7BA%7D%7C%5Cbar%7BB%7D" alt="[公式]"> ”，即当A或B处于逻辑0时上拉被打开。这些特性确保了控制上拉结构的功能将输出节点的逻辑上拉至Vdd。由于下拉结构由互补函数控制，因此当上拉结构函数的值为0时，输出节点处于逻辑0。</p>
<p>对于逻辑0或逻辑1的输入，由于上拉和下拉结构不能同时开启，因此处于稳态的CMOS逻辑门不会对输入或电源汲取任何电流。CMOS逻辑的另一个重要方面是，输入仅对前一级构成容性负载。</p>
<p>若CMOS逻辑门是一个反相门，这意味着单个输入的变化（上升或下降）只能使输出往相反的方向改变，也就是说，输出无法与输入同相变化。但是，可以将CMOS逻辑门级联起来以实现更复杂的逻辑功能。</p>
<h2 id="标准单元">标准单元</h2>
<p>芯片中的大多数复杂功能通常是使用基本构建块（basic building block）来设计的，这些基本构建块实现了简单的逻辑功能，例如与、或、与非、或非、或与非，与或非以及触发器（flip-flop）。这些基本构建块是预先设计的，称为标准单元（standard cell）。标准单元的功能和时序已预先确定，可供设计人员使用。然后，设计人员可以使用标准单元作为基本构建块来实现所需的功能。</p>
<p>前面小节中描述的CMOS逻辑门的关键特性适用于所有CMOS数字设计。当输入处于稳定的逻辑状态时，所有数字CMOS单元的设计都能够保证不从电源汲取电流（漏电流除外）。因此，大多数功耗与设计的功能有关，并且是由设计中CMOS单元输入端的充放电引起的。</p>
<p>什么是逻辑1或逻辑0？在CMOS单元中，VIHmin和 VILmax这两个值定义了范围：高于VIHmin的电压值被认为是逻辑1，低于VILmax的电压值被认为是逻辑0。如图2-4所示，0.13um工艺下一个具有1.2V Vdd电源的CMOS反相器单元的典型VILmax值为0.465V、VIHmin值为0.625V。 VIHmin和VILmax的值是从标准单元的直流传输特性中得出的。直流传输特性会在接下去的6.2.3节中有更详细的描述。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0e18512fef5ac668ab1dcb929bc75a8b_720w.jpg" alt="图2-4"></p>
<h2 id="cmos单元建模">CMOS单元建模</h2>
<p>如果一个单元的输出引脚驱动多个扇出单元，则该单元的输出引脚上的总电容等于该单元正在驱动的单元的所有输入电容的总和加上构成该网络所有走线电容之和再加上驱动单元的输出电容。注意，在CMOS单元中，输入引脚仅呈现电容性负载。</p>
<p><img src="https://pic4.zhimg.com/80/v2-6ec63472a1bd9be52546be8c7e189b1f_720w.jpg" alt="图2-5"></p>
<p>图2-5是一个单元G1驱动其他三个单元G2、G3和G4的示例。 Cs1，Cs2，Cs3和Cs4是组成该网络的走线电容值，因此G1输出引脚的总电容=G2单元的输入电容+G3单元的输入电容+G4单元的输入电容+G1单元的输出电容+ Cs1+Cs2+Cs3+Cs4 。这个值就是G1单元进行电平切换时需要充放电的电容值，因此该总电容值会影响G1单元的时序特性。</p>
<p>从时序角度来看，我们需要对CMOS单元建模，以帮助我们分析通过该单元的时序。每个输入引脚必须指定一个输入引脚电容，而大多数CMOS逻辑单元可以不包括输出引脚的引脚电容，但也可能存在输出引脚电容。</p>
<p>当输出为逻辑1时，输出级的上拉结构导通，并提供了一条从输出到Vdd的路径。同样，当输出为逻辑0时，输出级的下拉结构提供了一条从输出到Vss的路径。当CMOS单元切换电平状态时，切换的速度取决于输出引脚上的电容被充放电的速度。输出引脚上的电容（图2-5）分别通过上拉和下拉结构充电和放电。注意，上拉和下拉结构中的通道会对输出的充放电路径构成电阻，充放电路径的电阻是决定CMOS单元速度的主要因素。上拉电阻的倒数称为单元的输出高电平驱动（output high drive）。输出上拉结构越大，上拉电阻就越小，即单元的输出高电平驱动就越大，较大的输出结构也意味着该单元的面积较大。而输出上拉结构越小，单元的面积就越小，其输出高电平驱动也就越小。上拉结构的相同概念可用于下拉结构，下拉结构决定了下拉路径的电阻值以及输出低电平驱动（output low drive）。通常，单元的上拉和下拉结构具有相似的驱动强度。</p>
<p>输出驱动决定了可以驱动的最大电容负载，最大电容负载又决定了扇出的最大数量，即可以驱动多少个其他单元。较高的输出驱动对应较低的输出上拉/下拉电阻，这使单元可以在输出引脚上对较大的负载进行充电和放电。</p>
<p>下图2-6是CMOS单元的等效抽象模型。该模型的目的是抽象单元的时序行为，因此仅对输入级和输出级进行建模，此模型无法捕获单元的固有延迟或电学行为。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bf581fb2b21db0ec50e11bb33c872ff1_720w.jpg" alt="图2-6"></p>
<p>CpinA是单元在输入A上的输入引脚电容；Rdh和Rdl是单元的输出驱动电阻，可根据单元所驱动的负载确定输出引脚Z电平转换时的上升/下降时间，输出驱动电阻还确定了单元的最大扇出限制。</p>
<p>图2-7与图2-5具有相同的网络，但使用等效模型表示了CMOS单元：</p>
<p><img src="https://pic2.zhimg.com/80/v2-68c7436ae3443380e16b6f8a371c2a19_720w.jpg" alt="图2-7"></p>
<p>● Cwire = Cs1+Cs2+Cs3+Cs4</p>
<p>● 输出充放电延迟 = Rout × （Cwire + Cin2 + Cin3 + Cin4）</p>
<p>在上述表达式中，Rout是Rdh或Rdl之一，其中Rdh是上拉的输出驱动电阻，Rdl是下拉的输出驱动电阻。</p>
<h2 id="电平切换波形">电平切换波形</h2>
<p>如图2-8（a）所示，通过按下SW0开关将电压施加到RC网络时，输出将变为逻辑1。假设还未按下SW0时输出为0V，则输出电压的变化由以下公式表示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-8a6c974eb8d994950fb689151ecba308_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-80b95f14292cb28be9a2048f262b9ccd_720w.jpg" alt="图2-8"></p>
<p>该上升的电压波形如图2-8（b）所示。乘积（Rdh * Cload）称为RC时间常数（RC time constant），该值与输出的过渡时间有关。</p>
<p>断开SW0开关同时按下SW1开关，输出就会从逻辑1变为逻辑0，输出电压的变化如图2-8（c）所示。输出电容通过按下的SW1开关放电，这种情况下的电压变化由以下公式表示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-7866eb36a5736a53ddb7e0cd2b8c4166_720w.png"></p>
<p>在CMOS单元中，由于PMOS上拉晶体管和NMOS下拉晶体管在短时间内会同时导通，因此输出的充放电波形不会像图2-8的RC充放电波形那样。 图2-9显示了在CMOS反相器单元内，从逻辑1到逻辑0输出切换时各个阶段的电流路径。图2-9（a）显示了当上拉和下拉结构同时开启时的电流流动。随后，上拉结构关闭，电流流向随即如图2-9（b）中所示。输出达到最终状态后，由于电容Cload已完全放电，因此不再有电流流动。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e35127deebe216a697d5ddacb06db06f_720w.jpg" alt="图2-9"></p>
<p>图2-10（a）是CMOS单元输出级的典型波形，请注意观察过渡波形如何逐渐朝向Vss和Vdd弯曲，且波形的线性部分位于中间位置。</p>
<p><img src="https://pic3.zhimg.com/80/v2-dcae7a88ee6024498fd3467119ba444a_720w.jpg" alt="图2-10"></p>
<p>在本文中，我们将使用如图2-10（b）所示的简化版来描绘一些波形，简化版的近似波形也是具有一定过渡时间（transition time）的波形，过渡时间是指从一种逻辑状态过渡到另一种逻辑状态所需的时间。图2-10（c）是过渡时间为0的波形，即理想波形。我们将在本文中交替使用（b）（c）这两种形式的波形来解释一些概念，但我们一定要清楚，实际上每个波形都有（a）那样的真实的边缘特性。</p>
<h2 id="传播延时">传播延时</h2>
<p>考虑一个CMOS反相器单元及其输入和输出波形，单元的传播延时（propagation delay）是由电平切换波形上的某些测量点定义的。使用以下四个变量定义这些测量点：</p>
<p>#输入端口下降沿的阈值点</p>
<p><strong>input_threshold_pct_fall</strong>：50.0；</p>
<p>#输入端口上升沿的阈值点</p>
<p><strong>input_threshold_pct_rise</strong>：50.0；</p>
<p>#输出端口下降沿的阈值点</p>
<p><strong>output_threshold_pct_fall</strong>：50.0；</p>
<p>#输出端口上升沿的阈值点</p>
<p><strong>output_threshold_pct_rise</strong>：50.0；</p>
<p>以上这些变量是用于描述单元库（cell library）的命令集里的一部分。 这些阈值的单位是Vdd或电源的百分比，对于大多数标准单元库，通常将50％阈值用于计算延时。</p>
<p>上升沿是指从逻辑0到逻辑1的跳变，下降沿是从逻辑1到逻辑0的跳变。</p>
<p>假设有一个CMOS反相器单元，其输入输出管脚的波形如图2-11所示，传播延时是指如下两个值：</p>
<p>1.输出下降沿延时（output fall delay）：Tf</p>
<p>2.输出上升沿延时（output rise delay）：Tr</p>
<p><img src="https://pic1.zhimg.com/80/v2-f457a18b69930fddbac8dc41db072768_720w.jpg" alt="图2-11"></p>
<p>通常，这两个值是不相等的，上图2-11也展示了这两个传播延时值是如何测量的。</p>
<p>若使用理想波形来看，则传播延时将仅仅是两个边沿之间的延迟，如图2-12所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-c019718f9a474a09442d3a4fb6b254d3_720w.jpg" alt="图2-12"></p>
<h2 id="波形的压摆">波形的压摆</h2>
<p>压摆率（slew rate）的定义是电压转换速率。在静态时序分析中，通常会根据电平转换的快慢来衡量上升波形或下降波形。 压摆（slew）通常是根据转换时间（transition time）来定义的，转换时间是指信号在两个特定电平之间转换所需要的时间。请注意，转换时间实际上就是压摆率的倒数，因此转换时间越大，压摆率就越低，反之亦然。</p>
<p><img src="https://pic3.zhimg.com/80/v2-dcae7a88ee6024498fd3467119ba444a_720w.jpg" alt="图2-10"></p>
<p>回顾图2-10给出的CMOS单元输出端典型波形：靠近Vdd和Vss两端的波形是渐近的，很难确定过渡时间的确切起点和终点。因此，一般使用指定的阈值电压来规定过渡时间计算的起点和终点。例如，压摆阈值设置可以如下所示：</p>
<p>#下降沿的阈值点</p>
<p><strong>slew_lower_threshold_pct_fall</strong>：30.0；</p>
<p><strong>slew_upper_threshold_pct_fall</strong>：70.0；</p>
<p>#上升沿的阈值点</p>
<p><strong>slew_lower_threshold_pct_rise</strong>：30.0；</p>
<p><strong>slew_upper_threshold_pct_rise</strong>：70.0；</p>
<p>以上这些数值的单位同样是Vdd的百分比。阈值设置指定了下降压摆（Fall slew）为下降沿达到Vdd的70％和30％的时间之差。类似地，设置指定了上升压摆（Rise slew）为上升沿达到Vdd的30％和70％的时间之差，如图2-13所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-31d562c5a5c9c8ca6b00bd339863175b_720w.jpg" alt="图2-13"></p>
<p>图2-14是另一个示例，其中下降沿的压摆测量范围为80％至20％，而上升沿的压摆测量范围为10％至90％，以下是这个例子的阈值设置：</p>
<p>#下降沿的阈值点</p>
<p><strong>slew_lower_threshold_pct_fall</strong>：20.0；</p>
<p><strong>slew_upper_threshold_pct_fall</strong>：80.0；</p>
<p>#上升沿的阈值点</p>
<p><strong>slew_lower_threshold_pct_rise</strong>：10.0；</p>
<p><strong>slew_upper_threshold_pct_rise</strong>：90.0；</p>
<p><img src="https://pic3.zhimg.com/80/v2-12cbcf0dd30d312a27bb761cbf4d6286_720w.jpg" alt="图2-14"></p>
<h2 id="信号偏斜">信号偏斜</h2>
<p>偏斜（skew）是指两个或多个信号（数据或者时钟）之间的时序之差。例如，如果一个时钟树（clock tree）有500个终点，并且有50ps的偏斜，则意味着最长时钟路径和最短时钟路径之间的延迟差为50ps。如图2-15所示是一个时钟树，时钟树的起点通常是定义时钟的节点，时钟树的终点通常是同步元件（例如触发器）的时钟引脚。时钟延迟（clock latency）是指从时钟源到终点所花费的总时间，时钟偏斜（clock skew）是指到达不同时钟树终点的时间差。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9bfb081b8498595ee7952cb61153cfad_720w.jpg" alt="图2-15"></p>
<p>理想时钟树是假定时钟源具有无限驱动力，也就是说，时钟可以无延迟地驱动无限个终点。另外，假定时钟树中存在的任何逻辑单元都具有零延迟（zero delay）。 在逻辑设计的早期阶段，STA通常使用理想的时钟树来执行，因此分析的重点是数据路径（data path）。在理想的时钟树中，默认情况下时钟偏斜为0ps，可以使用<strong>set_clock_latency</strong>命令显式地指定时钟树的延迟：</p>
<p><strong>set_clock_latency</strong> 2.2 [<strong>get_clocks</strong> BZCLK]</p>
<p>上述命令规定了时钟树BZCLK的上升沿延迟（rise latency）和下降沿延迟（fall latency）均为2.2ns。注意，如果两个延时值不同，可以使用选项<strong>-rise</strong>和<strong>-fall</strong>来分别指定延时值。</p>
<p>时钟树的时钟偏斜可以借助<strong>set_clock_uncertainty</strong>命令显式指定时钟不确定度的值来进行描述：</p>
<p><strong>set_clock_uncertainty</strong> 0.250 <strong>-setup</strong> [<strong>get_clocks</strong> BZCLK]</p>
<p><strong>set_clock_uncertainty</strong> 0.100 <strong>-hold</strong> [<strong>get_clocks</strong> BZCLK]</p>
<p><strong>set_clock_uncertainty</strong>命令为时钟沿的出现指定了一个窗口。时钟边沿时序的不确定性将考虑多个因素，例如时钟周期抖动（jitter）和用于时序验证的额外裕量（slack）。每个实际的时钟源都有一定的抖动量，即一个时间窗口，在该窗口内都可能会出现时钟沿。时钟周期抖动取决于所使用的时钟发生器的类型。实际上是不存在理想时钟的，也就是说，所有时钟都具有一定的抖动量，并且在指定时钟不确定度（clock uncertainty）时应包括时钟周期抖动。</p>
<p>在时钟树被实现（implement）之前，时钟不确定度还必须包括预期的时钟偏斜。</p>
<p>可以为建立时间（setup time）检查和保持时间（hold time）检查指定不同的时钟不确定度。保持时间检查不需要将时钟抖动包括在内，因此通常为保持时间检查指定较小的时钟不确定度。</p>
<p>如下图2-16所示是时钟不确定度为250ps的建立时间检查。图2-16（b）揭示了时钟不确定度是如何从逻辑传播到下一个触发器的耗时中消去的，这相当于要验证设计能够以更高的频率运行。</p>
<p><img src="https://pic2.zhimg.com/80/v2-48609c4e609f654f7f3f14b5ef98cd3d_720w.jpg" alt="图2-16"></p>
<p>如上所述，<strong>set_clock_uncertainty</strong>命令也可以用于建模任何额外时序裕量。例如，设计人员可以在设计过程中依据一定的悲观度而设置50ps的时序裕量，使用<strong>set_clock_uncertainty</strong>命令时会将这个值加进去。</p>
<p>总而言之，在实现时钟树之前，<strong>set_clock_uncertainty</strong>命令指定的值将包括时钟抖动、时钟偏斜估计值以及额外悲观度。</p>
<p><strong>set_clock_latency</strong> 2.0 [<strong>get_clocks</strong> USBCLK]</p>
<p><strong>set_clock_uncertainty</strong> 0.2 [<strong>get_clocks</strong> USBCLK]</p>
<p>上面这条命令中200ps的时钟不确定度可能是由50ps时钟抖动、100ps时钟偏斜以及50ps的额外悲观度组成的。</p>
<p>随后我们将看到<strong>set_clock_uncertainty</strong>这条命令是如何影响建立时间和保持时间检查的，我们最好能够将时钟不确定度视为最终计算时序裕量（slack）的补偿（offset）。</p>
<h2 id="时序弧">时序弧</h2>
<p>每个逻辑单元都有多个时序弧（timing arc）。像与门、或门、与非门、加法器这些组合逻辑单元，每个输入引脚到每个输出引脚都存在一条时序弧。而像触发器之类的时序逻辑单元除了有从时钟引脚到输出引脚的时序弧，还有相对于时钟引脚的数据引脚时序约束（timing constraint）。每个时序弧都具有特定的时序敏感（timing sense），即输出如何针对输入的不同跳变类型而变化。如果输入引脚上的上升沿跳变导致输出引脚电平上升（或不变），而输入引脚上的下降沿跳变导致输出引脚电平下降（或不变），则时序弧为正单边（positive unate）类型。 例如,与门和或门的时序弧为正单边类型，如下图2-17（a）所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-89d9671135e476cca5b55076bca73889_720w.jpg" alt="图2-17"></p>
<p>如果输入引脚上的上升沿跳变导致输出引脚电平下降（或不变），而输入引脚上的下降沿跳变导致输出引脚电平上升（或不变），则时序弧为负单边（negative unate）类型。例如，与非门和或非门的时序弧为负单边类型，如上图2-17（b）所示。</p>
<p>在非单边（non-unate）时序弧中，仅仅从一个输入引脚的跳变方向是无法确定输出引脚电平将如何跳变的，还要取决于其他输入引脚的状态。例如，异或门中的时序弧是非单边时序弧，如上图2-17（c）所示。</p>
<p>单边性（unateness）对于时序很重要，因为它指定了输入引脚上电平跳变沿将如何通过逻辑单元传播以及将如何出现在逻辑单元的输出引脚上。</p>
<p>可以利用时序弧的非单边性（如异或门）来反转时钟的极性（polarity）。如下图2-18所示，如果输入POLCTRL为逻辑0，则单元UXOR0的输出上的时钟DDRCLK具有与输入时钟MEMCLK相同的极性。如果POLCTRL为逻辑1，则单元UXOR0的输出时钟的极性与输入时钟MEMCLK的极性相反。</p>
<p><img src="https://pic2.zhimg.com/80/v2-3f99b501c3bc3225b3df9e7c83298e41_720w.jpg" alt="图2-18"></p>
<h2 id="最小与最大时序路径">最小与最大时序路径</h2>
<p>逻辑通过逻辑路径传播的总延迟称为路径延迟（path delay），包括了逻辑路径中经过各个逻辑单元（cell）和网络走线（net）的延迟。通常，逻辑想要传递到一个终点可能有不止一条逻辑路径可走，所经过的实际路径取决于逻辑路径上其他输入的状态。图2-19给出了一个例子，由于有多个到达逻辑终点的路径，因此可以得出到达逻辑终点的最大时序和最小时序，对应于最大时序和最小时序的路径分别称为最大路径和最小路径。两个节点之间的最大路径是指延迟最大的路径（也称为最长路径），同样，最小路径是指延迟最小的路径（也称为最短路径）。请注意，最长和最短是指路径上的累积延迟，而不是路径上的逻辑单元个数。</p>
<p><img src="https://pic3.zhimg.com/80/v2-cd6e801dc8d46b8ac0a01cfc4674130a_720w.jpg" alt="图2-19"></p>
<p>图2-19给出了两级触发器之间数据路径的示例。可以看到经过UNAND0、UBUF2、UOR2和UNAND6单元的路径是触发器UFF1和UFF3之间的最大路径，而经过UOR4和UNAND6单元的路径是触发器UFF1和UFF3之间的最小路径。请注意，本例中所说的最小与最大时序路径都是基于终点是触发器UFF3的D引脚。</p>
<p>通常也称最大路径为晚路径（late path），称最小路径为早路径（early path）。</p>
<p>当考虑从UFF1到UFF3这样的从触发器到触发器的路径时，其中一个触发器发起（launch）数据，另一个触发器捕获（capture）数据。在这种情况下，由于UFF1发起数据，因此UFF1被称为发起触发器（launch flip-flop），由于UFF3捕获数据，因此UFF3被称为捕获触发器（capture flip-flop）。请注意，“发起”和“触发”不是绝对的，一定是相对于某一条时序路径才能决定触发器到底是发起数据还是捕获数据。例如，UFF3发起的数据如果被下一级触发器捕获了，那么在那条时序路径中UFF3则变为了发起触发器。</p>
<h2 id="时钟域">时钟域</h2>
<p>在同步逻辑设计中，周期性的时钟信号将计算出的新数据锁存到触发器中。新的输入数据基于的是前一个时钟周期的触发器值，因此锁存到的数据将被用于计算下一个时钟周期的数据。</p>
<p>一个时钟通常驱动许多触发器，由同一时钟驱动的一组触发器称为其时钟域（clock domain）。在典型的设计中，可能有多个时钟域。例如，USBCLK驱动了200个触发器，而时钟MEMCLK驱动了1000个触发器，如图2-20所示。在此示例中，我们称有两个时钟域。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5070e0f3e5f8499854378e512f4c56d8_720w.jpg" alt="图2-20"></p>
<p>需要关注一个问题：两个时钟域是相关的还是彼此独立的？答案取决于是否存在一条从一个时钟域开始并在另一时钟域结束的数据路径，如果没有这样的路径，我们可以肯定地说这两个时钟域彼此独立，这意味着没有时序路径从一个时钟域开始而在另一时钟域结束。</p>
<p><img src="https://pic4.zhimg.com/80/v2-590e76815ceb15c697610d14515a31a7_720w.jpg" alt="图2-21"></p>
<p>若存在跨时钟域的数据路径（如图2-21所示），则必须确定这些路径是否为真实（real）路径。例如，一个两倍频时钟驱动的触发器发起数据，再由一倍频时钟驱动的触发器捕获数据，这条路径就是一条真实路径。伪路径（false path）的一个例子是设计人员将时钟同步器（clock synchronizer）逻辑明确放置在两个时钟域之间。在这种情况下，即使好像存在从一个时钟域到下一时钟域的时序路径，但这也不是真实的时序路径，因为数据没有被约束要在一个时钟周期之内通过同步器逻辑传播。这样的路径称为伪路径（不是真实的），因为是由时钟同步器来确保数据正确地从一个时钟域传递到另一个时钟域。可以使用<strong>set_false_path</strong>命令指定时钟域之间的伪路径，例如：</p>
<p><strong>set_false_path -from</strong> [<strong>get_clocks</strong> USBCLK]   <strong>-to</strong> [<strong>get_clocks</strong> MEMCLK]</p>
<p>虽然无法从图2-21中看到，但实际出现跨时钟域的情况往往是双向的，即从USBCLK时钟域到MEMCLK时钟域，以及从MEMCLK时钟域到USBCLK时钟域，这两种情况都需要在STA中正确理解和处理。</p>
<p>为什么要讨论时钟域之间的路径呢？通常，一个设计中会有多个时钟，并且时钟域之间可能有无数条路径。 分辨出哪些跨时钟域路径是真实的，哪些是伪路径，是时序验证工作的重要组成部分，这使得设计人员可以专注于验证真实的时序路径。</p>
<p>图2-22给出了时钟域的另一个示例，多路复用器（multiplexer）根据设计的工作模式选择时钟源。虽然只有一个时钟域，但却有两个时钟，这两个时钟是互斥的，因为一次只有一个时钟处于有效状态。因此，在这个例子中，USBCLK和USBCLKx2这两个时钟域之间永远不会存在时序路径（假定多路复用器的控制是静态的，并且设计中其余部分也不存在这两个时钟域之间的时序路径）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-066a7d80cf987dfc20864234d649241d_720w.jpg" alt="图2-22"></p>
<h2 id="工作条件">工作条件</h2>
<p>静态时序分析通常是在特定的工作条件（operating condition）下执行的，工作条件定义为工艺（process）、电压（voltage）和温度（temperature）的组合，简称PVT。逻辑单元延迟和互连线的走线延迟是根据特定的工作条件计算的。</p>
<p>半导体代工厂（foundry）为数字设计提供了3种加工工艺模型：慢速（slow）工艺模型，典型（typical）工艺模型和快速（fast）工艺模型，快速和慢速工艺模型代表了半导体代工厂加工的两个极端工艺角（process corner）。对于稳健（robust）的设计，应该在极端加工工艺角以及温度和电源电压都比较极端的环境下对设计进行验证。图2-23（a）展示了逻辑单元延迟如何随工艺角变化；图2-23（b）展示了逻辑单元延迟如何随电源电压变化；图2-23（c）展示了逻辑单元延迟如何随温度变化。因此，为静态时序分析选择特定的工作条件是非常重要的。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d28be4c789c1e86d5aaf8ed2984b7c86_720w.jpg" alt="图2-23"></p>
<p>为STA选择合适的工作条件还需要考虑到可用的单元库（cell library），3种标准的工作条件如下所示：</p>
<p>（1）<strong>WCS</strong>（Worst-Case Slow）：工艺慢（slow）、温度最高（例如125°C）并且电压最低（例如额定1.2V减去10％）。对于使用低电源的纳米技术，可能还有另一个最坏的情况：工艺慢、电压最低并且温度也最低。低温下的延迟并不总是小于高温下的延迟，这是因为对于纳米技术而言，相对于电源的器件阈值电压（Vt）裕度降低了。在这种低电源的情况下，负载较小的逻辑单元的延迟在低温下要高于在高温下的延迟。 对于高Vt（较高阈值，较大延迟）甚至是标准Vt（常规阈值，较低延迟）的单元，情况尤其如此。在较低温度下延迟增加的这种异常行为称为温度反转（temperature inversion），参见图2-23（c）。</p>
<p>（2）<strong>TYP</strong>（Typical）：典型（typical）工艺，温度是额定值（例如25°C），电压是额定值（例如1.2V）。</p>
<p>（3）<strong>BCF</strong>（Best-Case Fast）：工艺快（fast），温度最低（例如-40°C），电压最高（例如额定1.2V加10％）。</p>
<p>功耗分析（power analysis）的工作条件通常不同于静态时序分析所使用的工作条件。 对于功耗分析，工作条件可能是：</p>
<p>（1）<strong>ML</strong>（Maximal Leakage）：工艺快，温度最高（例如125°C），电压也最高（例如1.2V加10％）。该工作条件有最大的漏电功耗（leakage power），对于大多数设计，也有着最大的有效功耗（active power）。</p>
<p>（2）<strong>TL</strong>（Typical Leakage）：经典工艺，温度最高（例如125°C），电压是额定值（例如1.2V）。该工作条件下的漏电功耗比较具有代表性，因为由于正常工作时的功耗，芯片温度往往会更高。</p>
<p>静态时序分析基于的是设计人员所加载（load）和链接（link）的库，可以使用<strong>set_operating_conditions</strong>命令明确指定设计的工作条件。</p>
<p><strong>set_operating_conditions</strong> “WCCOM” -library mychip</p>
<p>上述命令使用了在单元库mychip中定义的名为WCCOM的工作条件。</p>
<p>单元库可在各种工作条件下使用，选择何种工作条件进行分析取决于为STA加载的单元库。</p>
<h1 id="标准单元库">标准单元库</h1>
<blockquote>
<p>本章节介绍库（library）里单元描述中所提供的时序信息。单元可以是标准单元、IO缓冲器或者是如USB内核这样的复杂IP。</p>
</blockquote>
<p>●除时序信息外，库单元描述中还包含一些其它属性，例如单元面积和功能，这些属性与时序无关，但在RTL综合（synthesis）过程中会用到。在本章节中，我们仅关注与时序和功耗计算有关的那些属性。</p>
<p>●可以使用各种标准格式来描述库单元，各种格式的内容基本相似，本书中使用<strong>Liberty</strong>语法描述库单元。</p>
<p>●本章节的前面部分介绍了线性和非线性时序模型，随后介绍了用于纳米技术的高级时序模型，这些将在3.7节中进行介绍。</p>
<h2 id="引脚电容">引脚电容</h2>
<p>单元的每个输入和输出都可以在引脚（pin）上指定电容。在大多数情况下，仅为单元输入引脚指定电容，而不为输出引脚指定电容，即大多数单元库中的输出引脚电容为0。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bfe979da5008b8fa29d9479e725dab45_720w.jpg"></p>
<p>上面的示例展示了输入INP1引脚电容值的一般规格（specification）。在最基本的格式中，引脚电容被指定为单个值（在上面的示例中为0.5个单位）。电容单位通常为皮法拉（pF），一般在库文件的开头指定。单元描述中还可以为<strong>rise_capacitance</strong>（0.5个单位）和<strong>fall_capacitance</strong>（0.45个单位）分别指定值，这些值是指引脚INP1上发生电平上升和下降跳变时的值。也可以将<strong>rise_capacitance</strong>和<strong>fall_capacitance</strong>的值指定为范围，并在描述中指定下限值和上限值。</p>
<h2 id="时序模型">时序模型</h2>
<p>逻辑单元的时序模型（timing model）旨在为设计中的各种单元实例（instance）提供准确的时序信息。通常会从单元的详细电路仿真中获得时序模型，用以对单元工作时的实际情况进行建模，且需要为逻辑单元的每个时序弧都建立一个时序模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-92ec460c49e3f987d1c0d9c9881886f2_720w.jpg" alt="图3-1"></p>
<p>让我们首先考虑图3-1中所示的反向器（inverter）的时序弧。 由于这是一个反相器，因此输入端的电平上升（下降）跳变会导致输出端的电平下降（上升）跳变。表征这个反相器的两种延迟是：</p>
<p>●Tr：输出上升沿延迟</p>
<p>●Tf：输出下降沿延迟</p>
<p>注意，延迟是根据单元库中定义的阈值（threshold）点（详见2.4节）测量的，通常为50％Vdd。 因此，延迟值是指从输入经过其阈值点到输出经过其阈值点的延迟。</p>
<p>通过反相器的时序弧的延迟取决于两个因素：</p>
<p>1.输出负载，即反相器输出引脚上的电容负载</p>
<p>2.输入信号的过渡（transition）时间</p>
<p>延迟值与负载电容有直接关系：负载电容越大，延迟越大。在大多数情况下，延迟会随着输入信号过渡时间的增加而增加。而在某些情况下，输入信号阈值点（用于测量延迟）与单元的内部开关点（switching point）明显不同。在这种情况下，通过单元的延迟可能相对于输入信号过渡时间表现出非单调行为：较大的输入信号过渡时间可能会产生较小的延迟，尤其是在输出负载较小的情况下。</p>
<p>逻辑单元输出引脚的压摆（slew）主要取决于输出引脚电容：输出信号过渡时间会随着输出负载的增加而增加。 因此，在输入端压摆较大（输入信号过渡时间较长）的情况下，选择合适的单元类型及输出负载，可以改善输出端的压摆。图3-2展示了通过调节逻辑单元的输出负载，可以改善或恶化单元输出信号过渡时间的情况。</p>
<p><img src="https://pic1.zhimg.com/80/v2-9e1c81985e7f89b97b2fb9bc8196b4b0_720w.jpg" alt="图3-2"></p>
<h2 id="线性时序模型">线性时序模型</h2>
<p>一个简单的时序模型是线性延迟模型（linear delay model），该模型使用含两个参数的线性函数表示逻辑单元的延迟和输出过渡时间，这两个参数是：输入过渡时间（input transition time）和输出负载电容（output load capacitance）。通过逻辑单元的延迟（D）使用线性模型的一般形式如下所示：</p>
<p>D = D0 + D1 * S + D2 * C</p>
<p>其中D0，D1，D2是常数，S是输入过渡时间，C是输出负载电容。 对于亚微米（submicron）技术，线性延迟模型在输入过渡时间和输出负载电容的范围内并不准确，因此，目前大多数单元库都使用更复杂的模型，例如非线性延迟模型（non-linear delay model）。</p>
<h2 id="非线性延迟模型">非线性延迟模型</h2>
<p>大多数单元库都包括表格模型（table model），用于为单元的各种时序弧指定延迟并进行时序检查。一些用于纳米技术的较新的时序库还提供了基于电流源的高级时序模型（例如CCS，ECSM等），本章稍后将对此进行介绍。 这些表格模型被称为<strong>NLDM</strong>（<strong>N</strong>on-<strong>L</strong>inear <strong>D</strong>elay <strong>M</strong>odel），可用于延迟、输出压摆计算或其他时序检查。表格模型中提供了：在单元输入引脚处输入过渡时间和输出引脚处输出负载电容的各种组合下通过单元的延迟。</p>
<p>NLDM模型以二维形式表示，两个独立变量是输入过渡时间和输出负载电容，表中的数值表示延迟。以下是一个典型反相器单元的表格模型示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-bd81fd2c0d2137a52819c239173c5dc7_720w.jpg"></p>
<p>上面的示例描述了输出引脚OUT的延迟信息。单元描述里的这个部分包含了从引脚INP1到引脚OUT时序弧的上升和下降延迟模型，以及引脚OUT的<strong>max_transition</strong>允许时间。上升和下降延迟有单独的模型（用于输出引脚），分别标记为<strong>cell_rise</strong>和<strong>cell_fall</strong>。索引（index）变量的类型和顺序在以下查找表模板<strong>delay_template_3x3</strong>中进行了描述：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2c764e7c9d70c8c4f7e9c928babc4b36_720w.jpg"></p>
<p>该查找表模板指定了表中的第一个变量是输入过渡时间，第二个变量是输出负载电容。表中数值的给定类似于嵌套循环，其中第一个索引（index_1）为外部循环变量，第二个索引（index_2）为内部循环变量，依此类推。在上面的示例中每个变量都有三个可能值（条目），因此它对应于一个3×3的表。在大多数情况下，表的条目也可按照表的格式设置，然后可以将第一个索引（index_1）视为行索引，而第二个索引（index_2）则等同于列索引。索引值（例如1000）是伪占位符，它们会被<strong>cell_fall</strong>和<strong>cell_rise</strong>延迟表中的实际索引值覆盖。指定索引值的另一种方法是在模板定义中指定索引值，而不是在<strong>cell_rise</strong>和<strong>cell_fall</strong>表中指定索引值，例如以下示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-24c6c3d6821889875c433a68f195fcd1_720w.jpg"></p>
<p>根据延迟表，输入下降过渡时间为0.3ns且输出负载为0.16pf时，反相器的上升延迟为0.1018ns。 由于输入的下降沿跳变导致反相器输出的上升沿跳变，因此当输入引脚发生下降沿跳变时，应该去查询<strong>cell_rise</strong>延迟表。</p>
<p>将表格中的延迟值表示为输入过渡时间和输出负载电容这两个变量的函数的这种形式称为非线性延迟模型，因为在这些表格中可以看到延迟随输入过渡时间和输出负载电容的非线性变化。</p>
<p>注意，表格模型也可以是3维的，例如一个具有互补输出Q和QN的触发器，这将在3.8节中进行介绍。</p>
<p>NLDM模型不仅可以用于计算延迟，而且还可用于计算逻辑单元输出引脚的过渡时间，该时间同样由输入过渡时间和输出负载电容来表征。因此，还存在着另外一张独立的用于计算单元的输出上升和下降过渡时间的二维表格。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a427e79d1b2ca16e74e8a845e3c8d82e_720w.jpg"></p>
<p>输出过渡时间也同样有两张表：<strong>rise_transition</strong>和<strong>fall_transition</strong>。如第2章所述，过渡时间是根据特定的压摆阈值点（通常为电源的10％-90％）测量的。</p>
<p>综上所述，使用NLDM模型的反相器单元具有下列表格模型：</p>
<p>● 上升延迟时间（Rise delay）</p>
<p>● 下降延迟时间（Fall delay）</p>
<p>● 上升过渡时间（Rise transition）</p>
<p>●下降过渡时间（Fall transition）</p>
<p>假设有这么一个反相器单元，其输入过渡时间和输出负载电容如图3-3所示。对于15ps的输入（下降）过渡时间和10fF负载，可从<strong>cell_rise</strong>表中获得输出上升延迟时间，而从<strong>cell_fall</strong>表中可获得20ps输入（上升）过渡时间和10fF负载下的输出下降延迟时间 。</p>
<p><img src="https://pic3.zhimg.com/80/v2-79845496ae9d2d5f568e2b7b2842fe3e_720w.jpg" alt="图3-3"></p>
<p>指定单元逻辑功能为“反相”（invert）的信息在哪里呢？该信息可以在时序弧里的<strong>timing_sense</strong>字段中找到，但在某些情况下如果该字段中未指明，则应该也可从引脚功能（pin function）中推断出。</p>
<p>例如对于反相器单元，时序弧为<strong>negative_unate</strong>，这表明输出引脚电平跳变方向与输入引脚电平跳变方向相反。因此，在<strong>cell_rise</strong>表中进行查找时使用的参数是输入引脚的下降过渡时间。</p>
<h3 id="查找非线性延迟模型">查找非线性延迟模型</h3>
<p>这个小节通过一个例子来说明表格模型的查找。如果输入过渡时间和输出电容正好与表格条目中的值相对应，则表格查找是很简单的，因为可以直接从表中对应的位置读出时序值。以下示例对应于一般情况，即输入过渡时间和输出电容无法与表格条目中的值对应的情况。在这种情况下，可利用二维插值的方法来得到最终的时序值，一般选择每个维度中两个最接近的表格条目中的值以进行表格插值。考虑输入过渡时间为0.15ns、输出电容为1.16pF的输出下降沿查找表（前文的示例）， 下面复制了与二维插值有关的输出下降过渡表的相应部分。</p>
<p><img src="https://pic4.zhimg.com/80/v2-1093cb4698092f7e3ae1403cc4462a63_720w.jpg"></p>
<p>在下面的公式中，两个index_1值分别表示为x1和x2；两个index_2值分别表示为y1和y2，而对应的表值分别表示为T11，T12，T21和T22。</p>
<p>如果需要在表中查找（x0，y0）的值，则查找值T00只能通过插值获得，计算公式如下：</p>
<p>T00 = X20 * Y20 * T11 + X20 * Y01 * T12 + X01 * Y20 * T21 + X01 * Y01 * T22</p>
<p>其中</p>
<p>X01 = （x0 - x1）/（x2 - x1）</p>
<p>X20 = （x2 - x0） /（x2 - x1）</p>
<p>Y01 = （y0 - y1）/（y2 - y1）</p>
<p>Y20 = （y2 - y0）/（y2 - y1）</p>
<p>将0.15ns代入index_1，将1.16pF代入index_2，根据上述公式可计算出fall_transition值为：</p>
<p>T00 = 0.75 * 0.25 * 0.1937 + 0.75 * 0.75 * 0.7280 + 0.25 * 0.25 * 0.2327 +0.25 * 0.75 * 0.7676 = <strong>0.6043</strong></p>
<p>请注意，上面的等式对于内插和外推均有效，即当索引值（x0，y0）超出范围时依然成立。例如，当index_1索引值为0.05且index_2索引值为1.7时，fall_transition值计算如下：</p>
<p>T00 = 1.25 * （-0.25） * 0.1937 + 1.25 * 1.25 * 0.7280 + （-0.25）<em>（-0.25） </em> 0.2327 + （-0.25） * 1.25 * 0.7676 = <strong>0.8516</strong></p>
<h2 id="阈值规格和压摆降额">阈值规格和压摆降额</h2>
<p>压摆值（slew）基于的是在库中指定的测量阈值点，大多数上一代的库（0.25um或更旧的库）都使用10％和90％作为压摆（或称过渡时间）的测量阈值点。</p>
<p>压摆阈值点的选择对应的是波形的线性部分。随着技术的发展，实际波形最线性的部分通常在30％至70％之间。 因此，大多数新一代时序库都将压摆测量阈值点指定为Vdd的30％和70％。但是，由于之前测得的过渡时间在10％至90％之间，因此在填充库时，通常将测得的30％至70％的过渡时间加倍，这由压摆降额系数（slew derate factor）指定，通常指定为0.5。压摆测量阈值点为30％和70％且压摆降额系数为0.5，等效于测量阈值点为10％和90％。 阈值设置的示例如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-a03731f771bc5ec6aae66aa03b7b36cd_720w.jpg"></p>
<p>上面的设置规定了要将表格中的过渡时间乘以0.5，以获得与阈值（30%-70%）设置相对应的过渡时间。这意味着表格中的值（以及相应的索引值）实际上是10%-90%阈值点的测量值。在标定过渡时间值时，首先在30%-70%处测量，然后再把测量值外推到10％至90％（（70-30）/（90-10）= 0.5）。</p>
<p>以下是压摆测量阈值点设置的另一个例子：</p>
<p><strong>slew_lower_threshold_pct_fall</strong>：20.0；</p>
<p><strong>slew_upper_threshold_pct_fall</strong>：80.0；</p>
<p><strong>slew_lower_threshold_pct_rise</strong>：20.0；</p>
<p><strong>slew_upper_threshold_pct_rise</strong>：80.0；</p>
<p><strong>slew_derate_from_library</strong> not specified</p>
<p>在上述20%-80%压摆阈值设置的例子中，未指定<strong>slew_derate_from_library</strong>（默认值为1.0），这意味着库中的过渡时间不会降额（derate）。表格中的过渡时间值直接对应于20%-80%的阈值点，如图3-4所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-04e19d6eed9852b5787ded76cae208c8_720w.jpg" alt="图3-4"></p>
<p>对上述单元库中压摆阈值设置稍作修改，如下所示：</p>
<p><strong>slew_lower_threshold_pct_fall</strong>：20.0；</p>
<p><strong>slew_upper_threshold_pct_fall</strong>：80.0；</p>
<p><strong>slew_lower_threshold_pct_rise</strong>：20.0；</p>
<p><strong>slew_upper_threshold_pct_rise</strong>：80.0；</p>
<p><strong>slew_derate_from_library</strong>：0.6；</p>
<p>在这种情况下，将<strong>slew_derate_from_library</strong>设置为0.6，并将压摆测量阈值点指定为20％和80％，这意味着库中的过渡时间表里的数据对应于外推到0％至100％（（80-20）/（100-0）= 0.6）的值，如图3-5所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-6201aec540c861cb2684384dfaf9b655_720w.jpg" alt="图3-5"></p>
<p>指定了压摆降额后，计算延迟时使用的压摆值等于：</p>
<p>库中过渡时间值 * 压摆降额系数 （ <strong>library_transition_time_value</strong> * <strong>slew_derate</strong>）</p>
<p>这就是延迟计算工具在内部使用的压摆值，是对应于指定的压摆阈值测量点的。</p>
<h2 id="时序模型-组合逻辑单元">时序模型-组合逻辑单元</h2>
<p>考虑一个两输入与门（and）的时序弧，由前面章节所述可知该单元的两个时序弧均为正单边类型（positive_unate）， 因此，输入引脚的电平上升对应于输出引脚的电平上升，反之亦然。</p>
<p>对于这个两输入与门，共有以下4种延时：</p>
<p>● A -&gt; Z ：输出上升沿延迟（Output rise）</p>
<p>● A -&gt; Z ：输出下降沿延迟（Output fall）</p>
<p>● B -&gt; Z ：输出上升沿延迟（Output rise）</p>
<p>● B -&gt; Z ：输出下降沿延迟（Output fall）</p>
<p><img src="https://pic2.zhimg.com/80/v2-b7e384972d404c2e638bad1e88e116d1_720w.jpg" alt="图3-6"></p>
<p>这意味着对于NLDM模型，将会有四个表格模型用于指定延迟。同样，也将有四个表格模型用于指定输出过渡时间（压摆）。</p>
<h2 id="延迟与压摆模型">延迟与压摆模型</h2>
<p>以下是一个用于分析三输入与非门（nand）单元的输入INP1到输出OUT的时序模型：</p>
<p><img src="https://pic2.zhimg.com/80/v2-57437a41383049fc1e26ba69fc9340f9_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-ae58d746091e358e4b0055e2a2d0f33c_720w.jpg"></p>
<p>在上面的例子中，使用了两个单元延迟表<strong>cell_rise</strong>和<strong>cell_fall</strong>以及两个过渡时间表<strong>rise_transition</strong>和<strong>fall_transition</strong>来描述从INP1到OUT的时序弧的特性，上面的例子中还包括了输出的最大过渡时间（<strong>max_transition</strong>）值。</p>
<p>如章节2.7中所述，与非门单元中的时序弧为负单边类型（negative unate），这表示输出引脚电平跳变方向与输入引脚电平跳变方向是相反的。因此，查找<strong>cell_rise</strong>表对应于输入引脚上的下降过渡时间。同样，通过与门单元或者或门单元的时序弧是正单边类型（positive unate）的，因为输出引脚电平跳变方向与输入引脚电平跳变方向相同。</p>
<h2 id="通用组合逻辑块">通用组合逻辑块</h2>
<p>考虑以下这个具有三输入和两输出的通用组合逻辑块（General Combinational Block）：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3590ac2df0450e06a20faec62fa0eafb_720w.jpg" alt="图3-7"></p>
<p>像这样的组合逻辑块可以具有多个时序弧。通常，从块的每个输入到每个输出都有一条时序弧。如果从输入到输出的逻辑路径是同相（non-inverting）或正单边类型的，则输出的极性（polarity）与输入的极性相同；如果逻辑路径是反相（inverting）或负单边类型，则输出的极性与输入相反，即当输入电平上升时，输出电平将下降。这些时序弧代表了通过这个组合逻辑块的传播延迟。</p>
<p>通过组合逻辑单元的某些时序弧可以既是正单边类型，也是负单边类型的。一个例子是通过两输入异或门（xor）单元的时序弧，根据该单元的另一个输入的逻辑状态，两输入异或门单元的输入引脚处的电平跳变会导致输出引脚处的电平沿相同或相反的方向跳变。这些时序弧可以描述为非单边类型（non-unate）的，也可以描述为两组状态相关（state-dependent）的正单边类型时序模型和负单边类型时序模型。这种与状态相关的表格模型将在3.5节中有更详细的描述。</p>
<h2 id="时序模型-时序逻辑单元">时序模型-时序逻辑单元</h2>
<p>考虑如下图3-8所示的时序逻辑单元的时序弧：</p>
<p><img src="https://pic1.zhimg.com/80/v2-feda51c573c3b9fbb7a7b60a11698ec0_720w.jpg" alt="图3-8"></p>
<p>对于同步（synchronous）输入，例如引脚D（或SI，SE），存在以下时序弧：</p>
<p>● 建立（Setup）时间检查时序弧（包括上升沿和下降沿）</p>
<p>● 保持（Hold）时间检查时序弧（包括上升沿和下降沿）</p>
<p>对于异步（asynchronous）输入，例如引脚CDN，存在以下时序弧：</p>
<p>● 恢复（Recovery）时间检查时序弧</p>
<p>● 撤销（Removal）时间检查时序弧</p>
<p>对于触发器的同步输出，例如引脚Q或QN，存在以下时序弧：</p>
<p>● 时钟引脚（CK）到输出端口（Q或QN）的传播延迟时序弧（包括上升沿和下降沿）</p>
<p>所有同步时序弧均相对于时钟的有效沿（active edge），即时序逻辑单元捕获数据的时钟沿。此外，时钟引脚和异步引脚（如复位引脚）还需要进行脉冲宽度（pulse width）时序检查。各种时序检查如下图3-9所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ae751dbf5fe8b0c72e3a51557efb9ddb_720w.jpg" alt="图3-9"></p>
<h2 id="同步时序检查建立时间与保持时间">同步时序检查：建立时间与保持时间</h2>
<p>需要进行建立时间和保持时间的同步时序检查，才能确保数据能够正确通过时序单元传播。这些时序检查可验证输入的数据在时钟有效沿上是否为确定的逻辑状态，并且在有效沿上将正确的数据锁存下来。这些时序检查也可以验证输入的数据在有效时钟沿附近是否稳定：输入的数据必须在有效时钟沿之前保持稳定的最短时间称为建立时间（setup time）。这是根据最晚的（the latest）数据信号超过其阈值（通常为Vdd的50％）到有效时钟沿超过其阈值（通常为Vdd的50％）的时间间隔测量的。同样，保持时间（hold time）是在时钟有效沿之后输入的数据必须保持稳定的最短时间，这也是根据有效时钟沿超过其阈值到最早的（the earliest）数据信号超过其阈值的时间间隔来度量的。如前文所述，时序单元的时钟有效沿是指使时序单元捕获数据的上升沿或下降沿。</p>
<h3 id="建立时间与保持时间检查示例">建立时间与保持时间检查示例</h3>
<p>时序单元同步引脚的建立时间和保持时间约束通常用二维表格来描述，如下所示。下面的例子展示了触发器数据引脚的建立时间和保持时间时序信息：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f3ab4089bd83356a2d9efa1c9a5ee7f0_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-e01adbc8438267b688ab92ef53840fc5_720w.jpg"></p>
<p>上面的例子展示了相对于时序单元时钟引脚CK的上升沿，在输入引脚D上的建立时间和保持时间约束。二维表格模型是根据约束引脚<strong>constrained_pin</strong>（D）和相关引脚<strong>related_pin</strong>（CK）处的过渡时间确定的，二维表格的查找是基于库中描述的模板<strong>setuphold_template_3x3</strong>的。对于上述示例，查找表模板<strong>setuphold_template_3x3</strong>如下所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9252346fb3247e556d14f0ec04cbb1ad_720w.jpg"></p>
<p>与前面示例中一样，表中的值如嵌套循环一样被指定，其中第一个索引<strong>index_1</strong>是外部循环变量，第二个索引<strong>index_2</strong>是内部循环变量， 以此类推。因此，当D引脚的上升沿过渡时间为0.4ns，CK引脚的上升沿过渡时间为0.84ns时，D引脚上升沿的建立时间约束为0.112ns，该值是从<strong>rise_constraint</strong>表中读取的。对于D引脚的下降沿，建立时间约束将检查建立时间表中的<strong>fall_constraint</strong>表。在表中查找过渡时间不与索引值相对应的建立时间和保持时间约束时，可使用章节3.2中所描述的非线性模型查找的一般过程。</p>
<p>请注意，建立时间约束的<strong>rise_constraint</strong>和<strong>fall_constraint</strong>表是指<strong>constrained_pin</strong>。所用的时钟过渡时间由<strong>Timing_type</strong>决定，它会指定该时序逻辑单元是上升沿触发还是下降沿触发。</p>
<h3 id="建立时间和保持时间检查里的负值">建立时间和保持时间检查里的负值</h3>
<p>请注意，上面示例中的某些保持时间值是负数。这是可以接受的，这种情况通常发生在触发器的引脚到数据内部锁存点的路径长于相应的时钟路径时。因此，负的保持时间检查意味着触发器的数据引脚可以在时钟引脚之前改变，并且仍然满足保持时间的检查要求。</p>
<p>触发器的建立时间值也可以为负。这意味着触发器的数据引脚可以在时钟引脚之后改变，并且仍然满足建立时间的检查要求。</p>
<p>建立时间和保持时间可以都为负吗？不行！为使建立时间和保持时间检查相一致，建立时间和保持时间的数值总和应为正。因此，如果建立（或保持）时间检查包含负值，则相应的保持（或建立）时间检查应为正值，且足够大，以使建立时间加上保持时间之和是一个正数。 具有负的保持时间值的示例如图3-10所示，由于建立时间检查会先于保持时间检查，所以此时的建立时间加上保持时间显然是一个正数。建立时间加上保持时间即为要求数据信号稳定的区域的宽度。</p>
<p><img src="https://pic2.zhimg.com/80/v2-88af4f833194fbfe2f837bddbfc435c5_720w.jpg" alt="图3-10"></p>
<p>对于触发器，在扫描数据（scan data）输入引脚上设置一个负的保持时间会很有帮助，这样可以给予时钟偏斜（clock skew）一定的灵活性，并且可以消除当扫描模式（scan mode）下保持时间发生违例时插入缓冲器（buffer）的需要（扫描模式是将触发器串联在一起形成一条扫描链的模式，触发器的输出通常连接到串联的下一个触发器的扫描数据输入引脚，这些连接是用于芯片测试的）。</p>
<p>与同步数据输入引脚上的建立时间或保持时间检查类似，对异步引脚进行的时序约束检查将在下个小节中介绍。</p>
<h2 id="异步时序检查">异步时序检查</h2>
<h3 id="恢复时间和撤销时间检查">恢复时间和撤销时间检查</h3>
<p>诸如异步复位（clear）或异步置位（set）之类的异步引脚会覆盖单元的任何同步行为。当异步引脚处于有效（active）状态时，输出将由异步引脚控制，而不是由时钟锁存到的输入数据控制。但是，当异步引脚变为无效（inactive）状态时，时钟的有效边沿将开始锁存输入的数据。异步恢复（recovery）时间和撤销（removal）时间约束检查将验证异步引脚在下一个时钟有效沿处是否已明确返回到了无效状态。</p>
<p>恢复时间是指异步输入被置为无效（de-asserted）后在下一个时钟有效沿之前需要保持稳定的最短时间。</p>
<p>同样，撤销时间是指在一个有效的时钟沿之后，异步引脚必须保持有效状态的最小时间，即在有效时钟沿之后必须经过一段撤销时间才能够将异步引脚置为无效状态。</p>
<p>异步恢复时间和撤销时间检查将分别在8.6节和8.7节中介绍。</p>
<h3 id="脉冲宽度检查">脉冲宽度检查</h3>
<p>除了同步和异步时序检查外，还有一项检查去确保逻辑单元输入引脚上的脉冲宽度满足最低要求。例如，如果时钟引脚上的脉冲宽度小于指定的最小值，则时钟可能无法正确锁存数据。也可以为相关的同步和异步引脚指定脉冲宽度检查（pulse width check），并且可以为高脉冲和低脉冲分别指定最小脉冲宽度检查。</p>
<h3 id="恢复时间撤销时间和脉冲宽度检查示例">恢复时间、撤销时间和脉冲宽度检查示例</h3>
<p>下面给出了触发器的异步清零引脚CDN的恢复时间、撤销时间和脉冲宽度检查的示例，其中恢复时间和撤销时间检查还与时钟引脚CK有关。由于恢复时间和撤销时间检查是针对异步引脚被置为无效的时刻，因此在以下示例中仅存在上升约束。CDN引脚的最小脉冲宽度检查用于低脉冲，这是由于CDN引脚为低电平有效，因此该引脚上的高脉冲宽度没有限制，因此未指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2df189618e0c05f97af14139388ef635_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-9ad4d96787ee12ed3578a63b0244f52e_720w.jpg"></p>
<h2 id="传播延迟">传播延迟</h2>
<p>时序单元的传播延迟（propagation delay）是指从时钟的有效沿到输出的上升沿或下降沿。以下是一个时钟下降沿触发的触发器从时钟引脚CKN到输出Q的传播延迟弧的示例。这是一个非单边类型（non-unate）的时序弧，因为时钟的有效沿会导致输出引脚Q的电平上升或下降。</p>
<p><img src="https://pic3.zhimg.com/80/v2-11b60b0df2cb98d100099ae22c7ba932_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5ffb5dbaf08b73c0aba3c1222e99b55c_720w.jpg"></p>
<p>与前一章中的示例一样，输出的传播延迟会根据输入过渡时间和输出负载电容以二维表格的形式呈现。但是在此示例中，由于触发器是时钟下降沿触发的，因此要使用的输入过渡时间是CKN引脚的下降过渡时间，这在上面的示例中可以从<strong>Timing_type</strong>字段中看出，上升沿触发的触发器将把<strong>rising_edge</strong>指定为其<strong>timing_type</strong>。</p>
<p><img src="https://pic1.zhimg.com/80/v2-cf68c50e7470a318f227864cd534afe4_720w.jpg"></p>
<h2 id="状态相关的时序模型">状态相关的时序模型</h2>
<p>在许多组合逻辑模块中，输入和输出之间的时序弧取决于模块中其他引脚的逻辑状态。输入和输出引脚之间的这些时序弧可以是正单边类型时序弧、负单边类型时序弧也可以既是正单边类型又是负单边类型时序弧。异或门（xor）以及同或门（xnor）单元就是一个例子，其输入到输出的时序弧可以是正单边类型的也可以是负单边类型的。 在这种情况下，其时序行为可能会有所不同，具体取决于该模块其他输入的状态。通常，取决于引脚状态的多个时序模型被称为状态相关的时序模型（state-dependent models）。</p>
<p>考虑一个两输入异或门单元的例子。当另一个输入A2为逻辑0时，从输入A1到输出Z的时序路径为正单边类型；当输入A2为逻辑1时，从A1到Z的路径为负单边类型。这两个时序模型是使用状态相关的时序模型指定的。A2为逻辑0时从A1到Z的时序模型如下所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d24ac9080f54ed69fec3f5a26321715_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e63bc07d8d6b568fda8e53ce45028fc3_720w.jpg"></p>
<p>使用<strong>when</strong>来指定与状态有关的条件。虽然以上单元模型的片段仅说明了<strong>cell_rise</strong>延迟，但其它时序模型（<strong>cell_fall</strong>，<strong>rise_transition</strong>和<strong>fall_transition</strong>）也指定了相同的<strong>when</strong>条件。当<strong>when</strong>中条件改变，如改为A2为逻辑1这个条件时，会指定另一个独立的时序模型：</p>
<p><img src="https://pic3.zhimg.com/80/v2-ee5f3576374dbc54c303957b78ea5d2e_720w.jpg"></p>
<p><strong>sdf_cond</strong>用于指定生成<strong>SDF</strong>文件时要使用的时序弧的条件，详情参见后面3.9节中的示例。</p>
<p>状态相关的时序模型可用于各种类型的时序弧，许多时序逻辑单元会使用状态相关的时序模型指定建立时间或保持时间的时序约束。以下是使用状态相关的时序模型进行保持时间约束的扫描触发器（scan flip-flop）的一个示例。在这种情况下，指定了两组时序模型：扫描使能引脚SE处于有效状态时的一组，以及扫描使能引脚处于无效状态时的另一组。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ad2b03435ddc02178c4fb6cbadaa6000_720w.jpg"></p>
<p>当扫描使能引脚SE为逻辑0时使用以上时序模型，当<strong>when</strong>中条件为SE是高电平时也有类似的时序模型。</p>
<p>可以既使用状态相关的时序模型又使用非状态相关的时序模型来指定一些时序关系。在这种情况下，如果单元的状态是已知的并且这个状态包含在状态相关的时序模型之一中，则时序分析将使用状态相关的时序模型。而如果状态相关的时序模型未包含单元的这个状态，则使用来自非状态相关模型的时序。例如考虑一种情况，保持时间约束仅由当<strong>when</strong>条件为SE处于逻辑0时来指定，而没有为SE处于逻辑1时指定单独的状态相关模型。在这种情况下，如果SE被置为逻辑1，则将会使用非状态相关时序模型的保持时间约束。而如果没有用于保持时间约束的非状态相关时序模型，那么将没有任何有效的保持时间约束！</p>
<p>可以为时序库中的任何属性指定状态相关的模型，因此可以存在功率、漏电功率、过渡时间、上升和下降延迟、时序约束等状态相关的模型。下面给出了一个状态相关的漏电功率模型示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-8d7f8a0a2fe00153136c3913943ba740_720w.jpg"></p>
<h2 id="黑盒的接口时序模型">黑盒的接口时序模型</h2>
<p>本节将介绍黑盒（任意模块或块）的IO接口时序弧，时序模型将捕获黑盒（black box）IO接口（interface）的时序。黑盒的接口时序模型可以具有组合逻辑弧，也可以有时序逻辑弧。通常，这些时序弧也可能取决于状态。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f9b5cc6b7c255cc3188c5098f38b878e_720w.jpg" alt="图3-11"></p>
<p>对于如图3-11所示的例子，可以将时序弧分为以下几类：</p>
<p>● 输入到输出的组合逻辑弧：这对应于直接从输入到输出的组合逻辑路径，例如从输入端口FIN到输出端口FOUT。</p>
<p>● 输入时序逻辑弧：这对应于连接到触发器D引脚的输入端口的建立时间或保持时间。通常，在将模块的输入端口连接到触发器的D引脚之前，可以存在一些组合逻辑。这样的一个例子是在输入端口DIN上相对于时钟端口ACLK的建立时间检查。</p>
<p>● 输出时序逻辑弧：这类似于触发器时钟端到输出端Q的传播延迟。通常，触发器输出引脚与模块输出端口之间可以存在一些组合逻辑。一个示例是从时钟BCLK到触发器UFF1的输出引脚再到输出端口DOUT的路径。</p>
<p>● 异步输入时序弧：这类似于触发器异步输入引脚的恢复时间和撤销时间时序约束，例如输入端口ARST到触发器UFF0的异步清零引脚。</p>
<p>除上述时序弧外，在黑盒的外部时钟引脚上还可以进行脉冲宽度检查。还可以定义内部节点（node）并在这些内部节点上定义衍生时钟（generated clock），从而指定在这些节点之间的时序弧。总之，黑盒模型可以具有以下时序弧：</p>
<p>● 纯组合逻辑路径的输入到输出时序弧（Input to output timing arcs）</p>
<p>● 从同步输入端口到相关时钟端口的建立时间和保持时间时序弧（Setup and hold timing arcs）</p>
<p>● 从异步输入端口到相关时钟端口的恢复时间和撤销时间时序弧（Recovery and removal timing arcs）</p>
<p>● 从时钟端口到输出端口的输出传播延迟（Output propagation delay）</p>
<p>如上所述的接口时序模型并非旨在捕获黑盒的内部时序，而只是捕获其接口上的时序。</p>
<h2 id="高级时序建模">高级时序建模</h2>
<p>非线性延迟模型（NLDM）这类的时序模型是基于输出负载电容和输入过渡时间来表示通过时序弧的延迟的。实际上，单元输出的负载不仅包括电容还应当包括互连电阻（interconnect resistance）。由于NLDM方法假设输出负载为纯电容，因此互连电阻成为了一个问题。即使互连电阻不为零，但当互连电阻的影响较小时，仍使用了这些NLDM模型。在互连电阻存在的情况下，延迟的计算方法通过在单元的输出端获得等效的有效电容（effective capacitance）来改进NLDM模型。延迟计算工具中使用的“有效”电容法获得的等效电容可保证单元输出延迟与具有RC互连的单元输出延迟相同。有效电容法将在5.2节里的延迟计算部分再详细介绍。</p>
<p>随着特征尺寸的缩小，由于波形变得高度非线性，互连电阻的影响会导致较大的误差，各种建模方法为单元的输出驱动能力提供了更高的精度。通常，这些方法通过用等效电流源对驱动器（driver）的输出级进行建模来获得更高的精度。例如<strong>CCS</strong>（<strong>C</strong>omposite <strong>C</strong>urrent <strong>S</strong>ource）复合电流源或<strong>ECSM</strong>（<strong>E</strong>ffective <strong>C</strong>urrent <strong>S</strong>ource <strong>M</strong>odel）有效电流源模型：<strong>CCS</strong>时序模型通过使用随时间变化且依赖电压的电流源，为建模单元输出驱动能力提供了更高的精度。通过为不同情况下的接收引脚电容（receiver pin capacitance）和输出充电电流（output charging currents）指定详细时序模型，可以提供时序信息。接下来描述<strong>CCS</strong>模型的细节。</p>
<h2 id="接收引脚电容">接收引脚电容</h2>
<p>接收引脚电容对应于NLDM模型中指定的输入引脚电容（input pin capacitance）。与NLDM模型的输入引脚电容不同，CCS模型允许在过渡波形的不同部分分别指定接收引脚电容。由于互连RC和由单元内部输入设备的米勒效应（Miller effect）所引起的等效输入非线性电容，接收引脚电容值会在过渡波形的不同点处发生变化。因此，该电容值在波形的初始部分（leading portion）与在波形的后续部分（trailing portion）的建模是不同的。</p>
<p>接收电容可以在引脚级别（pin level）上指定（如NLDM模型），通过该引脚的所有时序弧都使用该电容值；或者，接收电容可以在时序弧（timing arc level）级别上指定，在这种情况下可以为不同的时序弧指定不同的电容模型。接下来将介绍这两种指定接收引脚电容的方法。</p>
<h3 id="在引脚级别指定电容">在引脚级别指定电容</h3>
<p>当在引脚级别指定电容时，接收引脚电容的一维表格示例如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-9f14ee6e9286aaca528d78ef4770a82c_720w.jpg"></p>
<p><strong>index_1</strong>指定了此引脚输入过渡时间的索引值，一维表格<strong>values</strong>为波形的初始部分指定了输入引脚上用于上升沿波形的接收电容。</p>
<p>与上面示例中的<strong>receiver_capacitance1_rise</strong>表格类似，<strong>receiver_capacitance2_rise</strong>表格为波形的后续部分指定了输入引脚上用于上升沿波形的接收电容。而下降电容（用于下降沿输入波形的引脚电容）分别由表格<strong>receiver_capacitance1_fall</strong>和<strong>receiver_capacitance2_fall</strong>指定。</p>
<h3 id="在时序弧级别指定电容">在时序弧级别指定电容</h3>
<p>接收引脚电容值也可以在时序弧级别上，根据输入过渡时间和输出负载以二维表格的形式来指定。以下给出了在时序弧级别指定电容的示例。本示例指定了输入引脚IN上波形初始部分的接收引脚上升电容，该电容取决于输入引脚IN上的过渡时间和输出引脚OUT上的负载。</p>
<p><img src="https://pic3.zhimg.com/80/v2-25a47e9f7d7ed1b80ecf5b0249da2a12_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-0593657515051dfbbd2d6abd42c55979_720w.jpg"></p>
<p>上面的示例指定了<strong>receiver_capacitance1_rise</strong>的模型，库中也包含有关<strong>receiver_capacitance2_rise</strong>、<strong>receiver_capacitance1_fall</strong>和<strong>receiver_capacitance2_fall</strong>的类似定义。</p>
<p>下表总结了四种不同类型的接收电容类型。如上所述，可以在引脚级别将它们指定为一维表格，或在时序弧级别将它们指定为二维表格。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e1c7488114abed0408ac8b8dafae744f_720w.jpg"></p>
<h2 id="输出电流">输出电流</h2>
<p>在CCS模型中，非线性时序表现为输出电流。输出电流信息被指定为一个查找表，该表的查找取决于输入过渡时间和输出负载。</p>
<p>输出电流会根据输入过渡时间和输出负载电容的不同组合被指定，对于每一个组合，都将分别指定一个输出电流波形。本质上，此处的波形指的是随时间变化的输出电流值。以下示例使用<strong>output_current_fall</strong>指定了用于下降输出波形的输出电流：</p>
<p><img src="https://pic1.zhimg.com/80/v2-57b07262faf6814cf72ee0bf265e8fec_720w.jpg"></p>
<p><strong>reference_time</strong>是指输入波形超过延迟阈值的时间，<strong>index_1</strong>和<strong>index_2</strong>是指输入过渡时间和所使用的输出负载电容，而<strong>index_3</strong>是时间。<strong>index_1</strong>和<strong>index_2</strong>（输入过渡时间和输出负载电容）只能有一个值，<strong>index_3</strong>是指时间值，表值是指相应的输出电流。因此，对于给定的输入过渡时间和输出负载，输出电流波形是时间的函数。同样，还指定了用于输入过渡时间和输出电容的其他组合的查找表。</p>
<p>类似地可以使用<strong>output_current_rise</strong>去指定上升输出波形的输出电流。</p>
<h2 id="串扰噪声分析模型">串扰噪声分析模型</h2>
<p>本节介绍用于串扰噪声（或毛刺）分析的CCS模型，又被称为<strong>CCSN</strong>（<strong>CCS</strong> <strong>N</strong>oise）模型。CCS噪声模型是结构（structural）模型，并针对单元内的不同沟道连接块-CCB（Channel Connected Blocks）表示。</p>
<p>什么是CCB？ CCB是指单元的源极（source）-漏极（drain）的沟道（channel）连接部分。例如，单级（single stage）单元（例如反相器、与非门和或非门单元）仅包含一个CCB，即整个单元仅通过一个沟道连接区域进行连接，而多级单元（例如与门和或门单元）包含多个CCB。</p>
<p>通常仅为由单元输入驱动的第一个CCB和驱动单元输出的最后一个CCB指定CCSN模型，并且会使用稳态电流、输出电压和传播噪声模型来指定这些CCSN模型。</p>
<p>对于单级组合逻辑单元（例如与非门和或非门单元），将为每个时序弧指定CCS噪声模型。 这些单元只有一个CCB，因此模型将会是从单元的输入引脚到输出引脚的。</p>
<p>以下是一个与非门单元的模型示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-54d19f4c7da8ea514c5622d4c9afb273_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-dd2c4fd6ba88110bc706a66c665ea982_720w.jpg"></p>
<p>现在我们描述CCS噪声模型的属性：<strong>ccsn_first_stage</strong>字段表示该模型用于与非门单元的第一级CCB。如前所述，与非门单元只有一个CCB。<strong>is_needed</strong>字段几乎始终为<strong>true</strong>，但天线单元（antenna cell）等非功能性单元除外。<strong>stage_type</strong>字段中的<strong>both</strong>表示该级CCB同时具有上拉（pull-up）和下拉（pull-down）结构。<strong>miller_cap_rise</strong>和<strong>miller_cap_fall</strong>分别代表输出上升和下降过渡时的米勒（Miller）电容值。</p>
<h3 id="直流电流">直流电流</h3>
<p><strong>dc_current</strong>表中为输出引脚上针对输入和输出引脚电压不同组合的的直流电流，其中<strong>index_1</strong>为输入电压，<strong>index_2</strong>为输出电压， 二维表格中的数值为CCB输出处的直流电流。输入电压和输出电流均在库中指定单位（通常为伏特和毫安）。对于从与非门单元的输入引脚IN1到输出引脚OUT的CCS噪声模型示例，当输入电压为-0.9V并且输出电压为0V时，输出端的直流电流为0.42mA。</p>
<h3 id="输出电压">输出电压</h3>
<p><strong>output_voltage_rise</strong>和<strong>output_voltage_fall</strong>表中分别包含CCB输出上升和下降的时序信息。这些表格是CCB输出节点的多维表格，指定了针对不同输入过渡时间和输出电容的上升和下降输出电压。每个表格的<strong>index_1</strong>指定了轨到轨输入过渡时间，<strong>index_2</strong>指定了输出电容，<strong>index_3</strong>指定了输出电压超过特定阈值点的时间（在这种情况下，为0.9V的Vdd电源的30％，70％和90％）。在每个多维表中，电压交叉点（voltage crossing points）是固定的，并且CCB输出节点与电压交叉时的时间值在<strong>index_3</strong>中指定。</p>
<h3 id="噪声传播">噪声传播</h3>
<p><strong>propagated_noise_high</strong>模型和<strong>propagated_noise_low</strong>模型指定的多维表格提供了通过CCB的噪声传播信息。这些模型表征了串扰毛刺（或噪声）从CCB的输入到输出的传播，表征时输入端使用了对称的三角波。噪声传播的多维表被组织为了多个表，这些表指定了CCB输出处的毛刺波形。这些多维表包含：</p>
<p>● 输入毛刺幅值（<strong>index_1</strong>）</p>
<p>● 输入毛刺宽度（<strong>index_2</strong>）</p>
<p>● CCB输出电容（<strong>index_3</strong>）</p>
<p>● 时间（<strong>index_4</strong>）</p>
<p>表格中的数值指定了CCB输出电压（或通过CCB传播的噪声）。</p>
<h3 id="两级单元的噪声模型">两级单元的噪声模型</h3>
<p>与单级单元一样，两级单元（例如与门和或门单元）的CCS噪声模型通常被描述为时序弧的一部分。由于这些单元包含两个单独的CCB，因此需要分别为<strong>ccsn_first_stage</strong>和<strong>ccsn_last_stage</strong>指定噪声模型。例如，对于两输入与门单元，CCS噪声模型由第一级和最后一级相互独立的模型组成，如下所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-3cfba89e2472a20357480a0d3ca0c9ee_720w.jpg"></p>
<p>为IN2引脚指定的<strong>ccsn_last_stage</strong>中的模型与为IN1引脚指定的<strong>ccsn_last_stage</strong>中的模型是相同的。</p>
<h3 id="多级单元和时序单元的噪声模型">多级单元和时序单元的噪声模型</h3>
<p>通常将较为复杂的组合逻辑单元或时序逻辑单元的CCS噪声模型描述为引脚规范（pin specification）的一部分，这与前面在单级或二级单元的CCS噪声模型中以引脚对（pin-pair）为基础，指定为时序弧的一部分是不同的。通常由所有输入引脚的<strong>ccsn_first_stage</strong>模型和所有输出引脚的<strong>ccsn_last_stage</strong>模型描述复杂的多级和时序单元。这些单元的CCS噪声模型不是时序弧的一部分，但通常是为引脚指定的。</p>
<p>如果输入和输出之间的内部路径多达两级CCB，则噪声模型也可以表示为引脚对时序弧的一部分。通常，多级单元中可以将某些CCS噪声模型指定为引脚对时序弧的一部分，而其他一些噪声模型可以通过引脚说明来指定。</p>
<p>下面的示例使用引脚说明以及时序弧的一部分指定了CCS噪声模型：</p>
<p><img src="https://pic4.zhimg.com/80/v2-bf9b86c76e53609f09a41237af6eacab_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8766dda3f943739c2d97776f841df329_720w.jpg"></p>
<p>请注意，上述触发器单元的某些CCS模型是通过引脚定义的。使用输入引脚上的引脚说明定义的指定为<strong>ccsn_first_stage</strong>，而输出引脚QN上的CCS模型指定为<strong>ccsn_last_stage</strong>。另外，两级CCS噪声模型被描述为CDN到Q的时序弧的一部分。因此本示例表明，一个单元可以具有指定为引脚说明一部分和时序弧一部分的CCS模型。</p>
<h2 id="其它噪声模型">其它噪声模型</h2>
<p>除了上述CCS噪声模型之外，某些单元库还提供了其他模型来表征噪声。早在CCS噪声模型出现之前，就已经使用了其中一些模型。如果CCS噪声模型可用，则不需要这些附加模型。为了完整起见，我们在下面介绍一些早期的噪声模型。</p>
<p>直流裕度模型（<strong>Models for DC margin</strong>）：直流裕度是指单元输入引脚允许的最大直流变化（DC variation），它将使单元保持稳定状态，即不会在输出端引起毛刺。例如，低电平输入的直流裕度指的是输入引脚上最大的直流电压值，而不会在输出端引起任何电平跳变。</p>
<p>抗扰度模型（<strong>Models for noise immunity</strong>）：抗扰度模型指定输入引脚可以允许的毛刺幅度（glitch magnitude）。通常以二维表的形式来描述，其中毛刺宽度和输出电容为两个索引量，表中的值对应于输入引脚可以允许的毛刺幅度。这意味着任何小于指定幅度和宽度的毛刺都不会通过单元传播。抗扰度模型还具有不同变形形式，例如：</p>
<p>● <strong>noise_immunity_high</strong></p>
<p>● <strong>noise_immunity_low</strong></p>
<p>● <strong>noise_immunity_above_high</strong></p>
<p>● <strong>noise_immunity_below_low</strong></p>
<h2 id="功耗建模">功耗建模</h2>
<p>单元库中也包含与单元功耗有关的信息，包括有功功率（active power）以及待机（standby）或漏电（leakage）功率。顾名思义，有功功率与设计中的行为有关，而待机功率是待机模式下的功耗，这主要是由于漏电引起的。</p>
<h2 id="有功功率">有功功率</h2>
<p>有功功率与单元输入和输出引脚上的行为有关。单元中的有功功率是由于输出负载的充电以及内部的开关引起的，通常分别称这两个为输出开关功率（output switching power）和内部开关功率（internal switching power）。</p>
<p>输出开关功率与单元类型无关，仅取决于输出负载电容、开关频率和供电电源；内部开关功率取决于单元的类型，因此该值会包含在单元库中，接下来将介绍库中的内部开关功率。</p>
<p>内部开关功率在单元库中被称为<strong>internal power</strong>，这是当单元的输入或输出处于活动状态时单元内部的功耗。对于组合逻辑单元，输入引脚的电平跳变会导致输出引脚的电平跳变，从而导致内部开关功耗。例如，每当输入引脚电平跳变（上升或下降）时，反相器单元就会消耗功率。 库中描述的内部开关功率如下所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-2e501fad0b7e642d40cd3a4bbde8dbc1_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c11d667c7959c0dbe2b6d6e9639009c5_720w.jpg"></p>
<p>上面的示例展示了单元从输入引脚A到输出引脚Z1的功耗，模板中的2x2表是根据引脚A上的输入过渡时间和引脚Z1上的输出电容来确定的。注意，尽管该表包含了输出电容，但表中的值仅对应于内部开关，不包括输出电容的影响。该值表示每个开关转换（上升或下降）时在单元中耗散的内部能量，单位是从库中的其他单位导出的（通常电压以伏特V为单位，电容以皮法拉pF为单位，并且表示为以皮焦耳pJ为单位的能量）。因此，库中的内部开关功率实际上是指每次开关转换时内部所消耗的能量。</p>
<p>除了内部开关功率表之外，上面的示例中还给出了电源引脚、接地引脚的说明，并且指定了可将单元断电的条件。这些构造允许在设计和方案中使用多个电源，在这些情况下可以关闭不同的电源。下面展示了单元的电源引脚说明：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0a65a297ed368bf5a2ae0dd20ad60c76_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-17132af077f04b955bf430b67e751e28_720w.jpg"></p>
<p>功率描述的语法允许上升和下降（指输出过渡方向）功率使用单独的构造。就像时序弧一样，功率描述也可能取决于状态。例如，可以将异或门（XOR）单元的状态相关功耗指定为取决于各种输入的状态。</p>
<p>对于组合逻辑单元，开关功率是基于输入-输出引脚对指定的。但是，对于诸如具有互补输出Q和QN的触发器之类的时序单元来说，CLK-&gt; Q转换也会导致CLK-&gt; QN转换。因此，该库可以将内部开关功率指定为三维表格，如下所示。下例中的三个维度分别是CLK的输入压摆（input slew）和Q与QN的输出电容。</p>
<p><img src="https://pic1.zhimg.com/80/v2-efd6637dd24de18173c10a761a6cf198_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-96d1c9f4e001c06d17c9a446bfbc4625_720w.jpg"></p>
<p>即使输出和内部状态没有转换，也可以消耗开关功率。一个常见的例子是在触发器的时钟引脚上切换（toggle）的时钟。触发器在每次时钟切换时都会消耗功率，通常是由触发器单元内部反相器的开关所带来的。即使触发器输出未切换，也会消耗由于时钟引脚切换引起的功率。因此，对于时序逻辑单元，输入引脚功率（input pin power）是指单元内部的功耗，即输出不切换时的功耗。以下例子中描述了输入引脚功率：</p>
<p><img src="https://pic4.zhimg.com/80/v2-2871b98c494bf3d3ea3b0ecd36e08e27_720w.jpg"></p>
<p>上述例子展示了CLK引脚切换时的功率说明，它表示即使输出未切换，时钟切换也会导致功耗。</p>
<h3 id="时钟引脚的功率是否被重复计算了">时钟引脚的功率是否被重复计算了？</h3>
<p>注意，触发器还包含由于CLK-&gt; Q转换引起的功耗。因此重要的是，CLK-&gt; Q功率描述表格中的值是不包括与CLK内部功率有关的影响的，CLK内部功率与输出Q不切换时的状况相对应。</p>
<p>以上内容涉及到了应用工具对功率表使用的一致性，能够确保在功率计算期间与时钟输入有关的内部功率不会被重复计算。</p>
<h2 id="漏电功率">漏电功率</h2>
<p>大多数标准单元的设计都仅在输出或状态发生变化时才消耗功率。单元通了电但没有任何行为时，所有功耗都归因于泄漏电流（leakage current）。泄漏可能是由于MOS器件的亚阈值电流引起的，也可能是由于通过栅极氧化物的隧穿电流引起的。在以前的CMOS工艺技术中，漏电功率可以忽略不计，并且在设计过程中并不是主要考虑因素。但是，随着技术的发展，漏电功率变得越来越大，与有功功率相比，漏电功率已经无法忽略不计了。</p>
<p>如上所述，漏电功率主要有两个来源：MOS器件中的亚阈值电流和栅氧化物隧穿。通过使用高阈值电压单元，可以降低亚阈值电流；然而，由于高阈值电压单元的速度较低而存在一个折中（trade-off）：高阈值电压单元的漏电较小，但速度较慢。同样，低阈值电压单元的漏电较大，但速度较高。无论是使用高阈值电压还是低阈值电压的单元，栅极氧化物隧穿带来的影响都差不多。因此，控制漏电功率的可能方法是使用高阈值电压的单元。类似于在高阈值电压和标准阈值电压单元之间进行选择，设计中使用的单元强度（strength）也是一种漏电和速度之间的折中。强度较高的单元具有较高的漏电功率，但速度较高。与功率管理有关的折中将在10.6节中详细介绍。</p>
<p>MOS器件的亚阈值泄漏电流与温度具有很强的非线性特性，在大多数工艺技术中，随着器件温度从25°C升高到125°C，亚阈值泄漏电流可能会增加10倍至20倍。栅极氧化物隧穿带来的影响基本不随温度或器件阈值电压而改变，在100nm及以上工艺技术中可以忽略的栅极氧化物隧穿已成为65nm或更精细技术在较低温度下漏电的主要原因。例如，对于65nm或更精细的工艺技术，栅极氧化物隧穿漏电量可能等于室温下的亚阈值漏电量。而在高温下，亚阈值漏电仍然是导致漏电功率的主要因素。</p>
<p>库中的每个单元都被指定了漏电功率。例如，反相器单元的漏电功率可能描述如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a84f8a8fa0327da8f58264ac935bf31b_720w.png"></p>
<p>这是单元中耗散的漏电功率，漏电功率单位在库的头文件中指定，通常以纳瓦为单位。通常，漏电功率还取决于单元的状态，可以使用<strong>when</strong>条件指定状态相关值。</p>
<p>例如，一个反相器单元可以具有如下描述：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b9fe9444269622d27050d92529b8e2e4_720w.jpg"></p>
<p>其中I是反相器单元的输入引脚。需要注意的是，上例中的描述还包括了一个默认值（在<strong>when</strong>条件之外），该默认值通常是在<strong>when</strong>条件内指定值的平均值。</p>
<h2 id="单元库中的其它属性">单元库中的其它属性</h2>
<p>除时序信息外，库中的单元描述还指定了单元面积、功能和时序弧的SDF条件。这些将在本节中进行简要描述，有关更多详细信息，请参阅<strong>Liberty</strong>手册。</p>
<h3 id="单元面积">单元面积</h3>
<p>面积描述中指定了一个单元或一组单元的面积：</p>
<p><strong>area</strong>：2.35</p>
<p>上面指定了单元的面积为2.35个面积单位，这可以代表单元实际使用的硅面积，也可以是面积的相对测量值。</p>
<h3 id="单元功能">单元功能</h3>
<p>功能描述中指定了一个引脚或一组引脚的功能：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5282e70aa7a23f349250292aac6c5619_720w.png"></p>
<p>上面指定了一个两输入与门单元输出引脚Z的逻辑功能。</p>
<h3 id="sdf条件">SDF条件</h3>
<p>SDF条件属性支持标准延迟格式SDF（Standard Delay Format）文件的生成以及在反标（backannotation）期间的条件匹配。就像<strong>when</strong>条件指定用于时序分析的状态相关模型的条件一样，SDF标注（annotation）时状态相关时序的相应条件由<strong>sdf_cond</strong>来表示。以下是一个示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-c5d321b65b899dafe79c4bfcb2b86a0b_720w.jpg"></p>
<h2 id="特征和工作条件">特征和工作条件</h2>
<p>单元库中还会指定创建该库的特征（characterization）和工作条件。例如，库文件的头部可能包含以下内容：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e98430c27156aef6e3d012d6ca8a58e6_720w.jpg"></p>
<p>工作条件（<strong>nom_process</strong>、<strong>nom_temperature</strong>和<strong>nom_voltage</strong>）指定了对库进行表征的工艺、电压和温度， 也指定了使用该库中单元的条件。如果特征和工作条件不同，则需要对延迟计算过程中获得的时序值进行降额（derate）处理， 这可以通过使用库中指定的降额系数（k-系数）来实现。</p>
<p>在除用于表征之外的条件下使用降额获得时序值会导致时序计算不准确。只有当无法在预期的条件下表征库时，才能使用降额过程。</p>
<h3 id="什么是工艺变量">什么是工艺变量？</h3>
<p>与作为物理量的温度和电压不同，工艺是不可量化的变量。就数字特征和验证而言，它可能是缓慢（slow）、典型（typical）或快速（fast）的工艺之一。因此，工艺值为1.0（或任何其它值）是什么意思？答案在下面。</p>
<p>库的表征是一个耗时的过程，针对各种工艺角（process corner）对库进行表征可能需要数周的时间，工艺变量的设置使得以特定工艺角为特征的库可以用于不同工艺角的时序计算。工艺的k-系数可用于完成从特征库工艺到目标工艺的延迟降额。如上所述，降额系数的使用在时序计算期间引入了不准确性，跨工艺条件进行降额尤其不准确，因此很少采用。总而言之，指定不同工艺变量值（例如1.0或任何其它值）的唯一功能就是在少数情况下允许跨工艺条件进行降额处理。</p>
<h2 id="使用k-系数降额">使用K-系数降额</h2>
<p>如上所述，当工作条件不同于表征条件时，降额系数（或称k-系数）可用于计算延迟，k-系数是近似系数。库中k-系数的示例如下所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-9e19c6fbb2fa24006648b1601747ee64_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-6c52b0758154d1577bdad8b0c2bbae17_720w.jpg"></p>
<p>当延迟计算过程中工作条件的工艺、电压或温度与库中的标称条件不同时，可使用这些系数来进行计算。注意，<strong>k_volt</strong>系数为负，这意味着延迟随着电压的增加而减小，而<strong>k_temp</strong>因子为正，这意味着延迟通常随温度的升高而增加（除非单元具有2.10节中所描述的温度反转现象）。k-系数的用法如下：</p>
<p>● 降额后延迟 = 库中原始延迟 * （1 + k_process * <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="[公式]">Process + k_volt * <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="[公式]"> Volt + k_temp * <img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="[公式]"> Temp）</p>
<p>例如，假设使用slow工艺模型在1.08V和125°C下表征了一个库。如果要获得1.14V和100°C的延迟，则slow工艺模型的单元上升延迟可以通过以下计算获得：</p>
<p>● 降额后延迟 = 库中原始延迟 * （1 + k_volt_cell_rise * 0.06 - k_temp_cell_rise * 25）</p>
<p>假设使用上例中的k-系数代入以上计算公式，可得：</p>
<p>● 降额后延迟 = 库中原始延迟 * （1 - 0.42 * 0.06 - 0.0012 * 25） = 库中原始延迟 * 0.9448</p>
<p>可见，在降额条件下的延迟约为原始延迟的94.48％。</p>
<h2 id="库中各单位">库中各单位</h2>
<p>单元描述中数值的单位都是在库中指定的，可使用<strong>Liberty</strong>命令集在库文件中声明单位。电压、时间、电容和电阻的单位声明如下例所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-f33c2226d055e9589b4e24ed99139d82_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-db6930c2b1f63bb36186bde6e3e1f571_720w.jpg"></p>
<p>在本书中，我们假设库中时间单位为纳秒（ns），电压单位为伏特（V），每转换一次的内部功率单位为皮焦耳（pJ），漏电功率单位为纳瓦（nW），电容单位为皮法（pF），电阻单位为Kohms，面积单位为平方微米，但明确有特殊说明的情况除外。</p>
<h1 id="互联寄生">互联寄生</h1>
<blockquote>
<p>本章节介绍用于处理和表示互连寄生（interconnect parasitics）现象的各种技术，以验证设计的时序。</p>
</blockquote>
<p>● 在数字设计中，将标准单元或块（block）的引脚连接在一起的线（wire）称为网络（net）。网络通常只有一个驱动，但它可以驱动多个扇出单元或块。物理实现（physical implementation）后，网络可以在芯片的多个金属层上移动，各种金属层可以具有不同的电阻和电容值。对于等效的电气表示，通常将网络划分为多个段（segment），每个段均由等效的寄生参数表示。我们也将段称为互连走线（interconnect trace），也就是说，它是特定金属层上网络的一部分。</p>
<h2 id="互连rlc">互连RLC</h2>
<p>互连电阻（R）来自设计实现中各种金属层和过孔（vias）中的互连走线。图4-1是一个穿越各种金属层和过孔的网络示例。因此，可以将互连电阻视为单元的输出引脚与扇出单元的输入引脚之间的电阻。</p>
<p><img src="https://pic2.zhimg.com/80/v2-87e30f6007f588675b35e1d179e08d79_720w.jpg" alt="图4-1"></p>
<p>互连电容（C）也来自金属走线，包括接地电容以及相邻信号路径之间的电容。</p>
<p>互连电感（L）是由于电流环路而产生的，通常，电感效应在芯片内可以忽略不计，仅在封装和板级分析中考虑。在芯片级设计中，电流环路又窄又短，这意味着电流返回路径是通过电源或地信号而紧密相连的。在大多数情况下，时序分析不考虑片上电感，片上电感分析的任何进一步描述都超出了本书的范围。接下来仅分析互连电阻和互连电容的表示方法。</p>
<p>理想情况下，互连走线一部分的电阻和电容（RC）用分布式（distributed）RC树表示，如图4-2所示。 在此图中，RC树的总电阻和总电容Rt和Ct分别等于Rp * L和Cp * L，其中Rp和Cp分别是单位长度走线的互连电阻和电容值，L是走线长度。Rp和Cp值通常是从各种配置下提取的寄生参数中获得的，并由ASIC代工厂提供。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0bb394f5f37655e837612cfacb4fed34_720w.jpg" alt="图4-2"></p>
<p>RC互连可以通过各种简化模型来表示，这些将在下面的小节中进行介绍。</p>
<h3 id="t模型">T模型</h3>
<p>使用T模型表示时，总电容Ct被建模为在电阻树中间的连接。总电阻Rt被分为两部分（每部分为Rt / 2），Ct连接在电阻树的中点，如图4-3所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-de37ffc3a9f3eaf36e75344eb585fee9_720w.jpg" alt="图4-3"></p>
<h3 id="π模型">π模型</h3>
<p>在如图4-4所示的π模型中，总电容Ct被分为两部分（每部分为Ct / 2），并连接在电阻的两侧。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f94e27880cf5f2d929707b05ec34dd49_720w.jpg" alt="图4-4"></p>
<p>通过将Rt和Ct分成多个部分，可以获得分布式RC树的更准确表示。若分为N个部分，则每个中间部分的电阻和电容值分别为Rt / N和Ct /N，而两端部分需要根据T模型或π模型的概念来进行建模。图4-5中两端部分使用了T模型进行建模，而图4-6中两端部分使用了π模型进行建模。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ce70e4fb09ee95382eba654c9d150045_720w.jpg" alt="图4-5"></p>
<p><img src="https://pic1.zhimg.com/80/v2-fd6004d1237f355b39cf56af8ae46790_720w.jpg" alt="图4-6"></p>
<h2 id="线负载模型">线负载模型</h2>
<p>在进行布局规划（floorplanning）或布局（layout）之前，可以使用线负载模型（wireload models）来估计由互连线带来的电容、电阻以及面积开销。线负载模型可用于根据扇出数量来估计网络的长度，线负载模型取决于块（block）的面积，具有不同面积的设计可以选择不同的线负载模型。线负载模型还可以将网络的估计长度映射（map）为电阻、电容以及由于布线而产生的相应面积开销。</p>
<p>块内的平均走线长度与块的面积密切相关：随着块面积的增加，平均走线长度也会增加。图4-7显示，对于不同的面积（芯片或块），通常将使用不同的线负载模型来确定寄生效应。因此，下图中面积小的块的电容比较小。</p>
<p><img src="https://pic4.zhimg.com/80/v2-77b55cde55f0b9205cd6611cc5e5283f_720w.jpg" alt="图4-7"></p>
<p>以下是一个线负载模型的例子：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a32528081750b36dc587aa9c8134aa63_720w.jpg"></p>
<p><strong>resistance</strong>是互连线单位长度的电阻值，<strong>capacitance</strong>是互连线单位长度的电容值，<strong>area</strong>是互连线单位长度的面积开销，<strong>slope</strong>是用于扇出-长度（<strong>fanout_length</strong>）表中未指定的数据点的外推斜率。</p>
<p><img src="https://pic4.zhimg.com/80/v2-9b67f41f20048d7fd5c5127de316c507_720w.jpg" alt="图4-8"></p>
<p>线负载模型描述了互连线长度与扇出之间的函数关系，上面的示例如图4-8所示。对于表中未明确列出的任何扇出值，可使用具有指定斜率的线性外推法计算得到互连线长度。例如，扇出为8时可进行如下计算：</p>
<p>● 互连线长度 = 4.1 + （8 - 5） * 0.5 = 5.6</p>
<p>● 电容值 = 5.6 * 1.1 = 6.16</p>
<p>● 电阻值 = 5.6 * 5 =28.0</p>
<p>● 面积开销 = 5.6 * 0.05 = 0.28</p>
<p>上述计算结果中长度、电容、电阻、面积的单位都会在库（library）中指定。</p>
<h2 id="互连树">互连树</h2>
<p>一旦确定了预布局（pre-layout）后互连线的电阻电容估计值（即Rwire和Cwire），下一个问题便是互连结构。互连RC结构相对于驱动单元该如何分布呢？ 这一点很重要，因为从驱动引脚（driver pin）到负载引脚（load pin）的互连延迟取决于互连的结构。通常，互连延迟取决于沿路径的互连电阻和电容大小。因此，延迟值可能会有所不同，具体取决于给这个网络（net）假定的拓扑结构。</p>
<p>对于预布局估计，可以使用以下三种不同形式来表示互连RC树（见图4-9）。请注意，每个互连线的总长度（以及电阻和电容估计值）在这三种情况下是相同的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-128cb6c95143b87bf2eeef75349dec4f_720w.jpg" alt="图4-9"></p>
<p>● <strong>Best-case tree</strong></p>
<p>在最佳情况树中，假定负载引脚在物理上与驱动引脚相邻。因此，到负载引脚的路径中都没有互连电阻，来自其它扇出引脚的所有互连线电容和引脚电容仍然作为驱动引脚上的负载。</p>
<p>● <strong>Balanced tree</strong></p>
<p>在这种情况下，假定每个负载引脚都在互连线的一部分上，并且每条到达负载引脚的路径上的总电阻和电容都相等。</p>
<p>● <strong>Worst-case tree</strong></p>
<p>在最差情况树中，假定所有负载引脚都集中在互连线的另一端。因此，每条到负载引脚的路径上都会有全部的互连线电阻和电容。</p>
<h2 id="指定线负载模型">指定线负载模型</h2>
<p>使用以下命令指定线负载模型：</p>
<p><strong>set_wire_load_model</strong> "wlm_cons" <strong>-library</strong> "lib_stdcell"</p>
<p>以上命令表示使用单元库lib_stdcell中的线负载模型wlm_cons。</p>
<p>当一个网络跨越了设计层次（hierarchical）的边界时，可以基于线负载模式（wireload mode）将不同的线负载模型应用于每个层次中网络的不同部分。这些线负载模式是：</p>
<p>● <strong>top</strong></p>
<p>● <strong>enclosed</strong></p>
<p>● <strong>segmented</strong></p>
<p>可以使用<strong>set_wire_load_mode</strong>来指定线负载模式：</p>
<p><strong>set_wire_load_mode</strong> enclosed</p>
<p>在<strong>top</strong>线负载模式下，层次结构中的所有网络都将继承顶层（top）的线负载模型，即忽略下级层级中指定的任何线负载模型。因此，顶层的线负载模型具有优先权。对于图4-10所示的例子，块B1中指定的wlm_cons线负载模型优先于块B2、B3和B4中指定的所有其它线负载模型。</p>
<p><img src="https://pic1.zhimg.com/80/v2-4139276db7b00035af47b274cb6258bc_720w.jpg" alt="图4-10"></p>
<p>在<strong>enclosed</strong>线负载模式下，将完全包含网络的那个块中使用的线负载模型用于整个网络。对于图4-11中所示的例子，网络NETQ被完全包含在块B2中，因此将块B2的线负载模型wlm_light用于该网络。同理，完全包含在块B3中的网络使用wlm_aggr线负载模型，而完全包含在块B5中的网络使用wlm_typ线负载模型。</p>
<p><img src="https://pic1.zhimg.com/80/v2-dd78a4736f39956c9cbb07e2980aaff0_720w.jpg" alt="图4-11"></p>
<p>在<strong>segmented</strong>线负载模式下，网络的每段（segment）都从包含该段的块中获取其线负载模型，网络的每个部分都在该层次内使用适当的线负载模型。图4-12举例说明了一个网络NETQ，它的三段分别在三个块中。B3块中此网络的扇出互连使用wlm_aggr线负载模型，B4块中使用wlm_typ线负载模型，B2块中使用wlm_light线负载模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9b598cc53702b3695400ceb2abaaeef6_720w.jpg" alt="图4-12"></p>
<p>通常，是根据模块的芯片面积来选择线负载模型的。但是，可以根据用户的判断修改或更改它们。例如，可以为面积在0到400之间的块选择线负载模型wlm_aggr，为面积在400到1000之间的块选择线负载模型wlm_typ，为面积大于1000的块选择线负载模型wlm_cons。 线负载模型通常在单元库中定义，但是用户也可以自定义线负载模型。可以在单元库中将默认的线负载模型指定为：</p>
<p><strong>default_wire_load</strong> : "wlm_light" ；</p>
<p>在单元库中定义了一个线负载模型选择组，该组根据面积选择线负载模型，以下是一个示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-48477a3d6d09d832c2c4676cd9cdc021_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4816c3581b2a550ae0129f61b4dd1aef_720w.png"></p>
<p>单元库可以包含许多这样的选择组。通过使用<strong>set_wire_load_selection_group</strong>，可以选择特定的一个组供STA使用。</p>
<p><strong>set_wire_load_selection_group</strong> WireAreaSelGrp</p>
<p>本节介绍了在物理实现之前（即在预布局阶段）估算寄生参数的建模过程。下一节将介绍从布局中提取得到的寄生参数的表示方法。</p>
<h2 id="提取所得寄生参数的表示方法">提取所得寄生参数的表示方法</h2>
<p>从布局（layout）中提取的寄生参数可以用三种格式描述：</p>
<p>● 详尽的寄生参数格式 ：Detailed Standard Parasitic Format（DSPF）</p>
<p>● 精简的寄生参数格式 ：Reduced Standard Parasitic Format（RSPF）</p>
<p>● 标准的寄生参数格式 ：Standard Parasitic Extraction Format（SPEF）</p>
<p>一些工具还提供了专用的寄生参数二进制表示格式，例如SBPF；这有助于减小文件存储空间，并加快了工具读取寄生参数的速度。下面分别对以上三种格式进行简要说明。</p>
<h2 id="详尽的寄生参数格式">详尽的寄生参数格式</h2>
<p>使用DSPF格式时，详尽的寄生参数以<strong>SPICE</strong>格式表示。<strong>SPICE</strong>中的Comment语句用于表明单元类型、单元引脚及其电容。电阻和电容值采用标准<strong>SPICE</strong>语法，并且单元实例也包含在此表示格式中。这种格式的优势在于，DSPF文件可以用作<strong>SPICE</strong>仿真器本身的输入。但是，缺点是DSPF语法过于详细和冗长，导致模块的总文件大小非常大。因此，这种格式在实际中仅用于相对较小的一组网络。</p>
<p>以下是DSPF文件的示例，描述了从主输入IN到缓冲器BUF的输入引脚A以及从BUF的输出引脚OUT到主输出引脚OUT的一个网络互连。</p>
<p><img src="https://pic4.zhimg.com/80/v2-9c4b4cb7188ad235d8a8cc805576968b_720w.jpg"></p>
<p>DSPF中的非标准<strong>SPICE</strong>语句是以 * |开头，并具有以下格式：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1ee31302414ddc729670a4a54326fcfc_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-12a8603077c679691e14058f9db06ee2_720w.png"></p>
<h2 id="精简的寄生参数格式">精简的寄生参数格式</h2>
<p>使用RSPF格式时，寄生参数以精简的形式表示。精简格式包括电压源和受控电流源。RSPF格式也是<strong>SPICE</strong>文件，也可以将其读取到类似<strong>SPICE</strong>的仿真器中。RSPF格式要求简化详细的寄生参数并将其映射为精简格式，因此这是RSPF格式的一个缺点，因为寄生提取过程的重点通常是提取的精度，而不是压缩成RSPF之类的精简格式。RSPF格式的另一个限制是不能以这种格式表示双向信号流。</p>
<p>以下是RSPF文件的示例，原始设计和等效表示如图4-13所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3d9a362ffe72b6b60f76bd2ae106e7b6_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ce3be722de48a8c7bed6d0938bdc679b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-bf33c480d65b5432fbcab0fd999f5572_720w.jpg" alt="图4-13"></p>
<p>这个文件具有以下特点：</p>
<p>● 在每个扇出单元的输入引脚上都使用0.1pF的电容（C3和C4）和电阻（R2和R3）对引脚到引脚（pin-to-pin）的互连延迟进行建模，电阻值的选取原则是使RC延迟对应于引脚到引脚的互连延迟。驱动单元输出引脚上的π型负载模拟了通过该单元的延迟。</p>
<p>● 输入端的RC元件由理想电压源（E1和E2）驱动，该电压源等于驱动单元输出端的电压。</p>
<h2 id="标准的寄生参数格式">标准的寄生参数格式</h2>
<p>SPEF是一种紧凑格式，可以表示详细的寄生参数。下面是一个具有两个扇出的网络的示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-42562002c6f4f6b83c64e690134db6c5_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-55d8bdcdcde1d7183dc6360a740ead83_720w.jpg"></p>
<p>寄生电阻和电容的单位在SPEF文件的开头中指定，附录C中提供了SPEF文件的更详细说明。由于SPEF的紧凑性和表示的完整性，它是设计中寄生参数表示方法的首选格式。</p>
<h2 id="耦合电容的表示方法">耦合电容的表示方法</h2>
<p>上一节说明了将一个网络的电容表示为接地（grounded）电容的情况。由于纳米技术中的大多数电容是侧壁（sidewall）电容，因此这些电容的恰当表示形式应该是信号到信号（signal-to-signal）的耦合电容（Coupling Capacitance）。</p>
<p>DSPF中耦合电容的表示是对原始DSPF标准的附加（add-on），因此不是唯一的。耦合电容会在两组耦合网络之间被复制，这意味着由于两组网络中有重复的耦合电容，因此DSPF无法直接被读入<strong>SPICE</strong>。一些输出DSPF的工具通过在两个耦合网络中各包含一半的耦合电容解决了这一问题。</p>
<p>RSPF是精简的格式，因此不适合表示耦合电容。</p>
<p>SPEF标准以统一和明确的方式处理耦合电容，因此是考虑串扰（crosstalk）时序时优先选择的提取格式。此外，就文件大小而言，SPEF是紧凑的表示格式，适合用于表示带耦合或不带耦合的寄生参数。</p>
<p>如附录C中所描述，管理文件大小的机制之一是在文件的开头列出名称目录（name directory）。现在，许多提取工具在SPEF文件的开头指定了网络名目录（将网络名表示为索引），从而避免了重复网络名的冗长性，这样可以大大减小文件大小。附录C中列举了一个SPEF的名称目录示例。</p>
<h2 id="分层方法">分层方法</h2>
<p>大型复杂的设计通常在物理设计过程中需要使用分层方法（hierarchical methodology）来进行寄生参数提取和时序验证。在这种情况下，模块的寄生参数会在模块级别提取，然后可以在更高的层次上使用。</p>
<p>可以将从一个模块的布局中提取得到的寄生参数用于尚未完成布局的另一个模块的时序验证。在这种情况下，通常将已布局完的模块的寄生参数与预布局模块的基于线负载模型的估计寄生参数结合使用。</p>
<p>在使用分层方法的流程中，顶层（top）模块的布局最先完成，但其中的模块仍为黑匣子（预布局），基于线负载模型估计所得的寄生参数可以结合从布局完成的顶层中提取得到的寄生参数用于较低层次的模块。 一旦各模块的布局也完成了，就可以将从顶部和模块的布局中提取得到的寄生参数结合在一起。</p>
<h3 id="布局中的重复模块">布局中的重复模块</h3>
<p>如果将一个设计模块在布局中复制多次，则可以将从一个实例（instantiation）中提取的寄生参数用于所有实例，这就要求该模块的布局在各方面对于每个实例都是相同的。例如，从布局内的布线网络看，布局环境（environment）应该没有差异，这意味着模块内网络不与模块外部的任何网络电容耦合。可以做到这一点的一种方法是：确保没有在模块内布线任何顶层的网络，并且对在块的边界附近布线的网络有足够的保护或间距。</p>
<h2 id="减少关键网络的寄生参数">减少关键网络的寄生参数</h2>
<p>本节简要概述了管理寄生参数对关键（critical）网络影响的常用技术。</p>
<h3 id="降低互连电阻">降低互连电阻</h3>
<p>对于关键网络，重要的是要保持较低的压摆率（slew）或快速的过渡时间（transition），这意味着应降低互连电阻。通常，有两种方法可以实现较低的电阻：</p>
<p>● 宽走线（Wide trace）：具有比最小宽度更加宽的走线可以降低互连电阻，而且不会引起寄生电容的显著增加。因此，可以减少总的RC互连延迟和过渡时间。</p>
<p>● 在较高（较厚）金属中布线：较高的金属层通常具有低电阻率，可用于给关键信号布线。较低的互连电阻可减少互连延迟以及目标引脚（destination pin）上的过渡时间。</p>
<h3 id="增加走线间距">增加走线间距</h3>
<p>增加走线之间的间距可以减少网络的耦合电容和总电容。大的耦合电容会增加串扰，避免串扰是在长距离相邻走线中布线的网络的重要考虑因素。</p>
<h3 id="相关网络的寄生参数">相关网络的寄生参数</h3>
<p>在许多情况下，一组网络必须在时序上匹配。比如高速DDR接口的一个字节通道内的数据信号，因为需要保证一个字节通道内的所有信号都具有相同的寄生参数，所以这些信号都应在同一金属层中布线。例如，虽然金属层M2和M3具有相同的平均值和相同的统计变化，但是这些变化是独立的，从而这两个金属层中的寄生参数变化是无关的。因此，如果对于关键信号的时序匹配很重要，则在每个金属层中的布线必须相同。</p>
<h1 id="延迟计算">延迟计算</h1>
<blockquote>
<p>本章节介绍了用于布局前后时序验证的基于单元（cell-based）的设计的延迟计算（delay calculation）。</p>
</blockquote>
<p>● 前几章重点介绍了对互连线和单元库的建模，单元和互连线建模技术可用于获得设计的时序信息。</p>
<h2 id="概述">概述</h2>
<h2 id="延迟计算基础">延迟计算基础</h2>
<p>典型的设计中包括各种组合逻辑单元和时序逻辑单元，我们使用如图5-1中所示的逻辑设计来描述延迟计算的概念：</p>
<p><img src="https://pic1.zhimg.com/80/v2-67d30d03cd00dd591256c2e113f7dc98_720w.jpg" alt="图5-1"></p>
<p>库中为每个单元的每个输入引脚都指定了电容值，因此，设计中的每个网络都具有容性负载，该负载是该网络每个扇出的引脚负载电容再加上互连线的寄生电容之和。为了简单起见，本节中暂不考虑互连线的影响，这些内容将在后面章节中进行介绍。不考虑互连寄生的影响，图5-1中的内部网络NET0的电容将由UAND1和UNOR2单元的输入引脚电容组成；输出O1具有UNOR2单元的输入引脚电容再加上逻辑模块输出端口的任何电容性负载；输入I1和I2具有UAND1和UINV0单元的输入引脚电容。通过这种抽象，图5-1中的逻辑设计可以用图5-2所示的等效表示来描述：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0f033c065074b1671eda6c7d1ff76997_720w.jpg" alt="图5-2"></p>
<p>如第3章所述，单元库中包含了用于各种时序弧的NLDM时序模型，非线性模型以输入过渡时间和输出负载电容的形式表示为二维表格。逻辑单元的输出过渡时间也以输入过渡时间和总输出负载电容的形式表示为二维表格。因此，如果在逻辑块的输入引脚处（I1和I2）指定了输入过渡时间（或称压摆），则可以从库中获得UINV0单元和UAND1单元（对于输入I1）的时序弧的输出过渡时间和延迟。对扇出单元使用如上相同的方法，则可以获得通过UAND1单元的另一条时序弧（从NET0到O1）以及通过UNOR2单元的过渡时间和延迟。对于多输入单元（例如UAND1），不同的输入引脚会导致不同的输出过渡时间值，对扇出网络过渡时间的选择取决于压摆合并（slew merge）选项，这将在5.4节中进行介绍。使用上述方法，可以基于输入引脚上的过渡时间和输出引脚上的电容来获得通过任何逻辑单元的延迟。</p>
<h2 id="带互连线的延迟计算">带互连线的延迟计算</h2>
<h3 id="布局前时序">布局前时序</h3>
<p>如第4章所述，在布局前（pre-layout）时序验证期间，使用线负载模型估算了互连寄生参数。在许多情况下，线负载模型中电阻的影响被设置为了0。在这种情况下，线负载是纯电容性的，因此上一部分中描述的延迟计算方法适用于获得设计中所有时序弧的延迟。</p>
<p>如果线负载模型考虑了互连电阻的影响，则将NLDM模型与总网络电容一起使用，以计算通过单元的延迟。由于互连线是电阻性的，因此从驱动单元的输出到扇出单元的输入引脚会有额外的延迟。互连线的延迟计算过程将在5.3节中进行介绍。</p>
<h3 id="布局后时序">布局后时序</h3>
<p>金属走线的寄生参数将被映射为驱动单元和目标单元之间的RC网络。以图5-1中示例为例，网络的互连电阻如图5-3所示。内部网络（例如图5-1中的NET0）映射到了多个子节点，如图5-3所示。因此，反相器单元UINV0的输出负载由RC结构组成。由于NLDM表格仅针对输入过渡时间和输出负载电容而言，因此输出引脚上的电阻性负载意味着NLDM表格不能直接应用。下一节将介绍如何将NLDM表格模型与互连电阻一起结合使用。</p>
<p><img src="https://pic2.zhimg.com/80/v2-18e3d16159797ff1ae5841b2fcaee195_720w.jpg" alt="图5-3"></p>
<h2 id="使用有效电容计算单元延迟">使用有效电容计算单元延迟</h2>
<p>如上所述，当单元输出端的负载包含互连电阻时，NLDM模型不可直接使用。因此，采用“有效”电容法来处理电阻的影响。</p>
<p>有效电容法试图找到一个可以用作等效负载的电容，以使原始设计与具有等效电容负载的设计在单元输出的时序方面表现一致。这个等效电容被称为有效电容（effective capacitance）。</p>
<p>图5-4（a）为在扇出处具有RC互连的单元，该RC互连可由等效的π模型表示，如图5-4（b）所示。有效电容的概念是为了获得等效的输出电容Ceff（如图5-4（c）所示），此时通过单元的延迟与具有RC互连负载的原始设计相同。通常，具有RC互连负载的单元输出波形与具有单个电容性负载的单元输出波形非常不同。</p>
<p><img src="https://pic2.zhimg.com/80/v2-cd93fb7df81301c6537e332f3335dc7d_720w.jpg" alt="图5-4"></p>
<p>图5-5中展示了具有总电容、有效电容的单元输出端的代表性波形以及具有实际RC互连的波形。选择准确的有效电容Ceff应该可以使得图5-4（c）中单元输出处的延迟（在过渡波形的中点测得）与图5-4（a）中的延迟相同，如图5-5所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-29fe5dfe8a74105adb653cdc768286d4_720w.jpg" alt="图5-5"></p>
<p>使用π模型等效表示RC互连时，有效电容可以表示为：</p>
<p>● Ceff = C1 + k * C2 , 0 &lt;= k &lt;= 1</p>
<p>其中C1是近端（near-end）电容，C2是远端（far-end）电容，如图5-4（b）所示。k的值在0到1之间。在互连电阻可忽略的情况下，有效电容几乎等于总电容。通过在图5-4（b）中将R设置为0，可以直接解释这一点。同样，如果互连电阻相对较大，则有效电容几乎等于近端电容C1，这可以通过将R增加到无限大（本质上是开路）的极限情况来解释。</p>
<p>有效电容是以下各项的函数：</p>
<p>● 驱动单元</p>
<p>● 负载的特性，尤其是驱动单元负载的输入阻抗。</p>
<p>对于给定的互连线，输出驱动较弱的单元将比驱动较强的单元具有更大的有效电容。因此有效电容的值将介于最小值C1（对于较大的互连电阻或者较强的驱动单元）与最大值C1+C2（对于小到可忽略的互连电阻或较弱的驱动单元）之间。注意，目标引脚的转换要晚于驱动单元的输出。近端电容充电速度比远端电容快的现象也被称为互连线的电阻屏蔽效应（resistive shielding effect），因为驱动单元只能看到一部分远端电容。</p>
<p>与通过库中的NLDM模型直接查找来计算延迟不同，延迟计算工具通过迭代过程获得有效电容。就算法而言，第一步是获取单元输出端看到的实际RC负载的驱动点阻抗，可以使用二阶AWE或Arnoldi算法等方法计算实际RC负载的驱动点阻抗。计算有效电容的下一步是使两种情况下直到过渡波形中点为止传输的电荷量相等：使用实际RC负载时（基于驱动点阻抗）在单元输出处传输的电荷与使用有效电容作为负载时的电荷传输量相匹配，请注意，电荷传输匹配仅到过渡波形的中点为止。该过程从有效电容的估算值开始，然后迭代更新估算值。在大多数实际情况下，有效电容值会在少量次数的迭代中收敛。</p>
<p>因此，有效电容近似值是计算通过单元的延迟的优秀模型。但是，使用有效电容法获得的输出压摆（slew）与单元输出处的实际波形并不一致。有效电容近似值不能代表单元输出处的波形，尤其是波形的后半部分。请注意，在典型情况下，需要关注的波形并不是在单元输出处，而是在互连线的终点处，也即扇出单元的输入引脚处。</p>
<p>有多种方法可以计算互连线终点处的延迟和波形。在许多实现（implementation）方法中，有效电容的计算过程还会计算驱动单元的等效戴维宁（Thevenin）电压源。戴维宁电压源由具有串联电阻Rd的电压源组成，如图5-6所示。串联电阻Rd对应于单元输出级的下拉电阻（或上拉电阻）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ef4169663cbbd1959ab2d313c60aaf49_720w.jpg" alt="图5-6"></p>
<p>本节介绍了使用有效电容替代RC互连来计算通过驱动单元的延迟。有效电容的计算还提供了等效的戴维宁电压源模型，然后将其用于获取通过RC互连的时序。接下来将具体介绍获取通过RC互连时序信息的过程。</p>
<h2 id="互连线延迟">互连线延迟</h2>
<p>如第4章所述，网络的互连寄生通常由RC电路表示，RC互连电路可以是布局前或布局后的。虽然布局后的互连寄生可以包括与相邻网络的耦合，但是基本延迟计算中将所有电容（包括耦合电容）都视为接地电容。一个网络及其驱动单元和扇出单元的寄生参数如图5-7所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-581a7348bb5f3458e88a2d8c860ebac2_720w.jpg" alt="图5-7"></p>
<p>使用有效电容法，可以分别获得通过驱动单元和通过互连线的延迟。使用有效电容法可获得通过驱动单元的延迟，并在单元的输出端提供等效的戴维宁电压源，然后使用戴维宁电压源分别计算通过互连线的延迟。互连线部分具有一个输入和与目标引脚一样多的输出。在互连线输入端使用等效戴维宁电压源，计算到每个目标引脚的延迟，如图5-6所示。</p>
<p>在布局前进行分析时，RC互连结构由RC树类型决定，而RC互连结构又决定了互连线延迟。4.2节中已详细介绍了三种类型的RC互连树表示形式，所选的RC树类型通常在库中定义。通常，最坏情况（worst-case）的慢速库会选择最坏情况的RC树，因为该类型的树提供了最大的互连线延迟。类似地，最佳情况（best-case）的RC树结构中不包括从源引脚到目标引脚的任何电阻，通常在最佳情况的快速工艺角时被选择。因此，最佳情况RC树的互连延迟等于零。典型（typical）情况RC树和最坏情况RC树的互连延迟的处理方式与布局后RC互连一样。</p>
<h3 id="elmore延迟模型">Elmore延迟模型</h3>
<p>Elmore延迟模型（如图5-8所示）适用于RC树。什么是RC树？ RC树应满足以下三个条件：</p>
<p>● 有单一的输入（源）节点</p>
<p>● 没有任何电阻回路</p>
<p>● 所有电容都在节点和地之间</p>
<p>Elmore延迟可以看作是找到每段的延迟，即R与下游电容的乘积，然后取各延迟之和。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ff88760c57e6fd3658664842b425006d_720w.jpg" alt="图5-8"></p>
<p>到各个中间节点的延迟计算如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-80e5f24483ee251b53f5b252535c5fa6_720w.jpg"></p>
<p>Elmore延迟在数学上考虑的是脉冲响应的第一时刻。 现在，我们将Elmore延迟模型进行如下简化表示：互连线的寄生电阻与电容分别为Rwire和Cwire，互连线远端的引脚电容由负载电容Cload来建模。等效的RC网络可以简化为π模型或T模型，分别如前面章节四中图4-4和图4-3所示。两种模型都具有如下走线延迟（基于Elmore延迟方程）：</p>
<p>● Rwire * （ Cwire / 2 + Cload）</p>
<p>这是因为Cload在充电路径中能看到整个互连线的电阻，而Cwire电容在T模型中仅能看到Rwire / 2且Cwire / 2在π模型中能看到Rwire。以上方法也可以扩展到更复杂的互连结构。</p>
<p>下面给出了使用线负载模型和平衡（balanced）RC树（以及最坏情况RC树）计算一个网络的Elmore延迟的示例。</p>
<p>使用平衡RC树模型时，网络的电阻和电容在网络的各个分支之间平均分配（假设扇出为N）。对于具有引脚负载Cpin的分支，使用平衡RC树的延迟为：</p>
<p>● （Rwire / N）* （Cwire / （2N）+ Cpin）</p>
<p>使用最坏情况RC树模型时，网络的每个分支终点都考虑了网络的电阻和整个电容。此时的延迟值如下所示，这里的Cpins是所有扇出的总引脚负载：</p>
<p>● Rwire * （Cwire / 2 + Cpins）</p>
<p>图5-9是一个设计实例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2c694d039fd48184427d91b32d57becc_720w.jpg" alt="图5-9"></p>
<p>如果我们使用最坏情况RC树模型来计算网络N1的延迟，我们将得到：</p>
<p>● Rwire * （Cwire / 2 + Cpins）= 0.3 * （0.5 + 2.3）=0.84</p>
<p>如果使用平衡RC树模型，则对于网络N1的两个分支，将得到以下延迟：</p>
<p>● 到NOR2单元的分支 ： （0.3 / 2）* （0.5 / 2 + 1.3）= 0.2325</p>
<p>● 到BUF单元的分支： （0.3 / 2）*（0.5 / 2 + 1.0）= 0.1875</p>
<h3 id="高阶互连线延迟估计">高阶互连线延迟估计</h3>
<p>如上所述，Elmore延迟考虑的是脉冲响应的第一时刻，而AWE（渐近波形评估）、Arnoldi或其他方法能够匹配更高阶的响应时刻。通过进行更高阶的估计，可以提高计算互连线延迟的精度。</p>
<h3 id="全部片上延迟计算">全部片上延迟计算</h3>
<p>到目前为止，本章已经介绍了单元延迟以及单元输出处互连线的延迟计算。因此，给定在单元输入处的过渡时间，可以计算通过单元和单元输出处互连线的延迟。互连线远端（终点）的过渡时间是下一级的输入，整个设计过程中都会重复此过程，这样就计算出了设计中每个时序弧的延迟。</p>
<h2 id="压摆合并">压摆合并</h2>
<p>当多个压摆到达一个公共点时（例如在多输入单元的情况下）会发生什么呢？这种公共点称为压摆合并点（slew merge point）。 选择哪个压摆在压摆合并点处继续向下传播呢？考虑图5-10所示的2输入单元：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2188bbcf229c2b8b4d7a1bcc72c054b0_720w.jpg" alt="图5-10"></p>
<p>由于引脚A上的信号改变，引脚Z上的压摆到达较早，但上升缓慢（压摆较小）；由于引脚B上的信号改变，引脚Z上的压摆到达较晚，但上升很快（压摆较大）。在压摆合并点（例如引脚Z），应选择哪个压摆进一步传播呢？取决于所执行的时序分析的类型（最大或最小时序路径分析），这些压摆值中的任何一个都可能是正确的。</p>
<p>进行最大时序路径分析时有两种可能性：</p>
<p>● 最差的压摆传播（Worst slew propagation）：此模式选择要在合并点传播最坏的压摆，这将是图5-10（a）中的压摆。对于通过引脚A-&gt; Z的时序路径，此选择是准确的，但对于通过引脚B-&gt; Z的任何时序路径都是悲观的。</p>
<p>● 最差的到达时间传播（Worst arrival propagation）：此模式选择要在合并点传播最差的到达时间，这对应于图5-10（b）中的压摆。在这种情况下选择的压摆对于通过引脚B-&gt; Z的时序路径是准确的，但对于通过引脚A-&gt; Z的时序路径是乐观的。</p>
<p>同样，进行最小时序路径分析时也有两种可能性：</p>
<p>● 最佳的压摆传播（Best slew propagation）：此模式选择要在合并点传播最佳的压摆，这就是图5-10（b）中的压摆。对于通过引脚B-&gt; Z的时序路径，此选择是准确的，但对于通过引脚A&gt; Z的任何时序路径，该选择的压摆值较小。对于经过A-&gt; Z的路径，路径延迟小于实际值，因此对于最小时序路径分析是悲观的。</p>
<p>● 最佳的到达时间传播（Best arrival propagation）：此模式选择要在合并点传播最佳的到达时间，这对应于图5 10（a）中的压摆。在这种情况下，选择的压摆对于通过引脚A-&gt; Z的时序路径是准确的，但大于通过引脚B-&gt; Z的时序路径的实际值。对于经过B-&gt; Z的路径，路径延迟大于实际值，因此对于最小时序路径分析是乐观的。</p>
<p>设计人员可以在静态时序分析环境之外执行延迟计算，以生成SDF文件。在这种情况下，延迟计算工具通常使用最差的压摆传播。生成的SDF文件足以用于最大时序路径分析，但对于最小时序路径分析可能是过于乐观的。</p>
<p>大多数静态时序分析工具均使用最差和最佳的压摆传播作为默认设置，因为它会保守地限制分析。但是，在分析特定路径时可以使用精确的压摆传播，精确的压摆传播需要在时序分析工具中启用一个选项。因此，重要的是要了解静态时序分析工具中默认使用哪种压摆传播模式，并清楚其可能过于悲观的情况。</p>
<h2 id="不同压摆阈值">不同压摆阈值</h2>
<p>通常，库会指定在单元表征（characterization）期间使用的压摆（过渡时间）阈值。问题是，当具有一组压摆阈值的单元驱动其他具有不同压摆阈值设置的单元时，会发生什么呢？ 考虑图5-11中所示的情况，具有20%-80%压摆阈值的单元驱动两个扇出单元，其中一个具有10%-90%的压摆阈值，另一个具有30%-70%的压摆阈值且压摆降额系数为0.5。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b5c7464fb7edf190a0486f31db31549b_720w.jpg" alt="图5-11"></p>
<p>U1单元的压摆设置在单元库中定义如下：</p>
<p><strong>slew_lower_threshold_pct_rise：</strong> 20.00</p>
<p><strong>slew_upper_threshold_pct_rise：</strong>80.00</p>
<p><strong>slew_derate_from_library：</strong>1.00</p>
<p><strong>input_threshold_pct_fall：</strong>50.00</p>
<p><strong>output_threshold_pct_fall：</strong>50.00</p>
<p><strong>input_threshold_pct_rise：</strong>50.00</p>
<p><strong>output_threshold_pct_rise：</strong>50.00</p>
<p><strong>slew_lower_threshold_pct_fall：</strong>20.00</p>
<p><strong>slew_upper_threshold_pct_fall：</strong>80.00</p>
<p>U2单元的压摆设置在另一个单元库中定义如下：</p>
<p><strong>slew_lower_threshold_pct_rise：</strong>10.00</p>
<p><strong>slew_upper_threshold_pct_rise：</strong>90.00</p>
<p><strong>slew_derate_from_library：</strong>1.00</p>
<p><strong>slew_lower_threshold_pct_fall：</strong>10.00</p>
<p><strong>slew_upper_threshold_pct_fall：</strong>90.00</p>
<p>U3单元的压摆设置在另一个单元库中定义如下：</p>
<p><strong>slew_lower_threshold_pct_rise：</strong>30.00</p>
<p><strong>slew_upper_threshold_pct_rise：</strong>70.00</p>
<p><strong>slew_derate_from_library：</strong>0.5</p>
<p><strong>slew_lower_threshold_pct_fall：</strong>30.00</p>
<p><strong>slew_upper_threshold_pct_fall：</strong>70.00</p>
<p>上面仅展示了与U2和U3压摆相关的设置， 输入和输出阈值的延迟相关设置为50％，未在上面显示。延迟计算工具会根据连接到这个网络的单元的压摆阈值来计算过渡时间。图5-11显示了U1 / Z处的压摆如何与此引脚上的切换波形相对应，U1/ Z处的等效戴维宁源可用于获得扇出单元输入端的切换波形。延迟计算工具会根据U2 / A和U3 / A处的波形及其压摆阈值，计算出U2 / A和U3 / A处的压摆。请注意，U2 / A的压摆是基于10%-90%设置的，而U3 / A所用的压摆是基于30%-70%设置，然后根据库中指定的压摆降额（slew derate）系数0.5使用的。 此示例说明了如何根据切换波形和扇出单元的压摆阈值设置来计算扇出单元输入端的压摆。</p>
<p>在可能不考虑互连电阻的预布局（pre-layout）设计阶段时，可以按以下方式计算具有不同阈值的网络处的压摆。例如，10%-90%压摆阈值和20%-80%压摆阈值之间的关系为：</p>
<p>● slew2080 / （0.8 - 0.2） = slew1090 / （0.9 - 0.1）</p>
<p>因此，10%-90%阈值测量点设置时的500ps压摆对应于20%-80%阈值测量点设置时（500ps * 0.6）/ 0.8 = 375ps的压摆。类似地，20%-80%阈值测量点设置时的600ps压摆对应于10%-90%阈值测量点设置时（600ps * 0.8）/ 0.6 = 800ps的压摆。</p>
<h2 id="不同电压域">不同电压域</h2>
<p>典型的设计中可能会对芯片的不同部分使用不同的电源。在这种情况下，在不同电压域之间的接口处应使用电平转换单元（level shifting cell）。电平转换单元在一个电压域接受输入，而在另一电压域提供输出。例如，一个标准单元输入可以为1.2V，其输出可以为较低的电压，如0.9V。下图5-12为一个示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-085bf27f899145f6cafd75b70d21ec05_720w.jpg" alt="图5-12"></p>
<p>请注意，延迟是根据50％阈值点计算的。对于接口单元的不同引脚，这些点可能处于不同的电压。</p>
<h2 id="路径延迟计算">路径延迟计算</h2>
<p>一旦得到了每个时序弧的全部延迟，则可以将设计中各个单元的时序表示为时序图。通过组合逻辑单元的时序可以表示为从输入到输出的时序弧。类似地，互连线可用从源引脚到每个目的引脚的相应弧表示，表示为单独的时序弧。一旦整个设计由相应的时序弧标定（annotate）了，计算路径延迟就是将沿路径的所有网络和单元的时序弧相加起来即可。</p>
<h2 id="组合逻辑路径延迟">组合逻辑路径延迟</h2>
<p>考虑串联的三个反相器，如图5-13所示。在考虑从网络N0到网络N3的路径时，我们同时考虑了上升沿和下降沿路径，现假设网络N0处有上升沿。</p>
<p><img src="https://pic2.zhimg.com/80/v2-6ead4a912c8aacabe7ecaf583576516d_720w.jpg" alt="图5-13"></p>
<p>可以指定第一个反相器输入端的过渡时间（或压摆），若没有此类指定的话，就假定过渡时间为0（相当于理想情况）。输入UINVa / A处的过渡时间可通过使用上一节中指定的互连延迟模型来确定，同样，这个互连延迟模型也可用于确定网络N0的延迟Tn0。</p>
<p>根据UINVa输出处的RC负载，可以获得输出处UINVa/Z的有效电容。输入处UINVa/A的过渡时间和输出处UINVa/Z的等效有效负载则可用于获得单元输出下降延迟（output fall delay）。</p>
<p>等效的戴维宁电压源模型在引脚UINVa/Z上通过互连延迟模型可确定引脚UINVb/A上的过渡时间，互连延迟模型还用于确定网络N1上的延迟Tn1。</p>
<p>一旦知道了输入UINVb/A的过渡时间，就可以类似地计算通过UINVb的延迟。UINVb/Z处的RC互连以及引脚UINVc/A的引脚电容可用于确定N2处的有效负载。UINVb/A处的过渡时间可用于确定通过反相器UINVb的输出上升延迟（output rise delay），依此类推。</p>
<p>最后一级的负载由明确的负载说明来指定，如果没有指定，则仅使用网络N3的线负载。</p>
<p>上述分析假设网络N0为上升沿，对于网络N0的下降沿，可以进行类似的分析。因此，在这个简单的示例中，存在两条具有以下延迟的时序路径：</p>
<p>● Tfall = Tn0rise + Tafall + Tn1fall + Tbrise + Tn2rise + Tcfall + Tn3fall</p>
<p>● Trise = Tn0fall + Tarise + Tn1rise + Tbfall + Tn2fall + Tcrise + Tn3rise</p>
<p>通常，由于驱动单元输出处的戴维宁电压源模型不同，通过互连线的上升和下降延迟可能会有所不同。</p>
<h2 id="到触发器的路径">到触发器的路径</h2>
<h3 id="输入到触发器路径">输入到触发器路径</h3>
<p>考虑从输入SDT到触发器UFF1的时序路径，如图5-14所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f3093185439bd1f3781d890bf5984a89_720w.jpg" alt="图5-14"></p>
<p>我们需要同时考虑上升沿和下降沿路径。对于输入SDT的上升沿，数据路径延迟为：</p>
<p>● Tn1rise + Tafall + Tn2fall + Tbuf1fall + Tn3fall + Tbrise + Tn4rise</p>
<p>同样，对于输入SDT的下降沿，数据路径延迟为：</p>
<p>● Tn1fall + Tarise + Tn2rise + Tbuf1rise + Tn3rise + Tbfall + Tn4fall</p>
<p>输入MCLK上升沿的捕获（capture）时钟路径延迟为：</p>
<p>● Tn5rise + Tbuf2rise + Tn6rise</p>
<h3 id="触发器到触发器路径">触发器到触发器路径</h3>
<p>图5-15给出了两个触发器之间的数据路径和相应的时钟路径的示例：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e462041d110bb1106e02475f186975fe_720w.jpg" alt="图5-15"></p>
<p>UFF0 / Q上升沿的数据路径延迟为：</p>
<p>● Tck2qrise + Tn1rise + Tafall + Tn2fall + Tbfall + Tn3fall</p>
<p>输入PCLK上升沿的发起（launch）时钟路径延迟为：</p>
<p>● Tn4rise + T5rise + Tn5arise</p>
<p>输入PCLK上升沿的捕获（capture）时钟路径延迟为：</p>
<p>● Tn4rise + T5rise + Tn5brise + T6rise + Tn6rise</p>
<p>需要注意单元的单边性（unateness），因为边沿方向在通过单元时可能会改变（上升沿变下降沿，下降沿变上升沿）。</p>
<h2 id="多路径">多路径</h2>
<p>在任何两点之间，可以有很多路径。最长的路径是花费时间最多的路径，这也称为最差路径、较晚路径或最大路径。最短的路径是花费时间最少的路径，这也称为最佳路径、较早路径或最小路径。</p>
<p>请参见图5-16中时序弧的逻辑和延迟。两个触发器之间的最长路径是通过单元UBUF1、UNOR2和UNAND3，两个触发器之间的最短路径是通过单元UNAND3。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5e6e6b9243816f7b13df3e5d42e0d2e8_720w.jpg" alt="图5-16"></p>
<h2 id="裕量计算">裕量计算</h2>
<p>裕量（Slack）是信号需要到达时间（Required Time）与实际到达时间（Arrival Time）之差。在图5-17中，要求数据在7ns时保持稳定才能满足建立时间（setup）要求。但是，数据在1ns时就已稳定。因此，裕量为6ns（= 7ns-1ns）。</p>
<p><img src="https://pic3.zhimg.com/80/v2-94dbd3422854b3eef3c97b0d32a67422_720w.jpg" alt="图5-17"></p>
<p>假设数据需要到达的时间是从捕获触发器的建立时间获得的，则计算过程如下：</p>
<p>● 需要到达时间Required_Time = Tperiod - Tsetup = 10 - 3 = 7ns</p>
<p>● 实际到达时间Arrival_Time = 1ns</p>
<p>● 裕量Slack = Required_Time - Arrival_Time = 7 - 1 = 6ns</p>
<p>同样，如果两个信号之间的偏斜（skew）要求为100ps，并且测得的偏斜为60ps，则偏斜的裕量为40ps（= 100ps-60ps）。</p>
<h1 id="串扰噪声">串扰噪声</h1>
<blockquote>
<p>本章节介绍了纳米技术中ASIC的信号完整性（signal integrity）。</p>
</blockquote>
<p>● 在深亚微米（submicron）技术中，串扰（crosstalk）在设计的信号完整性中起着重要作用，串扰噪声是指两个或多个信号之间无意间的耦合。相关的噪声和串扰分析技术，即毛刺分析和串扰分析，可用于静态时序分析中，这将在本章中进行介绍。这些技术可用于使ASIC稳定运行。</p>
<h2 id="概述-1">概述</h2>
<p>噪声是指影响芯片正常运行的不良或无意的现象。在纳米技术中，噪声会影响功能或器件的时序。</p>
<p>为什么会有噪声和信号完整性？</p>
<p>噪声在深亚微米技术中起重要作用的原因有以下几个：</p>
<p>● 金属层数量的增加：例如，一个0.25um或0.3um的工艺具有四个或五个金属层，而在65nm和45nm工艺中增加到了十个或更多的金属层。章节四中的图4-1已描绘过了金属互连线的多层结构。</p>
<p>● 垂直占主导地位的金属长宽比：这意味着走线既细又高，与早期工艺几何形状中比较宽不同。因此，较大比例的电容是由侧壁耦合电容组成的，该侧壁耦合电容即为相邻信号线之间的走线间电容。</p>
<p>● 更高的布线密度：由于具有更精细的几何形状，更多的金属线可以在物理上紧密相邻。</p>
<p>● 大量的交互设备和互连线：在同一硅片面积中封装了更多的标准单元和信号走线，从而导致更多的交互。</p>
<p>● 由于频率变高而导致波形切换加快：快速的边沿速率会导致更多的电流尖峰以及对相邻走线和单元的更大耦合效应。</p>
<p>● 较低的电源电压：电源电压的降低使得噪声裕量较小。</p>
<p>在本章中，我们特别研究串扰噪声的影响。串扰噪声是指两个或多个信号之间无意识的耦合。串扰噪声是由芯片上相邻信号之间的电容耦合引起的，这会导致一个网络的高低电平切换，从而对耦合信号产生意外影响。受影响的信号称为受害者（victim），而产生影响的信号称为攻击者（aggressor）。请注意，两个耦合的网络可能会相互影响，并且通常一个网络可能既是受害者又是攻击者。</p>
<p>图6-1给出了几个信号走线耦合在一起的示例，图中描绘了提取得到的耦合互连的分布式RC以及几个驱动单元和扇出单元。在此示例中，网络N1和N2之间的耦合电容为Cc1 + Cc4，而Cc2 + Cc5是网络N2和N3之间的耦合电容。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3e31f7d2e79ac6b18a1552b654c0c487_720w.jpg" alt="图6-1"></p>
<p>广泛地讲，串扰会带来两种类型的噪声效应：毛刺（glitch）是指由于相邻攻击者电平切换的耦合而在稳定受害者信号上产生的噪声；以及由于受害者电平切换与攻击者电平切换的耦合而导致的时序变化（串扰增量延迟）。接下去的两小节将介绍这两种类型的串扰噪声。</p>
<h2 id="串扰毛刺分析">串扰毛刺分析</h2>
<h2 id="基础">基础</h2>
<p>一个稳定的信号网络可能会由于攻击者电平切换时通过耦合电容转移的电荷而产生毛刺（正或负）。图6-2所示为攻击者网络上升沿电平切换的串扰引起的正毛刺。将两个网络之间的耦合电容描绘为一个集总（lumped）电容Cc而不是分布式（distributed）耦合电容，这是为了简化下面的说明，而又不失一般性。在提取所得网表的典型表示中，耦合电容可以分布在多个段中，如之前6.1节中所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-8970cb121a6c5ce355303ea850cbc7b1_720w.jpg" alt="图6-2"></p>
<p>在此示例中，与非门单元UNAND0电平切换并为其输出网络充电（标记为“攻击者”）。一些电荷也通过耦合电容Cc转移到“受害”网络上，并导致正毛刺。转移的电荷量与攻击者和受害者之间的耦合电容Cc直接相关。向受害网络的接地电容上转移的电荷会导致该网络上的毛刺。由于通过驱动单元INV2的下拉（pull-down）结构转移了电荷，因此可以恢复受害网络上的稳定值（在这种情况下为低电平）。</p>
<p>毛刺的幅度取决于多种因素，其中一些因素是：</p>
<p>● 攻击者与受害者之间的耦合电容：耦合电容越大，毛刺的幅度越大。</p>
<p>● 攻击者网络的压摆（slew）：攻击者网络上的压摆越快，毛刺的幅度越大。通常，较快的压摆是因为驱动攻击者网络的单元具有较高的输出驱动强度。</p>
<p>● 受害者网络接地电容：受害者网络上的接地电容越小，毛刺的幅度越大。</p>
<p>● 受害者网络驱动强度：驱动受害者网络的单元输出驱动强度越小，毛刺的幅度越大。</p>
<p>总体而言，虽然受害者网络上的稳定值得以恢复，但由于以下原因，毛刺依然可能会影响电路的功能。</p>
<p>● 毛刺幅度可能足够大，以至于扇出单元可以将其视为不同的逻辑值（例如，受害者网络上的逻辑0可能在扇出单元处被视为逻辑1）。 这对于时序逻辑单元（触发器或锁存器）或存储器而言尤其重要，在这些单元中，时钟或异步置位/复位引脚上的毛刺会严重影响设计功能。类似地，锁存器输入端的数据信号出现毛刺会导致锁存不正确的数据，如果在输入数据时发生毛刺也可能造成灾难性的后果。</p>
<p>● 即使受害者网络不驱动时序逻辑单元，但也可能通过受害者网络的扇出传播较大的毛刺，并到达时序逻辑单元的输入，这将对设计造成灾难性的后果。</p>
<h2 id="毛刺种类">毛刺种类</h2>
<p>毛刺具有许多不同种类：</p>
<h3 id="上升和下降毛刺">上升和下降毛刺</h3>
<p>前面小节中的讨论说明了受害者网络上的上升毛刺（Rise Glitch），该受害者网络一直稳定在低电平。类似的情况是在稳定的高电平信号上出现负毛刺，电平下降切换的攻击者网络会在稳定的高电平信号上引起下降毛刺（Fall Glitch）。</p>
<h3 id="过冲和下冲毛刺">过冲和下冲毛刺</h3>
<p>当上升的攻击者网络与稳定高电平的受害者网络耦合时会发生什么呢？仍会有一个毛刺使受害者网络的电压值超过其稳定的高电平，这种毛刺称为过冲毛刺（Overshoot Glitch）。类似地，下降的攻击者网络与稳定低电平的受害者网络耦合时，会在受害者网络上引起下冲毛刺（Undershoot Glitch）。</p>
<p>由串扰引起的所有四种毛刺情况如图6-3所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-84d3a23e15fdcfe689831053fb36c304_720w.jpg" alt="图6-3"></p>
<p>如前面小节所述，毛刺由耦合电容、攻击者的压摆和受害者网络的驱动强度决定。计算毛刺基于的是攻击者网络转移的电流量、受害者网络的RC互连 、以及驱动受害者网络的单元的输出阻抗。详细的毛刺计算是基于库模型的：相关的噪声模型是第3章中描述的标准单元库模型的一部分，3.7节中的输出dc_current模型与单元的输出阻抗有关。</p>
<h2 id="毛刺阈值和传播">毛刺阈值和传播</h2>
<p>如何确定网络上的一个毛刺是否可以通过扇出单元传播？如前面的小节所述，由攻击者网络耦合引起的毛刺是否可以通过扇出单元传播，具体取决于扇出单元和毛刺属性（例如毛刺高度和毛刺宽度）。该分析可以基于直流（DC）或交流（AC）噪声阈值。直流噪声分析仅检查毛刺幅度并且比较保守，而交流噪声分析则检查其他属性，例如毛刺宽度和扇出单元输出负载。下面介绍了毛刺的直流和交流分析中使用的各种阈值标准。</p>
<h3 id="直流阈值">直流阈值</h3>
<p>直流噪声裕度（DC noise margin）是对毛刺幅度的一种检查，是指在确保正确逻辑功能的同时输入单元的直流噪声限制。例如，只要反相器单元的输入保持在VIL最大值以下，则输出就可以保持为高电平（高于VOH最小值）。类似地，只要输入保持在VIH最小值以上，反相器单元的输出就可以保持为低电平（低于VOL最大值）。这些限制是基于单元的DC传输特性获得的，并且可以记录在单元库中。</p>
<p>VOH是被视为逻辑1或高电平的输出电压范围，VIL是被视为逻辑0或低电平的输入电压范围，VIH是被视为逻辑1的输入电压范围，VOL是被视为逻辑0的输出电压范围。图6-4给出了一个反相器单元的输入-输出DC传输特性图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b9c860dc511b5edd11d062ee34225d85_720w.jpg" alt="图6-4"></p>
<p>VILmax和VIHmin也称为DC裕度极限，基于VIH和VIL的DC裕度是稳态噪声极限，因此可以用作确定毛刺是否会通过扇出单元传播的判断依据。直流噪声裕量限制适用于单元的每个输入引脚。通常，DC裕度限制对于上升毛刺（输入低电平）和下降毛刺（输入高电平）是分开独立的。直流裕度的模型可以指定为单元库描述的一部分。低于直流裕度极限的毛刺（例如，低于扇出引脚的VILmax的上升毛刺）不能通过扇出传播，无论毛刺的宽度如何。因此，保守的毛刺分析会检查（所有毛刺）峰值电压电平是否满足扇出单元的VIL和VIH电平。即使有任何毛刺产生，只要所有网络都能满足扇出单元的VIL和VIH电平，就可以得出结论：毛刺对设计的功能没有任何影响（因为毛刺不会导致输出发生任何变化）。</p>
<p>图6-5给出了DC裕量极限的示例。对于设计中的所有网络，DC噪声裕量可以固定为相同的极限值。可以设置最大可容忍的噪声（或毛刺）幅值，在此幅值之上，噪声可以通过单元传播到输出引脚。通常，此检查可保证毛刺电平小于VILmax或大于VIHmin。毛刺高度（height）通常表示为电源的百分比。 因此，如果将DC噪声裕量设置为30％，则表明任何高度大于电压摆幅30％的毛刺都将被标识为可能通过单元传播并影响设计功能的潜在毛刺。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d75bb82381ceb9fccd93225a7367ac34_720w.jpg" alt="图6-5"></p>
<p>并非所有幅度大于DC噪声裕量的毛刺都能改变单元的输出。毛刺的宽度也是确定毛刺是否会传播到输出的重要考虑因素。单元输入端的窄毛刺通常不会对单元输出产生任何影响。但是，DC噪声裕量仅使用恒定的最差高度值（worst-case value），而与信号噪声宽度无关。如图6-6中的示例提供了噪声抑制水平，该噪声抑制水平是单元噪声容限的非常保守的估计。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f645d90053d7f0ef2ffc9749d9f940cd_720w.jpg" alt="图6-6"></p>
<h3 id="交流阈值">交流阈值</h3>
<p>如以上小节所述，毛刺分析的DC裕度极限是保守的，因为是在最坏情况下分析设计的。DC裕量极限不检查毛刺宽度，也不会影响设计的正常运行。</p>
<p>在大多数情况下，设计可能无法通过保守的DC噪声分析。因此，必须针对毛刺宽度和单元的输出负载来验证毛刺的影响。通常，如果毛刺很窄或扇出单元的输出电容较大，则毛刺不会影响正常的功能运行。毛刺宽度和输出电容的影响都可以用扇出单元的惯性（inertia）来解释。通常，单级（single stage）的单元将阻止任何比通过该单元的延迟还要窄得多的输入毛刺。这是因为在毛刺较窄的情况下，毛刺会在扇出单元可以响应之前就结束了，因此，非常窄的毛刺对单元没有任何影响。由于输出负载会增加通过单元的延迟，因此增加输出负载的作用是使输入端的毛刺影响最小化，尽管这会增加单元延迟。</p>
<p>交流噪声抑制如图6-7所示（对于固定的输出电容）。黑色阴影区域表示良好或可接受的毛刺，因为这些毛刺太窄或太矮，或既窄又矮，因此对单元的功能行为没有影响。浅阴影区域表示不良或不可接受的毛刺，因为这些毛刺太宽或太高，或既宽又高，因此在单元输入端的这种毛刺会影响单元的输出。在毛刺较宽的极限情况下，毛刺阈值对应于DC噪声裕量，如图6-7所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ba1503ae8a047afd92d1acb32a6ee1e6_720w.jpg" alt="图6-7"></p>
<p>对于给定的单元，增加输出负载会增加噪声容限，因为这会增加惯性延迟和可以通过单元的毛刺宽度，下面的示例说明了这种现象。图6-8（a）所示为一个未加负载的反相器单元，其输入端具有正毛刺。输入毛刺高于单元的直流裕量，因此会在其输出端引起毛刺。图6-8（b）中为相同的反相器单元，其输出端有一定负载。此时输入端相同的输入毛刺会导致输出端的毛刺小很多。如果反相器单元的输出负载更高，如图6-8（c）所示，则反相器单元的输出将没有任何毛刺。因此，增加输出端的负载可使单元更加能够抵抗从输入端传播到输出端的噪声。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7a4620ea643c7ad056802ef5d8c4a7df_720w.jpg" alt="图6-8"></p>
<p>如上所述，可以忽略低于AC阈值的毛刺（图6-7中的AC噪声抑制区域），或者可以认为扇出单元不受这种毛刺的影响。AC阈值区域是取决于输出负载和毛刺宽度的。如第3章中所述，抗扰度模型（noise immunity model）包括上述AC噪声抑制的影响，3.7节中介绍的<strong>propagated_noise</strong>模型除了对通过单元的传播进行建模外，还包括了AC噪声阈值的影响。</p>
<p>如果毛刺大于AC阈值会怎么样？在毛刺幅度超过AC阈值的情况下，单元输入处的毛刺会在单元输出处产生另一种毛刺。输出毛刺的高度和宽度是输入毛刺的宽度、高度以及输出负载的函数。该信息在单元库中进行了表征，该单元库中包含了有关输出毛刺幅度和宽度的详细表格或函数，并且这些函数是输入引脚的毛刺幅度、毛刺宽度和输出引脚负载的函数。毛刺传播会在库中的<strong>propagated_noise</strong>模型进行描述，第3章中已详细介绍了<strong>propagated_noise</strong>模型。</p>
<p>我们在上述内容中，对扇出单元输出处的毛刺（以及毛刺的传播）进行了计算，并在扇出网络上进行了相同的检查，依此类推。</p>
<p>尽管我们在上面的讨论中使用了通用术语“毛刺”，但应注意，这分别适用于前一小节中提到的所有类型的毛刺：上升毛刺（由早期模型中的<strong>propagated_noise_high</strong>或<strong>noise_immunity_high</strong>建模），下降毛刺（由早期模型中的<strong>propagated_noise_low</strong>或<strong>noise_immunity_low</strong>建模），过冲毛刺（由<strong>noise_immunity_above_high</strong>建模）和下冲毛刺（由<strong>noise_immunity_below_low</strong>建模）。</p>
<p>总而言之，单元的不同输入对毛刺阈值有不同的限制，这是毛刺宽度和输出电容的函数，对于输入高电平（向低电平过渡的毛刺）和输入低电平（向高电平过渡的毛刺），这些限制是独立的。噪声分析检查毛刺峰值以及宽度，并分析是否可以忽略或是否可以传播到扇出。</p>
<h2 id="多攻击者的噪声累积">多攻击者的噪声累积</h2>
<p>图6-9介绍了由于单个攻击者网络电平切换而在受害者网络上引入串扰毛刺的耦合。通常，受害者网络可以电容耦合到许多网络。当多个网络同时电平切换时，由于有多个攻击者，对受害者网络的串扰耦合噪声影响会更加严重。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2112fee13a615a1f0f8018f67e265e09_720w.jpg" alt="图6-9"></p>
<p>大多数由多个攻击者网络引起的耦合分析都考虑了每个攻击者网络引起的毛刺效应，并计算了对受害者网络的累积效应，这看起来很保守，但这确实表明了受害者网络的最坏情况。另一种方法是使用RMS（均方根）方法，使用RMS方法时，是通过单个攻击者网络引起的毛刺的均方根来计算受害者网络的毛刺幅度的。</p>
<h2 id="多攻击者的时序相关性">多攻击者的时序相关性</h2>
<p>对于由多个攻击者引起的串扰，分析时必须考虑攻击者网络的时序相关性，并确定多个攻击者是否可以同时电平切换。STA会从攻击者网络的时序窗口获取此信息。在时序分析过程中，将获得网络的最早（earliest）和最迟（latest）电平切换时间，这些时间表示网络可以在一个时钟周期内切换的时序窗口。电平切换窗口（上升和下降）提供了有关攻击者网络是否可以一起切换的必要信息。</p>
<p>根据多个攻击者是否可以同时电平切换，将决定是否要合并单个攻击者对受害者网络带来的毛刺。第一步，毛刺分析为每个潜在的攻击者分别计算四种毛刺（上升、下降、下冲和过冲）。下一步将来自各个单独攻击者的毛刺带来的影响合并在一起，多个攻击者可以针对每种不同类型的毛刺分别进行组合。例如，考虑与攻击者网络A1、A2、A3和A4耦合的受害者网络V。在分析过程中，可能A1、A2和A4会引起上升和过冲毛刺，而只有A2和A3会造成下冲和下降毛刺。</p>
<p>考虑另一个示例，当四个攻击者网络中任何一个电平切换时，都会引起上升毛刺。如图6-10所示为时序窗口和每个攻击者网络引起的毛刺幅度。基于时序窗口，毛刺分析确定了可能导致最大毛刺的最坏情况的攻击者组合。在此示例中，电平切换窗口可分为四个区域，其中每个区域都显示了可能进行电平切换的攻击者网络，每个攻击者所引起的毛刺幅度也如图6-10所示。区域1中攻击者网络A1和A2会进行电平切换，这可能导致毛刺幅度为0.21（= 0.11 + 0.10）。区域2中攻击者网络A1、A2和A3会进行电平切换，这可能导致毛刺幅度为0.30（= 0.11 + 0.10 + 0.09）。区域3中攻击者网络A1和A3会进行电平切换，这可能导致毛刺幅度为0.20（= 0.11 + 0.09）。区域4中攻击者网络A3和A4会进行电平切换，可导致0.32（= 0.09 + 0.23）的毛刺幅度。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4f50042b6346c70c3da90ed3d390ceae_720w.jpg" alt="图6-10"></p>
<p>因此，区域4具有0.32这个情况最差的毛刺幅度。请注意，不使用时序窗口进行的分析将预测总毛刺幅度为0.53（= 0.11 + 0.10 + 0.09 + 0.23），这可能过于悲观。</p>
<h2 id="多攻击者的功能相关性">多攻击者的功能相关性</h2>
<p>对于多个攻击者，时序窗口通过考虑不同网络可能进行电平切换的不同时间段来减少分析中的悲观度。另外，要考虑的另一个因素是各种信号之间的功能相关性。例如，扫描控制（scan control）信号仅在扫描模式（scan mode）下电平切换，并且在执行设计的正常功能或任务模式时保持稳定。因此，在功能模式期间，扫描控制信号不会在其它任何信号上引起毛刺，扫描控制信号只有在扫描模式期间才可能成为攻击者。在某些情况下，测试时钟和功能时钟是互斥的，因此只有在关闭功能时钟时，测试时钟才可以在测试期间处于有效状态。在这些设计中，由测试时钟控制的逻辑和由功能时钟控制的逻辑创建了两组独立且互不相干的攻击者。在这种情况下，测试时钟控制的攻击者无法与功能时钟控制的其它攻击者结合使用，以进行最坏情况的噪声计算。功能相关性的另一个示例是两个攻击者彼此互补（逻辑相反）。在这种情况下，信号及其互补信号不可能在同一方向上进行电平切换以进行串扰噪声计算。</p>
<p>图6-11中所示为网络N1与其它三个网络N2、N3和N4耦合的示例。在功能相关性分析中，需要考虑网络的功能。假设网络N4是一个常数（例如，一个模式设置网络），因此尽管其与网络N1耦合但不能成为网络N1的攻击者。假设网络N2是调试总线（debug bus）的一部分，其在功能模式时处于稳定状态。因此，网络N2也不可能成为网络N1的攻击者。假设网络N3传输功能数据，则只能将网络N3视为网络N1的潜在攻击者。</p>
<p><img src="https://pic3.zhimg.com/80/v2-eb51662dcd28250d2575f9849c3f199a_720w.jpg" alt="图6-11"></p>
<h2 id="串扰延迟分析">串扰延迟分析</h2>
<h2 id="基础-1">基础</h2>
<p>纳米设计中典型网络的电容提取包括许多相邻网络的影响，其中一些是接地电容，而其它一些则来自其它信号网络的一部分走线。接地电容和信号间电容如图6-1所示。在基本延迟计算时（不考虑任何串扰），所有这些电容均被视为网络总电容的一部分。当相邻网络稳定（或电平不切换）时，信号间电容也可以视为接地电容。当一个相邻网络电平切换时，通过耦合电容的充电电流会影响该网络的时序。网络间的等效电容会根据攻击者网络电平切换的方向而变大或变小，下面的一个简单示例对此进行了说明。</p>
<p>从图6-12中可以看出，网络N1通过电容Cc耦合到相邻的网络（标记为攻击者网络），并通过电容Cg接地。此示例假定网络N1在输出端具有上升电平过渡，并根据攻击者网络是否同时进行电平切换来考虑不同的情况。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f1ff55eb74bca4af0ed258f13955384f_720w.jpg" alt="图6-12"></p>
<p>各种情况下，驱动单元所需的电容电荷可能会有所不同，如下所述。</p>
<p>● 攻击者网络处于稳定状态：在这种情况下，网络N1的驱动单元将提供电荷使Cg和Cc充电至Vdd。因此，该网络的驱动单元提供的总电荷为（Cg + Cc）* Vdd。这种情况可以进行基本的延迟计算，因为在这种情况下未考虑来自攻击者网络的串扰。表6-13中为此情况下在网络N1电平切换前后Cg和Cc中的电荷量：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e6e2056f82891ac770e9597635fdf51d_720w.jpg" alt="表6-13"></p>
<p>● 攻击者网络朝同方向切换电平： 在这种情况下，往同方向电平切换的攻击者网络可以起辅助驱动单元的作用。如果攻击者网络同时以相同的压摆（相同的过渡时间）进行电平切换，则驱动单元提供的总电荷仅为（Cg * Vdd ）。如果攻击者网络的压摆比N1网络压摆更快，则所需的实际电荷可能甚至小于（Cg * Vdd），因为攻击者网络也可以为Cg提供充电电流。因此，在攻击者朝相同方向切换电平时，来自驱动单元的所需电荷会小于表6-13中描述的攻击者处于稳定状态时的所需电荷。因此，当攻击者网络朝相同方向切换电平时会导致网络N1切换电平的延迟更短， 延迟的减少被标记为负串扰延迟（negative crosstalk delay）。这种情况请参见表6-14，通常会在进行最小路径分析时考虑此情况。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a8c5f1709b3fdeac19f9aaaf153e5fe9_720w.jpg" alt="表6-14"></p>
<p>● 攻击者网络朝相反方向切换电平：在这种情况下，耦合电容需要从-Vdd充电到Vdd。因此在电平切换前后，耦合电容上的电荷变化量为（2 * Cc * Vdd），网络N1的驱动单元以及攻击者网络均需要提供额外的电荷。这种情况会导致网络N1切换电平的延迟更大，延迟的增加被标记为正串扰延迟（positive crosstalk delay）。这种情况请参阅表6-15，通常会在进行最大路径分析时考虑此情况。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c4af651bc64e1931631de43c852d6e54_720w.jpg" alt="表6-15"></p>
<p>上面的示例说明了在各种情况下电容Cc的充电以及它如何影响网络N1切换电平的延迟。该示例仅考虑了网络N1处的上升过渡，但是类似的分析也适用于下降过渡。</p>
<h2 id="正负串扰">正负串扰</h2>
<p>基本延迟计算（不考虑任何串扰）假定驱动单元为网络总电容Ctotal（= Cground + Cc）的轨到轨（rail-to-rail）过渡提供了所有必要的电荷。如前一小节所述，当耦合（攻击者）网络和受害者网络朝相反方向切换电平时，耦合电容Cc所需的电荷会更大。朝相反方向电平切换的攻击者网络增加了来自受害者网络驱动单元的所需电荷量，并且增加了驱动单元和受害者网络互连的延迟。</p>
<p>类似地，当耦合（攻击者）网络和受害者网络朝相同方向切换电平时，Cc上的电荷在受害者和攻击者切换电平前后都保持不变。这减少了来自受害者网络驱动单元的所需电荷，并且减少了驱动单元和受害者网络互连的延迟。</p>
<p>综上所述，同时切换受害者和攻击者的电平会影响受害者网络过渡的时序。根据攻击者网络电平切换方向的不同，串扰延迟影响可能为正（减慢受害者网络过渡时间）或为负（加快受害者网络过渡时间）。</p>
<p>正串扰延迟影响的示例如图6-16所示。受害者网络在下降的同时，攻击者网络却在上升。攻击者网络向相反方向的电平切换会增加受害者网络的延迟。正串扰（positive crosstalk）会影响驱动单元以及互连线，这两者的延迟都会增加。</p>
<p><img src="https://pic2.zhimg.com/80/v2-318e2d524f3b4214402f793914f26a1d_720w.jpg" alt="图6-16"></p>
<p>串扰延迟为负的情况如图6-17所示。攻击者网络与受害者网络同时上升，攻击者网络与受害者网络朝相同方向的电平切换可减少受害者网络的延迟。如前所述，负串扰（negative crosstalk）会影响驱动单元和互连线的时序，两者的延迟都会减小。</p>
<p><img src="https://pic4.zhimg.com/80/v2-ad2d3a887b5136f406710606060b378f_720w.jpg" alt="图6-17"></p>
<p>注意，最差的正串扰延迟和最差的负串扰延迟会分别针对上升和下降延迟进行计算。一般来说，由于串扰而导致的最大上升时间、最小上升时间、最大下降时间、最大下降时间延迟的攻击者是不同的，这将在下面的小节中进行介绍。</p>
<h2 id="多攻击者的累积效应">多攻击者的累积效应</h2>
<p>在多攻击者的串扰延迟分析中将累积由每个攻击者串扰带来的影响，这类似于6.2节中介绍的串扰毛刺分析。当多个网络同时进行电平切换时，对受害者网络的串扰延迟影响将由于多攻击者而变得更加复杂。</p>
<p>大多数由于多攻击者而导致的耦合分析都增加了每个攻击者的增量影响，并计算了对受害者网络的累积影响。这可能看起来很保守，但是它确实表明了受害者网络最差情况的串扰延迟。</p>
<p>与多攻击者时的串扰毛刺分析相似，也可以使用均方根（RMS）法，这种方法的悲观度不如直接累加每个攻击者带来的影响。</p>
<h2 id="攻击者与受害者网络的时序相关性">攻击者与受害者网络的时序相关性</h2>
<p>串扰延迟分析时序相关的处理在概念上类似于6.2节中介绍的串扰毛刺分析时序相关内容。只有当攻击者可以与受害者网络同时切换电平时，串扰才会影响受害者的延迟，这是使用攻击者和受害者网络的时序窗口确定的。如6.2节所述，时序窗口表示网络可以在一个时钟周期内切换的最早（earliest）和最迟（latest）时间。如果攻击者和受害者网络的时序窗口重叠，则可以计算出串扰对延迟的影响。对于多攻击者，也将类似地分析多个攻击者的时序窗口。计算各种时序区域的可能影响，并考虑串扰延迟影响最严重的时序区域，以进行延迟分析。</p>
<p>考虑下面的示例，其中三个攻击者网络可能会影响受害者网络的时序。攻击者网络（A1，A2，A3）与受害者网络（V）电容耦合，并且它们的时序窗口与受害者网络的时序窗口有重叠部分。图6-18中为时序窗口以及每个攻击者可能造成的串扰延迟影响。基于时序窗口，串扰延迟分析可以确定引起最大串扰延迟影响的攻击者组合。在此示例中，时序窗口可分为三个重叠区域，每个区域中都有不同的攻击者进行电平切换。区域1中A1和A2进行电平切换，这可能导致串扰延迟影响为0.26（= 0.12 + 0.14）。区域2中仅A1进行电平切换，带来的串扰延迟影响为0.14。区域3中仅A3进行电平切换，带来的串扰延迟影响为0.23。因此，区域1的串扰延迟影响0.26为最坏的情况。</p>
<p><img src="https://pic2.zhimg.com/80/v2-555c9d81bb9f8ac2ca226bd150420fdd_720w.jpg" alt="图6-18"></p>
<p>如前所述，串扰延迟分析将分别计算四种类型的串扰延迟。串扰延迟的四种类型是：正上升延迟（上升沿提前到达）、负上升延迟（上升沿滞后到达）、正下降延迟和负下降延迟。通常，在这四种情况下，网络可以具有不同的攻击者组合。例如，受害者网络具有攻击者网络A1、A2、A3和A4。在串扰延迟分析过程中，A1、A2、A4可能对正上升和负下降延迟有影响，而A2和A3对负上升和正下降延迟有影响。</p>
<h2 id="攻击者与受害者网络的功能相关性">攻击者与受害者网络的功能相关性</h2>
<p>除时序窗口外，串扰延迟计算还会考虑各种信号之间的功能相关性。例如，扫描控制信号仅在扫描模式期间进行电平切换，并且在执行设计的功能或任务模式期间保持稳定。因此，在功能模式期间，扫描控制信号不可能成为攻击者。扫描控制信号只能在扫描模式期间成为攻击者，在这种情况下，扫描控制信号不能与其他功能信号组合在一起，以进行最差情况的噪声计算。</p>
<p>功能相关性的另一个示例是两个攻击者互补（逻辑相反）的情况。在这种情况下，信号及其互补信号永远都不可能朝相同方向上切换电平以进行串扰噪声计算。可以利用这种类型的功能相关性信息，来确保仅实际上可以一起切换电平的信号作为攻击者，从而使串扰分析结果不会过于悲观。</p>
<h2 id="使用串扰延迟进行时序检查">使用串扰延迟进行时序检查</h2>
<p>需要为设计中的每个单元和互连线计算以下四种类型的串扰延迟影响：</p>
<p>● 正上升延迟（Positive rise delay）：上升沿提前到达</p>
<p>● 负上升延迟（Negative rise delay）：上升沿滞后到达</p>
<p>● 正下降延迟（Positive fall delay）：下降沿提前到达</p>
<p>● 负下降延迟（Negative fall delay）：下降沿滞后到达</p>
<p>然后，在时序分析时将串扰延迟影响用于最大和最小路径的时序检查（建立时间和保持时间检查），对数据发起和捕获触发器的时钟路径处理方式是不同的。本节将介绍建立时间和保持时间检查时对数据路径和时钟路径的详细分析。</p>
<h2 id="建立时间分析">建立时间分析</h2>
<p>带有串扰分析的STA可以通过最差情况下数据路径和时钟路径的串扰延迟来验证设计的时序。考虑图6-19所示的逻辑电路，其中串扰可能会沿着数据路径和时钟路径在各种网络处发生。建立时间检查的最差条件是发起时钟（launch clock）路径和数据路径都具有正串扰，而捕获时钟（capture clock）路径具有负串扰。发起时钟路径和数据路径上的正串扰影响会延迟数据到达捕获触发器的时间。此外，捕获时钟路径上的负串扰影响会导致捕获触发器的时钟有效沿过早地到达。</p>
<p><img src="https://pic1.zhimg.com/80/v2-548d7f7f2e9cf4e4733275af8f3a572c_720w.jpg" alt="图6-19"></p>
<p>基于上述介绍，建立时间（或最大路径）分析将假定：</p>
<p>● 发起时钟路径出现正串扰延迟，因此发起数据较迟；</p>
<p>● 数据路径出现正串扰延迟，因此数据到达目的地需要更长的时间；</p>
<p>● 捕获时钟路径的串扰延迟为负，因此捕获触发器会更早捕获数据。</p>
<p>由于建立时间检查的发起和捕获时钟沿是不同的（通常间隔一个时钟周期），所以公共时钟路径（common clock path）对于发起和捕获时钟沿可能具有不同的串扰影响。</p>
<h2 id="保持时间分析">保持时间分析</h2>
<p>STA的最差情况保持时间（或最小路径）分析类似于前面小节中介绍的最差情况建立时间分析。根据图6-19所示的逻辑电路，当发起时钟路径和数据路径均具有负串扰且捕获时钟路径具有正串扰时，会发生最差的保持时间检查条件。发起时钟路径和数据路径上的负串扰影响导致数据提前到达捕获触发器。此外，捕获时钟路径上的正串扰会导致捕获触发器的时钟有效沿延迟到达。</p>
<p>保持时间分析与建立时间分析对公共时钟路径上的串扰分析存在一个重要的区别：在保持时间分析中，发起和捕获时钟边沿通常是同一个边沿，通过公共时钟路径部分的时钟沿不会对发起时钟路径和捕获时钟路径具有不同的串扰影响，因此，最差情况的保持时间分析会从公共时钟路径中消除串扰影响。</p>
<p>因此，具有串扰的STA最差情况保持时间（或最小路径）分析将假定：</p>
<p>● 发起时钟（不包括公共时钟路径部分）的串扰延迟影响为负，因此可以较早地发起数据；</p>
<p>● 数据路径的串扰延迟影响为负，因此数据会较早到达目的地；</p>
<p>● 捕获时钟（不包括公共时钟路径部分）的串扰延迟影响为正，因此捕获触发器会较迟地捕获数据。</p>
<p>如上所述，在保持时间分析中不考虑对时钟树公共路径部分的串扰影响，仅针对时钟树的非公共路径部分计算发起时钟的正串扰影响和捕获时钟的负串扰影响。在用于保持时间分析的STA报告中，公共时钟路径可能会显示发起时钟路径和捕获时钟路径具有不同的串扰影响。但是，来自公共时钟路径的串扰影响会被作为公共路径悲观度单独减去。10.1节中将介绍一个STA报告中常见的减去路径悲观度的示例。</p>
<p>如前面小节所述，建立时间分析涉及时钟的两个不同边沿，这些边沿可能会在时序上受到不同影响。因此，在建立时间分析中，发起和捕获时钟路径均考虑了公共路径的串扰影响。</p>
<p>时钟信号至关重要，因为时钟树上的任何串扰都直接转化为时钟抖动（jitter）并影响设计的性能。因此，应该采取特殊的方法来减少时钟信号上的串扰。常见的避免噪声的方法是时钟树的屏蔽（shield），这将在6.6节中进行详细讨论。</p>
<h2 id="计算复杂度">计算复杂度</h2>
<p>大型的纳米级设计通常过于复杂，以至于无法在合理的时间内对每个耦合电容进行分析。典型网络的寄生参数提取包含了许多相邻信号的耦合电容。大型设计通常需要对寄生参数提取、串扰延迟分析和串扰毛刺分析进行适当的设置。选择这些设置可为分析提供可以接受的准确度，同时确保对CPU的要求仍然可行。本节介绍了可用于分析大型纳米级设计的一些技术。</p>
<h3 id="分层设计与分析">分层设计与分析</h3>
<p>4.5节已介绍了可用于验证大型设计的分层方法（Hierarchical Methodology），类似的方法也可用于降低提取寄生参数和进行分析的复杂性。</p>
<p>对于大型设计，运行（run）一次通常无法实现寄生参数的提取。每个层级模块的寄生参数可以分别提取，这又需要在设计实现的时候使用了分层设计方法。这意味着在分层模块内部的信号与模块外部的信号之间不存在耦合，这可以通过不在模块边界上布线或通过在模块上添加屏蔽层来实现。另外，信号网络不应该布在靠近模块边界的地方，并且任何布线网络都应在靠近模块边界的地方进行屏蔽保护，这样可以避免与其他模块的网络耦合。</p>
<h3 id="耦合电容的过滤">耦合电容的过滤</h3>
<p>即使对于中等规模的模块，寄生参数通常也会包括大量非常小的耦合电容。小耦合电容可以在提取过程中或在分析过程中过滤掉。</p>
<p>这样的过滤是基于以下原则的：</p>
<p>● 较小的值：在串扰或噪声分析中，可以忽略非常小的耦合电容，例如低于1fF。在提取过程中，数值较小的耦合电容可以视为接地电容。</p>
<p>● 耦合比：耦合对受害者网络的影响是基于耦合电容相对于受害者网络总电容的相对值。具有较小耦合比（例如低于0.001）的攻击者网络可以从串扰延迟分析或串扰毛刺分析中排除。</p>
<p>● 合并小型攻击者：可以将影响很小的多个攻击者映射为一个较大的虚拟攻击者。这可能有点悲观，但可以简化分析。可以通过切换攻击者的子集来缓解一些悲观度，攻击者的确切子集可以通过统计方法来确定。</p>
<h2 id="噪声避免技术">噪声避免技术</h2>
<p>前面的小节介绍了串扰效应的影响和分析。在本小节中，我们将介绍一些可以在物理设计阶段使用的噪声避免技术。</p>
<p>● 屏蔽（Shielding）：此方法要求将屏蔽线放在关键信号的两侧，屏蔽线已连接到了电源或地。关键信号的屏蔽确保了关键信号没有有效的攻击者，因为在同一金属层中最相邻的走线是处于固定电位的屏蔽走线。尽管在不同的金属层中可能存在来自布线的某些耦合，但是大多数耦合电容还是由于同一层中的电容耦合引起的。由于不同金属层（上方和下方）通常会正交走线，这样跨层的电容耦合会最小化。因此，将屏蔽线放置在同一金属层中可确保关键信号的耦合最小。如果由于布线拥塞而无法使用接地或电源线进行屏蔽，则可以把在功能模式下保持不变、电平切换不频繁的信号（如扫描控制信号）布线为关键信号的直接相邻信号。这些屏蔽方法可确保不会由于相邻网络的电容耦合而产生串扰。</p>
<p>● 线距（Wire spacing）：这减少了与相邻网络的耦合。</p>
<p>● 快速压摆（Fast slew rate）：网络上的压摆较快表示该网络不易受到串扰的影响。</p>
<p>● 保持良好的稳定电源（Maintain good stable supply）：这对于串扰而言并不重要，但对于最大程度地减少由于电源变化而引起的抖动至关重要。由于电源上的噪声，可能会在时钟信号上引入大量噪声。应该添加足够的去耦电容，以最大程度地减少电源上的噪声。</p>
<p>● 保护环（Guard ring）：衬底（substrate）上的保护环（或双重保护环）有助于将关键的模拟电路与数字噪声隔离开来。</p>
<p>● 深n阱（Deep n-well）：与上面类似，因为在模拟部分具有深n阱，有助于防止噪声耦合到数字部分。</p>
<p>● 隔离块（Isolating a block）：在分层设计流程中，可以将布线晕圈（halos）添加到块的边界；此外，还可以将隔离缓冲器（isolation buffers）添加到块的每个IO中。</p>
<h1 id="配置sta环境">配置STA环境</h1>
<blockquote>
<p>本章节介绍了如何为静态时序分析配置环境。</p>
</blockquote>
<p>● 正确的约束对于分析STA结果很重要，只有准确指定设计环境，STA分析才能够识别出设计中的所有时序问题。STA的准备工作包括设置时钟、指定IO时序特性以及指定伪路径和多周期路径。在继续学习下一章的时序验证之前，请务必全面了解本章节。</p>
<h2 id="什么是sta环境">什么是STA环境</h2>
<p>大部分数字设计是同步的，从前一个时钟周期计算出的数据在时钟有效沿上被锁存在触发器中。请考虑图7-1所示的典型同步设计，假定待分析设计（DUA）会与其它同步设计交互。这意味着DUA从触发器接收数据，并将数据输出到DUA外部的另一个触发器。</p>
<p><img src="https://pic2.zhimg.com/80/v2-aa744d6ffbef6109377a3eccda7e218d_720w.jpg" alt="图7-1"></p>
<p>为了对这种设计执行STA，需要指定触发器的时钟、以及进入设计和退出设计的所有路径的时序约束。</p>
<p>图7-1中的例子假定只有一个时钟，并且C1、C2、C3、C4和C5代表组合逻辑块，其中C1和C5在待分析设计之外。</p>
<p>在典型的设计中，可能存在多个时钟，且许多路径都会从一个时钟域到另一个时钟域。以下各小节将介绍在这种情况下如何配置环境。</p>
<h2 id="指定时钟">指定时钟</h2>
<p>要定义时钟，我们需要提供以下信息：</p>
<p>● 时钟源（Clock source）：它可以是设计的端口，也可以是设计内部单元的引脚（通常是时钟生成逻辑的一部分）。</p>
<p>● 周期（Period）：时钟的周期。</p>
<p>● 占空比（Duty cycle）：高电平持续时间（正相位）和低电平持续时间（负相位）。</p>
<p>● 边沿时间（Edge times）：上升沿和下降沿的时刻。</p>
<p>基本定义如图7-2所示。通过定义时钟，所有内部时序路径（触发器到触发器路径）都将受到约束，这意味着可以仅使用时钟约束来分析所有内部路径。时钟约束指定触发器到触发器的路径必须占用一个周期，稍后我们将介绍如何放宽这一要求（一个周期时间）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-6e1ad5dbf33e4c8c136550a31b319aef_720w.jpg" alt="图7-2"></p>
<p>以下是一个基本的时钟约束规范：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> SYSCLK <strong>-period</strong> 20 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> SCLK]</p>
<p>该时钟名为SYSCLK，并在端口SCLK上定义。SYSCLK的周期指定为20个单位，如果未指定，默认时间单位为纳秒（通常，时间单位会在技术库中进行指定）。<strong>waveform</strong>中的第一个自变量指定出现上升沿的时刻，第二个自变量指定出现下降沿的时刻。</p>
<p><strong>waveform</strong>选项中可以指定任意数量的边沿。但是，所有边沿必须在一个周期内。边沿时刻从零时刻之后的第一个上升沿开始，然后是下降沿，然后再是上升沿，以此类推，这意味着<strong>waveform</strong>列表中的所有时刻值必须单调增加。</p>
<p>● <strong>-waveform</strong> {time_rise time_fall time_rise time_fall ...}</p>
<p>另外，必须指定偶数个边沿时刻。<strong>waveform</strong>选项将指定一个时钟周期内的波形，然后不断重复。</p>
<p>如果未指定任何<strong>waveform</strong>选项，则默认值为：</p>
<p>● <strong>-waveform</strong> {0，period/2}</p>
<p>以下是一个没有使用<strong>waveform</strong>选项的时钟约束示例（见图7-3）。</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 5 [<strong>get_ports SCAN_CLK</strong>]</p>
<p>在此约束中，由于未指定<strong>-name</strong>选项，因此时钟的名称与端口的名称相同，即SCAN_CLK。</p>
<p><img src="https://pic3.zhimg.com/80/v2-dbbcd77f39398830ea5cf2fd2eb25bde_720w.jpg" alt="图7-3"></p>
<p>以下是时钟约束的另一个示例，其中波形的边沿在一个周期的中间位置（见图7-4）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d0c02747fa5844119df9c7e7195a1874_720w.jpg" alt="图7-4"></p>
<p>● <strong>create_clock</strong> <strong>-name</strong> BDYCLK <strong>-period</strong> 15 <strong>-waveform</strong> {5 12} [<strong>get_ports GBLCLK</strong>]</p>
<p>时钟的名称为BDYCLK，并且在端口GBLCLK上定义。实际上，最好将时钟名称与端口名称保持一致。</p>
<p>以下是另一些时钟约束示例：</p>
<p><img src="https://pic3.zhimg.com/80/v2-516fe313698455d1d526b37d09993dc6_720w.jpg" alt="图7-5"></p>
<p>上图7-5（a）中的时钟约束为：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 10 <strong>-waveform</strong> {5 10} [<strong>get_ports</strong> FCLK]</p>
<p>上图7-5（b）中的时钟约束为：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 125 <strong>-waveform</strong> {100 150} [<strong>get_ports</strong> ARMCLK]</p>
<p><img src="https://pic2.zhimg.com/80/v2-6c5dab5ba4ba161baf81c50755916381_720w.jpg" alt="图7-6"></p>
<p>上图7-6（a）中的时钟约束为：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 1.0 <strong>-waveform</strong> {0.5 1.375} [<strong>get_ports</strong> MAIN_CLK]</p>
<p>上图7-6（b）中的时钟约束为：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 1.2 <strong>-waveform</strong> {0.3 0.4 0.8 1.0} [<strong>get_ports</strong> JTAG_CLK]</p>
<p>还有一些时钟约束如下：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 1.27 <strong>-waveform</strong> {0 0.635} [<strong>get_ports</strong> clk_core]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> TEST_CLK <strong>-period</strong> 17 <strong>-waveform</strong> {0 8.5} <strong>-add</strong> [<strong>get_ports</strong> ip_io_clk[0]]</p>
<p>除了上述属性外，还可以在时钟源处指定过渡时间（压摆）。在某些情况下，例如顶层的输入端口或某些PLL的输出端口，工具无法自动计算出过渡时间。在这种情况下，在时钟源处显式地指定过渡时间很有用，这可以使用<strong>set_clock_transition</strong>命令来指定。</p>
<p>● <strong>set_clock_transition</strong> <strong>-rise</strong> 0.1 [<strong>get_clocks</strong> CLK_CONFIG]</p>
<p>● <strong>set_clock_transition</strong> <strong>-fall</strong> 0.12 [<strong>get_clocks</strong> CLK_CONFIG]</p>
<p>这个约束仅适用于理想时钟，一旦构建了时钟树就将其忽略，因为此时将会使用时钟引脚上的实际过渡时间。如果在输入端口上定义了时钟，也可以使用<strong>set_input_transition</strong>命令（参见7.7节）来约束时钟的压摆。</p>
<h2 id="时钟不确定度">时钟不确定度</h2>
<p>可以使用<strong>set_clock_uncertainty</strong>约束来指定时钟周期的时序不确定度（uncertainty），该不确定度可用于对可能会减少有效时钟周期的各种因素进行建模。 这些因素可能是时钟抖动（jitter）以及可能需要在时序分析中考虑的任何其它悲观度。</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-setup</strong> 0.2 [<strong>get_clocks</strong> CLK_CONFIG]</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-hold</strong> 0.05 [<strong>get_clocks</strong> CLK_CONFIG]</p>
<p>注意，建立时间检查的时钟不确定度将减少可用的有效时钟周期，如图7-7所示。对于保持时间检查，时钟不确定度将用作需要满足的额外时序裕量。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f96ee253d5ab4344d609d25ead44dd52_720w.jpg" alt="图7-7"></p>
<p>以下命令可用于指定跨时钟边界路径上的时钟不确定度，称为时钟间不确定度（inter-clock uncertainty）。</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> VIRTUAL_SYS_CLK <strong>-to</strong> SYSCLK <strong>-hold</strong> 0.05</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> VIRTUAL_SYS_CLK <strong>-to</strong> SYSCLK <strong>-setup</strong> 0.3</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> SYS_CLK <strong>-to</strong> CFG_CLK <strong>-hold</strong> 0.05</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> SYS_CLK <strong>-to</strong> CFG_CLK <strong>-setup</strong> 0.1</p>
<p>图7-8中为两个不同时钟域SYS_CLK和CFG_CLK之间的路径。根据上述时钟间不确定度的约束，将100ps用作建立时间检查的不确定度，将50ps用作保持时间检查的不确定度。</p>
<p><img src="https://pic3.zhimg.com/80/v2-12998af38a47e4142c6e20f5e6b4afce_720w.jpg" alt="图7-8"></p>
<h2 id="时钟延迟">时钟延迟</h2>
<p>可以使用<strong>set_clock_latency</strong>命令指定时钟的延迟。</p>
<p>● <strong>set_clock_latency</strong> 1.8 <strong>-rise</strong> [<strong>get_clocks</strong> MAIN_CLK]</p>
<p>● <strong>set_clock_latency</strong> 2.1 <strong>-fall</strong> [<strong>all_clocks</strong>]</p>
<p>时钟延迟有两种类型：网络延迟（network latency）和源延迟（source latency）。网络延迟是指从时钟定义点（create_clock）到触发器时钟引脚的延迟。源延迟，也称为插入延迟（insertion delay），是指从时钟源到时钟定义点的延迟，源延迟可能代表片上或片外延迟，图7-9展示了这两种情况。触发器时钟引脚上的总时钟延迟是源延迟和网络延迟之和。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c7004cb35ecb6cc694c7a0fb8573f446_720w.jpg" alt="图7-9"></p>
<p>以下是一些指定源延迟和网络延迟的命令示例：</p>
<p>● <strong>set_clock_latency</strong> 0.8 [<strong>get_clocks</strong> CLK_CONFIG]</p>
<p>● <strong>set_clock_latency</strong> 1.9 <strong>-source</strong> [<strong>get_clocks</strong> SYS_CLK]</p>
<p>● <strong>set_clock_latency</strong> 0.851 <strong>-source</strong> <strong>-min</strong> [<strong>get_clocks</strong> CFG_CLK]</p>
<p>● <strong>set_clock_latency</strong> 1.322 <strong>-source</strong> <strong>-max</strong> [<strong>get_clocks</strong> CFG_CLK]</p>
<p>源延迟和网络延迟之间的一个重要区别是：一旦为设计建立了时钟树，就可以忽略网络延迟（假设指定了<strong>set_propagated_clock</strong>命令）。但是，即使在建立时钟树之后，源延迟也会保留。网络延迟是在进行时钟树综合（Clock Tree Synthesis）之前对时钟树延迟的估计值。在时钟树综合完成后，从时钟源到触发器时钟引脚的总时钟延迟是源延迟加上时钟树从时钟定义点到触发器的实际延迟。</p>
<p>下一节将介绍衍生时钟（generated clocks），7.9节将介绍虚拟时钟（virtual clocks）。</p>
<h2 id="衍生时钟">衍生时钟</h2>
<p>衍生时钟是从主时钟（master clock）派生而来的时钟，主时钟是指使用<strong>create_clock</strong>命令定义的时钟。</p>
<p>在基于主时钟的设计中生成一个新时钟时，可以将这个新时钟定义为衍生时钟。例如，如果有一个时钟的三分频电路，则将在该电路的输出处定义一个衍生时钟。由于STA不知道分频逻辑输出的时钟周期已更改，更重要的是新的时钟周期是多少，因此需要定义衍生时钟。图7-10给出了衍生时钟示例，该时钟是主时钟CLKP的2分频。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP 10 [<strong>get_pins</strong> UPLL0/CLKOUT]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> CLKPDIV2 <strong>-source</strong> UPPL0/CLKOUT <strong>-divide_by</strong> 2 [<strong>get_pins</strong> UFF0/Q]</p>
<p><img src="https://pic4.zhimg.com/80/v2-941547528f380cbca82879d15bf2b3d7_720w.jpg" alt="图7-10"></p>
<p>可以在触发器的输出端口定义一个新时钟是主时钟，而非衍生时钟吗？答案是肯定的，这确实是可能的，但是它也有一些缺点。定义主时钟而不是衍生时钟会创建一个新的时钟域。通常这不是问题，除了在设置STA约束时需要处理更多的时钟域外。相反，将新时钟定义为衍生时钟不会创建新的时钟域，并且衍生时钟会被认为与其主时钟同相，衍生时钟不需要进行额外的约束。因此，尽量将内部新生成的时钟定义为衍生时钟，而不是将其声明为另一个主时钟。</p>
<p>主时钟和衍生时钟之间的另一个重要区别是时钟源的概念。在主时钟中，时钟源位于主时钟的定义点。而在衍生时钟中，时钟源是主时钟的源而不是衍生时钟的源。这意味着在时钟路径报告中，时钟路径的起点始终是主时钟的定义点。这样一来，与定义新的主时钟相比，衍生时钟具有很大优势，因为对于新的主时钟，是不会自动考虑源延迟的。</p>
<p>图7-11给出了一个在两个输入端都有时钟的多路复用器示例，在这种情况下，不必在多路复用器的输出端定义时钟。如果选择信号设置为常数，则多路复用器的输出会自动获取正确的时钟传播。而如果多路复用器的选择端不受约束，则出于STA的目的，两个时钟都将通过多路复用器传播。在这样的情况下，STA会报告出TCLK和TCLKDIV5之间的路径。注意，这样的路径是不可能存在的，因为选择信号只能选择一个多路复用器的时钟输入。在这种情况下，可能需要设置伪路径或指定这两个时钟之间的互斥（exclusive）关系，以避免报告出错误的路径。当然，这假定设计中其它部分的TCLK和TCLKDIV5之间没有路径。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c423248b15d63a8735f39e7c97cfdffc_720w.jpg" alt="图7-11"></p>
<p>如果多路复用器选择信号不是静态不变的并且在运行期间会发生变化，这样会发生什么呢？ 在这种情况下，会对多路复用器输入端进行时钟门控（clock gating）检查，时钟门控检查将在第10章中介绍，这些检查可确保多路复用器输入端的时钟相对于多路复用器选择信号能够安全地切换。</p>
<p>图7-12给出了一个示例，其中时钟SYS_CLK由触发器的输出进行门控。由于触发器的输出可能不是恒定的，因此处理这种情况的一种方法是在与门单元的输出处定义一个衍生时钟，该时钟与输入时钟相同。</p>
<p><img src="https://pic4.zhimg.com/80/v2-fd500c1fb9ceb87b41d91b8d99c0e497_720w.jpg" alt="图7-12"></p>
<p>● <strong>create_clock</strong> 0.1 [<strong>get_ports</strong> SYS_CLK]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> CORE_CLK <strong>-divide_by</strong> 1 <strong>-source</strong> SYS_CLK [<strong>get_pins</strong> UAND1/Z]</p>
<p>下一个示例是一个衍生时钟，其频率高于源时钟的频率。波形如图7-13所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-7f44f7cf3f9f2e084177458eef817bd3_720w.jpg" alt="图7-13"></p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> PCLK]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> PCLK×2 <strong>-source</strong> [<strong>get_ports</strong> PCLK] <strong>-multiply_by</strong> 2 [<strong>get_pins</strong> UCLKMULTREG/Q]</p>
<p>请注意，在主时钟定义中指定了主时钟周期，然后<strong>-multiply_by</strong>和<strong>-divide_by</strong>选项指定了衍生时钟的频率。</p>
<h3 id="时钟门控单元输出端的主时钟示例">时钟门控单元输出端的主时钟示例</h3>
<p>考虑图7-14中所示的时钟门控示例，两个时钟分别输入进一个与门单元中，问题是与门单元的输出是什么呢？如果与门单元的输入均为时钟，则可以安全地在与门单元的输出端定义一个新的主时钟，因为该单元的输出与任何一个输入时钟都没有相位关系的可能性很小。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7aae184dbb9001688b317a5b0cd297c9_720w.jpg" alt="图7-14"></p>
<p>● <strong>create_clock</strong> <strong>-name</strong> SYS_CLK <strong>-period</strong> 4 <strong>-waveform</strong> {0 2} [<strong>get_pins</strong> UFFSYS/Q]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CORE_CLK <strong>-period</strong> 12 <strong>-waveform</strong> {0 4} [<strong>get_pins</strong> UFFCORE/Q]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> MAIN_CLK <strong>-period</strong> 12 <strong>-waveform</strong> {0 2} [<strong>get_pins</strong> UAND2/Z]</p>
<p>在内部引脚上创建时钟的一个缺点是：它会影响路径延迟计算，并迫使设计人员手动计算源延迟。</p>
<h3 id="使用edge和edge_shift选项生成时钟">使用Edge和Edge_shift选项生成时钟</h3>
<p>图7-15给出了一个衍生时钟的示例，除两个不同相的时钟外，还会生成一个二分频时钟。各时钟的波形也显示在图中。</p>
<p><img src="https://pic1.zhimg.com/80/v2-d16d08f6864a33be0a8c5c02fa846b54_720w.jpg" alt="图7-15"></p>
<p>下面给出了该示例中所有时钟的定义。衍生时钟的定义使用了<strong>-edges</strong>选项，这是定义衍生时钟的另一种方法。该选项采用源主时钟{上升，下降，上升}的边沿列表，以形成新的衍生时钟。主时钟的第一个上升沿是沿1，第一个下降沿是沿2，下一个上升沿是沿3，依此类推。</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 2 [<strong>get_ports</strong> DCLK]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> DCLKDIV2 <strong>-edge</strong> {2 4 6} <strong>-source</strong> DCLK [<strong>get_pins</strong> UBUF2/Z]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> PH0CLK <strong>-edges</strong> {3 4 7} <strong>-source</strong> DCLK [<strong>get_pins</strong> UAND0/Z]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> PH1CLK <strong>-edges</strong> {1 2 5} <strong>-source</strong> DCLK [<strong>get_pins</strong> UAND1/Z]</p>
<p>如果衍生时钟的第一个边沿是下降沿怎么办？考虑如图7-16所示的衍生时钟G3CLK。可以通过指定边沿5、7和10来定义这种衍生时钟，如以下时钟约束所示。注意，1ns时刻的下降沿将被自动推断出来。</p>
<p><img src="https://pic2.zhimg.com/80/v2-24ae3783cf838e134c2d2b78a476b625_720w.jpg" alt="图7-16"></p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> G3CLK <strong>-edge</strong> {5 7 10} <strong>-source</strong> DCLK [<strong>get_pins</strong> UAND0/Z]</p>
<p><strong>-edge_shift</strong>选项可与<strong>-edges</strong>选项一起使用，以指定相应边沿的任何偏移以形成新的衍生波形。它指定边沿列表中每个边沿的偏移量（以时间单位）。以下是使用此选项的示例：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> MIICLK]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> MIICLKDIV2 <strong>-source</strong> MIICLK <strong>-edges</strong> {1 3 5} [<strong>get_pins</strong> UMIICLKREG/Q]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> MIIDIV2 <strong>-source</strong> MIICLK <strong>-edges</strong> {1 1 5} <strong>-edge_shift</strong> {0 5 0} [<strong>get_pins</strong> UMIIDIV/Q]</p>
<p>边沿列表中的边沿序列必须以非降序排列，但是同一边沿可重复使用，以指示不同于源时钟占空比的时钟脉冲。上例中的<strong>-edge_shift</strong>选项通过将源时钟的边沿1移位0ns获得了衍生时钟的第一个边沿，通过将源时钟的边沿1偏移5ns获得了衍生时钟的第二个边沿，而通过将源时钟的边沿5移位0ns获得了衍生时钟的第三个边沿。下图7-17显示了上述波形：</p>
<p><img src="https://pic1.zhimg.com/80/v2-67973f8c8d91e10d9977f44118aea458_720w.jpg" alt="图7-17"></p>
<h3 id="使用invert选项生成时钟">使用Invert选项生成时钟</h3>
<p>这是衍生时钟的另一个示例，这个示例使用了<strong>-invert</strong>选项：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 10 [<strong>get_ports</strong> CLK]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> NCLKDIV2 <strong>-divide_by</strong> 2 <strong>-invert</strong> <strong>-source</strong> CLK [<strong>get_pins</strong> UINVQ/Z]</p>
<p>在所有其它衍生时钟选项都被使用后，<strong>-invert</strong>选项将会对衍生时钟进行反相。图7-18给出了产生这种反相时钟的原理图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-57fdab36496c9d5c1d365c97bb6b8a52_720w.jpg" alt="图7-18"></p>
<h3 id="衍生时钟的时钟延迟">衍生时钟的时钟延迟</h3>
<p>也可以为衍生时钟指定时钟延迟，在衍生时钟上指定的源延迟还包括了从主时钟定义点到衍生时钟定义点的延迟。因此，由衍生时钟驱动的触发器的时钟引脚的总时钟延迟是主时钟源延迟、衍生时钟源延迟和衍生时钟网络延迟的总和。如下图7-19所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4df950c98fe52b60cfa72e2478a8b988_720w.jpg" alt="图7-19"></p>
<p>衍生时钟可以将另一个衍生时钟作为其时钟源，即一个衍生时钟也可以具有衍生时钟，以此类推。但是，衍生时钟只能有一个主时钟。在后面的章节中将介绍更多衍生时钟的示例。</p>
<h3 id="典型的时钟生成方案">典型的时钟生成方案</h3>
<p>图7-20给出了在典型ASIC设计中如何进行时钟分配（clock distribution）的情形。晶振（Oscillator）在芯片外部产生低频（典型值为10-50 MHz）时钟，片上PLL将其用作参考时钟，以生成高频低抖动时钟（典型值为200-800 MHz）。然后，该PLL的输出时钟被输入到时钟分频器逻辑中，该逻辑产生ASIC所需的时钟。</p>
<p><img src="https://pic2.zhimg.com/80/v2-3db3a3ad843d1528c0fa9a02ca77d63d_720w.jpg" alt="图7-20"></p>
<p>在时钟分配的某些分支上，可能有时钟门控（clock gates）用于在设计的无效部分关闭时钟，以在必要时节省功耗。在PLL的输出端也可以接一个多路复用器，以便在必要时可以绕过PLL。</p>
<p>在进入设计的芯片输入端口处为参考时钟定义了一个主时钟，在PLL的输出处定义了第二个主时钟。PLL的输出时钟与参考时钟没有任何相位关系。因此，PLL的输出时钟不应是参考时钟的衍生时钟。很有可能的是，由时钟分频器逻辑生成的所有时钟都将被指定为PLL输出处主时钟的衍生时钟。</p>
<h2 id="约束输入路径">约束输入路径</h2>
<p>本节将介绍输入路径的约束。这里需要注意的一点是，STA无法检查不受约束的路径上的任何时序，因此需要约束所有路径以进行时序分析。在后面的章节中会介绍一些示例，其中一些示例可能并不关心某些逻辑，因而这些输入路径可能可以不用约束。例如，设计人员可能并不在乎一些输入控制信号的时序，因此可能并不需要进行本节中将要介绍的时序检查。但是，本节假定我们要约束全部的输入路径。</p>
<p>图7-21中为待分析设计（DUA）的输入路径。触发器UFF0在设计的外部，并向设计内部的触发器UFF1提供数据。数据通过输入端口INP1连接两个触发器。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f713ddf9c69f23bbe3ab321fb441dd5a_720w.jpg" alt="图7-21"></p>
<p>CLKA的时钟定义指定了时钟周期，这是两个触发器UFF0和UFF1之间可用的总时间。外部逻辑所需的时间为Tclk2q（数据发起触发器UFF0的CK至Q延迟）加上Tc1（通过外部组合逻辑的延迟），因此输入引脚INP1上的延迟定义指定了Tclk2q加上Tc1的外部延迟。并且这个外部延迟是相对于一个时钟指定的，在本示例中为时钟CLKA。</p>
<p>以下是输入延迟的约束：</p>
<p>● <strong>set</strong> Tclk2q 0.9</p>
<p>● <strong>set</strong> Tc1 0.6</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> CLKA <strong>-max</strong> [<strong>expr</strong> Tclk2q + Tc1] [<strong>get_ports</strong> INP1]</p>
<p>该约束指定输入端口INP1的外部延迟为1.5ns，且这是相对于时钟CLKA而言的。假设CLKA的时钟周期为2ns，则INP1引脚的逻辑只有500ps（= 2ns-1.5ns）可以在设计内部中传播。此输入延迟定义意味着输入约束为：Tc2加上触发器UFF1的Tsetup必须小于500ps，才可以确保可靠地捕获到触发器UFF0发起的数据。请注意，上述外部延迟值被指定为了最大值（max）。</p>
<p><img src="https://pic3.zhimg.com/80/v2-1113d503c83279b8ab7675d415989a0e_720w.jpg" alt="图7-22"></p>
<p>让我们同时考虑最大和最小延迟情况，如图7-22所示。以下是此示例的约束：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 15 <strong>-waveform</strong> {5 12} [<strong>get_ports</strong> CLKP]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> CLKP <strong>-max</strong> 6.7 [<strong>get_ports</strong> INPA]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> CLKP <strong>-min</strong> 3.0 [<strong>get_ports</strong> INPA]</p>
<p>INPA的最大和最小延迟是从CLKP到INPA的延迟中得出的，最大和最小延迟分别是最长和最短路径延迟，这些通常也可以对应于最坏情况（worst-case）下的慢速（最大时序工艺角）和最佳情况（best-case）下的快速（最小时序工艺角）。因此，最大延迟对应于最大时序工艺角下的最长路径延迟，最小延迟对应于最小时序工艺角下的最短路径延迟。在我们的示例中，1.1ns和0.8ns是Tck2q的最大和最小延迟值。组合逻辑路径延迟Tc1的最大延迟为5.6ns，最小延迟为2.2ns。INPA上的波形显示了数据到达设计输入端的时间窗口，以及预计达到稳定状态的时间。从CLKP到INPA的最大延迟为6.7ns（= 1.1ns + 5.6ns），最小延迟为3ns（= 0.8ns + 2.2ns），这些延迟是相对于时钟有效沿指定的。在给定外部输入延迟的情况下，设计内部的可用建立时间是慢角（slow corner）下的8.3ns（= 15ns-6.7ns）和快角（fast corner）下的12ns（= 15ns-3.0ns）中的最小值。因此，8.3ns是用来可靠地捕获DUA内部数据的可用时间。</p>
<p>以下是输入约束的更多示例：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> clk_core 0.5 [<strong>get_ports</strong> bist_mode]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> clk_core 0.5 [<strong>get_ports</strong> sad_state]</p>
<p>由于未指定<strong>max</strong>或<strong>min</strong>选项，因此500ps这个值将同时用于最大延迟和最小延迟。此外部输入延迟是相对于时钟clk_core的上升沿指定的（如果输入延迟是相对于时钟的下降沿指定的，则必须使用<strong>-clock_fall</strong>选项）。</p>
<h2 id="约束输出路径">约束输出路径</h2>
<p>本节将借助下面的三个例子来介绍输出路径的约束。</p>
<h3 id="例子a">例子A</h3>
<p>图7-23为一条通过待分析设计输出端口的路径示例，其中Tc1和Tc2是通过组合逻辑的延迟。</p>
<p><img src="https://pic4.zhimg.com/80/v2-60b45c8d7e395dc89d5c52efad0d7717_720w.jpg" alt="图7-23"></p>
<p>时钟CLKQ的周期定义了触发器UFF0和UFF1之间的总可用时间。外部逻辑的总延迟为Tc2加上Tsetup，此总延迟Tc2 + Tsetup必须作为输出延迟约束的一部分来指定。注意，输出延迟是相对于捕获时钟指定的，数据必须及时到达外部触发器UFF1才能满足其建立时间要求。</p>
<p>● <strong>set</strong> Tc2 3.9</p>
<p>● <strong>set</strong> Tsetup 1.1</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> CLKQ <strong>-max</strong> [<strong>expr</strong> Tc2 + Tsetup] [<strong>get_ports</strong> OUTB]</p>
<p>这指定了相对于时钟边沿的最大外部延迟为Tc2加上Tsetup，即5ns的延迟。最小延迟可以类似地指定。</p>
<h3 id="例子b">例子B</h3>
<p>图7-24给出了同时具有最小和最大延迟的示例。最大路径延迟为7.4ns（=Tc2最大值加上Tsetup = 7 + 0.4），最小路径延迟为-0.2ns（=Tc2最小值减去Thold = 0-0.2）。因此，输出约束为：</p>
<p><img src="https://pic3.zhimg.com/80/v2-5fbca91a1e5e88caff80703df074f522_720w.jpg" alt="图7-24"></p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 20 <strong>-waveform</strong> {0 15} [<strong>get_ports</strong> CLKQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> CLKQ <strong>-min</strong> -0.2 [<strong>get_ports</strong> OUTC]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> CLKQ <strong>-max</strong> 7.4 [<strong>get_ports</strong> OUTC]</p>
<p>图7-24中的波形显示了OUTC必须保持稳定状态的时间，以确保外部触发器能够可靠地捕获它。这说明在所需的稳定区域开始之前，数据就必须在输出端口准备就绪，并且必须保持稳定，直到稳定区域结束为止。这同样反映了DUA内部对输出端口OUTC逻辑的时序要求。</p>
<h3 id="例子c">例子C</h3>
<p>这是另一个输入约束和输出约束的示例。该模块具有两个输入端口DATAIN和MCLK，以及一个输出端口DATAOUT。图7-25显示了预期的波形。</p>
<p><img src="https://pic3.zhimg.com/80/v2-6d4f02368e4d12bbd76106cb750dfdc2_720w.jpg" alt="图7-25"></p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 100 <strong>-waveform</strong> {5 55} [<strong>get_ports</strong> MCLK]</p>
<p>● <strong>set_input_delay</strong> 25 <strong>-max</strong> <strong>-clock</strong> MCLK [<strong>get_ports</strong> DATAIN]</p>
<p>● <strong>set_input_delay</strong> 5 <strong>-min</strong> <strong>-clock</strong> MCLK [<strong>get_ports</strong> DATAIN]</p>
<p>● <strong>set_output_delay</strong> 20 <strong>-max</strong> <strong>-clock</strong> MCLK [<strong>get_ports</strong> DATAOUT]</p>
<p>● <strong>set_output_delay</strong> -5 <strong>-min</strong> <strong>-clock</strong> MCLK [<strong>get_ports</strong> DATAOUT]</p>
<h2 id="时序路径组">时序路径组</h2>
<p>设计中的时序路径可以视为路径的集合，每个路径都有一个起点和一个终点。时序路径的示例如下图7-26所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e18974487168538c443b0ea0df357384_720w.jpg" alt="图7-26"></p>
<p>在STA中，时序路径是根据有效的起点和终点来划分的。有效的起点包括：输入端口或者同步器件（如触发器和存储器）的时钟引脚。有效的终点包括：输出端口或者同步器件的数据输入引脚。因此，有效的时序路径包括：</p>
<p>● 从输入端口到输出端口</p>
<p>● 从输入端口到触发器或存储器的数据输入引脚</p>
<p>● 从一个触发器或存储器的时钟引脚到另一个触发器或存储器的数据输入引脚</p>
<p>● 从一个触发器或存储器的时钟引脚到输出端口</p>
<p>图7-26中的有效时序路径包括：</p>
<p>● 输入端口A到输出端口Z</p>
<p>● 输入端口A到触发器UFFA的D引脚</p>
<p>● 触发器UFFA的CK引脚到触发器UFFB的D引脚</p>
<p>● 触发器UFFB的CK引脚到输出端口Z</p>
<p>时序路径可以根据与路径终点相关的时钟分类为不同时序路径组（path groups）。因此，每个时钟都有一组与之相关的时序路径。还有一个默认时序路径组，其中包括了所有非时钟（异步）路径。</p>
<p><img src="https://pic1.zhimg.com/80/v2-36074bc598c2171aa333caaa1c264150_720w.jpg" alt="图7-27"></p>
<p>在图7-27的示例中，时序路径分组为：</p>
<p>● CLKA组：输入端口A到触发器UFFA的D引脚</p>
<p>● CLKB组：触发器UFFA的CK引脚到触发器UFFB的D引脚</p>
<p>● 默认组：输入端口A到输出端口Z、触发器UFFB的CK引脚到输出端口Z</p>
<p>静态时序分析和报告通常分别在每个时序路径组中单独执行。</p>
<h2 id="外部属性建模">外部属性建模</h2>
<p>尽管<strong>create_clock</strong>、<strong>set_input_delay</strong>和<strong>set_output_delay</strong>足以约束设计中用于执行时序分析的所有路径，但这些并不足以获取该模块IO引脚上的准确时序。为了准确地对设计环境进行建模，还需要以下属性。对于输入，需要在输入端口处指定压摆。可以使用以下方式提供此信息：</p>
<p>● <strong>set_drive</strong></p>
<p>● <strong>set_driving_cell</strong></p>
<p>● <strong>set_input_transition</strong></p>
<p>对于输出，需要指定输出引脚的负载电容。可以使用以下命令来指定：</p>
<p>● <strong>set_load</strong></p>
<h2 id="驱动强度建模">驱动强度建模</h2>
<p><strong>set_drive</strong>和<strong>set_driving_cell</strong>约束用于对驱动模块输入端口的外部单元的驱动强度进行建模。在没有这些约束的默认情况下，假定所有输入都具有无限的驱动强度，即输入引脚的过渡时间为0。</p>
<p><strong>set_drive</strong>明确指定了DUA输入引脚上的驱动电阻值，该电阻值越小，驱动强度越高，电阻值为0表示无限的驱动强度。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a753d1df32090d6b3274a51125074ccb_720w.jpg" alt="图7-28"></p>
<p>● <strong>set_drive</strong> 100 UCLK</p>
<p>● <strong>set_drive</strong> <strong>-rise</strong> 3 [<strong>all_inputs</strong>]</p>
<p>● <strong>set_drive</strong> <strong>-fall</strong> 2 [<strong>all_inputs</strong>]</p>
<p>输入端口的驱动强度用于计算第一个单元的过渡时间。指定的驱动强度还可用于计算在任何RC互连情况下从输入端口到第一个单元的延迟值，计算公式如下：</p>
<p>● 延迟值 = （驱动强度 * 网络负载） + 互连线延迟</p>
<p><strong>set_driving_cell</strong>约束提供了一种更方便、更准确的方法来描述端口的驱动能力。<strong>set_driving_cell</strong>可用于指定驱动输入端口的单元类型。</p>
<p><img src="https://pic2.zhimg.com/80/v2-cb03063702ee294420e80a17f10bc305_720w.jpg" alt="图7-29"></p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> INV3 <strong>-library</strong> slow [<strong>get_ports</strong> INPB]</p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> INV2 <strong>-library</strong> tech13g [<strong>all_inputs</strong>]</p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> BUFFD4 <strong>-library</strong> tech90gwc [<strong>get_ports</strong> {testmode[3]}]</p>
<p>与<strong>set_drive</strong>约束一样，<strong>set_driving_cell</strong>也可用于计算第一个单元的过渡时间，并在任何互连情况下计算从输入端口到第一个单元的延迟值。</p>
<p>使用<strong>set_driving_cell</strong>约束的一个注意点是：由于输入端口上的电容性负载而导致驱动单元的增量延迟被视作为输入上的附加延迟被包括在内。</p>
<p>作为上述方法的替代方法，<strong>set_input_transition</strong>约束提供了一种在输入端口表示过渡时间的便捷方法，并且可以指定参考时钟。以下是图7-30中示例的约束以及其它约束示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-8a101572b7131c2329492842e143c39d_720w.jpg" alt="图7-30"></p>
<p>● <strong>set_input_transition</strong> 0.85 [<strong>get_ports</strong> INPC]</p>
<p>● <strong>set_input_transition</strong> 0.6 [<strong>all_inputs</strong>]</p>
<p>● <strong>set_input_transition</strong> 0.25 [<strong>get_ports</strong> SD_DIN*]</p>
<p>总之，设计人员需要指定输入端的压摆值来确定输入路径中第一个单元的延迟。在没有该约束的情况下，将假设为理想过渡值0，这显然是不现实的。</p>
<h2 id="电容负载建模">电容负载建模</h2>
<p><strong>set_load</strong>约束在输出端口上设置了电容性负载，以模拟由输出端口驱动的外部负载。默认情况下，端口上的电容性负载为0。可以将负载显式地指定为电容值或某个单元的输入引脚电容。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4733861a936ea7709cd63288f7f2fad6_720w.jpg" alt="图7-31"></p>
<p>● <strong>set_load</strong> 5 [<strong>get_ports</strong> OUTX]</p>
<p>● <strong>set_load</strong> 25 [<strong>all_outputs</strong>]</p>
<p>● <strong>set_load</strong> <strong>-pin_load</strong> 0.007 [<strong>get_ports</strong> {shift_write[31]}]</p>
<p>指定输出上的负载很重要，因为该值会影响驱动输出的单元的延迟。在没有该约束的情况下，将假定负载为0，这显然是不现实的。</p>
<p><strong>set_load</strong>约束还可用于在设计中指定内部网络上的负载，以下是一个例子：</p>
<p>● <strong>set_load</strong> 0.25 [<strong>get_nets</strong> UCNT5/NET6]</p>
<h2 id="设计规则检查">设计规则检查</h2>
<p>STA中两个常用的设计规则是最大过渡时间-<strong>max_transition</strong>和最大电容-<strong>max_capacitance</strong>。这些规则将会检查设计中的所有端口和引脚是否满足过渡时间和电容的规定约束。这些规则可以使用以下命令指定：</p>
<p>● <strong>set_max_transition</strong></p>
<p>● <strong>set_max_capacitance</strong></p>
<p>作为STA的一部分，任何设计规则的违例（violation）均以裕量（slack）的形式报告。以下是些例子：</p>
<p>● <strong>set_max_transition</strong> 0.6 IOBANK</p>
<p>● <strong>set_max_capacitance</strong> 0.5 [<strong>current_design</strong>]</p>
<p>网络上的电容是通过将所有引脚电容加上任何IO负载再加上网络上的任何互连电容的总和计算得出的。下图7-32为一个示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d75285beb068ed344a39c7fc2211fed7_720w.jpg" alt="图7-32"></p>
<p>● 网络N1的总电容 = UBUF1的A引脚电容 + UOR2的B引脚电容 + OUTP的输出负载电容 + 走线互连电容</p>
<p>= 0.05 + 0.03 + 0.07 + 0.02 = 0.17 pF</p>
<p>● 网络N2的总电容 = UBUF2的A引脚电容 + 走线互连电容</p>
<p>= 0.03 + 0.04 = 0.07 pF</p>
<p>过渡时间是延迟计算的一部分。对于图7-32中的示例（假设UBUF2单元使用线性延迟模型）：</p>
<p>● UBUF2的A引脚过渡时间 = 2 * 网络N2的总电容 = 2 * 0.07 = 0.14ns = 140ps</p>
<p>● 输出端口OUTP过渡时间 = UBUF2的Z引脚的驱动电阻 * 网络N1的总电容</p>
<p>= 1 * 0.17 = 0.17ns = 170ps</p>
<p>还可以为设计指定其他设计规则检查，比如：<strong>set_max_fanout</strong>（指定设计中所有引脚的扇出约束），<strong>set_max_area</strong>（用于设计）。但是，这些检查适用于综合（synthesis）而非STA。</p>
<h2 id="虚拟时钟">虚拟时钟</h2>
<p>虚拟时钟（virtual clock）是存在的时钟，但与设计中的任何引脚或端口均不相关。在STA中仅用作参考，以指定相对于时钟的输入延迟和输出延迟。虚拟时钟的示例如图7-33所示。 待分析设计的时钟端为CLK_CORE，但输入端口ROW_IN的驱动时钟为CLK_SAD。在这种情况下，如何指定输入端口ROW_IN的IO约束呢？同样，在输出端口STATE_O上也会出现同样的问题。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a8f8f538077e1e0c98ac3a10d962ff0b_720w.jpg" alt="图7-33"></p>
<p>为了处理这种情况，可以在不指定源端口或引脚的情况下来定义虚拟时钟。对于图7-33中的示例，为CLK_SAD和CLK_CFG定义了虚拟时钟。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> VIRTUAL_CLK_SAD <strong>-period</strong> 10 <strong>-waveform</strong> {2 8}</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> VIRTUAL_CLK_CFG <strong>-period</strong> 8 <strong>-waveform</strong> {0 4}</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 10 [<strong>get_ports</strong> CLK_CORE]</p>
<p>定义了这些虚拟时钟后，就可以相对于该虚拟时钟来指定IO约束。</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VIRTUAL_CLK_SAD <strong>-max</strong> 2.7 [<strong>get_ports</strong> ROW_IN]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> VIRTUAL_CLK_CFG <strong>-max</strong> 4.5 [<strong>get_ports</strong> STATE_O]</p>
<p>图7-34显示了输入路径上的时序关系。这将待分析设计中的输入路径限制为了5.3ns或更短。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4c1e2754ed6ec5c29a08b0c5b9cb35cb_720w.jpg" alt="图7-34"></p>
<p>图7-35显示了输出路径上的时序关系。这将待分析设计中的输出路径限制为了3.5ns或更短。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8182acee7604306f62bfa00bc3acd174_720w.jpg" alt="图7-35"></p>
<p><strong>-min</strong>选项在<strong>set_input_delay</strong>和<strong>set_output_delay</strong>约束中指定时，可用于检查最小时序路径。使用虚拟时钟只是约束输入和输出（IO）的一种方法，设计人员还可以选择其它方法来约束IO。</p>
<h2 id="完善时序分析">完善时序分析</h2>
<p>用于约束分析的四个常用命令是：</p>
<p>● <strong>set_case_analysis</strong> ：在单元的引脚或输入端口上指定常量值。</p>
<p>● <strong>set_disable_timing</strong> ：中断单元的时序弧。</p>
<p>● <strong>set_false_path</strong> ：指定实际不存在的路径，这意味着在STA中不需要检查这些路径。</p>
<p>● <strong>set_multicycle_path</strong> ：指定可能花费超过一个时钟周期的路径。</p>
<p>第8章将详细讨论<strong>set_false_path</strong>和<strong>set_multicycle_path</strong>约束。</p>
<h2 id="指定无效信号">指定无效信号</h2>
<p>在设计中，某些信号在芯片的特定模式下会具有恒定值。例如，如果芯片中具有DFT（可测性设计）逻辑，则在正常功能模式下，芯片的TEST引脚将一直为0。为STA指定这样的常量值通常很有用，除了不必报告任何不相关的路径之外，这还有助于减少分析空间。例如，如果未将TEST引脚设置为常数，则可能会存在一些奇怪的长路径，而这些长路径在功能模式下永远不会存在。通过使用<strong>set_case_analysis</strong>约束来指定此类常数信号。</p>
<p>● <strong>set_case_analysis</strong> 0 TEST</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_ports</strong> {testmode[3]}]</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_ports</strong> {testmode[2]}]</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_ports</strong> {testmode[1]}]</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_ports</strong> {testmode[0]}]</p>
<p>如果设计具有多种功能模式，而只需要分析其中一种功能模式，则可以使用<strong>set_case_analysis</strong>来指定要分析的模式。</p>
<p>● <strong>set_case_analysis</strong> 1 func_mode[0]</p>
<p>● <strong>set_case_analysis</strong> 0 func_mode[1]</p>
<p>● <strong>set_case_analysis</strong> 1 func_mode[2]</p>
<p>注意，可以在设计中的任何引脚上指定<strong>set_case_analysis</strong>，这个命令的另一个常见应用是可以在多个时钟上运行的设计，并且时钟的适当选择由多路复用器控制。为了使STA分析更容易并减少CPU运行时间，对每个选择的时钟分别进行STA是十分有用的。图7-36给出了一个多路复用器选择不同时钟的示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-0ec2facacbb01c27f1a6026bfa1e2725_720w.jpg" alt="图7-36"></p>
<p>● <strong>set_case_analysis</strong> 1 UCORE/UMUX0/CLK_SEL[0]</p>
<p>● <strong>set_case_analysis</strong> 1 UCORE/UMUX1/CLK_SEL[1]</p>
<p>● <strong>set_case_analysis</strong> 0 UCORE/UMUX2/CLK_SEL[2]</p>
<p>第一个<strong>set_case_analysis</strong>选择了PLLdiv16被用于MIICLK，PLLdiv8的时钟路径被阻塞并且不会通过多路复用器传播。因此，没有使用时钟PLLdiv8分析任何时序路径（假设时钟在多路复用器之前不驱动任何触发器）。类似地，最后一个<strong>set_case_analysis</strong>选择了SCANCLK 被用于ADCCLK，并阻塞了CLK200的时钟路径。</p>
<h2 id="中断单元内的时序弧">中断单元内的时序弧</h2>
<p>每个单元都有从其输入到输出的时序弧，并且时序路径可能会通过这些时序弧中的其中一个。在某些情况下，单元中的一条路径可能无法发生。例如可能有这样一种情况，其中时钟连接到多路复用器的选择端，而多路复用器的输出是数据路径的一部分。在这种情况下，中断多路复用器选择引脚和输出引脚之间的时序弧可能很有用。图7-37为一个示例，通过多路复用器选择端的路径不是有效的数据路径。可以使用<strong>set_disable_timing</strong>命令来中断这种时序弧。</p>
<p><img src="https://pic1.zhimg.com/80/v2-768c13acdb0d5de56febed90a8445d68_720w.jpg" alt="图7-37"></p>
<p>● <strong>set_disable_timing</strong> <strong>-from</strong> S <strong>-to</strong> Z [<strong>get_cells</strong> UMUX0]</p>
<p>由于时序弧不再存在，因此需要分析的时序路径更少。类似用法的另一个示例是取消触发器的最小时钟脉冲宽度检查。</p>
<p>使用<strong>set_disable_timing</strong>命令需要格外小心，因为它会删除通过指定引脚的所有时序路径。在可能的情况下，最好使用<strong>set_false_path</strong>和<strong>set_case_analysis</strong>命令。</p>
<h2 id="点对点约束">点对点约束</h2>
<p>可以通过使用<strong>set_min_delay</strong>和<strong>set_max_delay</strong>命令来约束点对点路径，这将引脚到引脚之间的路径延迟限制在了命令指定值内。该约束将覆盖所有默认的单周期时序路径以及此类路径的任何多周期路径约束。<strong>set_max_delay</strong>约束了指定路径的最大延迟，而<strong>set_min_delay</strong>约束了指定路径的最小延迟。</p>
<p>● <strong>set_max_delay</strong> 5.0 <strong>-to</strong> UFF0/D</p>
<p>● <strong>set_max_delay</strong> 0.6 <strong>-from</strong> UFF2/Q <strong>-to</strong> UFF3/D</p>
<p>● <strong>set_max_delay</strong> 0.45 <strong>-from</strong> UMUX0/Z <strong>-through</strong> UAND1/A <strong>-to</strong> UOR0/Z</p>
<p>● <strong>set_min_delay</strong> 0.15 <strong>-from</strong> {UAND0/A UXOR1/B} <strong>-to</strong> {UMUX2/SEL}</p>
<p>在上述示例中，需要注意的是，使用非标准的内部引脚将迫使它们成为起点和终点，并在这些点处分割路径。</p>
<p>还可以类似地指定从一个时钟到另一个时钟的点对点约束。</p>
<p>● <strong>set_max_delay</strong> 1.2 <strong>-from</strong> [<strong>get_clocks</strong> SYS_CLK] <strong>-to</strong> [<strong>get_clocks</strong> CFG_CLK]</p>
<p>● <strong>set_min_delay</strong> 0.4 <strong>-from</strong> [<strong>get_clocks</strong> SYS_CLK] <strong>-to</strong> [<strong>get_clocks</strong> CFG_CLK]</p>
<p>如果路径上有多个时序约束，例如时钟频率约束、<strong>set_max_delay</strong>和<strong>set_min_delay</strong>，则最严格的那个约束是始终用于检查的约束。多个时序约束可能是先应用某些全局（global）约束，然后再应用某些局部（local）约束。</p>
<h2 id="路径分段">路径分段</h2>
<p>路径分段（path segmentation）是指将时序路径分解为可以进行时序分析的较小路径。</p>
<p>时序路径具有起点和终点，可以使用<strong>set_input_delay</strong>和<strong>set_output_delay</strong>命令在时序路径上创建其它起点和终点。通常在单元的输出引脚上指定<strong>set_input_delay</strong>来定义新起点，而通常在单元的输入引脚上指定<strong>set_output_delay</strong>来定义新终点。这些约束定义了新的时序路径，它是原始时序路径的子集。</p>
<p>考虑图7-38中所示的路径。为SYSCLK定义时钟后，待分析的时序路径即为从UFF0 / CK到UFF1 / D。如果仅对报告从UAND2 / Z到UAND6 / A的路径延迟感兴趣，则可以使用以下两个命令：</p>
<p>● <strong>set</strong> STARTPOINT [<strong>get_pins</strong> UAND2/Z]</p>
<p>● <strong>set</strong> ENDPOINT [<strong>get_pins</strong> UAND6/A]</p>
<p>● <strong>set_input_delay</strong> 0 $STARTPOINT</p>
<p>● <strong>set_output_delay</strong> 0 $ENDPOINT</p>
<p><img src="https://pic4.zhimg.com/80/v2-bf3a3d54359f30117313816f146837ab_720w.jpg" alt="图7-38"></p>
<p>定义这些约束会导致从UFF0 / CK到UFF1 / D的原始时序路径被分段，并分别在UAND2 / Z和UAND6 / A处创建内部起点和内部终点。现在，时序报告将明确显示此新路径。请注意，还会自动创建另外两条时序路径，一条从UFF0 / CK到UAND2 / Z，另一条从UAND6 / A到UFF1 / D。因此，原始的时序路径已被分为了三个部分，每个部分分别进行时序分析。</p>
<p><strong>set_disable_timing</strong>、<strong>set_max_delay</strong>和<strong>set_min_delay</strong>命令也会对时序路径进行分段。</p>
<h1 id="时序检查">时序检查</h1>
<blockquote>
<p>本章节将介绍静态时序分析所执行的一部分检查，这些检查旨在详尽地验证待分析设计的时序。</p>
</blockquote>
<p>● 两项主要的检查是建立时间和保持时间检查。一旦在触发器的时钟引脚上定义了时钟，便会自动推断出该触发器的建立时间和保持时间检查。时序检查通常会在多个条件下执行，包括最差情况的慢速条件和最佳情况的快速条件。通常，最差情况的慢速条件对于建立时间检查很关键，而最佳情况的快速条件对于保持时间检查很关键（尽管也可以在最差情况的慢速条件下执行保持时间检查）。</p>
<p>● 本章节中的示例假定网络延迟为零，这样做是为了简化说明，并且不会更改所介绍的概念。</p>
<h2 id="建立时间检查">建立时间检查</h2>
<p>建立时间检查会验证触发器时钟和数据引脚之间的时序关系，从而满足建立时间要求。换句话说，建立时间检查会确保在触发器输入时钟之前，数据在触发器的输入端可用。在时钟的有效沿到达触发器之前，数据应在一定时间内保持稳定，即触发器的建立时间，该要求将确保数据可靠地被捕获到触发器中。图8-1显示了典型触发器的建立时间要求，建立时间检查将验证触发器的建立时间要求。</p>
<p><img src="https://pic3.zhimg.com/80/v2-1abb17fbb59597ad9fabeb61fe6f43d6_720w.jpg" alt="图8-1"></p>
<p>通常，有一个发起触发器（用于发起数据的触发器）和捕获触发器（用于捕获数据的触发器），这个捕获触发器的建立时间要求必须满足。建立时间检查将验证从发起触发器到捕获触发器的最长（或最大）路径，这两个触发器的时钟可以相同也可以不同。建立时间检查是从发起触发器中时钟的第一个有效沿到捕获触发器中时钟后面最接近的那个有效沿。建立时间检查将确保上一个时钟周期发起的数据准备好在一个周期后被捕获。</p>
<p>现在我们研究一个简单的示例，如图8-2所示，其中发起触发器和捕获触发器具有相同的时钟。时钟CLKM的第一个上升沿在Tlaunch时间后出现在发起触发器的时钟引脚上，由该时钟沿发起的数据出现在触发器UFF1的D引脚的所需时间为Tlaunch + Tck2q + Tdp。时钟CLKM的第二个上升沿（通常在一个周期后检查建立时间）出现在捕获触发器UFF1的时钟引脚上的时间为Tcycle + Tcapture。这两个时间之差必须大于触发器UFF1的建立时间要求，以确保触发器UFF1可靠地捕获数据。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b1b0c82a191bf8b68bc82b7f010b6582_720w.jpg" alt="图8-2"></p>
<p>建立时间检查可以用数学公式表示：</p>
<p>● Tlaunch + Tck2q + Tdp &lt; Tcapture + Tcycle - Tsetup</p>
<p>其中Tlaunch是发起触发器UFF0的时钟树延迟，Tdp是组合逻辑数据路径的延迟，Tcycle是时钟周期，Tcapture是捕获触发器UFF1的时钟树延迟。</p>
<p>换句话说，数据到达捕获触发器D引脚所花费的总时间必须小于时钟传输到捕获触发器所花费的时间加上时钟周期再减去建立时间要求。</p>
<p>由于建立时间检查受到<strong>-max</strong>的约束，因此建立时间检查始终使用最长或最大的时序路径。出于同样的原因，通常在延迟最大的慢工艺角（slow corner）下执行建立时间检查。</p>
<h2 id="触发器到触发器路径-1">触发器到触发器路径</h2>
<p>以下是一份建立时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-8fb61bb751af56a4ff5b8753405dc662_720w.jpg"></p>
<p>该报告中显示发起触发器（由<strong>Startpoint</strong>指定）的实例名称为UFF0，由时钟CLKM的上升沿触发。捕获触发器（由<strong>Endpoint</strong>指定）为UFF1，也由时钟CLKM的上升沿触发。路径组（<strong>Path Group</strong>）显示它属于路径组CLKM。如上一章所述，设计中的所有路径都基于捕获触发器的时钟归类为路径组。路径类型（<strong>Path Type</strong>）显示此报告中的延迟均为最大路径延迟，表明这是建立时间检查。这是因为建立时间检查对应于通过逻辑的最大（或最长路径）延迟。注意，保持时间检查对应于通过逻辑的最小（或最短路径）延迟。</p>
<p><strong>Incr</strong>列显示了指定端口或引脚的单元或网络延迟增量，<strong>Path</strong>列显示了数据实际到达和需要到达的路径累积延迟，这是用于此示例的时钟约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-setup</strong> 0.3 [<strong>all_clocks</strong>]</p>
<p>● <strong>set_clock_transition</strong> <strong>-rise</strong> 0.2 [<strong>all_clocks</strong>]</p>
<p>● <strong>set_clock_transition</strong> <strong>-fall</strong> 0.15 [<strong>all_clocks</strong>]</p>
<p>数据发起路径需要0.26ns的延迟才能到达触发器UFF1的D引脚，这是捕获触发器输入端的到达时间。捕获边沿（建立时间检查时为一个周期）为10ns，为此时钟指定了0.3ns的时钟不确定度（clock uncertainty），因此，有效时钟周期由于不确定度而减少了0.3ns。时钟不确定度包括由于时钟源抖动引起的周期变化以及用于分析的任何其它时序裕量。从总的捕获路径中还要减去触发器的建立时间0.04ns（library setup time），得出数据需要到达的时间为9.66ns。由于数据实际到达时间为0.26ns，因此在此时序路径上有9.41ns的正裕量（slack）。请注意，所需到达时间和实际到达时间之差可能看起来是9.40ns，但是实际值是出现在报告中的9.41ns。之所以存在差异，是因为报表仅显示小数点后两位数字，而内部计算和存储的值比所报告的精度更高。</p>
<p>时序报告中的时钟网络延迟（clock network delay）是什么？为什么将其标记为理想（ideal）？时序报告中的这一行表明时钟树被认为是理想的，时钟路径中的任何缓冲器（buffer）都假定为零延迟。一旦构建了时钟树，就可以将时钟网络标记为“已传播”（propagated），从而使得时钟路径显示实际延迟值，如下一个示例时序报告中所示：0.11ns延迟是发起时钟上的时钟网络延迟，而0.12ns延迟是捕获触发器上的时钟网络延迟。</p>
<p><img src="https://pic1.zhimg.com/80/v2-659fbb266702d07c91cdd3471d7a58c8_720w.jpg"></p>
<p>时序路径报告中可以选择包含扩展的时钟路径，即带有明确显示的时钟树。以下是一个例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-885ddf08cf7faaedaf99a02f51a89210_720w.jpg"></p>
<p>请注意，上述路径报告中的UCKBUF0、UCKBUF1和UCKBUF2都是时钟缓冲器，提供了有关如何计算时钟树延迟的详细信息。</p>
<p>如何计算第一个时钟单元UCKBUF0的延迟呢？如前几章所述，单元延迟是根据单元的输入过渡时间和输出电容来计算的。因此，问题是在时钟树的第一个单元的输入处指定了多大的过渡时间，可以使用<strong>set_input_transition</strong>命令明确指定第一个时钟单元输入引脚上的过渡时间（或压摆）。</p>
<p>● <strong>set_input_transition</strong> <strong>-rise</strong> 0.3 [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>set_input_transition</strong> <strong>-fall</strong> 0.45 [<strong>get_ports</strong> CLKM]</p>
<p>在上述的<strong>set_input_transition</strong>命令中，我们将输入上升过渡时间指定为了0.3ns，将下降过渡时间指定为了0.45ns。在没有该命令约束的情况下，将在时钟树的源端假设存在理想的压摆，这意味着上升和下降过渡时间均为0ns。</p>
<p>时序报告中的<strong>r</strong>和<strong>f</strong>字符表示时钟或数据信号的上升沿（和下降沿）。上一个时序路径报告中显示了一条从UFF0 / Q的下降沿开始到UFF1 / D的上升沿结束的路径。由于UFF1 / D可以为0或1，因此也可以有一条路径在UFF1 / D的下降沿结束。以下就是这样一条路径：</p>
<p><img src="https://pic4.zhimg.com/80/v2-449c5b9e653796cd1624568450930e63_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-960d4bba06fc3fc36f875aa2184c7945_720w.jpg"></p>
<p>注意，触发器时钟引脚的边沿（称为有效边沿）保持不变。它只能是上升或下降有效沿，具体取决于触发器是由上升沿触发的还是由下降沿触发的。</p>
<p>什么是时钟源延迟（clock source latency）？ 这也被称为插入延迟（insertion delay），是时钟从其源端传播到待分析设计的时钟定义点所花费的时间，如图8-3所示，这对应于设计之外的时钟树延迟。例如，如果该设计是较大模块的一部分，则时钟源延迟是指直到待分析设计时钟引脚为止的时钟树延迟。可以使用<strong>set_clock_latency</strong>命令明确指定此延迟。</p>
<p><img src="https://pic4.zhimg.com/80/v2-ee17cc1e989e35a6988dca118247fd57_720w.jpg" alt="图8-3"></p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-rise</strong> 0.7 [<strong>get_clocks</strong> CLKM]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-fall</strong> 0.65 [<strong>get_clocks</strong> CLKM]</p>
<p>在没有上述命令的情况下，将假定延迟为0，这是早期路径报告中使用的假设。请注意，源延迟不会影响设计内部的路径，并且它们具有相同的发起时钟和捕获时钟，这是因为发起时钟路径和捕获时钟路径都会加上一段相同的延迟。但是，这种延迟确实会影响经过待分析设计输入和输出的时序路径。</p>
<p>如果没有<strong>-source</strong>选项，则<strong>set_clock_latency</strong>命令将定义时钟网络延迟，这是从DUA中时钟定义点到触发器的时钟引脚的延迟。时钟网络延迟用于在建立时钟树之前（即在时钟树综合之前）对通过时钟路径的延迟进行建模。一旦建立了时钟树并标记为了“已传播”（propagated），便会忽略此时钟网络延迟约束。<strong>set_clock_latency</strong>命令也可用于对从主时钟到其衍生时钟的延迟进行建模，如7.3节所述。当时钟生成逻辑不是设计的一部分时，该命令也可用于建模片外时钟延迟。</p>
<h2 id="输入到触发器路径-1">输入到触发器路径</h2>
<p>以下是一个通过输入端口到触发器的路径报告示例，图8-4给出了与输入路径有关的原理图和时钟波形。</p>
<p><img src="https://pic1.zhimg.com/80/v2-3d39c2f3f84ff703df94162afb42db2c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-49d2ee6ba3a15b1b510ab13c45abcd19_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2784635a72641b6b1ea6fb190c6c944c_720w.jpg" alt="图8-4"></p>
<p>首先要注意的是第一行中的<strong>input port clocked by VIRTUAL_CLKM</strong>。如7.9节中所述，该时钟可以被认为是驱动设计输入端口INA的虚拟触发器，该虚拟触发器的时钟为VIRTUAL_CLKM。此外，从该虚拟触发器的时钟引脚到输入端口INA的最大延迟指定为2.55ns，在报告中显示为<strong>input external delay</strong>。可以使用以下SDC命令指定这些参数：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> VIRTUAL_CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {0 5}</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VIRTUAL_CLKM <strong>-max</strong> 2.55 [<strong>get_ports</strong> INA]</p>
<p>请注意，虚拟时钟VIRTUAL_CLKM的定义没有与设计中任何引脚相关，这是因为它是在设计之外定义的（它是虚拟的）。输入延迟约束<strong>set_input_delay</strong>指定了相对于虚拟时钟的延迟。</p>
<p>输入路径从端口INA开始，如何计算连接到端口INA的第一个单元UINV1的延迟呢？一种方法是指定输入端口INA的驱动单元，该驱动单元用于确定驱动强度，从而确定端口INA上的压摆，然后用于计算单元UINV1的延迟。在输入端口INA上没有任何压摆约束的情况下，将假定端口上的过渡是理想的，即过渡时间为0ns。</p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> BUFF <strong>-library</strong> lib0131wc [<strong>get_ports</strong> INA]</p>
<p>图8-4还展示了如何进行建立时间检查。数据必须到达UFF2 / D的时间为9.85ns，但是数据实际到达的时间为2.65ns，因此该报告显示该路径的正裕量为7.2ns。</p>
<h3 id="具有实际时钟的输入路径">具有实际时钟的输入路径</h3>
<p>输入延迟也可以相对于实际时钟来指定，并不一定必须相对于虚拟时钟来指定。实际时钟可以是设计中的内部引脚或者输入端口上的时钟，图8-5描绘了一个示例，其中相对于输入端口CLKP上的时钟指定了端口CIN上的输入延迟约束。此延迟约束为：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> CLKP <strong>-max</strong> 4.3 [<strong>get_ports</strong> CIN]</p>
<p><img src="https://pic4.zhimg.com/80/v2-5d5b17b91a60e2c707cf7c95487c579b_720w.jpg" alt="图8-5"></p>
<p>以下是与此约束相对应的输入路径时序报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-74ddc121e3ec31de31e8a1ddfb68b90b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-bb3afd75dcce80188a1463aba96c0a49_720w.jpg"></p>
<p>请注意，起始点（Startpoint）与预期一致，将输入端口的延迟参考时钟指定为了CLKP。</p>
<h2 id="触发器到输出路径">触发器到输出路径</h2>
<p>与上述输入端口约束类似，可以相对于虚拟时钟或设计中的内部时钟来约束输出端口，或者可以相对于实际的输入时钟端口或输出时钟端口来约束输出端口。以下是一个示例，相对于虚拟时钟约束了输出引脚ROUT，输出约束如下：</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> VIRTUAL_CLKP <strong>-max</strong> 5.1 [<strong>get_ports</strong> ROUT]</p>
<p>● <strong>set_load</strong> 0.02 [<strong>get_ports</strong> ROUT]</p>
<p>为了确定最后一个单元连接到输出端口的延迟，需要指定该端口上的负载，上面使用了<strong>set_load</strong>命令来指定输出负载。请注意，端口ROUT可能在DUA内部具有负载，而<strong>set_load</strong>约束指定的是额外的负载，即来自DUA外部的负载。在没有<strong>set_load</strong>命令约束的情况下，将假定外部负载的值为0（这可能不现实，因为该设计很可能会在其它设计中使用）。下图8-6显示了具有虚拟时钟的虚拟触发器的时序路径：</p>
<p><img src="https://pic3.zhimg.com/80/v2-72e833ba72a92505199136ca40e7c466_720w.jpg" alt="图8-6"></p>
<p>以下是通过该输出端口的时序路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-039ca01eda0e40343b0621348c2691b0_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5c816e85b2089f4a4f04e09142836b8b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-5cfe195e28bac15e1ac77b9f2c4a44fa_720w.png"></p>
<p>注意，指定的输出延迟在报告中显示为<strong>output external delay</strong>，其作用类似于虚拟触发器所需的建立时间。</p>
<h2 id="输入到输出路径">输入到输出路径</h2>
<p>设计也可以具有从输入端口到输出端口的纯组合逻辑路径。可以像我们前面看到的输入和输出路径一样，对路径进行约束和时序分析。下图8-7显示了这种路径的一个示例，虚拟时钟同时用于指定输入和输出端口上的约束，以下是输入和输出延迟约束：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VIRTUAL_CLKM <strong>-max</strong> 3.6 [<strong>get_ports</strong> INB]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> VIRTUAL_CLKM <strong>-max</strong> 5.8 [<strong>get_ports</strong> POUT]</p>
<p><img src="https://pic1.zhimg.com/80/v2-e26f357548803506bdcb89c465ae0438_720w.jpg" alt="图8-7"></p>
<p>以下是一个时序路径报告，它经过从输入INB到输出POUT的组合逻辑。请注意，任何内部时钟延迟（如果存在）都不会对该路径报告产生影响。</p>
<p><img src="https://pic1.zhimg.com/80/v2-7fbbaa3fcd074d83df06fe6c37a9eef0_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-c89b6a73903f863b5cdcaef457cb66c2_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-17184241732765e8977a17781a4e9d68_720w.jpg"></p>
<h2 id="频率直方图">频率直方图</h2>
<p>如果要绘制一个典型设计的建立时间裕量与路径数的频率直方图，则如图8-8所示。根据设计的状态（是否进行了优化） ，对于未优化的设计，零裕量（zero slack）线将更靠近右侧，而对于优化后的设计则更趋向于左侧。对于没有时序违例的设计（即没有路径的裕度为负），整个曲线将在零裕量线的右侧。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4d4edeba9b7db00433733772db4e4b71_720w.jpg" alt="图8-8"></p>
<p>以下是以文本形式显示的直方图，通常可以由静态时序分析工具生成：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e75eef21652cd076cfbe0ad2b4af0b12_720w.jpg"></p>
<p>前两个索引表示裕量的范围，第三个索引是该裕量范围内的路径数，例如，有941条路径的裕量范围为410ps至415ps。直方图表明该设计没有时序违例的路径，即所有路径均具有正的裕量，而关键路径的裕量值在375ps至380ps之间。</p>
<p>难以满足时序要求的设计会使直方图的驼峰向左偏大，也就是说，许多路径的裕量值接近于零。通过观察频率直方图可以得出的另一结果是：可以进一步优化设计以实现零裕量的可能性，即时序收敛有多困难。如果违例路径的数量少并且负裕量值也很小，则设计相对比较容易满足所需的时序。但是，如果违例路径的数量很大并且负裕量值也很大，则这意味着设计将需要付出很大努力才能满足所需的时序。</p>
<h2 id="保持时间检查">保持时间检查</h2>
<p>保持时间检查可确保正在变化的触发器输出值不会传递到捕获触发器、并在捕获触发器有机会捕获其原始值之前重写（overwrite）其输出。该检查基于触发器的保持时间要求，触发器的保持时间要求规定在时钟的有效沿之后的指定时间段内，被锁存的数据应保持稳定。图8-9给出了典型触发器的保持时间要求：</p>
<p><img src="https://pic4.zhimg.com/80/v2-7bb9c308b891e7d3259153c6864f0313_720w.jpg" alt="图8-9"></p>
<p>就像建立时间检查一样，是在发起触发器（发起数据的触发器）和捕获触发器（捕获数据的触发器以及必须满足其保持时间要求的触发器）之间进行保持时间检查的。这两个触发器的时钟可以相同也可以不同，保持时间检查从发起触发器时钟的一个有效沿到捕获触发器中相同的时钟沿。因此，保持时间检查与时钟周期无关，保持时间检查会在捕获触发器时钟的每个有效沿上执行。</p>
<p>现在我们来看一个简单的示例，如图8-10所示，其中发起触发器和捕获触发器具有相同的时钟。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5907ffa768e9dc8a369ea5b2936469d4_720w.jpg" alt="图8-10"></p>
<p>考虑时钟CLKM的第二个上升沿。时钟上升沿发起的数据需要Tlaunch + Tck2q + Tdp时间到达捕获触发器UFF1的D引脚。时钟的同一边沿需要Tcapture时间才能到达捕获触发器的时钟引脚，目的是使捕获触发器在下一个时钟周期捕获来自发起触发器的数据。如果在同一时钟周期内捕获数据，则捕获触发器中的预期数据（来自上一个时钟周期）将被覆盖，因此保持时间检查旨在确保捕获触发器中的目标数据不会被覆盖。保持时间检查可验证这两个时间之差（捕获触发器的数据到达时间和时钟到达时间）必须大于捕获触发器的保持时间，这样触发器上的数据才不会被覆盖，并且捕获到可靠的数据。</p>
<p>保持时间检查可以用数学公式表示为：</p>
<p>● Tlaunch + Tck2q + Tdp &gt; Tcapture + Thold</p>
<p>其中Tlaunch是发起触发器的时钟树延迟，Tdp是组合逻辑数据路径中的延迟，Tcapture是捕获触发器的时钟树延迟。换句话说，由时钟边沿发起的数据到达捕获触发器D引脚所需的总时间必须大于时钟同一边沿到达捕获触发器所需的时间加上保持时间。这样可以确保UFF1 / D保持稳定状态，直到触发器的时钟引脚UFF1 / CK时钟上升沿之后的保持时间为止。</p>
<p>保持时间检查对捕获触发器的数据路径施加了最小值（<strong>-min</strong>）约束，需要确定到捕获触发器D引脚的最快路径。这意味着将始终使用最短时序路径来进行保持时间检查，同样，通常在快速工艺角下进行保持时间检查。</p>
<p>即使设计中只有一个时钟，时钟树也会导致时钟在发起触发器和捕获触发器处的到达时间大不相同。为了确保可靠的数据捕获，捕获触发器的时钟沿必须在数据可改变之前到达。保持时间检查可确保（见图8-11）：</p>
<p>● 当前数据发起时钟沿（Setup launch edge）的下一个（subsequent）时钟沿发起的数据不被当前数据捕获时钟沿（Setup receiving edge）所捕获。</p>
<p>● 当前数据发起时钟沿发起的数据不被当前数据捕获时钟沿的前一个（Preceding）时钟沿所捕获。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f8eacf5e438626f6b7d49d5620612e92_720w.jpg" alt="图8-11"></p>
<p>如果发起时钟和捕获时钟都属于同一时钟域，则这两个保持时间检查实质上是相同的。但是，当发起时钟和捕获时钟处于不同频率或处于不同时钟域时，以上两个保持时间检查就有可能是不同的。在这种情况下，最差的保持时间检查就是所要报告的检查。上图8-11说明了这两个保持时间检查。</p>
<p>UFF0是发起触发器，UFF1是捕获触发器。建立时间检查在这一个数据发起时钟沿（Setup launch edge）和这一个数据捕获时钟沿（Setup receiving edge）之间。下一个数据发起时钟沿（Subsequent launch edge）不得以太快的速度传播数据，因为这可能会导致这一个数据捕获时钟沿没有时间可靠地捕获这一个数据。此外，这一个数据发起时钟沿同样不得以太快的速度传播数据，因为这可能会导致前一个数据捕获时钟沿（Preceding receiving edge）没有时间可靠地捕获前一个数据。在上述各种情况中，最差情况的保持时间检查对应于最严格的保持时间检查。</p>
<p>稍后将在8.3节和8.8节中分别讨论更通用的时钟，例如用于多周期路径和多频率路径的时钟。讨论内容将涵盖建立时间检查和保持时间检查之间的关系，尤其是如何从建立时间检查中推断出保持时间检查。虽然建立时间违例会导致设计的工作频率降低，但保持时间违例会“杀死”（kill）设计，即设计在任何频率下都无法运行。因此，了解保持时间检查并解决任何违例行为非常重要。</p>
<h2 id="触发器到触发器路径-2">触发器到触发器路径</h2>
<p>本小节将基于图8-2中示例说明触发器到触发器的保持时间路径。以下是一份保持时间检查的路径报告，该示例来自8.1节中的建立时间检查路径。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0f40e857c1e3d32138c152dc1cd69e27_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-be3487ce1ba509d89f9cc0ba8063c253_720w.jpg"></p>
<p>注意，路径类型（<strong>Path Type</strong>）为最小值(<strong>min</strong>)，表示使用了最短路径的单元延迟值，这对应于保持时间检查。库保持时间（<strong>library hold time</strong>）指定了触发器UFF1的保持时间。如前3.4节所述，触发器的保持时间也可以为负。请注意，发起和捕获路径都是从时钟CLKM的上升沿（触发器的有效沿）开始计算的。时序报告显示，新数据最早可以到达UFF1、同时又可以安全地捕获上一个时钟周期数据的时间为0.19ns。由于新数据的实际到达时间为0.33ns，因此报告显示正的保持时间裕量（slack）为0.14ns。</p>
<p>图8-12显示了时钟信号到达发起和捕获触发器时钟引脚的时间，以及数据在捕获触发器处的最早允许到达时间和实际到达时间。由于数据实际到达的时间晚于数据所需到达的时间（允许的最早到达时间），因此满足保持时间要求。</p>
<p><img src="https://pic1.zhimg.com/80/v2-80590009e4f9c7cb3d589878d66bbbbc_720w.jpg" alt="图8-12"></p>
<h3 id="保持时间裕量计算">保持时间裕量计算</h3>
<p>需要注意的一点是，为建立时间和保持时间的时序报告计算裕量值的方式有所不同。在建立时间报告中，会计算数据实际到达时间和数据需要到达时间，然后将需要到达时间减去实际到达时间，从而得到建立时间的裕量值。但是，在保持时间报告中，当我们把需要到达时间减去实际到达时间后，负的结果将转化为正的裕量值（表示满足保持时间要求），而正的结果将转化为负的裕量值（表示保持时间违例）。</p>
<h2 id="输入到触发器路径-2">输入到触发器路径</h2>
<p>接下来介绍输入端口的保持时间检查。有关示例，请参见图8-4。使用虚拟时钟将输入端口上的最小延迟指定为：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VIRTUAL_CLKM <strong>-min</strong> 1.1 [<strong>get_ports</strong> INA]</p>
<p>以下是一份保持时间检查的路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-6db404d96bc2a10e723288833c2d0384_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e866109a9bcbdffa607a96eb8f5c0382_720w.jpg"></p>
<p><strong>input external delay</strong>中的值为输入延迟约束命令中的指定值。在0时刻的VIRTUAL_CLKM上升沿和CLKM上升沿之间进行保持时间检查。UFF2在不违反其保持时间的情况下捕获数据所需的到达时间为0.25ns，这表明数据应在0.25ns之后到达。由于数据实际上在1.2ns才到达，因此显示出0.95ns的正裕量。</p>
<h2 id="触发器到输出路径-1">触发器到输出路径</h2>
<p>这小节将介绍输出端口上的保持时间检查。示例见图8-6，输出端口延迟约束为：</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> VIRTUAL_CLKP <strong>-min</strong> 2.5 [<strong>get_ports</strong> ROUT]</p>
<p>输出延迟也是相对于虚拟时钟指定的，这是另一份保持时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1131e4618833380b31748402cf41e3d3_720w.jpg"></p>
<p>请注意，<strong>output external delay</strong>中的值为输出延迟约束命令中的指定值。</p>
<h3 id="具有实际时钟的触发器到输出路径">具有实际时钟的触发器到输出路径</h3>
<p>有一条输出端口保持时间检查的路径，如图8-13所示。请注意，最小输出延迟是相对于实际时钟指定的。</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> CLKP <strong>-min</strong> 3.5 [<strong>get_ports</strong> QOUT]</p>
<p>● <strong>set_load</strong> 0.55 [<strong>get_ports</strong> QOUT]</p>
<p><img src="https://pic4.zhimg.com/80/v2-a479c55b7042e3b0c80805b521180b57_720w.jpg" alt="图8-13"></p>
<p>以下是保持时间报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-00db8edbd8862bc0738af3edda46c53d_720w.jpg"></p>
<p>保持时间检查是在时钟CLKP的上升沿（触发器的有效沿）处执行的。以上报告表明，这条触发器到输出的路径保持时间的正裕量为4.46ns。</p>
<h2 id="输入到输出路径-1">输入到输出路径</h2>
<p>这是对输入到输出路径的保持时间检查，如图8-7所示。端口的约束为：</p>
<p>● <strong>set_load</strong> <strong>-pin_load</strong> 0.15 [<strong>get_ports</strong> POUT]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> VIRTUAL_CLKM <strong>-min</strong> 3.2 [<strong>get_ports</strong> POUT]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VIRTUAL_CLKM <strong>-min</strong> 1.8 [<strong>get_ports</strong> INB]</p>
<p>● <strong>set_input_transition</strong> 0.8 [<strong>get_ports</strong> INB]</p>
<p><img src="https://pic1.zhimg.com/80/v2-8e621f38e5f80d99c789dc23f3a8ac44_720w.jpg"></p>
<p>输入端口和输出端口上的延迟约束是相对于虚拟时钟指定的，因此，保持时间检查是在该虚拟时钟的上升沿（有效沿）处执行的。</p>
<h2 id="多周期路径">多周期路径</h2>
<p>在某些情况下，两个触发器之间的数据路径可能需要一个以上的时钟周期才能传播通过逻辑。在这种情况下，这条组合逻辑路径会被定义为多周期路径（multicycle path）。虽然数据还是会在每个时钟沿上都被捕获触发器捕获，但我们需要告知STA在指定数量的时钟周期之后才会出现有效的捕获时钟沿。</p>
<p>图8-14是一个示例。由于数据路径最多需要三个时钟周期，因此应指定三个周期的多周期建立时间检查。为此需要指定如下的多周期建立时间约束：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b6dbc3d5b18b182e07679c13e1023ae4_720w.jpg" alt="图8-14"></p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>set_multicycle_path</strong> 3 <strong>-setup</strong> <strong>-from</strong> [<strong>get_pins</strong> UFF0/Q] <strong>-to</strong> [<strong>get_pins</strong> UFF1/D]</p>
<p>多周期建立时间约束规定，建立时间检查时从UFF0 / CK到UFF1 / D的路径最多可以花费三个时钟周期，这意味着设计每三个周期才会使用一次UFF1 / Q引脚上输出的数据，而不是每个周期都使用。</p>
<p>以下是一份具有多周期约束的建立时间路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-62b1fa198a38597ce1bb1870137fa5dc_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c99fc8a3cfcdd6a36bf155a69cc964fb_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-f7d25a791a3428e779e12b9785474726_720w.jpg"></p>
<p>注意，现在捕获触发器的时钟沿距离发起触发器的时钟沿三个时钟周期，为30ns。</p>
<p>现在，我们来检查一下多周期路径上的保持时间检查。在最常见的情况下，我们希望保持时间检查保持不变（与单周期路径一致），如图8-14所示，这样可使数据在三个时钟周期之内任意进行改变。只有指定多周期保持时间为2，才可以获得与单周期建立时间检查情况相同的保持时间检查。这是因为在没有这样的多周期保持时间约束的情况下，默认的保持时间检查是在建立时间捕获沿的前一个有效时钟沿上执行的，这显然不是我们希望的。我们需要将执行保持时间检查的时钟沿移动到默认时钟沿之前的两个周期，因此指定了多周期保持时间为2。预期的检查如图8-15所示，通过多周期保持时间约束，数据路径的最小延迟可以小于一个时钟周期。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b117769efdab9219481e8475fa8318bc_720w.jpg" alt="图8-15"></p>
<p>● <strong>set_multicycle_path</strong> 2 <strong>-hold</strong> <strong>-from</strong> [<strong>get_pins</strong> UFF0/Q] <strong>-to</strong> [<strong>get_pins</strong> UFF1/D]</p>
<p>多周期保持时间约束命令中的周期数指定了从默认保持时间检查沿（建立时间捕获沿之前的一个有效沿）需要移回多少个时钟周期。 以下是一份保持时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e287504a7ce5a03f6db6c992ad9af5d7_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d9f5052b0a8070b88daaa8a0a2a7d071_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e36290fc716ff88e1a7dce071f6d22c0_720w.jpg"></p>
<p>由于此路径的多周期建立时间约束为3，因此其默认保持时间检查是在建立时间捕获沿之前的有效时钟沿上执行的。在大多数设计中，如果最大路径（或建立时间）需要N个时钟周期，则大于（N-1）个时钟周期的最小路径约束是不可行的。通过指定两个周期的多周期保持时间约束，可以将保持时间检查时钟沿移回到数据发起沿处（即0ns处），如上面的路径报告中所示。</p>
<p>因此在大多数设计中，指定为N（周期）的多周期建立时间约束应伴随着指定为N-1（周期）的多周期保持时间约束。</p>
<p>如果指定了N个周期的多周期建立时间约束，但缺少了相应的N-1个周期的多周期保持时间约束，会发生什么情况呢？在这种情况下，会在建立时间捕获沿之前的一个周期时钟沿上执行保持时间检查。图8-16显示了仅约束多周期建立时间为3个周期时，进行这种保持时间检查的情况。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4f7c3e1caaa640e245662de1aed04abd_720w.jpg" alt="图8-16"></p>
<p>如图所示，这规定了数据只能在建立时间捕获沿之前的一个周期内进行改变。因此，数据路径必须具有至少两个时钟周期的最小延迟才能满足此要求。以下是这种情况的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7ba25cf8dce135166cb9c28c7e95a04d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-3a19f3b2dea6179dad34ab548e115d32_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ef38d0cdd0f62f8fb7d56fd55e1af11e_720w.png"></p>
<p>从路径报告中注意到，在捕获沿之前的一个时钟沿对保持时间进行了检查，这导致了较大的保持时间违例。实际上，该保持时间检查将要求组合逻辑中的最小延迟至少为两个时钟周期。</p>
<h3 id="跨时钟域">跨时钟域</h3>
<p>让我们考虑在周期相同的两个不同时钟之间存在多周期路径的情况。（时钟周期也不同的情况将在本章后面进行介绍）</p>
<p>例子1：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKP]</p>
<p>多周期建立时间约束指定了给定路径的时钟周期数，如图8-17所示。默认建立时间捕获沿总是与发起沿相隔一个时钟周期，约束多周期建立时间为2会使建立时间捕获沿与发起沿相隔2个时钟周期。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9e48c6a8f893ae6df5e4e73720d00771_720w.jpg" alt="图8-17"></p>
<p>多周期保持时间约束指定了保持时间检查应该在建立时间捕获沿之前几个时钟周期的时钟沿处执行，无论建立时间发起沿在何处，如图8-18所示。默认的保持时间检查是在建立时间捕获沿之前一个周期的时钟沿处执行的。约束多周期保持时间为1会将保持时间检查放置于默认保持时间检查之前一个周期的时钟沿处，因此变为建立时间捕获沿之前两个周期的时钟沿处。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5b0a0e115577687841e0a3d42963c3d7_720w.jpg" alt="图8-18"></p>
<p>假设有如下多周期路径约束：</p>
<p>● <strong>set_multicycle_path</strong> 2 <strong>-from</strong> [<strong>get_pins</strong> UFF0/CK] <strong>-to</strong> [<strong>get_pins</strong> UFF3/D]</p>
<p>由于没有<strong>-hold</strong>选项，因此将默认为<strong>-setup</strong>选项。以上约束指定多周期建立时间为2且多周期保持时间为0。对应建立时间检查的路径报告如下所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-bebe473e6ec8ca8b165d1de6d2f250b7_720w.jpg"></p>
<p>注意，路径报告中所打印出的路径组（Path Group）始终是捕获触发器的路径组，在这种情况下为CLKP。</p>
<p>接下来是保持时间检查的路径报告。由于多周期保持时间约束默认为0，因此将在建立时间捕获沿（20ns）之前一个时钟周期的10ns处进行保持时间检查。</p>
<p><img src="https://pic2.zhimg.com/80/v2-933545e9521f0d70f3a80b67c719bf85_720w.jpg"></p>
<p>以上报告报出了保持时间违例，这可以通过将多周期保持时间约束指定为1来消除，下面的另一个示例对此进行了说明。</p>
<p>例子2：</p>
<p>● <strong>set_multicycle_path</strong> 2 <strong>-from</strong> [<strong>get_pins</strong> UFF0/CK] <strong>-to</strong> [<strong>get_pins</strong> UFF3/D] <strong>-setup</strong></p>
<p>● <strong>set_multicycle_path</strong> 1 <strong>-from</strong> [<strong>get_pins</strong> UFF0/CK] <strong>-to</strong> [<strong>get_pins</strong> UFF3/D] <strong>-hold</strong></p>
<p>以下是多周期建立时间约束为2时建立时间检查的路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b87c3eec180aa91dcfbae65246d8bbcc_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-f47d32d80b8d871bd2f86a32d315a87c_720w.png"></p>
<p>以下是多周期保持时间约束为1时保持时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-7f20135a427c8eb2aef53c474930d31d_720w.jpg"></p>
<p>请注意，本节中建立时间检查和保持时间检查的示例报告是针对同一工艺角（corner）的。通常，在最坏情况的慢速工艺角下，建立时间检查最难满足（裕量最小），而在最佳情况的快速工艺角下，保持时间检查最难满足（裕量最小）。</p>
<h2 id="伪路径">伪路径</h2>
<p>当设计的功能运行时，某些时序路径可能不真实（或不可能）存在。在执行STA时可以将这些路径设置为伪路径（false path），这样就可以关闭这些路径，那么STA就不会对这些伪路径去进行分析了。</p>
<p>伪路径可能是从一个时钟域到另一个时钟域、从触发器的时钟引脚到另一触发器的输入引脚、通过一个单元的引脚、通过多个单元的引脚或这些情况的组合 。当通过单元的引脚指定了伪路径后，通过该引脚的所有路径都将被忽略，无需进行时序分析。辨别出伪路径的好处在于减少了分析空间，从而使分析可以专注于真实存在的路径，这同样有助于减少分析时间。但是，过多使用<strong>-through</strong>选项去指定伪路径同样会降低分析的速度。</p>
<p>可以使用<strong>set_false_path</strong>命令来约束伪路径，以下是一些例子：</p>
<p>● <strong>set_false_path</strong> <strong>-from</strong> [<strong>get_clocks</strong> SCAN_CLK] <strong>-to</strong> [<strong>get_clocks</strong> CORE_CLK]</p>
<p>● <strong>set_false_path</strong> <strong>-through</strong> [<strong>get_pins</strong> UMUX0/S]</p>
<p>● <strong>set_false_path</strong> <strong>-through</strong> [<strong>get_pins</strong> SAD_CORE/RSTN]</p>
<p>● <strong>set_false_path</strong> <strong>-to</strong> [<strong>get_ports</strong> TEST_REG*]</p>
<p>● <strong>set_false_path</strong> <strong>-through</strong> UINV/Z <strong>-through</strong> UAND0/Z</p>
<p>下面给出了一些关于设置伪路径的建议。要在两个时钟域之间设置伪路径，请使用：</p>
<p>● <strong>set_false_path</strong> <strong>-from</strong> [<strong>get_clocks</strong> clockA] <strong>-to</strong> [<strong>get_clocks</strong> clockB]</p>
<p>而不要使用：</p>
<p>● <strong>set_false_path</strong> <strong>-from</strong> [<strong>get_pins</strong> {regA_ * }/CK] <strong>-to</strong> [<strong>get_pins</strong> {regB_ * }/D]</p>
<p>后者这种方式要慢得多。</p>
<p>另一个建议是尽可能少使用<strong>-through</strong>选项，因为它增加了运行时不必要的复杂性。仅在绝对有必要且没有替代方法可以指定该伪路径的情况下，才可以使用<strong>-through</strong>选项。</p>
<p>从优化的角度来看，还有一个建议是不要将一条多周期路径约束为伪路径。如果需要在已知或可预测的时刻对信号进行采样，则无论时间间隔多大，都应使用多周期路径约束，以使路径具有一定的约束条件并进行优化以满足多周期约束。如果把一条许多时钟周期后进行采样的路径指定为了伪路径，则对设计中其余逻辑路径的优化可能会使该路径变长，甚至超出所需的时间。</p>
<h2 id="半周期路径">半周期路径</h2>
<p>如果设计中同时具有负边沿触发的触发器（有效时钟沿为下降沿）和正边沿触发的触发器（有效时钟沿为上升沿），则设计中可能存在半周期路径（half-cycle path）。半周期路径可能是从一个触发器的上升沿到另一个触发器的下降沿，或者反过来。图8-19给出了一个示例，其中数据的发起沿在触发器UFF5的时钟下降沿，而数据的捕获沿在触发器UFF3的时钟上升沿。</p>
<p><img src="https://pic2.zhimg.com/80/v2-98e248e7f84f99f7b535eef692c254f9_720w.jpg" alt="图8-19"></p>
<p>以下是建立时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-be44e53af2cedef45de62eb76c90b575_720w.jpg"></p>
<p>请注意起点（Startpoint）和终点（Endpoint）中的边沿说明。时钟CLKP的下降沿出现在6ns，上升沿出现在12ns。因此，数据需要在半个周期6ns内到达捕获触发器的输入引脚。</p>
<p>虽然在建立时间检查时数据路径仅有半个时钟周期，但额外的半个周期可用于保持时间检查。以下是保持时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4337b666f076001550167575c7f6ed96_720w.jpg"></p>
<p>保持时间检查通常是在捕获沿之前一个周期的捕获沿上执行的。由于捕获沿是在12ns处，因此前一个捕获沿在0ns处，故将在0ns处检查保持时间。这为保持时间检查有效地增加了半个时钟周期的裕量，因此可以看见保持时间检查有较大的正裕量（slack）。</p>
<h2 id="撤销时间检查">撤销时间检查</h2>
<p>撤销时间检查（removal timing check）可确保在有效时钟沿与释放异步控制信号之间有足够的时间。该检查可确保有效时钟沿不带来影响，因为异步控制信号将保持有效状态，直到有效时钟沿之后一段撤销时间为止。换句话说，异步控制信号会在有效时钟沿之后被释放（变为无效），因此该时钟沿不会产生任何影响，如图8-20所示。该检查基于的是触发器异步引脚上指定的撤销时间。以下是单元库中与撤销时间检查有关的描述片段：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9446a98d4591a4b35eec82f9b8fd396e_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-35a25d4990cb865aff5126d8474f61b0_720w.jpg" alt="图8-20"></p>
<p>与保持时间检查一样，该检查也是针对最小路径的，不过是在触发器的异步引脚上。</p>
<p><img src="https://pic1.zhimg.com/80/v2-157aac547d8db6508fb0b58ab19e540c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-e5296208be4d862dbf54ec4cab3ac799_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-930bb46a44c12c6b506b8528d356bc22_720w.png"></p>
<p>终点（Endpoint）表明这是撤销时间检查，且在触发器UFF6的异步引脚CDN上。该触发器的撤销时间在报告中显示为<strong>library removal time</strong>，值为0.19ns。</p>
<p>所有异步时序检查均被分配给了<strong>async_default</strong>路径组。</p>
<h2 id="恢复时间检查">恢复时间检查</h2>
<p>恢复时间检查（recovery timing check）可确保异步信号变为无效状态的时刻与下一个有效时钟沿之间的时间间隔大于一个最小值。换句话说，此检查可确保在异步信号变为无效状态之后，有足够的时间恢复，以便下一个有效时钟沿可以生效。例如，考虑从异步复位变为无效的时刻到触发器有效时钟沿之间的时间间隔。如果该时间间隔太短即有效时钟沿在复位释放后太早出现，则触发器可能进入未知的状态。恢复时间检查如图8-21所示。该检查基于的是触发器异步引脚上指定的恢复时间，单元库文件中与恢复时间有关的描述片段如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-9f217e87d027a4610864f52178de628f_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-b7c6c3f07693d7dc422a6ce03431efcc_720w.jpg" alt="图8-21"></p>
<p>与建立时间检查一样，该检查也是针对最大路径的，不过是在触发器的异步引脚上。</p>
<p>以下是一份恢复时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-7619e34d61d05c4ad88ee4114701cdd2_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0b777a54b5ab9bc0826c8e504047b446_720w.jpg"></p>
<p>终点（Endpoint）表明这是恢复时间检查，并且触发器UFF6的恢复时间在报告中显示为<strong>library recovery time</strong>，值为0.09ns。恢复时间检查也属于<strong>async_default</strong>路径组。</p>
<h2 id="跨时钟域的时序">跨时钟域的时序</h2>
<h2 id="慢速时钟域到快速时钟域">慢速时钟域到快速时钟域</h2>
<p>让我们来对一条从慢速时钟域到快速时钟域的路径来进行建立时间与保持时间检查，如图8-22所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5cee19981b9506cc2e1ad248117133bb_720w.jpg" alt="图8-22"></p>
<p>这是以上示例的时钟定义：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 20 <strong>-waveform</strong> {0 10} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 5 <strong>-waveform</strong> {0 2.5} [<strong>get_ports</strong> CLKP]</p>
<p>当数据发起触发器和捕获触发器的时钟频率不同时，STA会首先确定一个公共基本周期（common base period）。下面给出了在具有上述两个时钟的设计中执行STA时打印出的信息。较快的时钟会被延拓，以便获得一个公共周期。</p>
<p><img src="https://pic2.zhimg.com/80/v2-75af10ab6538a9fcfac9c6882dad94c9_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ed4a7b73458ce8e4b4abea36c8ec9fca_720w.jpg" alt="图8-23"></p>
<p>图8-23中为建立时间检查。默认情况下，将使用最严格的建立时间边沿去检查，在本例中为5ns处的时钟沿。以下是此时建立时间检查的路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-6cc2e34ceaccac6b9ff0442672283ffc_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-50e78515a3aecd4746713811c64d92c6_720w.jpg"></p>
<p>请注意，发起时钟沿为0ns，而捕获时钟沿为5ns。</p>
<p>如前所述，保持时间检查与建立时间检查有关，并确保由当前时钟沿发起的数据不会干扰先前数据的捕获。这是保持时间检查的报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-758b391685327d0956fbc3176ad235ab_720w.jpg"></p>
<p>在上面的示例中，我们可以看到发起的数据在捕获时钟的第四个周期可用。让我们假设该设计的目的不是在CLKP的下一个有效沿上就捕获数据，而是在每第4个捕获沿上捕获数据。该假设给触发器之间的组合逻辑路径提供了4个CLKP周期的时间，即20ns。我们可以通过设置以下多周期路径约束来做到这一点：</p>
<p>● <strong>set_multicycle_path</strong> 4 <strong>-setup</strong> <strong>-from</strong> [<strong>get_clocks</strong> CLKM] <strong>-to</strong> [<strong>get_clocks</strong> CLKP] <strong>-end</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-c598847be8e50d1c679d7f9b63643ab5_720w.jpg">图8-24</p>
<p><strong>-end</strong>选项指定了多周期4是用于终点（endpoint）或捕获时钟的。此多周期路径约束将建立时间和保持时间检查更改为了图8-24中所示。 以下是这种情况下建立时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-fd2b0f8f0247669f91bc1dddd83b211b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-74889e51ed9e6d3b3eb527766cbc5f39_720w.jpg"></p>
<p>上图8-24中也说明了保持时间检查，请注意，保持时间检查是根据建立时间检查而决定的，默认为当前数据捕获沿之前的一个周期。以下是保持时间检查的路径报告。注意，保持时间捕获沿为15ns，比建立时间捕获沿（20ns）早一个周期（5ns）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-ef224897373aa0d5402b5730a82c163b_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9818b5c85b873b62b58377eef9469ffc_720w.jpg"></p>
<p>在大多数设计中，这不是理想的时序检查，应将保持时间检查一直移回到数据发起沿所在位置。因此，我们可以约束多周期保持时间为3。</p>
<p>● <strong>set_multicycle_path</strong> 3 <strong>-hold</strong> <strong>-from</strong> [<strong>get_clocks</strong> CLKM] <strong>-to</strong> [<strong>get_clocks</strong> CLKP] <strong>-end</strong></p>
<p>3是指将保持时间检查沿向后移三个CLKP时钟周期，即0ns时刻处。与多周期建立时间约束的区别在于：在多周期建立时间约束中，建立时间捕获沿会从默认的建立时间捕获沿向前移动指定的周期数；而在多周期保持时间约束中，保持时间检查沿会从默认的保持时间检查沿向后移动指定的周期数。<strong>-end</strong>选项意味着我们想将终点（或捕获边沿）移回指定的周期数，即捕获时钟的周期数。代替<strong>-end</strong>的另一种选项<strong>-start</strong>指定了要移动的发起时钟周期数，<strong>-end</strong>选项指定了要移动的捕获时钟周期数。<strong>-end</strong>是多周期建立时间约束的默认值，<strong>-start</strong>是多周期保持时间约束的默认值。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1b873d910b82f69ecdf2923b6df7fa09_720w.jpg" alt="图8-25"></p>
<p>使用多周期保持时间约束，可以将保持时间检查的时钟沿往回移，检查效果如图8-25所示。具有多周期保持时间约束的保持时间检查路径报告如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-9b21f1983b5fe4065df9b67b2e0d6070_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-03da8487190c40b1953d3573ab5d72dd_720w.jpg"></p>
<p>总之，如果指定了N个周期的多周期建立时间，那么很可能还应指定N-1个周期的多周期保持时间。对于慢速到快速时钟域之间的路径，多周期路径约束的一个好经验是使用<strong>-end</strong>选项。使用此选项，可以根据快速时钟的时钟周期来调整建立时间和保持时间检查。</p>
<h2 id="快速时钟域到慢速时钟域">快速时钟域到慢速时钟域</h2>
<p>在本小节中，我们考虑数据路径从快速时钟域到慢速时钟域的示例。使用以下时钟定义时，默认的建立时间和保持时间检查如图8-26所示。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 20 <strong>-waveform</strong> {0 10} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 5 <strong>-waveform</strong> {0 2.5} [<strong>get_ports</strong> CLKP]</p>
<p><img src="https://pic4.zhimg.com/80/v2-6537c2f28f33e56234f05de21b22bee3_720w.jpg" alt="图8-26"></p>
<p>总共可能有四种建立时间检查，请参阅图8-26中的Setup1，Setup2，Setup3和Setup4。其中，最严格的是Setup4检查。以下是此最严格检查的路径报告。请注意，数据发起时钟沿为15ns，捕获时钟沿为20ns。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a56435e6b2ccf181fce57abb8b1b94b6_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-745dd34032d28368021dea1f9774f572_720w.jpg"></p>
<p>与建立时间检查类似，总共也可能有四种保持时间检查。图8-26中所示为最严格的保持时间检查，该检查可确保0ns处的捕获沿不捕获0ns处正在发起的数据。以下是这种情况下保持时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-6968f05dbbd40c9364e4dba8e12a557b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-7f7c96c7dff67003def27a548ca2d52a_720w.jpg"></p>
<p>通常，设计人员可以将从快时钟域到慢时钟域的数据路径指定为多周期路径。如果想要放宽建立时间检查，比如为数据路径提供两个快时钟周期，则此多周期路径约束如下：</p>
<p>● <strong>set_multicycle_path</strong> 2 <strong>-setup</strong> <strong>-from</strong> [<strong>get_clocks</strong> CLKP] <strong>-to</strong> [<strong>get_clocks</strong> CLKM] <strong>-start</strong></p>
<p>● <strong>set_multicycle_path</strong> 1 <strong>-hold</strong> <strong>-from</strong> [<strong>get_clocks</strong> CLKP] <strong>-to</strong> [<strong>get_clocks</strong> CLKM] <strong>-start</strong></p>
<p>在这种情况下，图8-27中为用于建立时间和保持时间检查的时钟沿。<strong>-start</strong>选项指定周期数的单位（在这种情况下为2）是发起时钟周期（在这种情况下为CLKP）。约束多周期建立时间为2会将发起沿移动到默认发起沿之前的一个时钟沿，即在10ns而不是默认的15ns处。多周期保持时间约束确保了在0ns处发起沿发起的数据，不会被0ns处的捕获沿捕获到。</p>
<p><img src="https://pic1.zhimg.com/80/v2-267d83e99120cfa9e95d1a656ebc082c_720w.jpg" alt="图8-27"></p>
<p>以下是建立时间检查的路径报告。与预期一样，发起时钟沿为10ns，捕获时钟沿为20ns。</p>
<p><img src="https://pic4.zhimg.com/80/v2-daee7d8960c241cfe97ef697d05189b7_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d61dac1f9813367a4680029f6df317ac_720w.jpg"></p>
<p>以下是保持时间检查的路径报告。保持时间检查是在0ns处执行的，此时捕获时钟和发起时钟均为上升沿。</p>
<p><img src="https://pic1.zhimg.com/80/v2-65feb213ee8cd1f086fc630fcb6ac744_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-33f3057fc54ce7bbe2d4bcd4ed15de5c_720w.jpg"></p>
<p>与从慢速时钟域到快速时钟域的路径不同，在从快速时钟域到慢速时钟域的路径中，多周期路径约束的一个好经验是使用<strong>-start</strong>选项，然后再根据快速时钟调整建立时间和保持时间检查。</p>
<h2 id="举例">举例</h2>
<p>在本节中，我们将介绍发起和捕获时钟的不同情况，并分别说明如何执行建立时间和保持时间检查。图8-28为所举例子的示意图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1c67162a7ab4ffc81e7b74dbf575f463_720w.jpg" alt="图8-28"></p>
<h3 id="半周期路径情况1">半周期路径——情况1</h3>
<p>在此示例中，两个时钟具有相同的周期，但相位相反。以下是时钟定义，其波形如图8-29所示。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 20 <strong>-waveform</strong> {0 10} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 20 <strong>-waveform</strong> {10 20} [<strong>get_ports</strong> CLKP]</p>
<p><img src="https://pic1.zhimg.com/80/v2-0d75e8b214de6e70ca6123947ac8feac_720w.jpg" alt="图8-29"></p>
<p>建立时间检查是从发起沿（0ns）到下一个捕获沿（10ns）的。半个时钟周期的裕量可用于保持时间检查，以验证在20ns处发起的数据是否在10ns处未被捕获沿所捕获。以下是建立时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-ea993d4b1d7958476a3c260237a66aed_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-65375ce6412e93e1d0098c7c15bebafb_720w.jpg"></p>
<p>以下是保持时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-9e646731344f89b485f26eb007572523_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e07c0e075ea754d22a239c46109f5dc3_720w.jpg"></p>
<h3 id="半周期路径情况2">半周期路径——情况2</h3>
<p>此示例与情况1类似，不过发起时钟和捕获时钟的相位相反。以下是时钟定义，其波形如图8-30所示。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {5 10} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKP]</p>
<p><img src="https://pic1.zhimg.com/80/v2-8e3dd1a39311ae28d979af87c8c8f800_720w.jpg" alt="图8-30"></p>
<p>建立时间检查从5ns的发起时钟沿到10ns的下一个捕获时钟沿。保持时间检查从5ns的发起时钟沿到0ns的捕获时钟沿。以下是建立时间检查的路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-16ad3f2a0a9cf8dff3466d0472ad2044_720w.jpg"></p>
<p>以下是保持时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1b0b966e5111b721b3e771364a07e9e9_720w.jpg"></p>
<h3 id="快速时钟域到慢速时钟域-1">快速时钟域到慢速时钟域</h3>
<p>在此示例中，捕获时钟是发起时钟的二分频。以下是时钟定义：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 20 <strong>-waveform</strong> {0 10} [<strong>get_ports</strong> CLKP]</p>
<p><img src="https://pic3.zhimg.com/80/v2-20251c15b2ad5518aca2ca5ef738fbee_720w.jpg" alt="图8-31"></p>
<p>波形如图8-31所示。建立时间检查是从10ns的发起沿到20ns的捕获沿，保持时间检查是从0ns的发起沿到0ns的捕获沿。以下是建立时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-3eff6e34bb8b98e3dba16d67165bc8ca_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-4999aa7814511ceba7bbbfd72d2791fe_720w.jpg"></p>
<p>以下是保持时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-256a93a2c7f24c9ce95832028c220d0f_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-fad0265ae2aeeab61881811fdd45a2d4_720w.jpg"></p>
<h3 id="慢速时钟域到快速时钟域-1">慢速时钟域到快速时钟域</h3>
<p>在此示例中，捕获时钟速度是发起时钟速度的2倍。图8-32中为建立时间和保持时间检查对应的时钟沿：从发起沿0ns到下一个捕获沿5ns进行建立时间检查，保持时间检查是在建立时间捕获沿前一个周期的捕获沿进行的，也就是说，发起沿和捕获沿都为0ns。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7424cb688e4685cb1a35eef964f49852_720w.jpg" alt="图8-32"></p>
<p>以下是建立时间检查的路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e24334d68bb29ca1945c2c347f747824_720w.jpg"></p>
<p>以下是保持时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c6d4bc53f4a925c20866dee8d1dab50a_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-5d36d983d3cb91b32b09c79b8acd50e1_720w.jpg"></p>
<h2 id="多时钟">多时钟</h2>
<h2 id="整数倍">整数倍</h2>
<p>在设计中通常会定义多个时钟，这些时钟的频率是彼此的整数倍。在这种情况下，会通过计算所有相关时钟（related clocks）之间的公共基本周期来执行STA（如果两个时钟域之间具有数据路径，则两个时钟相关）。建立公共基本周期的目的是以便所有时钟都同步。</p>
<p>以下是3个相关时钟的示例：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 20 <strong>-waveform</strong> {0 10} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKQ <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKQ]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 5 <strong>-waveform</strong> {0 2.5} [<strong>get_ports</strong> CLKP]</p>
<p>分析CLKP和CLKM时钟域之间的路径时，将使用20ns的公共基本周期，如图8-33所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4cc0aee5fd52adc7397f7f4adbce8d7b_720w.jpg" alt="图8-33"></p>
<p>以下是建立时间检查的路径报告，用于从较快时钟CLKP到较慢时钟CLKM的路径。</p>
<p><img src="https://pic2.zhimg.com/80/v2-cebf93a442a66c9a3972e637b34657c9_720w.jpg"></p>
<p>相应保持时间检查的路径报告如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b914046b4e5cf3baf8ce4cf3bde2d1b0_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9cf4669632611ea17512f87b405a5bb4_720w.jpg"></p>
<h2 id="非整数倍">非整数倍</h2>
<p>考虑当两个频率不是彼此整数倍的时钟域之间存在数据路径的的情况。例如，发起时钟是公共时钟的8分频，而捕获时钟是公共时钟的5分频，如图8-34所示。本节将介绍在这种情况下如何执行建立时间和保持时间检查。</p>
<p><img src="https://pic3.zhimg.com/80/v2-fa8ec1ec4e2e7adae85f3a02ed9297c2_720w.jpg" alt="图8-34"></p>
<p>以下是时钟定义，其波形如图8-35所示：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 8 <strong>-waveform</strong> {0 4} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKQ <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKQ]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 5 <strong>-waveform</strong> {0 2.5} [<strong>get_ports</strong> CLKP]</p>
<p><img src="https://pic4.zhimg.com/80/v2-268ee1fa2021a78ba2326de977fce817_720w.jpg" alt="图8-35"></p>
<p>时序分析会先计算相关时钟的公共周期，然后再将时钟扩展到该公共周期。请注意，仅针对相关时钟（即在它们之间具有时序路径的时钟）去计算公共周期。CLKQ和CLKP之间数据路径的公共周期仅扩展为10ns的公共周期，CLKM和CLKQ之间数据路径的公共周期为40ns，而CLKM和CLKP之间数据路径的公共周期也为40ns。</p>
<p>让我们考虑一条从CLKM时钟域到CLKP时钟域的数据路径，这种情况下时序分析的公共基本周期为40ns。</p>
<p>建立时间检查在时钟发起沿和捕获沿之间的最短时间内进行。在我们从CLKM到CLKP的示例路径中，这就是24ns处的时钟CLKM发起沿以及25ns处的时钟CLKP捕获沿。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3754829cf76b11942aabb6879417037a_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-01a729e09f55d55e7dfb7f5f8da8fe10_720w.jpg"></p>
<p>以下是保持时间检查的路径报告，最严格的保持时间检查是从0ns处的CLKM发起沿到0ns处的CLKP捕获沿。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a4eed0b242e2ae1797cffc1d91035f01_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d611186635520958c642e40113540338_720w.jpg"></p>
<p>现在，我们对从CLKP时钟域到CLKM时钟域的路径的建立时间进行检查。在这种情况下，最严格的建立时间检查是从15ns处的时钟CLKP发起沿到16ns处的时钟CLKM捕获沿。</p>
<p><img src="https://pic1.zhimg.com/80/v2-68d1fef421c0ddd3aca8a28abab145fc_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-1c7d02e9e30a7ed5ea6bd2e0589e85fb_720w.jpg"></p>
<p>以下是保持时间检查的路径报告，同样，最严格的还是0ns处的检查。</p>
<p><img src="https://pic4.zhimg.com/80/v2-1d117a836b8a822a30cad63740b633af_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-608dbf16d548301fd21116c0a21a1aa1_720w.jpg"></p>
<h2 id="移相">移相</h2>
<p>在以下示例中，两个时钟有90°的相移（phase shift）：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 2.0 <strong>-waveform</strong> {0 1.0} [<strong>get_ports</strong> CKM]</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 2.0 <strong>-waveform</strong> {0.5 1.5} [<strong>get_ports</strong> CKM90]</p>
<p><img src="https://pic2.zhimg.com/80/v2-c695c4b28909d3871c6323d348bb4b75_720w.jpg" alt="图8-36"></p>
<p>图8-36给出了使用这两个时钟的示例。建立时间检查的路径报告如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-cc55c7c56ea8d06233aedc0c48d8e324_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-2dde6c75406cbdef04538af3176d8dc4_720w.jpg"></p>
<p>0.5ns处的CKM90第一个上升沿是捕获沿，保持时间检查是在建立时间捕获沿之前一个周期的时钟沿处。对于2ns的发起沿，建立时间捕获沿为2.5ns，因此保持时间检查沿就在0.5ns处的前一个捕获沿。保持时间检查的路径报告如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f0a5b3be5f0b39a15d670a11a3c5c690_720w.jpg"></p>
<p>在第10章中还会介绍其它时序检查，例如数据到数据（data to data）检查和时钟门控（clock gating）检查。</p>
<h1 id="接口分析">接口分析</h1>
<blockquote>
<p>本章节将介绍各种类型输入和输出路径的时序分析过程以及几种常用的接口，还介绍了特殊接口（例如SRAM）的时序分析和源同步接口（例如DDR SDRAM）的时序分析。</p>
</blockquote>
<h2 id="io接口">IO接口</h2>
<p>本小节中的示例说明了该如何定义DUA输入和输出接口的约束。后面的小节介绍了SRAM和DDR SDRAM接口的时序约束示例。</p>
<h2 id="输入接口">输入接口</h2>
<p>有两种指定输入接口时序要求的方法：</p>
<p>● 以AC特性的形式指定DUA输入端的波形。</p>
<p>● 指定外部逻辑到输入的路径延迟。</p>
<h3 id="指定输入端口的波形">指定输入端口的波形</h3>
<p>考虑图9-1中所示的输入AC特性：输入CIN在时钟CLKP的上升沿之前4.3ns必须保持稳定，并且必须要保持稳定直到时钟上升沿之后2ns。</p>
<p><img src="https://pic4.zhimg.com/80/v2-fb8b07fe1708a3c9d0657b83c2e3caeb_720w.jpg" alt="图9-1"></p>
<p>首先考虑4.3ns的约束，给定时钟周期为8ns（如图9-1所示），这约束了从虚拟触发器（驱动该输入的触发器）到输入端口CIN的延迟。从虚拟触发器时钟引脚到CIN的延迟最大为3.7ns（= 8.0-4.3）， 这样可确保输入CIN处的数据在上升沿之前4.3ns到达。因此，AC特性的这一部分可以等效地指定为3.7ns的最大输入延迟。</p>
<p>AC特性还指出，输入CIN在时钟上升沿之后2ns必须继续保持稳定，这也约束了虚拟触发器的延迟，即从虚拟触发器到输入CIN的延迟必须至少为2.0ns。因此，最小输入延迟指定为2.0ns。</p>
<p>以下是输入延迟约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 8 [<strong>get_ports</strong> CLKP]</p>
<p>● <strong>set_input_delay</strong> <strong>-min</strong> 2.0 <strong>-clock</strong> CLKP [<strong>get_ports</strong> CIN]</p>
<p>● <strong>set_input_delay</strong> <strong>-max</strong> 3.7 <strong>-clock</strong> CLKP [<strong>get_ports</strong> CIN]</p>
<p>以下是设计在这些输入延迟约束下的路径报告，首先是建立时间检查：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f7f15ddc05fdca47adbb88ccc32277e1_720w.jpg"></p>
<p>指定的最大输入延迟（3.7ns）被添加到了数据路径中。建立时间检查会确保DUA内部的延迟小于4.3ns，这样就可以锁存到正确的数据。 接下来是保持时间检查：</p>
<p><img src="https://pic1.zhimg.com/80/v2-3f3ec43fb4253a8bbc376234a5254f74_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-395cc537298791ea37645f2bdd3499d5_720w.jpg"></p>
<p>最小输入延迟将被添加到保持时间检查的数据路径中。该检查可确保最早的数据在时钟沿之后的2ns处才变化，这样就不会覆盖触发器上捕获到的先前数据。</p>
<h3 id="指定输入端口的路径延迟">指定输入端口的路径延迟</h3>
<p>已知连接到输入的外部逻辑的路径延迟后，指定输入约束就是一件很简单的事情了。将沿外部逻辑路径到输入的任何延迟全部相加起来，然后使用<strong>set_input_delay</strong>命令去指定路径延迟。</p>
<p>图9-2给出了一条输入的外部逻辑路径示例。Tck2q和Tc1延迟相加就是外部延迟，知道了Tck2q和Tc1，就可以直接获得输入延迟，即Tck2q + Tc1。</p>
<p><img src="https://pic4.zhimg.com/80/v2-67801ca21e5f427bb719b3dea4a5ca7f_720w.jpg" alt="图9-2"></p>
<p>外部逻辑的最大和最小路径延迟可以转换为以下输入延迟约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> RCLK <strong>-period</strong> 10 [<strong>get_ports</strong> RCLK]</p>
<p>● <strong>set_input_delay</strong> <strong>-max</strong> 6.2 <strong>-clock</strong> RCLK [<strong>get_ports</strong> INIT]</p>
<p>● <strong>set_input_delay</strong> <strong>-min</strong> 3.0 <strong>-clock</strong> RCLK [<strong>get_ports</strong> INIT]</p>
<p>上述输入延迟约束的时序检查路径报告与8.1节和8.2节中的报告类似。</p>
<p>请注意，在计算设计内部触发器数据引脚的实际到达时间时，将会根据执行的是最大路径（建立时间）检查还是最小路径（保持时间）检查，分别选择将输入延迟的最大值或最小值添加到数据路径延迟中去。</p>
<h2 id="输出接口">输出接口</h2>
<p>与输入接口类似，也可以使用两种方法来指定输出时序要求：</p>
<p>● 以AC特性的形式指定DUA输出端的波形。</p>
<p>● 指定输出到外部逻辑的路径延迟。</p>
<h3 id="指定输出端口的波形">指定输出端口的波形</h3>
<p>考虑图9-3中所示的输出AC特性：在时钟CLKP的上升沿之前2ns，输出QOUT就应保持稳定。同样，输出QOUT需要保持稳定直到时钟上升沿之后的1.5ns为止。通常可从与QOUT接口的外部模块的建立时间和保持时间要求中获得这些约束值。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e6dd2e912ec71c53bf2c440b05789aed_720w.jpg" alt="图9-3"></p>
<p>以下是对输出端口时序要求进行的约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKP <strong>-period</strong> 6 <strong>-waveform</strong> {0 3} [<strong>get_ports</strong> CLKP]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> CLKP <strong>-max</strong> 2.0 [<strong>get_ports</strong> QOUT]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> CLKP <strong>-min</strong> -1.5 [<strong>get_ports</strong> QOUT]</p>
<p>最大输出路径延迟指定为了2.0ns，这将确保数据QOUT在时钟沿前2ns之前允许改变。从虚拟触发器的角度来看，最小输出路径延迟指定为了-1.5ns，这用于确保在输出QOUT上1.5ns的保持时间要求。1.5ns的保持时间要求就是<strong>set_output_delay</strong>中指定的最小值-1.5。</p>
<p>以下是建立时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-8126819dc8041f26cc6e1dcf9557b399_720w.jpg"></p>
<p>在建立时间检查中，将从下一个时钟沿减去最大的输出延迟，以确定在DUA输出处数据需要到达的时间。</p>
<p>接下来是保持时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f65bbb98ba886bad2ee342e1a8426931_720w.jpg"></p>
<p>在保持时间检查中，将从捕获时钟边沿中减去最小的输出延迟（-1.5ns），以确定满足保持时间要求的DUA输出的数据最早到达时间。注意，最小输出延迟为负值很常见。</p>
<h3 id="指定输出端口的路径延迟">指定输出端口的路径延迟</h3>
<p>在这种情况下，将明确指定外部逻辑的路径延迟。请参见图9-4中的示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e5de379e70c89980d1fa10513eb01a5c_720w.jpg" alt="图9-4"></p>
<p>让我们首先检查建立时间，由Tc2_max和Tsetup可获得最大输出延迟（<strong>set_output_delay -max</strong>）。为了检查DUA内部触发器（例如UFF0）和虚拟触发器之间输出路径的建立时间要求，最大输出延迟可指定为Tc2_max + Tsetup。</p>
<p>接下来，让我们检查保持时间，由Tc2_min和Thold可获得最小输出延迟（<strong>set_output_delay -min</strong>）。由于捕获触发器的保持时间被添加到了捕获时钟路径中，因此最小输出延迟指定为Tc2_min-Thold。</p>
<p>以下是输出延迟约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> SCLK <strong>-period</strong> 5 [<strong>get_ports</strong> SCLK]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> 3.1 <strong>-clock</strong> SCLK [<strong>get_ports</strong> RDY]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> 1.45 <strong>-clock</strong> SCLK [<strong>get_ports</strong> RDY]</p>
<p>这些路径报告与8.1节和8.2节中的报告相似。</p>
<h2 id="时序窗口内的输出变化">时序窗口内的输出变化</h2>
<p><strong>set_output_delay</strong>命令可用于指定输出信号相对于时钟的最大和最小到达时间。本节考虑特殊情况，当输出只能在相对于时钟沿的时序窗口内发生改变时，可以指定输出延迟约束来验证时序，在验证源同步（source synchronous）接口的时序时尤其常用。</p>
<p>在源同步接口中，时钟也与数据一起输出。在这种情况下，通常时钟和数据之间需要有一个时序关系。例如，可能仅在时钟上升沿附近的特定时序窗口内才能改变输出数据。</p>
<p>源同步接口的时序要求如下图9-5所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-9c43f832046de5abf30e4e8f90e34a9b_720w.jpg" alt="图9-5"></p>
<p>该时序要求：DATAQ的每个比特位（bit）只能在指定的时序窗口中改变，即在时钟上升沿之前2ns以及时钟上升沿之后1ns之间。这与前面各节中讨论的输出延迟约束有很大的不同，在前几节中，要求数据引脚在时钟上升沿附近的指定时序窗口中保持稳定。</p>
<p>我们以CLKM为主时钟创建了一个衍生时钟CLK_STROBE，方便去指定与该接口要求相对应的时序约束。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 6 [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> CLK_STROBE <strong>-source</strong> CLKM <strong>-divide_by</strong> 1 [<strong>get_ports</strong> CLK_STROBE]</p>
<p>通过结合建立时间和保持时间检查以及多周期路径约束来指定时序窗口要求。该时序要求对应在单个上升沿（相同的发起沿和捕获沿）处进行建立时间检查。因此，我们将多周期建立时间指定为0。</p>
<p>● <strong>set_multicycle_path</strong> 0 <strong>-setup</strong> <strong>-to</strong> [<strong>get_ports</strong> DATAQ]</p>
<p>另外，保持时间检查必须在同一时钟沿上执行，因此我们需要将多周期保持时间指定为-1。</p>
<p>● <strong>set_multicycle_path</strong> -1 <strong>-hold</strong> <strong>-to</strong> [<strong>get_ports</strong> DATAQ]</p>
<p>现在，相对于时钟CLK_STROBE指定输出的时序约束：</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> -1.0 <strong>-clock</strong> CLK_STROBE [<strong>get_ports</strong> DATAQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> +2.0 <strong>-clock</strong> CLK_STROBE [<strong>get_ports</strong> DATAQ]</p>
<p>请注意，输出延迟约束中指定的最小值大于最大值。之所以会这样，是因为在这种情况下，输出延迟约束并不对应于实际的逻辑块。与典型的输出接口（其中输出延迟约束对应于输出处的逻辑块）不同，源同步接口中的<strong>set_output_delay</strong>约束只是一种机制，用于验证输出是否被限制在了时钟有效沿附近的指定窗口内才能切换 。因此，我们才会有最小输出延迟大于最大输出延迟这样的一种异常情况。</p>
<p>这是针对以上约束的建立时间检查路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0b9ddec9f1288eed1272fdabffa71006_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d0b97aa432482d10e9504dea3d6a7864_720w.jpg"></p>
<p>请注意，数据发起沿和捕获沿都为在0时刻处的相同时钟沿。该报告显示DATAQ在0.61ns处变化，而CLK_STROBE在0.09ns处变化。由于DATAQ可以在CLK_STROBE的1ns内被允许变化，因此在考虑了0.3ns的时钟不确定性后，正裕量为0.18ns。</p>
<p>以下是保持时间检查的路径报告，用于检查时钟另一侧的界限：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ad78e5da899ea4bb9da84673475bd2e7_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-56144534a5513eef4a3d74b0ec746879_720w.jpg"></p>
<p>在上述最小路径分析中，DATAQ在0.48ns处到达，而CLK_STROBE在0.09ns处到达。由于要求是数据最早可以在CLK_STROBE之前2ns处发生改变，因此在考虑了50ps的时钟不确定度后，我们获得了2.35ns的正裕量。</p>
<p>源同步接口的另一个示例如图9-6所示。在这种情况下，输出时钟是主时钟的二分频，并且是数据同步接口的一部分。输出POUT被限制在QCLKOUT之前2ns和之后1ns之间才能进行改变。</p>
<p><img src="https://pic3.zhimg.com/80/v2-5a883fdc20e2eee3b43e8a91b782e9e2_720w.jpg" alt="图9-6"></p>
<p>以下是这种情况的时序约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 6 [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> QCLKOUT <strong>-source</strong> CLKM <strong>-divide_by</strong> 2 [<strong>get_ports</strong> QCLKOUT]</p>
<p>● <strong>set_multicycle_path</strong> 0 <strong>-setup</strong> <strong>-to</strong> [<strong>get_ports</strong> POUT]</p>
<p>● <strong>set_multicycle_path</strong> -1 <strong>-hold</strong> <strong>-to</strong> [<strong>get_ports</strong> POUT]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> -1.0 <strong>-clock</strong> QCLKOUT [<strong>get_ports</strong> POUT]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> +2.0 <strong>-clock</strong> QCLKOUT [<strong>get_ports</strong> POUT]</p>
<p>以下是建立时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-daeda77da7beef5049bd3c611f20f8c7_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-81abc3f315d65e2a37de49aceef371bf_720w.png"></p>
<p>请注意，多周期路径约束已将建立时间检查沿向后移了一个周期，以便在同一时钟沿执行检查。输出POUT在0.61ns处变化，而时钟QCLKOUT在0.27ns处变化。基于在时钟沿1ns内允许变化的要求，并考虑0.30ns的时钟不确定度，我们可得0.36ns的正裕量。</p>
<p>接下来是保持时间检查的路径报告，用于检查时序窗口要求的另一个约束：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1d99ae4d0b95975587a09905bb3464f4_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5865adec021f1d025e1639b729f5b1a3_720w.jpg"></p>
<p>路径报告显示，数据是在QCLKOUT时钟边沿之前的2ns时序窗口内才发生改变的，并且有2.17ns的正裕量。</p>
<h2 id="sram接口">SRAM接口</h2>
<p>SRAM接口中的所有数据传输仅发生在时钟的有效沿处，所有信号仅在有效时钟沿处由SRAM锁存或由SRAM发起。组成SRAM接口的信号包括命令（command）、地址（address）、控制输出总线（CAC）、双向数据总线（DQ）和时钟。在写周期（write cycle）中，DUA将数据写到SRAM中去，数据和地址从DUA传送到SRAM中去，并都在有效时钟沿处被锁存在SRAM中。在读周期（read cycle）中，地址信号仍然从DUA传送到SRAM中去，而数据信号则是由SRAM输出给DUA的。因此，地址和控制信号是单向的且方向为从DUA到SRAM，如图9-7所示。通常将延迟锁定环DLL（Delay-Locked Loop）放置在时钟路径中，DLL允许在必要时延迟时钟信号，以解决由于PVT和其它外部变化而导致接口上各种信号的延迟变化。通过考虑这些变化，在往返于SRAM的读周期和写周期中，都将有良好的时序裕度可用于数据传输。</p>
<p><img src="https://pic2.zhimg.com/80/v2-b52a504258c521ec667fcf19dcfa6df9_720w.jpg" alt="图9-7"></p>
<p>图9-8显示了典型SRAM接口的AC特性。请注意，图9-8中的数据输入和数据输出是指SRAM看到的方向。来自SRAM的Data out是DUA的输入，进入SRAM的Data in是DUA的输出。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d48accc20cbab09ba714ebbb8690f401_720w.jpg" alt="图9-8"></p>
<p>图9-8中的要求可以转换为用于DUA与SRAM之间接口的以下IO接口约束：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> PLL_CLK <strong>-period</strong> 5 [<strong>get_pins</strong> UPLL0/CLKOUT]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> SRAM_CLK <strong>-source</strong> [<strong>get_pins</strong> UPLL0/CLKOUT] <strong>-divide_by</strong> 1 [<strong>get_ports</strong> SRAM_CLK]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> 1.5 <strong>-clock</strong> SRAM_CLK [<strong>get_ports</strong> ADDR[*]]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> -0.5 <strong>-clock</strong> SRAM_CLK [<strong>get_ports</strong> ADDR[*]]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> 1.7 <strong>-clock</strong> SRAM_CLK [<strong>get_ports</strong> DQ[*]]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> -0.8 <strong>-clock</strong> SRAM_CLK [<strong>get_ports</strong> DQ[*]]</p>
<p>● <strong>set_input_delay</strong> <strong>-max</strong> 3.2 <strong>-clock</strong> SRAM_CLK [<strong>get_ports</strong> DQ[*]]</p>
<p>● <strong>set_input_delay</strong> <strong>-min</strong> 1.7 <strong>-clock</strong> SRAM_CLK [<strong>get_ports</strong> DQ[*]]</p>
<p>以下是典型地址引脚的建立时间检查路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-689fedb5bf89b3565f038f4aa568a7bc_720w.jpg"></p>
<p>建立时间检查将验证地址信号是否在SRAM_CLK时钟沿之前1.5ns（SRAM地址引脚的建立时间）到达SRAM。</p>
<p>以下是相同地址引脚的保持时间检查路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-d957225e3552800ae646f39dea30ff95_720w.jpg"></p>
<p>保持时间检查将验证地址信号在SRAM_CLK时钟沿之后是否继续保持稳定了0.5ns。</p>
<h2 id="ddr-sdram接口">DDR SDRAM接口</h2>
<p>DDR SDRAM接口可以看作是上一节中所介绍的SRAM接口的一种扩展。就像SRAM接口一样，有两条主要的总线，图9-9说明了DUA和SDRAM之间的总线及其方向。由命令、地址和控制引脚（通常称为CAC）组成的第一条总线将使用以下标准方案：在存储器时钟的一个时钟沿（或每个时钟周期一次）处发送信息。双向总线由DQ（数据总线）和DQS（数据选通脉冲）组成，DDR接口的不同之处就在于双向数据选通DQS。DQS选通脉冲可用于一组数据信号，这使得数据信号（每字节一个或每半字节一个）与选通脉冲的时序紧密匹配。如果时钟是整个数据总线共用的时钟，那么使用时钟信号进行这种紧密匹配可能不可行。双向选通信号DQS可用于读操作和写操作，并且在选通脉冲的两个边沿（下降沿和上升沿，或称双倍数据速率）上都可捕获数据。在SDRAM的读模式期间，DQ总线与数据选通引脚DQS（而不是存储器的时钟引脚）同步，即DQ和DQS从SDRAM中被输出时彼此是对齐的。而对于另一个方向，即当DUA发送数据时，DQS将相移90度。请注意，数据DQ和选通DQS的沿均来自DUA内部的存储器时钟。</p>
<p><img src="https://pic4.zhimg.com/80/v2-bc74b432ba8e6c2acd4627615aad76c7_720w.jpg" alt="图9-9"></p>
<p>如上所述，对于一组DQ信号（4个或8个bit）存在一个数据选通DQS。这样做是为了使DQS和DQ的所有bit之间的偏斜平衡（skew balancing）要求更容易满足。例如，如果对于一个字节使用一个DQS，则一组中只需平衡9个信号（8个DQ和1个DQS），这比平衡72位的数据总线和时钟要容易得多。</p>
<p>上面的描述并不是对DDR SDRAM接口的完整说明，但足以说明这种接口的时序要求。</p>
<p>图9-10显示了典型DDR SDRAM接口中CAC总线（在DUA处）的AC特性。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0ee398652921911fcbe5fc4c38472bf2_720w.jpg" alt="图9-10"></p>
<p>上述建立时间和保持时间的要求对应到CAC总线上的接口约束如下所示：</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> DDRCLK <strong>-source</strong> [<strong>get_pins</strong> UPLL0/CLKOUT] <strong>-divide_by</strong> 1 [<strong>get_ports</strong> DDRCLK]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> 0.75 <strong>-clock</strong> DDRCLK [<strong>get_ports</strong> CAC]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> -0.75 <strong>-clock</strong> DDRCLK [<strong>get_ports</strong> CAC]</p>
<p>在某些情况下，尤其是与无缓冲（unbuffered）存储器模块接口时，地址总线可能会比时钟驱动更大的负载。在这种情况下，地址信号对存储器的延迟要比时钟信号大，并且这种延迟差异可能会导致AC特性不同于图9-10中所示。</p>
<p>DQS和DQ的对齐方式在读周期和写周期中有所不同，以下小节将对此进行进一步探讨。</p>
<h2 id="读周期">读周期</h2>
<p>在读周期中，存储器输出的数据与DQS是边沿对齐（edge-aligned）的，如图9-11中波形所示。图中的DQ和DQS代表存储器引脚上的信号。数据（DQ）由存储器在DQS的每个沿上发出，并且DQ改变数据的时刻也与DQS的下降沿和上升沿对齐。</p>
<p><img src="https://pic2.zhimg.com/80/v2-24059ae747fe8d7843629c9c7d724c31_720w.jpg" alt="图9-11"></p>
<p>由于DQS选通信号和DQ数据信号彼此对齐，因此DUA内部的存储控制器（memory controller）通常使用DLL（或其它替代方法来实现四分之一周期延迟）来延迟DQS，从而使DQS的边沿对齐于数据有效窗口的中心。</p>
<p>即使DQ和DQS在存储器中彼此对齐，但DQ和DQS选通信号也可能无法再在DUA内部的存储控制器上对齐，这可能是由于IO缓冲器之间的延迟差以及PCB互连走线等因素所导致的。</p>
<p>图9-12中为基本的数据读取原理图。上升沿触发的触发器在DQS_DLL的上升沿捕获数据DQ，而下降沿触发的触发器在DQS_DLL的下降沿捕获数据DQ。虽然图中的DQ路径上没有DLL，但某些设计可能在数据路径上也会放置一个DLL。这样可以用来延迟信号（以解决由于PVT或互连走线长度或其它差异引起的变化），以便可以在数据有效窗口的中间准确地采样数据。</p>
<p><img src="https://pic2.zhimg.com/80/v2-234312a1d6e8edb088a60c44834566c9_720w.jpg" alt="图9-12"></p>
<p>为了对存储控制器上的读接口进行约束，我们在DQS上定义了一个时钟，并相对于该时钟在数据上指定了输入延迟。</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 5 <strong>-name</strong> DQS [<strong>get_ports</strong> DQS]</p>
<p>假定存储器读接口以200MHz（当在两个时钟沿上都传输数据时相当于400Mbps）的频率进行工作，这对应于每2.5ns采样一次DQ数据信号。由于数据是在两个边沿上捕获的，因此需要为每个边沿分别指定输入约束。</p>
<p>● <strong>set_input_delay</strong> 0.4 <strong>-max</strong> <strong>-clock</strong> DQS [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_input_delay</strong> -0.4 <strong>-min</strong> <strong>-clock</strong> DQS [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_input_delay</strong> 0.35 <strong>-max</strong> <strong>-clock</strong> DQS <strong>-clock_fall</strong> [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_input_delay</strong> -0.35 <strong>-min</strong> <strong>-clock</strong> DQS <strong>-clock_fall</strong> [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_multicycle_path</strong> 0 <strong>-setup</strong> <strong>-to</strong> UFF0/D</p>
<p>● <strong>set_multicycle_path</strong> 0 <strong>-setup</strong> <strong>-to</strong> UFF5/D</p>
<p>输入延迟命令指定了DUA引脚上DQ和DQS沿之间的延迟差，即使这两个信号通常是从存储器中同时输出的，但由于不同存储器的规格，在时序上仍会存在偏差。因此，DUA内的控制器设计应考虑到两个信号之间可能存在偏斜（skew）。以下是两个触发器建立时间检查的路径报告。假设捕获触发器的建立时间要求为0.05ns、保持时间要求为0.03ns，且DLL延迟设置为1.25ns，即四分之一周期。</p>
<p><img src="https://pic4.zhimg.com/80/v2-1d327f81a50ddf648ce4ebb9a40f2d27_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e3961d9db8d767fb982ebee53ce56113_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-bf3fbed304a106812e510c79ed5b04d2_720w.jpg"></p>
<p>以下是保持时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-ff7e4a81f530911cb6f37bfb91257396_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-fd369383802b4e3c525622d2d86f9138_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-748b53de949a247e3923f6b3ec35ae85_720w.jpg"></p>
<h2 id="写周期">写周期</h2>
<p>在写周期中，DQS沿会与从DUA内存储控制器输出的DQ信号相差四分之一周期，因此存储器可以直接使用DQS选通脉冲去捕获数据。</p>
<p>图9-13显示了存储器引脚上所需的波形，在存储器引脚处，DQS信号必须与DQ数据窗口的中心对齐。请注意，仍然是由于IO缓冲器延迟不匹配或者PCB互连走线的变化，仅在存储控制器（DUA内部）中对齐DQ和DQS还不足以使这些信号在SDRAM存储器引脚处真正的对齐。因此，DUA通常在写周期中使用额外的DLL去进行控制，以实现DQS和DQ信号之间所需的四分之一周期偏移（offset）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-479d19187c54aa98ab2c64d9931eb029_720w.jpg" alt="图9-13"></p>
<p>如何约束此模式的输出取决于控制器中时钟的生成方式，接下去我们考虑两种不同情况。</p>
<h3 id="情况1内部二倍频时钟">情况1：内部二倍频时钟</h3>
<p>如果内部时钟是DDR时钟频率的两倍，则输出逻辑可以类似于图9-14中所示。DLL提供了一种必要时使DQS时钟偏斜的机制，从而满足存储器引脚上的建立时间和保持时间要求。在某些情况下，可以不使用DLL，而是使用负沿触发的触发器来获得90度的偏移。</p>
<p><img src="https://pic1.zhimg.com/80/v2-69ecf9067bb97cf1dc1164e9b57561f8_720w.jpg" alt="图9-14"></p>
<p>对于图9-14中所示情况，可以进行如下输出延迟约束：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 3 [<strong>get_ports</strong> CLK2X]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> pre_DQS <strong>-source</strong> CLK2X <strong>-divide_by</strong> 2 [<strong>get_pins</strong> UFF1/Q]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> DQS <strong>-source</strong> UFF1/Q <strong>-edges</strong> {1 2 3} <strong>-edge_shift</strong> {1.5 1.5 1.5} [<strong>get_ports</strong> DQS]</p>
<p>DQ输出引脚上的时序必须相对于衍生时钟DQS进行约束。</p>
<p>假设DDR SDRAM的DQ和DQS引脚之间建立时间要求分别为DQ上升沿的0.25ns和下降沿的0.4ns。类似地，假设DQ引脚上升沿和下降沿的保持时间要求分别为0.15ns和0.2ns。DQS输出上的DLL延迟已设置为四分之一周期，即1.5ns，所有波形如下图9-15所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7eee407d3a777fd6e4f7e39eda839bd_720w.jpg" alt="图9-15"></p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> DQS <strong>-max</strong> 0.25 <strong>-rise</strong> [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> DQS <strong>-max</strong> 0.4 <strong>-fall</strong> [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> DQS <strong>-min</strong> -0.15 <strong>-rise</strong> [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-clock</strong> DQS <strong>-min</strong> -0.2 <strong>-fall</strong> [<strong>get_ports</strong> DQ]</p>
<p>以下是通过输出DQ路径的建立时间检查报告。建立时间检查从0ns处发起DQ的CLK2X上升沿到1.5ns处的DQS上升沿进行。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5d34a095966af25895fdfb63d95097d8_720w.jpg"></p>
<p>请注意，上述报告中的四分之一周期延迟出现在了时钟DQS上升沿的第一行中，而不是在DLL实例UDLL0的那行中。这是因为DLL延迟已被建模为了衍生时钟DQS定义的一部分，而不是DLL时序弧中的一部分。</p>
<p>以下是通过输出DQ路径的保持时间检查报告。保持时间检查从3ns处发起DQ的时钟CLK2X上升沿到1.5ns处的DQS前一个上升沿。</p>
<p><img src="https://pic2.zhimg.com/80/v2-47eee48c89bcd306ab02f7f6db0eb349_720w.jpg"></p>
<h3 id="情况2内部一倍频时钟">情况2：内部一倍频时钟</h3>
<p>当内部只有一倍频时钟可用时，输出电路通常可能类似于图9-16所示的电路。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d090cf5189674707f5256d8cca9ac6ed_720w.jpg" alt="图9-16"></p>
<p>有两个触发器用于生成DQ数据：第一个触发器NEGEDGE_REG由时钟CLK1X的负沿触发，而第二个触发器POSEDGE_REG由时钟CLK1X的正沿触发。每个触发器会锁存适当的边沿数据，然后使用CLK1X作为多路复用器的选择信号来多路复用该数据：CLK1X为高电平时，触发器NEGEDGE_REG的输出发送到DQ；而当CLK1X为低电平时，触发器POSEDGE_REG的输出发送到DQ。因此，数据会在时钟CLK1X的两个边沿都到达输出DQ。请注意，每个触发器都有半个周期将数据传播到多路复用器的输入端，以确保在由CLK1X边沿选择输入数据之前，已在多路复用器的输入端口上准备好了输入数据。相关波形如图9-17所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0f0fef00d37b1efdc49fba5926f1a33e_720w.jpg" alt="图9-17"></p>
<p>这种情况的输出延迟约束如下：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLK1X <strong>-period</strong> 6 [<strong>get_ports</strong> CLK1X]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> DQS <strong>-source</strong> CLK1X <strong>-edges</strong> {1 2 3} <strong>-edge_shift</strong> {1.5 1.5 1.5} [<strong>get_ports</strong> DQS]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> 0.25 <strong>-clock</strong> DQS [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-max</strong> 0.3 <strong>-clock</strong> DQS <strong>-clock_fall</strong> [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> -0.2 <strong>-clock</strong> DQS [<strong>get_ports</strong> DQ]</p>
<p>● <strong>set_output_delay</strong> <strong>-min</strong> -0.27 <strong>-clock</strong> DQS <strong>-clock_fall</strong> [<strong>get_ports</strong> DQ]</p>
<p>建立时间和保持时间检查可验证从多路复用器到输出的时序。建立时间检查之一是从多路复用器输入处的CLK1X上升沿（发起NEGEDGE_REG数据）到DQS的上升沿。另一个建立时间检查是从多路复用器输入处的CLK1X下降沿（发起POSEDGE_REG数据）到DQS的下降沿。同样，保持时间检查是从（与建立时间检查）相同的CLK1X边沿到DQS的前一个下降沿或上升沿。</p>
<p>以下是通过DQ端口的建立时间检查报告，该检查在（选择输出NEGEDGE_REG的）CLK1X的上升沿和DQS的上升沿之间进行。</p>
<p><img src="https://pic2.zhimg.com/80/v2-806cd68aca7c86b510d690538f6bd25d_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-dfd358f465bcf4752242988c2c3f51ed_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-97d3a127bc44614d7c5752f27ca41fa2_720w.png"></p>
<p>这是通过DQ端口的另一个建立时间检查报告，该检查在（选择输出POSEDGE_REG的）CLK1X的下降沿和DQS的下降沿之间进行。</p>
<p><img src="https://pic1.zhimg.com/80/v2-41f7b52d2110ead078093e9ceb203130_720w.jpg"></p>
<p>这是通过DQ端口的保持时间检查报告，该检查在CLK1X的上升沿和DQS的前一个下降沿之间进行。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3066fe4d709731e2dc038368af25481a_720w.jpg"></p>
<p>这是另一个通过DQ端口的保持时间检查报告，该检查在CLK1X的下降沿和DQS的前一个上升沿之间进行。</p>
<p><img src="https://pic2.zhimg.com/80/v2-dac2698ab600edd3dfd00cfb1171462d_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-b921a3ffe97188a3200dcd9666535706_720w.jpg"></p>
<p>尽管以上接口时序分析已忽略了任何负载对输出的影响，但我们也可以指定额外的负载（使用<strong>set_load</strong>命令）来提高准确性。STA同样可以通过电路仿真来补充，以实现可靠的DRAM时序。</p>
<p>DDR接口的DQ和DQS信号通常在读模式和写模式下使用终端电阻ODT（On-Die Termination），以减少由于DRAM和DUA处的阻抗不匹配而引起的任何反射（reflection）。在使用ODT的情况下，用于STA的时序模型将无法提供足够的精度。设计人员可以使用另一种机制，例如详尽的电路级仿真，来验证信号完整性和DRAM接口的时序。</p>
<h2 id="dac接口">DAC接口</h2>
<p>考虑下图9-18的一个典型DAC接口，其中高速时钟将数据传输到DAC的低速时钟接口。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2ba441962f954f574f4cb92e9c71c999_720w.jpg" alt="图9-18"></p>
<p>时钟DAC_CLK是时钟XPLL_CLK的2分频，DAC建立时间和保持时间检查针对的是DAC_CLK的下降沿。</p>
<p>在这种情况下，即使可以根据需要将从快时钟域到慢时钟域的接口指定为多周期路径，但也可以将建立时间视作单周期（XPLL_CLK）路径。如图9-18所示，XPLL_CLK的上升沿发起数据，而DAC_CLK的下降沿捕获数据。以下是建立时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-7f9f118702dc551f2824bf6699bd6bb7_720w.jpg"></p>
<p>请注意，该接口是从较快的时钟域到较慢的时钟域，因此如有必要，完全可以将其设置为两周期路径。</p>
<p>以下是保持时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-94fd47ca4afd8e5def7f42845e7207fb_720w.jpg"></p>
<p>保持时间检查是在建立时间捕获沿之前一个周期完成的。在这种接口情况下，最关键的保持时间检查是在发起沿和捕获沿重合处执行的，这在以上保持时间检查的报告中可以看出。</p>
<h1 id="鲁棒性检查">鲁棒性检查</h1>
<blockquote>
<p>本章节将介绍特殊的STA分析，例如时间借用（time borrowing）、时钟门控（clock gating）和非时序（non-sequential）检查。此外，还介绍了高级STA概念，例如片上变化（on-chip variation）、统计时序（statistical timing）以及功耗和时序之间的折中。</p>
</blockquote>
<h2 id="片上变化">片上变化</h2>
<p>通常，工艺和各环境参数在芯片的不同部分上可能不一致。由于工艺差异，芯片上不同部分的相同MOS晶体管可能没有相似的特性，这些差异是由于芯片内部的工艺差异引起的。请注意，多个制造批次中的工艺参数差异可能会覆盖慢工艺到快工艺（2.10节中所介绍）。在本节中，我们讨论的是对一个芯片上可能存在的工艺差异（称为局部工艺差异）的分析，该差异远小于多个制造批次之间的差异（称为全局工艺差异）。</p>
<p>除了工艺参数的变化之外，设计中不同部分可能还会存在不同的电源电压和温度。因此，同一芯片的两个区域可能不在相同的PVT条件下。这些差异可能是由许多因素引起的，包括：</p>
<p>● 会影响局部电源电压的沿芯片区域的IR压降变化；</p>
<p>● PMOS或NMOS器件的电压阈值变化；</p>
<p>● PMOS或NMOS器件的沟道长度变化；</p>
<p>● 由于局部热点造成的温度变化；</p>
<p>● 互连金属刻蚀或厚度变化会影响互连电阻或电容。</p>
<p>上述的PVT变化被称为片上变化（OCV），这些变化会影响芯片不同部分的走线延迟和单元延迟。如上所述，OCV建模并不是要对芯片与芯片之间可能的PVT变化进行建模，而是要对单个芯片内局部可能的PVT变化进行建模。OCV带来的影响通常在时钟路径上更为明显，因为时钟路径在芯片中传播的距离更长。解决局部PVT变化的一种方法是在STA期间包含OCV分析。前面各章中所介绍的静态时序分析能够获得特定时序角（timing corner）的时序，但没有对芯片上的变化进行建模。由于时钟和数据路径可能受到不同OCV的影响，因此时序验证可以通过使数据发起路径和捕获路径的PVT条件稍有不同来对OCV的影响进行建模。通过降额（derate）特定路径的延迟就可以对OCV带来的影响进行建模，即首先使这些路径更快或更慢，然后通过这些变化来验证设计的性能。可以降额单元延迟或走线延迟，或同时降额两者，以模拟OCV的影响。</p>
<p>现在，我们来讨论如何完成OCV降额处理以进行建立时间检查。考虑图10-1中所示逻辑，其中PVT条件可能随芯片的不同区域而变化。当发起时钟路径和数据路径的OCV条件导致延迟最大、而捕获时钟路径的OCV条件导致延迟最小时，此时的建立时间检查最为严格。请注意，此处最小和最大延迟是由于芯片上局部PVT的变化。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4fe685c886c29fe8c6f70c6d88e89751_720w.jpg" alt="图10-1"></p>
<p>对于此示例，以下是建立时间检查，注意此处还不包括任何用于降额延迟的OCV设置：</p>
<p>● LaunchClockPath + MaxDataPath &lt;= ClockPeriod + CaptureClockPath - Tsetup_UFF1</p>
<p>● Minimum clock period = LaunchClockPath + MaxDataPath - CaptureClockPath + Tsetup_UFF1</p>
<p>● LaunchClockPath = 1.2 + 0.8 = 2.0</p>
<p>● MaxDataPath = 5.2</p>
<p>● CaptureClockPath = 1.2 + 0.86 = 2.06</p>
<p>● Tsetup_UFF1 = 0.35</p>
<p>● Minimum clock period = 2.0 + 5.2 - 2.06 + 0.35 = 5.49ns</p>
<p>以上路径延迟对应于没有任何OCV降额的延迟值，我们可以使用<strong>set_timing_derate</strong>命令来对单元和网络延迟进行降额处理。比如以下命令：</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.8</p>
<p>● <strong>set_timing_derate</strong> <strong>-lata</strong> 1.1</p>
<p>上述命令将最小/最短/最早路径的延迟降低了20％，并将最大/最长/最迟路径的延迟增加了10％。长路径的延迟（例如，用于建立时间检查的数据路径和发起时钟路径或用于保持时间检查的捕获时钟路径）将乘以使用<strong>-late</strong>选项指定的降额值，而短路径的延迟（例如，用于建立时间检查的捕获时钟路径或用于保持时间检查的数据路径和发起时钟路径）将乘以使用<strong>-early</strong>选项指定的降额值。如果未指定降额系数，则假定值为1.0。</p>
<p>降额系数将统一应用于所有网络延迟和单元延迟，如果某个应用场景中需要保证单元和网络的降额系数不同，则可以在<strong>set_timing_derate</strong>命令中使用<strong>-cell_delay</strong>和<strong>-net_delay</strong>选项。</p>
<p>● <strong>set_timing_derate</strong> <strong>-cell_delay</strong> <strong>-early</strong> 0.9</p>
<p>● <strong>set_timing_derate</strong> <strong>-cell_delay</strong> <strong>-late</strong> 1.0</p>
<p>● <strong>set_timing_derate</strong> <strong>-net_delay</strong> <strong>-early</strong> 1.0</p>
<p>● <strong>set_timing_derate</strong> <strong>-net_delay</strong> <strong>-late</strong> 1.2</p>
<p>可以使用<strong>-cell_check</strong>选项来对单元检查（例如建立时间和保持时间）的延迟进行降额。使用此选项时，使用<strong>set_output_delay</strong>指定的任何输出延迟也将被降额，因为此约束也是输出建立时间要求的一部分。但是，对于使用<strong>set_input_delay</strong>指定的输入延迟，是不会被降额的。</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.8 <strong>-cell_check</strong></p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.1 <strong>-cell_check</strong></p>
<p><strong>-clock</strong>选项仅将降额应用于时钟路径。同样，<strong>-data</strong>选项仅将降额应用于数据路径。</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.95 <strong>-clock</strong></p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.05 <strong>-data</strong></p>
<p>现在，我们将以下降额约束应用于图10-1的示例：</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.9</p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.2</p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.1 <strong>-cell_check</strong></p>
<p>在以上降额约束的情况下，我们可以进行如下计算：</p>
<p>● LaunchClockPath = 2.0 * 1.2 = 2.4</p>
<p>● MaxDataPath = 5.2 * 1.2 = 6.24</p>
<p>● CaptureClockPath = 2.06 * 0.9 = 1.854</p>
<p>● Tsetup_UFF1 = 0.35 * 1.1 = 0.385</p>
<p>● Minimum clock period = 2.4 + 6.24 - 1.854 + 0.385 = 7.171ns</p>
<p>在上面的建立时间检查中，由于时钟树的公共时钟路径（图10-1）具有1.2ns的延迟，而发起时钟和捕获时钟路径上的降额有所不同，因此存在差异。时钟树的这一部分对于发起时钟和捕获时钟路径都是通用的，因此不应进行不同的降额。对发起和捕获时钟路径应用不同的降额是过于悲观的，因为在实际上时钟树的这一部分实际上仅处于一个PVT条件下，即最大路径或最小路径（或介于两者之间），但绝不会同一时间处在两种不同PVT条件下。由于对时钟树的公共部分应用了不同降额系数而引起的悲观被称为“公共路径悲观度”CPP（Common Path Pessimism），在分析过程中应将其消除。CPPR（Common Path Pessimism Removal）表示“公共路径悲观度消除”，通常在路径报告中作为单独的条目列出，它也被标记为时钟收敛悲观度消除CRPR（Clock Reconvergence Pessimism Removal）。</p>
<p>CPPR消除了时序分析中发起时钟路径和捕获时钟路径之间的人为悲观情绪。如果同一个时钟既驱动捕获触发器又驱动发起触发器，那么时钟树很可能会在分支之前共享一条公共路径。CPP本身是沿时钟树公共路径的延迟之差，这是由于发起和捕获时钟路径的降额系数不同所致。时钟信号在公共点的最小到达时间和最大到达时间之间的差即为CPP。公共点（Common Point）的定义为时钟树公共部分中最后一个单元的输出引脚。</p>
<p>● CPP = LatestArrivalTime <span class="citation" data-cites="CommonPoint">@CommonPoint</span> - EarliestArrivalTime <span class="citation" data-cites="CommonPoint">@CommonPoint</span></p>
<p>上述分析中的“最晚时间”和“最早时间”是指在特定工艺角（Corner）下的OCV降额值，例如最坏情况下的慢速（Worst-Case-Slow）或最佳情况下的快速（Best-Case-Fast）。对于图10-1的示例：</p>
<p>● LatestArrivalTime <span class="citation" data-cites="CommonPoint">@CommonPoint</span> = 1.2 * 1.2 = 1.44</p>
<p>● EarliestArrivalTime <span class="citation" data-cites="CommonPoint">@CommonPoint</span> = 1.2 * 0.9 = 1.08</p>
<p>● CPP = 1.44 - 1.08 = 0.36ns</p>
<p>● Minimum clock period = 7.171 - 0.36 = 6.811ns</p>
<p>对于前面的设计示例，应用OCV降额会把最小时钟周期从5.49ns增加到6.811ns，这说明了通过这些降额系数建模的OCV变化会降低设计的最大工作频率。</p>
<h3 id="最差pvt条件下的ocv分析">最差PVT条件下的OCV分析</h3>
<p>如果在最差情况（worst-case）的PVT条件下执行建立时间检查，则在较晚路径（late path）上就无需降额了，因为它们已经是最差的情况了。但是，可以通过将特定的降额系数应用于较早路径（early path）来使那些路径更快，例如使较早路径加速10％。在最差情况下，降额约束可能如下所示：</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.9</p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.0</p>
<p>上述降额约束可用于在最差情况的慢速工艺角下进行最大路径（或建立时间）检查。因此，较晚路径的OCV降额系数设置为1.0，以使其不会超出最差情况的慢速工艺角。</p>
<p>接下来介绍在最差情况的慢速工艺角下进行建立时间检查的示例。为捕获时钟路径指定了以下降额约束：</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.8 <strong>-clock</strong></p>
<p>以下是在最差情况的慢速工艺角下执行的建立时间检查路径报告。较晚路径使用的降额系数在报告中为Max Data Paths Derating Factor和Max Clock Paths Derating Factor，而较早路径使用的降额系数在报告中为Min Clock Paths Derating Factor。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c098e797bd93b9340d4920a026ad3f22_720w.jpg"></p>
<p>请注意，捕获时钟路径的延迟已被降低了20％：可参考时序报告中的单元UCKBUF0，在发起路径中它有56ps的延迟，而在捕获路径中仅有45ps的延迟。单元UCKBUF0处在公共时钟路径上，也就是既在捕获时钟路径上又在发起时钟路径上。由于公共时钟路径不能有不同的降额系数，因此该公共路径的延迟差56ps-45ps = 11ps将会被补偿校正，这可以从clock reconvergence pessimism那行中看出。总而言之，如果要比较此路径报告降额与不降额的差别的话，则可能会注意到只有捕获时钟路径的单元和网络延迟被降低了。</p>
<h3 id="保持时间检查的ocv">保持时间检查的OCV</h3>
<p>现在，我们将介绍如何对保持时间检查进行降额处理。考虑如图10-2所示的逻辑，如果整个芯片上的PVT条件不同，则当发起时钟路径和数据路径具有导致延迟最小的OCV条件（即最早的发起时钟），且保持时钟路径具有导致延迟最大的OCV条件（即最晚的捕获时钟）时，保持时间检查的最差情况就会发生。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4a44882b001473bd5803a62af80734d7_720w.jpg" alt="图10-2"></p>
<p>以下表达式即为此示例所要执行的保持时间检查：</p>
<p>● LaunchClockPath + MinDataPath - CaptureClockPath - Told_UFF1 &gt;= 0</p>
<p>将图10-2中的延迟值应用于上述表达式，我们可得（不应用任何降额系数）：</p>
<p>● LaunchClockPath = 0.25 + 0.6 = 0.85</p>
<p>● MinDataPath = 1.7</p>
<p>● CaptureClockPath = 0.25 + 0.75 = 1.00</p>
<p>● Thold_UFF1 = 1.25</p>
<p>这意味着检查结果如下：</p>
<p>● 0.85 + 1.7 - 1.00 - 1.25 = 0.3ns &gt;= 0</p>
<p>因此可得结论：保持时间没有违例。</p>
<p>应用以下降额约束：</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.9</p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.2</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 0.95 <strong>-cell_check</strong></p>
<p>重新计算的结果如下：</p>
<p>● LaunchClockPath = 0.85 * 0.9 = 0.765</p>
<p>● MinDataPath = 1.7 * 0.9 = 1.53</p>
<p>● CaptureClockPath = 1.00 * 1.2 = 1.2</p>
<p>● Thold_UFF1 = 1.25 * 0.95 = 1.1875</p>
<p>● Common Clock Path Pessimism = 0.25 * (1.2 - 0.9) = 0.075</p>
<p>由于在公共时钟路径上应用不同降额系数而导致的悲观度也进行了计算，这个值将被补偿然后再进行保持时间检查。保持时间的检查将变为：</p>
<p>● 0.765 + 1.53 - 1.2 - 1.1875 + 0.075 = -0.0175ns</p>
<p>结果小于0，因此表明对路径应用了OCV降额系数之后保持时间违例了。</p>
<p>通常，保持时间检查是在最佳情况的快速PVT角下执行的。在这种情况下，较早路径无需降额，因为这些路径已经是最快的路径了。但是，可以通过将特定的降额系数应用于较晚路径来使那些路径更慢，例如使较晚路径变慢20％。在最佳情况下，降额约束可能如下所示：</p>
<p>● <strong>set_timing_derate</strong> <strong>-early</strong> 1.0</p>
<p>● <strong>set_timing_derate</strong> <strong>-late</strong> 1.2</p>
<p>对于图10-2中的示例：</p>
<p>● LatestArrivalTime <span class="citation" data-cites="CommonPoint">@CommonPoint</span> = 0.25 * 1.2 = 0.30</p>
<p>● EarliestArrivalTime <span class="citation" data-cites="CommonPoint">@CommonPoint</span> = 0.25 * 1.0 = 0.25</p>
<p>因此此时公共路径悲观度为：</p>
<p>● 0.30 - 0.25 = 0.05ns</p>
<p>这是使用此降额约束的设计示例的保持时间检查路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-49d3e3dabff90d5e24147168a77b1b9a_720w.jpg"></p>
<p>请注意，较晚路径的延迟增加了20％，而较早路径保持不变。来看一下单元UCKBUF0的延迟，其在发起时钟路径上的延迟为56ps，而在捕获时钟路径上的延迟为67ps，增加了20％。UCKBUF0是公共时钟树上的单元，因此由于此公共时钟树上的降额系数不同而引入的悲观度为67ps-56ps = 11ps，这在clock reconvergence pessimism一行中得到了补偿校正。</p>
<h2 id="时间借用">时间借用</h2>
<p>时间借用（Time Borrowing）技术（也称为周期窃取cycle stealing技术）发生在锁存器（Latch）上。在锁存器中，时钟的一个边沿会使锁存器透明，即这个沿打开了锁存器，使得锁存器的输出与数据输入相同，该时钟沿被称为打开沿（opening edge）。时钟的另一个沿会关闭锁存器，也就是说，输入数据的任何改变在锁存器的输出处都无效，此时钟沿被称为关闭沿（closing edge）。</p>
<p>通常，应在时钟有效沿之前就在锁存器输入处准备好数据。但是，由于锁存器在时钟处于有效状态时是透明的，因此数据可以晚于有效时钟沿到达，也就是说，它可以从下一个周期借用时间。如果这样借用了时间，则会减少可用于下一级（锁存器到另一个时序单元）的时间。</p>
<p>图10-3给出了使用有效上升沿借用时间的示例。如果在锁存器10ns处的CLK上升沿（打开沿）之前的时间A处数据DIN就已经准备好了，则数据在锁存器打开时会流向锁存器的输出。如果数据DIN在时间B处（延迟）到达，则它将借用时间Tb。但是，这减少了从锁存器到下一个触发器UFF2的可用时间，只有时间Ta可用，而不再是完整的时钟周期。</p>
<p><img src="https://pic4.zhimg.com/80/v2-92462f6246aa665d6913064c39c040a3_720w.jpg" alt="图10-3"></p>
<p>锁存器的时序的第一条规则是：如果数据在锁存器的打开沿之前到达，则寄存器行为将与触发器完全一样。在打开沿捕获数据，而同一时钟沿又将发起数据，作为下一条时序路径的起点。</p>
<p>第二条规则适用的情况是：数据在锁存器为透明状态时（在打开沿和关闭沿之间）到达。锁存器的输出将被用作下一级时序路径的起点，而不是时钟引脚。在锁存器处结束的时序路径所借用的时间将决定下一级的发起时间。</p>
<p>在锁存器的关闭沿之后到达的数据信号是时序违例的。图10-4显示了正裕量、零裕量和负裕量（即发生违例时）所分别对应的数据到达时序区域。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f5c5f6aa659d27ec861aeea3277c46ef_720w.jpg" alt="图10-4"></p>
<p>图10-5（a）中为锁存器到下一级触发器的半周期路径，图10-5（b）描绘了时间借用的波形，时钟周期为10ns。UFF0在0时刻发起数据，但数据路径需要7ns。锁存器ULAT1在5ns时打开。因此，向ULAT1到UFF1的路径借用了2ns，而ULAT1到UFF1的可用时间仅为3ns（5ns-2ns）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-9449d68f5c038890259904b0626b3a33_720w.jpg" alt="图10-5"></p>
<p>接下来，我们将介绍图10-5（a）锁存器示例的三组不同时序报告，以说明从下一级路径借用的不同时间量。</p>
<h3 id="没有借用时间">没有借用时间</h3>
<p>若从触发器UFF0到锁存器ULAT1的数据路径延迟小于5ns，则建立时间检查的路径报告如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1c70e6c7ead6db4913fc15ffe56f6801_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c7ab0e56fc693c633c35216a1ac8f8e5_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-926720b6c6ced7f562f7c6ad2ad2fc6a_720w.jpg"></p>
<p>在这种情况下，由于数据在锁存器打开之前及时到达了锁存器ULAT1，因此无需借用时间。</p>
<h3 id="借用了时间">借用了时间</h3>
<p>若从触发器UFF0到锁存器ULAT1的数据路径延迟大于5ns，则建立时间检查的路径报告如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-13bb17c6049ec4fcda11155187a0cb28_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e6cbbe9bf9bfea5ad13983e8e103aa5a_720w.png"></p>
<p>在这种情况下，由于锁存器透明时数据是可用的，因此会从后续路径借用所需的1.81ns，然后仍能满足时序要求。以下是后续路径的路径报告，其中显示了前一条路径借用的1.81ns：</p>
<p><img src="https://pic4.zhimg.com/80/v2-483088aa7ee64eb99e22d799c6d29f5f_720w.jpg"></p>
<h3 id="时序违例的例子">时序违例的例子</h3>
<p>在这种情况下，数据路径延迟要大得多，并且数据在锁存器关闭之后才能到达，这显然是时序违例的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-629c81426d6b701a9120607123ddd7ff_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-c7152ee0ace9ff30a7aa8c3a9d7f3404_720w.png"></p>
<h2 id="数据引脚到数据引脚检查">数据引脚到数据引脚检查</h2>
<p>建立时间和保持时间检查也可以在任意两个数据引脚之间进行，这两个都不是时钟引脚。一个引脚为约束引脚（constrained pin），其作用类似于触发器的数据引脚，而另一个引脚为相关引脚（related pin），其作用类似于触发器的时钟引脚。关于触发器建立时间检查的一个重要区别是，数据到数据的建立时间检查是在与发起沿相同的沿上执行的（不同于触发器的常规建立时间检查，其中捕获时钟边沿通常会距离发起时钟沿一个周期）。因此，数据到数据的建立时间检查也称为零周期检查（zero-cycle checks）或同周期检查（same-cycle checks）。</p>
<p>使用<strong>set_data_check</strong>命令可以指定数据到数据的检查，SDC约束命令示例如下：</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> SDA <strong>-to</strong> SCTRL <strong>-setup</strong> 2.1</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> SDA <strong>-to</strong> SCTRL <strong>-hold</strong> 1.5</p>
<p>参见图10-6，SDA是相关引脚，而SCTRL是约束引脚。建立时间数据检查规定SCTRL应该在相关引脚SDA的边沿之前至少2.1ns到达，否则即为数据到数据的建立时间检查违例。保持时间数据检查规定SCTRL应该在SDA之后至少1.5ns到达，如果约束引脚的信号早于该时刻到达，即为数据到数据的保持时间检查违例。</p>
<p><img src="https://pic1.zhimg.com/80/v2-18ba570f6bd626c46016c2cfa5368730_720w.jpg" alt="图10-6"></p>
<p>此检查在定制设计的模块中很有用，在定制设计的模块中很有可能会要去约束一个信号相对于另一个信号的到达时间。一种常见情况是由使能信号选通的数据信号，此时需要确保当数据信号到达时使能信号保持稳定。</p>
<p>考虑图10-7中所示的与门单元。我们假设要求是确保PNA在PREAD上升沿之前1.8ns到达，并且在PREAD上升沿之后1.0ns内不应发生改变。在此示例中，PNA是约束引脚，而PREAD是相关引脚，对应的波形如图10-7所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9efdba4ea9827cebc08ccb5aa32a8bb2_720w.jpg" alt="图10-7"></p>
<p>对于这样的时序要求，可以使用数据到数据的建立时间和保持时间检查：</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> UAND0/A1 <strong>-to</strong> UAND0/A2 <strong>-setup</strong> 1.8</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> UAND0/A1 <strong>-to</strong> UAND0/A2 <strong>-hold</strong> 1.0</p>
<p>以下是建立时间检查路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-edbb7924f8bad6307849876b77453e1c_720w.jpg"></p>
<p>建立时间在报告中显示为data check setup time。以上时序违例的报告表明PREAD至少需要延迟1.72ns，以确保PNA在PREAD之前1.8ns能够到达，这是我们的建立时间要求。</p>
<p>数据到数据建立时间检查很重要的一点是，约束引脚和相关引脚的发起时钟沿都来自同一时钟周期。因此，在报告中请注意，捕获沿（UDFF0 / CK）的起始时间为0ns，而不是一个周期之后的时钟沿（通常在报告中看到的都是这种情况）。</p>
<p>零周期（zero-cycle）建立时间检查会导致保持时间检查与其它保持时间检查有所不同，保持时间检查将不再位于同一时钟沿。以下是CLKPLL的时钟定义，将用于下面的保持时间路径报告：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKPLL <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKPLL]</p>
<p><img src="https://pic1.zhimg.com/80/v2-4004b879c0ecbd77fe7abea728d88294_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-81d92132cd56f3e208fc0e99f5624015_720w.jpg"></p>
<p>注意，在保持时间检查中，相关引脚的发起沿比约束引脚的发起沿要早一个周期。这是因为根据定义，通常在建立时间捕获沿之前的一个周期执行保持时间检查。由于数据到数据建立时间检查的约束引脚和相关引脚的时钟沿相同，因此会在发起沿之前一个周期执行保持时间检查。</p>
<p>在某些情况下，设计人员可能要求在同一时钟周期上执行数据到数据的保持时间检查。相同周期的保持时间要求意味着要将用于相关引脚的时钟沿移回约束引脚的时钟沿处。可以通过指定多周期保持时间为-1来实现：</p>
<p>● <strong>set_multicycle_path</strong> -1 <strong>-hold</strong> <strong>-to</strong> UAND0/A2</p>
<p>以下是带有多周期约束的上述示例的保持时间检查路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-8f351e794312c68ecf2b713f5c1ae9f4_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d4feea1cd0025c0c78a0f7bcac5451fd_720w.jpg"></p>
<p>现在，保持时间检查是在约束引脚和相关引脚相同时钟沿上执行的。在同一周期中执行数据到数据保持时间检查的另一种方法是：将其指定为相反方向上的引脚之间的数据到数据建立时间检查。</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> UAND0/A2 <strong>-to</strong> UAND0/A1 <strong>-setup</strong> 1.0</p>
<p>数据到数据的检查在对数据不改变进行检查（no-change data check）时也很有用。通过在上升沿处指定建立时间检查，在下降沿处指定保持时间检查，从而有效地定义了数据不变窗口，如图10-8所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c4e783e36f84659956a95cc37a06d399_720w.jpg" alt="图10-8"></p>
<p>这种情况的约束如下：</p>
<p>● <strong>set_data_check</strong> <strong>-rise_from</strong> D2 <strong>-to</strong> D1 <strong>-setup</strong> 1.2</p>
<p>● <strong>set_data_check</strong> <strong>-fall_from</strong> D2 <strong>-to</strong> D1 <strong>-hold</strong> 0.8</p>
<h2 id="非时序检查">非时序检查</h2>
<p>单元或宏（macro）的库文件可以将时序弧指定为非时序（non-sequential）检查，例如两个数据引脚之间的时序弧。非时序检查是指两个引脚之间的检查，两者都不是时钟。一个引脚是约束引脚，其作用类似于数据，而第二个引脚是相关引脚，其作用类似于时钟。该检查指定了在相关引脚上的数据改变前后，约束引脚上的数据必须保持稳定多长时间。</p>
<p>请注意，此检查被指定为单元库规范的一部分，并且不需要显式的数据到数据检查约束。以下是这种时序弧在单元库中的表示形式：</p>
<p><img src="https://pic4.zhimg.com/80/v2-2d7b72f3d1a380869175f43fc866b387_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-b83f52f40de05764936a315d823d243c_720w.jpg"></p>
<p>setup_rising指相关引脚的上升沿，固有（intrinsic）上升值和下降值是指约束引脚的上升和下降建立时间。可以为hold_rising、setup_falling和hold_falling定义类似的时序弧。</p>
<p>非时序检查类似于10.3节中介绍的数据到数据检查，但是有两个主要区别。在非时序检查中，建立时间和保持时间的值是从标准单元库中获得的，可以使用NLDM表格模型或其它高级时序模型来描述建立时间和保持时间模型。而在数据到数据检查中，只能为数据到数据的建立时间或保持时间检查指定一个值。第二个区别是，非时序检查只能应用于单元的引脚，而数据到数据的检查可以应用于设计中的任意两个引脚。</p>
<p>非时序建立时间检查指定了约束信号必须相对于相关引脚多早到达，如图10-9所示。单元库中包含了建立时间弧D0-&gt; WEN，它被指定为了非时序弧。如果在建立时间窗口内出现WEN信号，则非时序建立时间检查将失败。</p>
<p><img src="https://pic4.zhimg.com/80/v2-1f21fce26412e6f59a269232f4587757_720w.jpg" alt="图10-9"></p>
<p>非时序保持时间检查指定了约束信号必须相对于相关引脚多晚到达，如图10-9所示。如果WEN在保持时间窗口中改变了，则非时序保持时间检查将失败。</p>
<h2 id="时钟门控检查">时钟门控检查</h2>
<p>当一个门控信号（gating signal）可以控制逻辑单元中时钟信号（clock signal）的路径时，将会执行时钟门控检查（clock gating check），一个示例如图10-10所示。逻辑单元与时钟相连的引脚称为时钟引脚（clock pin），与门控信号相连的引脚称为门控引脚（gating pin），产生时钟门控的逻辑单元也称为门控单元（gating cell）。</p>
<p><img src="https://pic3.zhimg.com/80/v2-4c4b546e263da9c619709576f5e05686_720w.jpg" alt="图10-10"></p>
<p>进行时钟门控检查的条件之一是：必须将通过门控单元的时钟用作下游的时钟。下游时钟的使用可以是触发器的时钟、也可以是扇出到输出端口、也可以是作为衍生时钟的主时钟。如果时钟不用作门控单元之后的下游时钟，则不会推断出时钟门控检查。</p>
<p>时钟门控检查的另一个条件针对的是门控信号：门控引脚上的信号不应是时钟，或者如果是时钟，也不应将其用作下游时钟（例如本节稍后要介绍的将时钟用作门控信号的一个示例）。</p>
<p>在一般情况下，时钟信号和门控信号不需要连接到同一个逻辑单元（例如与门、或门），但是可以输入到任意逻辑块。在这种情况下，为了推断出时钟门控检查，检查的时钟引脚和检查的门控引脚必须扇出到公共输出引脚。</p>
<p>可推断出两种时钟门控检查：</p>
<p>● 高电平有效时钟门控检查：门控单元具有“与”功能或者“与非”功能。</p>
<p>● 低电平有效时钟门控检查：门控单元具有“或”功能或者“或非”功能。</p>
<p>高电平有效和低电平有效是指门控信号的逻辑状态，该逻辑状态用以使能门控单元输出端的时钟信号。如果门控单元是门控关系不明显的复杂功能，例如多路复用器（MUX）或异或门（XOR），则STA输出通常会给出警告，提示没有推断出时钟门控检查。但是，可以通过使用命令<strong>set_clock_gating_check</strong>为门控单元显式地指定时钟门控关系。在这种情况下，如果<strong>set_clock_gating_check</strong>命令与门控单元的功能不一致，则STA通常会给出警告。我们将在本节稍后部分介绍此类命令的示例。</p>
<p>如前所述，只有当时钟不用作下游时钟时，它才可以用作门控信号，考虑图10-11中的示例。由于定义了CLKA的衍生时钟，因此CLKB不用作下游时钟，即CLKB的路径被衍生时钟的定义阻塞了。因此，针对这个与门单元会推断出时钟CLKA的时钟门控检查。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2f7bf1238ff8f3cb6590b9257db006ed_720w.jpg" alt="图10-11"></p>
<h3 id="高电平有效时钟门控">高电平有效时钟门控</h3>
<p>现在，我们来讨论高电平有效时钟门控检查的时序关系。这发生在与门（and）或者与非门（nand）单元上，使用与门单元的示例如图10-12所示。门控单元的引脚B是时钟信号，门控单元的引脚A是门控信号。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ff352b04406f382c7aecda177cfc53ed_720w.jpg" alt="图10-12"></p>
<p>让我们假设两个时钟CLKA和CLKB具有相同的波形。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKA <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKA]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKB <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKB]</p>
<p>因为它是一个与门单元，所以门控信号引脚UAND0 / A上为高电平时才会打开门控单元，并允许时钟传播通过。时钟门控检查旨在验证门控引脚的电平切换不会为扇出时钟创建时钟有效沿。对于上升沿触发的逻辑，这意味着门控信号的上升沿发生在时钟的无效周期内（当其为低电平时）。类似地，对于下降沿触发的逻辑，门控信号的下降沿应仅在时钟为低电平时产生。注意，如果时钟同时驱动上升沿和下降沿触发的触发器，则门控信号的任何边沿（上升沿或下降沿）都必须仅在时钟为低电平时产生。图10-13给出了一个在有效周期期间门控信号电平切换的示例，该信号需要延迟才能通过时钟门控检查。</p>
<p><img src="https://pic2.zhimg.com/80/v2-3a3534f505052b17de8d35e48a8e8bd5_720w.jpg" alt="图10-13"></p>
<p>高电平有效时钟门控的建立时间检查可确保门控信号的电平改变发生在时钟变为高电平之前。以下是建立时间检查的路径报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-107e2d53e8cd9e8e74e2e3dc08a99e75_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-dbe3938ec9bb40f968ec38dbee1ce638_720w.jpg"></p>
<p>请注意，终点（Endpoint）处说明这是时钟门控检查。另外，从Path Group一行中可以看出该路径属于clock_gating_default路径组中。该检查能确保门控信号在10ns处的时钟CLKB下一个上升沿之前改变。</p>
<p>高电平有效时钟门控的保持时间检查要求门控信号仅在时钟的下降沿之后才可以发生变化。以下是保持时间检查的路径报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-5ebc8f49ab4ab2315eb6e9224ca57522_720w.jpg"></p>
<p>时钟门控的保持时间检查失败了，因为在5ns处的CLKB下降沿之前，门控信号发生了改变。如果在UDFF0 / Q和UAND0 / A1引脚之间添加了5ns的延迟，则时钟门控的建立时间和保持时间检查都会通过，即门控信号仅在指定的时间窗口内发生变化。</p>
<p>从前文可以看到保持时间要求是非常大的，这是由于产生门控信号的时钟沿和门控单元时钟信号的有效沿是相同沿（上升沿或下降沿）导致的，这可以通过使用另一种类型的触发器（例如下降沿触发的触发器）产生门控信号来解决。下面将介绍这样的示例。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7861bd4bf114af942b54a12e8060ae2b_720w.jpg" alt="图10-14"></p>
<p>在图10-14中，触发器UFF0由时钟CLKA的下降沿触发。安全的时钟门控意味着触发器UFF0的输出必须在门控时钟的无效周期（5ns至10ns）之间才能变化。</p>
<p>与图10-14中的原理图相对应的信号波形如图10-15所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-2109ae5dbe3011157935e1746480f286_720w.jpg" alt="图10-15"></p>
<p>以下是时钟门控的建立时间检查报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-554444aff9daffbeaeae8a24bc75c997_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-ed3be3f5ee10be3a8b26bec568bc3c0f_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-085acccd02f785346fa4a1b1926adc49_720w.png"></p>
<p>以下是时钟门控的保持时间检查报告。请注意，在此新设计中，保持时间检查更容易满足要求。</p>
<p><img src="https://pic4.zhimg.com/80/v2-37dd6774edcc688302f690d51ccdb0eb_720w.jpg"></p>
<p>由于产生门控信号的时钟沿（下降沿）与门控时钟相反（高电平有效），因此很容易满足建立时间和保持时间的要求。这也是门控时钟最常用的结构。</p>
<h3 id="低电平有效时钟门控">低电平有效时钟门控</h3>
<p>图10-16给出了低电平有效时钟门控检查的示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-283f0e718558c34b4ee126cc30e6b5cf_720w.jpg" alt="图10-16"></p>
<p>● <strong>create_clock</strong> <strong>-name</strong> MCLK <strong>-period</strong> 8 <strong>-waveform</strong> {0 4} [<strong>get_ports</strong> MCLK]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> SCLK <strong>-period</strong> 8 <strong>-waveform</strong> {0 4} [<strong>get_ports</strong> SCLK]</p>
<p>低有效时钟门控检查可验证对于上升沿触发的逻辑，门控信号的上升沿在时钟的有效周期（高电平时）内到达。如前所述，关键在于门控信号不应使门控时钟的输出产生有效沿。当门控信号为高电平时，时钟无法通过。因此，只有在时钟为高电平时，门控信号才允许切换，如图10-17所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-236ecd525319b508071dbfecd07caf42_720w.jpg" alt="图10-17"></p>
<p>以下是低电平有效时钟门控的建立时间检查报告。该检查可确保门控信号在时钟沿变为无效状态（在这种情况下为4ns）之前到达。</p>
<p><img src="https://pic1.zhimg.com/80/v2-4a3bcadadab97636a934353fcc1b375c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-e503435cbda648a0ec46c15fe5cf9101_720w.jpg"></p>
<p>以下是时钟门控的保持时间检查报告。此检查可确保门控信号仅在时钟信号的上升沿（在这种情况下为0ns）之后才发生变化。</p>
<p><img src="https://pic4.zhimg.com/80/v2-80855a23d93871b6283adc8283522843_720w.jpg"></p>
<h3 id="使用多路复用器的时钟门控">使用多路复用器的时钟门控</h3>
<p>图10-18给出了使用多路复用器单元进行时钟门控的示例。多路复用器输入上的时钟门控检查可确保多路复用器选择信号在正确的时间到达，以在MCLK和TCLK之间进行“干净”（clean）的切换。对于这个例子，我们感兴趣的是MCLK，假设TCLK为低电平时选择信号进行切换。这意味着多路复用器的选择信号应仅在MCLK为低电平时进行切换，这类似于高电平有效时钟门控检查。</p>
<p><img src="https://pic2.zhimg.com/80/v2-056c2cf75af61a1575f6a0bb340ad161_720w.jpg" alt="图10-18"></p>
<p>时序关系如图10-19所示，多路复用器的选择信号必须在MCLK为低电平时到达。同样，假设选择信号改变时TCLK为低电平。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e76f5ec82fcdaf40890e429d162ad96c_720w.jpg" alt="图10-19"></p>
<p>由于门控单元是多路复用器，因此不会自动推断出时钟门控检查，在STA期间会报告出以下信息：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1d3da6fc099ff195029d2e5dbeef2420_720w.png"></p>
<p>但是，通过使用<strong>set_clock_gating_check</strong>命令可以强制执行时钟门控检查。</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-high</strong> [<strong>get_cells</strong> UMUX0]</p>
<p>● <strong>set_disable_clock_gating_check</strong> UMUX0/I1</p>
<p>第一条命令中的<strong>-high</strong>选项表示这是高电平有效的时钟门控检查，第二条命令中的禁止检查将关闭特定引脚上的时钟门控检查，因为我们不考虑该引脚。以下是建立时间检查的路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-ac1440551673e36fb1639eb6b6b58794_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ddede48d0f4380b8aacad78335a1b742_720w.jpg"></p>
<p>接下来是时钟门控的保持时间检查报告：</p>
<p><img src="https://pic2.zhimg.com/80/v2-688b8242caa000b10b9517449a39bec5_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-86160c7e2ce8cd47fc9ba15ae28c756f_720w.jpg"></p>
<h3 id="带时钟反相的时钟门控">带时钟反相的时钟门控</h3>
<p>图10-20显示了另一个时钟门控示例，其中产生门控信号的触发器时钟被反相了。由于门控单元是与门单元，因此门控信号必须仅在时钟信号为低电平时才能切换，这定义了时钟门控的建立时间和保持时间检查。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f6d5cc6f95785bf15baa8a01f7a299d1_720w.jpg" alt="图10-20"></p>
<p>以下是时钟门控的建立时间检查报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0e047fa61f7e26c5adec923088368cdb_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-e2ce688429bd67f194498762dcdd7366_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-055846dab002d2fa228274e1447b4159_720w.png"></p>
<p>请注意，建立时间检查会验证数据是否在15ns处的MCLK沿之前发生改变。以下是时钟门控的保持时间检查报告：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a9e7a33d61b8e169553966d0351a977e_720w.jpg"></p>
<p>保持时间检查可验证门控信号是否在10ns处的MCLK下降沿之前发生了改变。</p>
<p>如果门控单元是一个复杂的单元并且建立时间和保持时间检查不够明显，则可以使用<strong>set_clock_gating_check</strong>命令来指定对门控单元的门控信号进行建立时间和保持时间检查。建立时间检查会去确保门控信号在时钟信号的有效沿之前是稳定的，建立时间检查的失败可能会导致门控单元输出端出现毛刺。保持时间检查可验证门控信号在时钟信号的无效沿处是否稳定。以下是<strong>set_clock_gating_check</strong>命令的一些示例：</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-setup</strong> 2.4 <strong>-hold</strong> 0.8 [<strong>get_cells</strong> U0/UXOR1]</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-high</strong> [<strong>get_cells</strong> UMUX5]</p>
<h2 id="功耗管理">功耗管理</h2>
<p>功耗管理是任何设计及其实现方式的一个重要方面。在设计实现（implementation）过程中，设计人员通常需要评估在速度、功耗和面积之间权衡（trade-off）的不同方法。</p>
<p>如第3章所述，一个设计的逻辑部分中消耗的功率包括漏电功率（leakage power）和有功功率（active power）。 此外，模拟部分和IO缓冲器（尤其是具有主动匹配功能的）会耗散与功能无关且非漏电的功率。在本节中，我们重点讨论设计中逻辑部分所耗散功率的权衡。</p>
<p>通常，管理由标准单元和存储器组成的数字逻辑的功率影响有两个注意事项：</p>
<p>● 使设计的总有功功率最小化：设计人员将确保总功耗保持在特定的功耗极限之内。设计的不同工作模式可能会有不同的极限值，此外，设计中使用的不同供电电源也会有不同的极限值。</p>
<p>● 使待机模式下设计的功耗最小化：对于电池供电的设备（例如手机），这是一个重要的考虑因素，其目的是使待机模式下的功耗最小。待机模式下的功耗等于漏电功耗加上待机模式下有效逻辑的任何功耗。如上所述，可能存在其它模式，例如睡眠模式，其对功耗的约束有所不同。</p>
<p>本节将介绍各种功耗管理方法，这些方法中的每一种都有其优缺点。</p>
<h2 id="时钟门控">时钟门控</h2>
<p>如第3章所述，触发器的时钟翻转是总功耗的重要组成部分。即使触发器的输出未切换，触发器也会由于时钟切换而消耗功率。考虑图10-21（a）中的示例，其中触发器仅在使能信号EN处于有效状态时才接收新数据，否则将保持先前的状态。在EN信号处于无效状态期间，时钟在触发器处的翻转不会引起任何输出变化，但是仍然导致了触发器内部的功率消耗。时钟门控的目的是：通过在触发器输入无效的时钟周期内消除触发器的时钟翻转来最大程度地减少这种影响。通过时钟门控进行的逻辑重组会在触发器时钟引脚上引入时钟门控，图10-21给出了此时钟门控的示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-9812d706d455443b99e698ebea02c707_720w.jpg" alt="图10-21"></p>
<p>因此，时钟门控可确保仅在其数据输入端有新数据可用时，触发器的时钟引脚才会翻转。</p>
<h2 id="电源门控">电源门控</h2>
<p>电源门控包括关闭电源，以便可以关闭无效模块的供电。图10-22中说明了此过程，其中在电源中串联添加了Header（或Footer）MOS器件。适当配置控制信号SLEEP后，可以使Header（或Footer）MOS器件在模块的正常工作期间处于打开状态。由于在正常工作期间电源门控MOS器件（Header或Footer）处于打开状态，因此该模块已被上电，并在正常功能模式下运行。在模块的无效（或睡眠）模式期间，门控MOS器件（Header或Footer）被关闭，这可以消除逻辑模块中的任何有功功耗。Footer是在实际的地与模块的地网络之间的大型NMOS器件，可通过电源门控对其进行控制。Header是实际的电源和模块的电源网络之间的大型PMOS设备，也可通过电源门控进行控制。在睡眠模式下，模块中唯一消耗的功率是通过Header（或Footer）器件的漏电功率。</p>
<p><img src="https://pic2.zhimg.com/80/v2-05dc9dc328457e8aa12b252075127569_720w.jpg" alt="图10-22"></p>
<p>通常使用多个电源门控单元来实现Header或Footer，这些电源门控单元对应于多个并联的MOS器件。Header和Footer器件为电源引入了一系列导通电阻。如果导通电阻的值不小，则通过门控MOS器件的IR压降会影响逻辑模块中单元的时序。关于门控器件尺寸的考虑主要是为了确保导通电阻值足够小，若再同时考虑电源门控MOS器件在无效模式或睡眠模式下的漏电功耗，则需要进行权衡。</p>
<p>总之，应该有足够数量的并联电源门控单元，以确保在正常工作模式下电阻串联时的IR压降最小。但是，在无效模式或睡眠模式下门控单元的漏电功耗也是选择并联电源门控单元数量的标准。</p>
<h2 id="多阈值单元">多阈值单元</h2>
<p>如第3章（3.8节）中所述，多阈值（Vt）单元可用于权衡速度与漏电。高Vt单元的漏电较少，但是却比标准Vt单元的速度更慢，相反，标准Vt单元虽然速度更快，但是漏电也更多。同样，低Vt单元的速度比标准Vt单元更快，但漏电量也相应地比较高。</p>
<p>在大多数设计中，目标是在达到所需工作速度的同时将总功率降至最低。即使漏电可能是总功率的重要组成部分，但仅采用高Vt单元来减少漏电的设计也可能会增加总功率，尽管漏电确实减少了。这是因为最终的设计实现可能需要更多（或更高强度）的高Vt单元才能实现所需的性能。由于使用高Vt单元，等效门数的增加导致的有功功率增加将会远大于漏电功率的减少。但是在某些情况下，漏电才是总功率的主要组成部分，在这种情况下，使用高Vt单元的设计可以使总功率降低。由于需要取决于具体的设计以及切换活动曲线（switching activity profile），因此需要适当地利用上述具有不同Vt的单元之间在速度和漏电方面的折中。下面将介绍一个高性能模块的两种不同情况，根据模块是处于非常活跃状态还是低切换状态，实现方法可能有所不同。</p>
<h3 id="具有高切换活动的高性能模块">具有高切换活动的高性能模块</h3>
<p>这种情况是具有高切换活动的高性能模块，其功率主要由有功功率决定。对于此类模块，即使可以将漏电影响最小化，但仅专注于降低漏电功率还是会导致总功率的增加。在这种情况下，初始设计实现应使用标准Vt（或低Vt）单元来满足所需的性能。在达到所需的时序之后，可以将具有正时序裕量的路径上的单元更改为高Vt单元，以便在仍满足时序要求的同时减少漏电功率。因此，在最终实现中，仅沿着关键或难以实现的时序路径使用标准Vt（或低Vt）单元，而沿着非关键时序路径的单元可以是高Vt单元。</p>
<h3 id="具有低切换活动的高性能模块">具有低切换活动的高性能模块</h3>
<p>这种情况是切换活动非常低的高性能模块，因此漏电功率是总功率的主要组成部分。由于该模块切换活动频率很低，因此有功功率并不是设计总功率的主要组成部分。对于此类模块，最初的设计实现在组合逻辑和触发器中仅使用高Vt单元。由于时钟树始终处于有效状态，因此会使用标准Vt（或低Vt）单元。在仅使用高Vt单元的最初实现之后，可能会有一些时序路径无法满足所需的时序。然后，可以将沿着此类路径的单元替换为标准Vt（或低Vt）单元，以实现所需的时序性能。</p>
<h2 id="阱极偏置">阱极偏置</h2>
<p>阱极偏置（well bias）是指分别向用于NMOS和PMOS器件的P阱或N阱增加小的电压偏置。图2-1中所示的NMOS器件的衬底（或P阱）通常连接至地。同样，图2-1中所示的PMOS器件的衬底（或N阱）通常连接至电源（Vdd）。</p>
<p>如果阱的连接处具有轻微的负偏置电压，则可以大大降低漏电功率。这意味着NMOS器件的P阱连接到较小的负电压（例如-0.5V），类似地，PMOS器件的N阱连接处被连接到了高于电源的电压（例如Vdd + 0.5V）。通过添加阱极偏置，将会影响单元的速度，但是漏电大大减少了。单元库中的时序是考虑了阱极偏置之后的。</p>
<p>使用阱极偏置的缺点是：P阱和N阱连接需要额外的供电电源（例如-0.5V和Vdd + 0.5V）。</p>
<h2 id="反标">反标</h2>
<h2 id="spef">SPEF</h2>
<p>STA如何知道设计的寄生参数？通常，此参数信息是使用寄生提取工具提取出的，并且STA工具会以SPEF格式来读取此数据。SPEF的详细信息和格式将在附录C中介绍。</p>
<p>物理设计布局工具中STA引擎的行为也是类似的，不同之处在于提取信息将被写入内部数据库中。</p>
<h2 id="sdf">SDF</h2>
<p>在某些情况下，单元和互连走线的延迟是由另一个工具计算的，并通过SDF文件将其读入STA。使用SDF的优点是不再需要计算单元延迟和互连走线延迟，因为它们直接来自SDF文件，因此STA可以专注于时序检查。但是，这种标注延迟（delay annotation）的缺点是，由于缺少寄生信息，STA无法执行串扰计算。通常SDF是用于将延迟信息传递给仿真器的一种机制。</p>
<p>SDF的详细信息和格式将在附录B中介绍。</p>
<h2 id="sign-off方法学">Sign-off方法学</h2>
<p>STA可以在许多不同的情况下执行，不同的情况主要由三个变量来确定：</p>
<p>● 寄生角（用于寄生参数提取的RC互连角和工作条件）</p>
<p>● 操作模式</p>
<p>● PVT角</p>
<h3 id="互连寄生角">互连寄生角</h3>
<p>寄生参数可以在许多角（corner）下提取。这些主要取决于制造过程中金属宽度和金属刻蚀的变化，这些角包括：</p>
<p>● Typical：这是指互连电阻和电容的标准值。</p>
<p>● Mac C：这是指使电容值最大的互连角，其互连电阻小于Typical角下的电阻。该角会导致较短网络的路径延迟最大，因此可用于最大路径分析。</p>
<p>● Min C：这是指使电容值最小的互连角，其互连电阻大于Typical角下的电阻。 该角会导致较短网络的路径延迟最小，因此可用于最小路径分析。</p>
<p>● Max RC：这是指使互连RC乘积最大的互连角。这通常对应于较大的刻蚀，较大的刻蚀可以减小走线的宽度。该角会使电阻值最大，但对应的电容值小于Typical角下的电容。总体而言，该角对于互连走线较长的路径具有最大的延迟，可用于最大路径分析。</p>
<p>● Min RC：这是指使互连RC乘积最小的互连角。这通常对应于较小的蚀刻，较小的刻蚀会增加走线的宽度。该角会使电阻值最小，但对应的电容值大于Typical角下的电容。总的来说，该角对于互连走线较长的路径具有最小的路径延迟，可用于最小路径分析。</p>
<p>基于上述各个角的互连电阻和电容，具有较大电容的互连角会导致电阻较小，具有较小电容的互连角会导致电阻较大。因此，电阻在一定程度上补偿了各个互连角下的电容。这意味着对于所有类型网络的延迟，没有一个角会真正对应极限情况（最差情况或最佳情况）。使用Cworst / Cbest角下的路径延迟仅对于较短网络是极限情况，而RCworst / RCbest角仅对于较长网络是极限情况，而对于平均长度的网络，Typical互连角通常在路径延迟方面是极限的。因此，设计人员经常会在上述各个互连角下都去验证设计的时序。但是，即使在每个角处都进行了验证也可能无法涵盖所有可能的情况，因为不同的金属层实际上可以独立地处于不同互连角下，例如：METAL2在Max C角下而METAL1在Max RC角下。10.9节中介绍的统计（statistical）时序分析将提出一种静态时序分析的机制，其中不同的金属层可以处于不同的互连角下。</p>
<h3 id="操作模式">操作模式</h3>
<p>操作模式决定了设计所要执行的操作，设计的各种操作模式包括：</p>
<p>● 功能模式1（工作在高速时钟下）</p>
<p>● 功能模式2（工作在低速时钟下）</p>
<p>● 功能模式3（睡眠模式）</p>
<p>● 功能模式4（调试模式）</p>
<p>● 测试模式1（scan capture）</p>
<p>● 测试模式2（scan shift）</p>
<p>● 测试模式3（bist）</p>
<p>● 测试模式4（jtag）</p>
<h3 id="pvt角">PVT角</h3>
<p>PVT角指的是STA在什么条件下执行。最常见的PVT角有：</p>
<p>● WCS（慢工艺、低电压、高温）</p>
<p>● BCF（快工艺、高电压、低温）</p>
<p>● Typical（典型工艺、标准电压、标准温度）</p>
<p>● WCL（低温下的最差情况：慢工艺、低电压、低温）</p>
<p>STA分析可以在任何条件下执行，这里的条件是指上述互连寄生角、操作模式和PVT角的组合。</p>
<h3 id="多模式多角分析">多模式多角分析</h3>
<p>多模式多角分析MMMC（Multi-Mode Multi-Corner）是指同时在多个工作模式、PVT角和寄生互连角之间执行STA。例如，假设一个DUA具有四个工作模式（正常、睡眠、扫描移位和Jtag），并且正在三个PVT角（WCS，BCF，WCL）和三个寄生互连角（Typical，Min C，Min RC）下进行分析 ，如下表所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-dad6b51188d07dcff579fa9e1fbccc8b_720w.jpg"></p>
<p>总共有36种可能的情况可以去执行所有时序检查，例如建立时间、保持时间、压摆和时钟门控检查。对于运行时间而言，同时运行所有36个情况的STA可能会因设计规模而导致运行时间过长。某一个情况可能不是基本的，因为它可能包含在了另一个情况中，又或者这个情况不是必需的。例如，设计人员可以确定情况4、6、7和9不相关，因此不是必需的。此外，可能不必在一个角上运行所有模式，例如在情况5中可能不需要扫描移位模式或Jtag模式。如果可以使用MMMC功能，则STA可以在单个情况中运行，也可以在多个情况中同时运行。</p>
<p>运行多模式多角STA的优点是可以节省运行时间并节省设置分析脚本的复杂性。MMMC方案的另一个优势在于，与每种模式或角需要分别多次加载设计和寄生参数相比，MMMC只需加载一次或两次即可。这样的工作也更适合在LSF服务器上运行。多模式多角在优化过程中也具有很大的优势：在优化过程中会对所有情况进行优化，因此在一个情况中解决的时序违例不会在另一情况中引入时序违例。</p>
<p>对于IO约束，<strong>-add_delay</strong>选项可与多个时钟源一起使用，以在一次运行（run）中分析不同的模式，例如scan或bist模式，或PHY中对应于不同速度的不同操作模式。通常每种模式都会在单独的运行中进行分析，但并非总是如此。</p>
<p>通常这样的设计是不常见的：具有大量时钟、需要数十次独立运行才能覆盖最大和最小角的每种模式、需要包括串扰和噪声的影响。</p>
<h2 id="统计静态时序分析">统计静态时序分析</h2>
<p>到目前为止介绍的静态时序分析技术是确定性的，因为分析基于的是设计中所有时序弧的固定延迟。每个时序弧的延迟都是根据工作条件以及工艺和互连模型计算得出的，尽管可能存在多个模式和多个角，但给定情况下的时序路径延迟是可以明确获得的。</p>
<p>实际上，执行STA时通常使用的工艺和工作条件的最差情况（WCS）或最佳情况（BCF）对应于极端的3σ角。时序库基于的是代工厂提供的带有工作条件的工艺角模型，这些条件对应于单元时序值的不同角。例如，使用快速工艺模型、最高电源和最低温度来表征最佳情况的快速时序库。</p>
<h2 id="工艺和互连走线变化">工艺和互连走线变化</h2>
<h3 id="全局工艺变化">全局工艺变化</h3>
<p>全局工艺变化（global process variation），也称为芯片间器件变化（inter-die device variations），是指影响芯片（或晶圆）上所有器件的工艺参数变化，参见图10-24。这表明芯片上的所有器件都会受到这些工艺变化的影响，芯片上的每个器件都会是slow或是fast的，或者介于两者之间。 因此，通过全局工艺参数建模的变化旨在捕获芯片与芯片之间的变化。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9b99775a26aaadc5df58b6f217ef4e0e_720w.jpg" alt="图10-24"></p>
<p>图10-25中显示了全局参数值（例如g_par1）的变化。例如，参数g_par1可以对应于标准NMOS器件的IDSsat（器件饱和电流）。由于这是一个全局参数，因此芯片上所有单元实例中的所有NMOS器件将对应于相同的g_par1值。可以有如下选择：所有单元实例的g_par1的变化是完全相关的，或者芯片上g_par1的变化相互影响。注意，可能还存在其它全局参数（g_par2，...），其可能可以对PMOS器件饱和电流和其它相关变量建模。</p>
<p><img src="https://pic1.zhimg.com/80/v2-f143639ba578b873b0d291279c46a7c4_720w.jpg" alt="图10-25"></p>
<p>不同的全局参数（g_par1，g_par2，...）之间是不相关的。不同全局参数的变化是不会相互影响的，这意味着g_par1和g_par2参数彼此将独立地变化。在一块芯片上，g_par1可能处于最大值，而g_par2可能处于最小值。</p>
<p>在确定性（即非统计性）分析中，慢速工艺模型可能对应于芯片间变化的+ 3σ角的条件。类似地，快速工艺模型可能对应于芯片间变化的-3σ角的条件。</p>
<h3 id="局部工艺变化">局部工艺变化</h3>
<p>局部工艺变化（local process variation），也称为芯片内器件变化，是指工艺参数的变化，这些变化可以在给定芯片上影响不同器件，参见图10-26。这意味着并排放置在同一芯片上的相同器件可能具有不同的行为。由局部工艺变化建模的变化旨在捕获芯片内的随机工艺变化。</p>
<p><img src="https://pic2.zhimg.com/80/v2-91ed0ec2716b393b8ca949876a12c211_720w.jpg" alt="图10-26"></p>
<p>图10-27显示了局部工艺参数的变化。芯片上的局部参数变化不会相互影响，并且它们从一个单元实例到另一单元实例的变化是不相关的。这意味着对于同一芯片上的不同器件，局部参数可能具有不同的值。例如，芯片上的不同NAND2单元实例可能会具有不同的局部工艺参数值。即使其它参数（例如输入压摆和输出负载）相同，这也可能导致同一NAND2单元的不同实例具有不同的延迟值。</p>
<p><img src="https://pic4.zhimg.com/80/v2-8ffa5824474a31166616a3dec7729833_720w.jpg" alt="图10-27"></p>
<p>由全局和局部变化引起的NAND2单元延迟变化的示意图如图10-28所示。该图说明了全局参数变化比局部参数变化引起的延迟变化更大。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ec90bc73facee8b98299e6846856ede1_720w.jpg" alt="图10-28"></p>
<p>局部工艺变化是打算在使用OCV建模的分析中捕获的变化之一，如10.1节中所述。由于统计时序模型通常包括局部工艺变化，因此使用统计时序模型进行的OCV分析不应在OCV设置中包括局部工艺变化。</p>
<h3 id="互连走线变化">互连走线变化</h3>
<p>如10.8节中所述，实际上存在着各种互连角，它们代表影响互连电阻和电容值的每个金属层的参数变化。这些参数变化通常是金属和电介质的厚度以及影响各种金属层中金属走线的宽度和间距的金属刻蚀。通常，影响金属的参数会影响该金属层中所有走线的寄生参数，但对其它金属层中走线的寄生影响很小甚至是没有影响。</p>
<p>10.8节中介绍的互连角可用于对互连走线变化进行建模，以便所有金属层都对应到相同的互连角下。对互连走线变化进行统计建模时，每个金属层都可以独立地变化。统计方法会对互连走线空间中所有可能的变化组合进行建模，从而对仅通过在指定互连角下进行分析可能无法捕获的变化进行建模。例如，时钟树的发起路径可能在METAL2中，而时钟树的捕获路径可能在METAL3中。传统互连角下的时序分析会考虑各种角，这些角会同时改变所有金属层，因此无法对这种情况进行建模：METAL2在该角下延迟最大，而METAL3在该角下延迟最小。这种组合对应于路径建立时间检查的最差情况，并且只能通过对互连走线变化进行统计建模来捕获。</p>
<h2 id="统计分析">统计分析</h2>
<h3 id="什么是ssta">什么是SSTA？</h3>
<p>如果对单元时序模型和互连寄生进行统计建模，则上述对变化的建模是可行的。除延迟外，还对单元输入端的引脚电容值也进行了统计建模，这意味着时序模型是根据工艺参数（全局和局部）的均值和标准差来描述的，而互连电阻和电容是根据互连参数的平均值和标准差来描述的。延迟计算过程（在第5章中介绍的）会先获得每个时序弧（单元以及互连走线）的延迟，然后再用相对于各种参数的平均值和标准差来表示。因此，每个延迟都由平均值和N个标准差来表示（其中N是统计建模中独立工艺和互连参数的数量）。</p>
<p>由于通过各个时序弧的延迟是用统计形式表示的，因此统计静态时序分析SSTA（Statistical Static Timing Analysis）过程中会结合时序弧的延迟以获得路径延迟，该路径延迟同样会以统计形式表示（具有均值和标准差）。SSTA会根据独立的工艺和互连参数的标准差，来获得路径延迟的总体标准差。例如，考虑由两个时序弧组成的路径延迟，如图10-29所示。由于每个延迟分量都有其变化，因此根据变化是相关的还是不相关的，将对变化进行不同的组合。如果变化来自同一来源（例如，由相互影响的g_par1参数引起），则路径延迟的σ仅等于（σ1 + σ2）。但是，如果变化是不相关的（例如由于l_par1参数），那么路径延迟的σ等于 <img src="https://www.zhihu.com/equation?tex=%5Csqrt%7B%5Csigma_%7B1%7D%5E%7B2%7D%2B%5Csigma_%7B2%7D%5E%7B2%7D%7D" alt="[公式]"> ，该值小于（σ1 + σ2）。当对局部（不相关的）工艺变化建模时，路径延迟σ较小的现象也称为各个延迟变化的统计抵消（statistical cancellation）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-159fa60a3bd2fba8f5372662077b222b_720w.jpg" alt="图10-29"></p>
<p>对于一个实际设计，既要建模相关变化，也要建模不相关变化，因此需要适当组合这两种类型变化的权重。</p>
<p>发起和捕获时钟的时钟路径延迟也以相同的统计形式表示。基于数据和时钟路径延迟，可以将裕量（slack）作为具有标准值和标准差的统计量。</p>
<p>假设使用正态分布，可以获得对应于（平均值mean +/- 3σ）的有效最小值和最大值。 （平均值mean -/ + 3σ）对应于图10-30中所示正态分布的0.135％和99.865％的分位数。0.135％的分位数意味着仅0.135％的结果分布小于此值（平均值mean-3σ）；同样，99.865％的分位数表示99.865％的结果小于此值，或仅0.135％（100％-99.865％）的结果大于此值（平均值mean+3σ）。有效的下限和上限在SSTA报告中称为分位数（quantile），设计人员可以选择分析中使用的分位数，例如0.5％或99.5％，对应于（平均值mean -/ + 2.576σ）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-2e7c436aa3d482982a9485870c5ad85b_720w.jpg" alt="图10-30"></p>
<p>对于噪声和串扰分析（第6章），将使用相对于各种参数的平均值和标准差来对路径延迟和时间窗口进行统计建模。</p>
<p>根据路径裕量分布，SSTA会报告每个路径裕量的平均值、标准差和分位数，从而可以根据所需的统计置信度（confidence）来判断时序是通过还是违例。</p>
<h3 id="统计时序库">统计时序库</h3>
<p>在SSTA方法中，标准单元库（以及设计中使用的其它单元库）提供了各种环境条件下的时序模型。例如，在最小Vdd和高温角下进行的分析利用了在此条件下表征的库，但对工艺参数进行了统计建模。该库包含了用于标准参数值以及参数变化的时序模型。对于N个工艺参数，在0.9V电源和125°C条件下表征的统计时序库可能包括以下内容：</p>
<p>● 具有标准工艺参数的时序模型</p>
<p>● 参数i为（标准值+1σ）的时序模型，其他参数保持为标准值</p>
<p>● 参数i为（标准值-1σ）的时序模型，其他参数保持为标准值</p>
<p>对于仅具有两个独立工艺参数的简化情况示例，时序模型是以标准参数值以及参数值的变化来表征的，如图10-31所示。</p>
<p><img src="https://pic2.zhimg.com/80/v2-6c2983fec99df6bccdaa7eb91e3b95a5_720w.jpg" alt="图10-31"></p>
<h3 id="统计互连走线变化">统计互连走线变化</h3>
<p>每个金属层有三个独立的参数：</p>
<p>● 金属刻蚀：这可以控制金属宽度以及与相邻导体的间距。金属层中的大刻蚀减小了宽度（这增加了电阻）并增加了到相邻走线的间距（这减小了到相邻走线的耦合电容）。该参数表示为导体宽度的变化。</p>
<p>● 金属厚度：较厚的金属意味着与下面各层的电容更大。该参数表示为导体厚度的变化。</p>
<p>● IMD（金属间介电层）厚度：较大的IMD厚度会减少与下面各层的耦合。该参数表示为IMD厚度的变化。</p>
<h3 id="ssta结果">SSTA结果</h3>
<p>统计分析中输出的结果将根据平均值和角的有效值来提供路径的裕量。以下是用于建立时间检查（最大路径分析）的SSTA报告示例：</p>
<p><img src="https://pic3.zhimg.com/80/v2-567e60308c8da148c5f0928349b7e176_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-b9a94c859f92dcd9103cd88ae491b89f_720w.jpg"></p>
<p>上面的报告显示，尽管时序路径的均值满足要求，但0.135％的分位数却有0.43ns的时序违例，时序路径裕量的分位数为-0.43ns。时序路径裕量的平均值为+ 0.86ns，标准差为0.43ns，这意味着+/- 2σ的分布结果满足要求。由于95.5％的分布落在2σ的变化范围内，这意味着只有2.275％的路径会出现时序违例（其余的2.275％分布具有较大的正裕量）。因此，把分位数设置为2.275％后可以使得裕量为0或没有时序违例。到达时间和路径裕量分布如下图10-32所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-3011c4cfb2b97e23926f89482ae73d61_720w.jpg" alt="图10-32"></p>
<p>请注意，以上报告是针对建立时间检查的，因此分位数那一列提供的是分位数上限（例如，路径延迟的+ 3σ值），保持时间检查时则会指定为分位数下限（例如-3σ值）。报告中的“sensitiv”列是指敏感度，即标准差与平均值的比值（表示为百分比）。就裕量而言，需要较小的灵敏度，这意味着即使平均值发生变化，以平均值通过的路径也会继续通过。“incr”列中指定了报告中该行的增量标准差。</p>
<p>使用单元和互连走线的统计模型，统计时序方法可以分析各种角条件下的设计，并分析由于工艺和互连参数变化而导致的情况。例如，在最差VT（电压和温度）情况下进行统计分析将分析整个全局工艺和互连走线空间。在最佳VT（电压和温度）情况下的另一种统计分析也将分析整个工艺和互连走线空间。这些分析可以与在最差PVT情况或最佳PVT情况下进行的传统分析进行对比，传统分析仅探讨工艺和互连空间中的单个点。</p>
<h2 id="时序违例路径">时序违例路径</h2>
<p>在本节中，我们提供了一些示例，重点介绍了设计人员在STA调试期间需要重点关注的方面。其中一些示例仅包含STA报告中的相关片段。</p>
<h3 id="找不到路径">找不到路径</h3>
<p>如果有人试图获取路径报告而STA却报告找不到路径，或者它提供了路径报告但裕量是无限的，该怎么办？在这两种情况下，都可能是由于以下原因引起的：</p>
<p>● 时序路径被打断</p>
<p>● 路径不存在</p>
<p>● 这是一条伪路径</p>
<p>在每种情况下，都需要仔细检查约束条件，以识别导致路径阻塞的约束条件。一种“简单粗暴”的选择是删除所有伪路径和时序中断的设置，然后查看路径是否可以进行时序分析。（时序中断是在STA中中断时序弧，可通过使用7.10节中所述的<strong>set_disable_timing</strong>命令来实现）</p>
<h3 id="跨时钟域-1">跨时钟域</h3>
<p>以下是一份路径报告的前面部分：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1a1687fcf0c35ce75f20e1b75f462cbd_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-6aea9551762f3a011504f55db44c191e_720w.png"></p>
<p>首先要注意的是，该路径从输入端口开始，到触发器的复位引脚结束，并且在该复位引脚上会进行恢复时间检查（图中表示为library recovery time）。接下来要注意的是，该路径跨越了两个不同的时钟域：用于发起输入数据的SYS_IN_CLK和用于恢复时间检查的PX9_CLK。即使从时序报告中看不出来，但从设计知识上来看，也可以检查两个时钟是否完全异步，以及这两个时钟域之间的任何路径是否应申明为伪路径。</p>
<h3 id="反相衍生时钟">反相衍生时钟</h3>
<p>创建衍生时钟时，需要谨慎使用<strong>-invert</strong>选项。如果使用<strong>-invert</strong>选项指定了衍生时钟，则STA会假定指定点处的衍生时钟属于指定的类型。但是根据逻辑，在设计中可能不会出现这种波形。STA通常会给出错误或警告消息，表明衍生时钟无法实现，但是它将继续进行分析并报告时序路径。</p>
<p><img src="https://pic1.zhimg.com/80/v2-64018dfea37e21bd79c3a133da9e6720_720w.jpg" alt="图10-33"></p>
<p>考虑图10-33中示例，让我们在单元UCKBUF0的输出上使用<strong>-invert</strong>选项定义一个衍生时钟：</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> CLKGEN <strong>-divide_by</strong> 1 <strong>-invert</strong> <strong>-source</strong> [<strong>get_ports</strong> CLKM] [<strong>get_pins</strong> UCKBUF0/C]</p>
<p>以下是基于上述约束的建立时间检查路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-6bde78c9393c1366c8e328408e15ca1b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-1e7630122d9b98629c6006f93f0986ed_720w.png"></p>
<p>注意，STA会假设单元UCKBUF0的输出波形是时钟CLKM的反相时钟。因此上升沿为5ns，建立时钟捕获沿为15ns。除了时钟的上升沿是5ns而不是0ns之外，从时序报告中还看不出有什么问题。应该注意的是，由于错误是在发起时钟路径和捕获时钟路径的共同部分上，因此建立时间和保持时间检查是正确的。设计人员需要仔细分析和理解STA产生的警告和错误信息。</p>
<p>要注意的重要一点是，无论是否可实现，STA都会按照指定的方式创建衍生时钟。</p>
<p>现在，让我们尝试将带有<strong>-invert</strong>选项的衍生时钟移至单元UCKBUF1的输出处，看看会发生什么。</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CLKM <strong>-period</strong> 10 <strong>-waveform</strong> {0 5} [<strong>get_ports</strong> CLKM]</p>
<p>● <strong>create_generated_clock</strong> <strong>-name</strong> CLKGEN <strong>-divide_by</strong> 1 <strong>-invert</strong> <strong>-source</strong> [<strong>get_ports</strong> CLKM] [<strong>get_pins</strong> UCKBUF1/C]</p>
<p>以下是建立时间检查的路径报告：</p>
<p><img src="https://pic4.zhimg.com/80/v2-2350ed3d694889bac83f2011dbdc83b7_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-580b3767a24caffc5ca70703150359ff_720w.jpg"></p>
<p>该路径看起来像半周期路径（half-cycle path），但这是不正确的，因为实际逻辑中的时钟路径上没有反相。STA将再次假定UCKBUF1 / C引脚上的时钟为<strong>create_Generated_clock</strong>命令中指定的时钟。因此，上升沿出现在5ns。捕获时钟为时钟CLKM，其下一个上升沿发生在10ns处。下面的保持时间检查路径报告也会出现与建立时间检查路径相似的异常情况：</p>
<p><img src="https://pic4.zhimg.com/80/v2-c2230ef6e62b22b4565250433482193f_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3a5ec1a58d5acd958d718e3f754f71a9_720w.jpg"></p>
<p>通常，STA输出的结果将包含指示衍生时钟不可实现的错误或警告信息。调试此类不正确路径的最佳方法是在捕获触发器和发起触发器处绘制时钟波形，并尝试了解所示时钟沿是否确实有效。</p>
<h3 id="缺少虚拟时钟延迟">缺少虚拟时钟延迟</h3>
<p>考虑以下路径报告：</p>
<p><img src="https://pic1.zhimg.com/80/v2-361e86b3930aad244677daf8d9a3f72c_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-81e66526239210d4d03e3d70021024a5_720w.jpg"></p>
<p>这是一条从输入端口开始的路径。请注意，起始的数据到达时间列为0。这表示在时钟VCLKM上未指定延迟，时钟VCLKM用于定义输入引脚RESET_L上的输入到达时间。这很可能是一个虚拟时钟，这就是为什么会缺少数据到达时间的原因。</p>
<h3 id="io延迟大">IO延迟大</h3>
<p>当输入或输出路径有时序违例时，首先要检查的是时钟延迟，该延迟用作指定输入到达时间或输出所需时间的参考。这同样适用于前面所讲的例子。</p>
<p>要检查的第二件事是输入或输出延迟，即输入路径上的输入到达时间或输出路径上的输出所需时间。我们可能会发现这些数值对于目标频率是不现实的。输入到达时间通常是时序报告中数据路径的第一个值，而输出所需时间通常是时序报告中数据路径的最后一个值。</p>
<p><img src="https://pic3.zhimg.com/80/v2-5101cbdc92d51354ee038fefd093c8be_720w.jpg"></p>
<p>在这条时序违例的输入数据路径中，注意输入到达时间为14ns。在这种特殊情况下，输入到达时间约束中会存在一个错误，因为它太大了。</p>
<h3 id="io缓冲器延迟不正确">IO缓冲器延迟不正确</h3>
<p>当路径经过输入缓冲器或输出缓冲器时，约束不正确可能会导致输入或输出缓冲器延迟值较大。在如下所示的情况中，请注意18ns这个较大的输出缓冲器延迟值，这是由于输出引脚上指定的负载值较大导致的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-df977497b2202488cce103126d4c07dc_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-8eb5528bf1565157191327d61d523f44_720w.jpg"></p>
<h3 id="延迟值不正确">延迟值不正确</h3>
<p>当时序路径出现违例时，需要检查的一件事是发起时钟和捕获时钟的延迟是否合理，即确保这些时钟之间的偏斜（skew）在可接受的范围内。错误的延迟约束或生成时钟树时错误的时钟平衡（balancing）可能会导致发起时钟和捕获时钟路径间的较大偏斜，从而导致时序违例。</p>
<h3 id="半周期路径-1">半周期路径</h3>
<p>如前面的示例所述，设计人员需要检查违例路径的时钟域。随之而来的是，设计人员可能需要检查发起和捕获触发器的时钟沿。在某些情况下，可能会发现一个半周期路径（上升沿至下降沿路径或下降沿至上升沿路径）并且可能无法满足半周期路径的时序要求，又或者这些半周期路径不是真实存在的 。</p>
<h3 id="较大的延迟和过渡时间">较大的延迟和过渡时间</h3>
<p>一个关键事项是要检查沿数据路径的延迟或过渡时间的值是否异常地大，其中一些原因可能是：</p>
<p>● 高扇出网络：未适当缓冲（buffered）的网络。</p>
<p>● 较长网络：需要在中间插入缓冲器的网络。</p>
<p>● 低强度单元：由于在设计中标有“don't touch”，因此未被更换的单元。</p>
<p>● 存储器路径：这些路径通常会由于存储器输入上的建立时间较长以及存储器输出上的输出延迟较大而导致时序违例。</p>
<h3 id="缺少多周期保持时间约束">缺少多周期保持时间约束</h3>
<p>对于多周期建立时间约束N，常见的是缺少相应的多周期保持时间约束N-1。因此，这可能会导致工具在修复保持时间违例时插入大量不必要的延迟单元。</p>
<h3 id="未优化的路径">未优化的路径</h3>
<p>STA违例也可能出现在尚未优化的路径上，可以通过检查数据路径来确定这种情况。是否存在延迟较大的单元？可以手动改善数据路径的时序吗？也许数据路径需要进一步优化，工具可能正在其它违例路径上工作。</p>
<h3 id="仍不满足时序的路径">仍不满足时序的路径</h3>
<p>如果数据路径具有强驱动能力的单元，而该路径仍然时序违例，则需要检查布线延迟和线负载较高的引脚。这可能是下一个改进方法：也许可以将单元移动得更近一些，从而可以减少线负载和布线延迟。</p>
<h3 id="如果仍然不满足时序怎么办">如果仍然不满足时序怎么办</h3>
<p>可以利用有用偏斜（useful skew）来帮助时序收敛。有用偏斜是指故意使时钟树失衡的地方，尤其是时序违例路径的发起时钟和捕获时钟路径，从而使时序在该路径上收敛。通常，这意味着可以延迟捕获时钟，以使捕获触发器的时钟在数据准备就绪稍后到达。当然，这假定了后续数据路径（即下一级触发器到触发器的数据路径）上有足够的裕量。</p>
<p>也可以尝试相反的操作，也就是说，可以使发起时钟路径更短，以便更早地发起来自发起触发器的数据，从而帮助满足建立时间要求。同样，只有在前一级触发器到触发器路径具有多余的裕量时，才能做到这一点。</p>
<p>有用偏斜技术不仅可用于修复建立时间违例，还可用于修复保持时间违例。此技术的一个缺点是，如果设计具有多种操作模式，则有用偏斜可能会在另一种模式下引起问题。</p>
<h2 id="验证时序约束">验证时序约束</h2>
<p>随着芯片尺寸的增长，将越来越依赖静态时序分析所交付的时序。仅依赖STA的风险在于STA取决于时序约束的合理与否。因此，时序约束的验证成为重要的考虑因素。</p>
<h3 id="检查路径例外">检查路径例外</h3>
<p>有一些工具可以根据设计的结构（网表）检查伪路径和多周期路径的有效性，这些工具会检查指定的伪路径或多周期路径约束是否有效。此外，这些工具还可能可以根据设计的结构生成缺少的伪路径和多周期路径约束。但是，这些工具生成的某些路径例外（path exception）也可能是无效的。这是因为这些工具通常使用形式验证技术（formal verification techniques）通过逻辑结构来确定伪路径或多周期路径，而设计人员对设计的功能行为有更深入的了解。因此，在接受并在STA中使用它们之前，设计人员需要检查工具生成的路径例外。可能还存在其它基于设计语义行为的路径例外，如果工具无法提取此类路径例外，设计者必须手动定义这些路径例外。</p>
<p>时序约束中最大的风险就是路径例外。因此，应在仔细分析设计后确定出伪路径和多周期路径。通常，相比于伪路径，最好使用多周期路径，这确保了该路径至少受到一定程度的约束。如果在已知或可预期的时间会对信号进行采样，则无论信号离时钟沿有多远，都应使用多周期路径，这样静态时序分析至少可以知道一些时序约束的信息。伪路径可能会导致时序优化工具完全忽略这些路径，而实际上，它们确实可能在经过大量时钟周期后才被采样。</p>
<h3 id="检查跨时钟域">检查跨时钟域</h3>
<p>可用工具来确保设计中所有的跨时钟域均有效，这些工具还可以自动生成必要的伪路径约束。这样的工具也可能可以识别出非法（illegal）的跨时钟域，即数据在没有任何时钟同步逻辑的情况下跨越了两个不同时钟域。在这种情况下，这些工具可以提供在需要时自动插入合适的时钟同步逻辑的功能。请注意，并非所有跨异步时钟域都需要时钟同步器，应该取决于数据性质以及是否需要在下一个周期或几个周期后捕获数据。</p>
<p>使用STA检查跨异步时钟域的另一种方法是设置一个很大的时钟不确定度（uncertainty），该不确定度等于采样时钟的周期。这样可以确保至少存在一些时序违例行为，根据这些时序违例行为，可以确定适当的路径例外，或者将时钟同步逻辑添加到设计中。</p>
<h3 id="验证io和时钟约束">验证IO和时钟约束</h3>
<p>验证IO和时钟约束仍然是一个挑战，设计人员会经常进行时序仿真以检查设计中所有时钟的有效性。可以进行系统级时序仿真来验证IO时序，以确保芯片可以与其外围设备通信且没有任何时序问题。</p>
<h1 id="附录asdc">附录A:SDC</h1>
<blockquote>
<p>本附录将介绍1.7版本的SDC格式，此格式主要用于指定设计的时序约束。它不包含任何特定工具的命令，例如链接（link）和编译（compile）。它是一个文本文件，可以手写或由程序创建，并由程序读取。某些SDC命令仅适用于实现（implementation）或综合（synthesis），但是本附录会列出所有SDC命令。</p>
</blockquote>
<p>SDC语法是基于TCL的格式，即所有命令都遵循TCL语法。一个SDC文件会在文件开头包含SDC版本号，其次是设计约束，注释（注释以字符＃开始，并在行尾处结束）在SDC文件中可以散布在设计约束中。设计约束中较长的命令行可以使用反斜杠（）字符分成多行。</p>
<h2 id="a.1-基本命令">A.1 基本命令</h2>
<p>以下是SDC中的基本命令：</p>
<p>● <strong>current_instance</strong> [instance_pathname]</p>
<p>上述命令设置了设计的当前实例，这允许其它命令从该实例中设置或获取属性（attribute）。如果未提供任何参数，则当前实例将成为顶层（top-level）。</p>
<p>例子：</p>
<p>● <strong>current_instance</strong> /core/U2/UPLL</p>
<p>● <strong>current_instance</strong> .. （向上一层）</p>
<p>● <strong>current_instance</strong> （设为顶层）</p>
<p>● <strong>expr</strong> arg1 arg2 ... argn</p>
<p>● <strong>list</strong> arg1 arg2 ... argn</p>
<p>● <strong>set</strong> variable_name value</p>
<p>● <strong>set_hierarchy_separator</strong> separator</p>
<p>上述命令指定了SDC文件中使用的默认层次结构分隔符。在允许的情况下，可以通过在各个SDC命令中使用<strong>-hsc</strong>选项来覆盖此设置。</p>
<p>例子：</p>
<p>● <strong>set_hierarchy_separator</strong> /</p>
<p>● <strong>set_hierarchy_separator</strong> .</p>
<p>● <strong>set_units</strong> [<strong>-capacitance</strong> cap_unit] [<strong>-resistance</strong> res_units] [<strong>-time</strong> time_unit] [<strong>-voltage</strong> voltage_unit] [<strong>-current</strong> current_unit] [<strong>-power</strong> power_unit]</p>
<p>上述命令指定了SDC文件中使用的单位。</p>
<p>例子：</p>
<p>● <strong>set_units</strong> <strong>-capacitance</strong> pf <strong>-time</strong> ps</p>
<h2 id="a.2-对象访问命令">A.2 对象访问命令</h2>
<p>以下命令指定了如何访问设计实例中的对象。</p>
<p><strong>all_clocks</strong>命令会返回一个所有时钟的集合：</p>
<p>● <strong>foreach_in_collection</strong> clkvar [<strong>all_clocks</strong>]</p>
<p>● <strong>set_clock_transition</strong> 0.150 [<strong>all_clocks</strong>]</p>
<p><strong>all_inputs</strong> [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-clock</strong> clock_name] 命令会返回一个设计中所有输入端口的集合：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VCLK 0.6 <strong>-min</strong> [<strong>all_inputs</strong>]</p>
<p><strong>all_outputs</strong> [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-clock</strong> clock_name] 命令会返回一个设计中所有输出端口的集合：</p>
<p>● <strong>set_load</strong> 0.5 [<strong>all_outputs</strong>]</p>
<p><strong>all_registers</strong> [<strong>-no_hierarchy</strong>] [<strong>-clock</strong> clock_name] [<strong>-rise_clock</strong> clock_name] [<strong>-fall_clock</strong> clock_name] [<strong>-cells</strong>] [<strong>-data_pins</strong>] [<strong>-clock_pins</strong>] [<strong>-slave_clock_pins</strong>] [<strong>-async_pins</strong>] [<strong>-output_pins</strong>] [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-master_slave</strong>] 命令会返回一个具有指定属性的寄存器的集合：</p>
<p>● <strong>all_registers</strong> <strong>-clock</strong> DAC_CLK</p>
<p>上述这个命令返回的集合中为所有由时钟DAC_CLK触发的寄存器。</p>
<p><strong>current_design</strong> [design name] 命令会返回当前设计的名称。如果使用参数指定，则将会设置当前设计为指定的名称：</p>
<p>● <strong>current_design</strong> FADD</p>
<p>● <strong>current_design</strong></p>
<p><strong>get_cells</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个设计中与指定模型（pattern）匹配的单元的集合，通配符可用于匹配多个单元：</p>
<p>● <strong>get_cells</strong> RegEdge*</p>
<p>● <strong>foreach_in_collection</strong> cvar [<strong>get_cells</strong> <strong>-hierarchical</strong> *]</p>
<p><strong>get_clocks</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个设计中与指定模型匹配的时钟的集合。当在<strong>-from</strong>或<strong>-to</strong>等上下文中使用时，它将返回一个由指定时钟驱动的所有触发器的集合：</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_clocks</strong> SYS_CLK]</p>
<p>● <strong>set_multicycle_path</strong> <strong>-to</strong> [<strong>get_clocks</strong> jtag*]</p>
<p><strong>get_lib_cells</strong> [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会创建一个当前正在加载的库中并且与指定模型匹配的库单元的集合：</p>
<p>● <strong>get_lib_cells</strong> cmos131v/AOI3*</p>
<p><strong>get_lib_pins</strong> [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个与指定模型匹配的库单元引脚的集合。</p>
<p><strong>get_libs</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个设计中当前加载的库的集合。</p>
<p><strong>get_nets</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个与指定模型匹配的网络的集合：</p>
<p>● <strong>get_nets</strong> <strong>-hierarchical</strong> *</p>
<p>● <strong>get_nets</strong> FIFO_patt*</p>
<p><strong>get_pins</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个与指定模型匹配的引脚名称的集合：</p>
<p>● <strong>get_pins</strong> *</p>
<p>● <strong>get_pins</strong> U1/U2/U3/UAND/Z</p>
<p><strong>get_ports</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个与指定模型匹配的设计（输入和输出）端口名称的集合：</p>
<p>● <strong>foreach_in_collection</strong> port_name [<strong>get_ports</strong> clk*]</p>
<p>可以在不“获取”对象的情况下引用诸如端口（port）之类的对象吗？当设计中只有一个具有该名称的对象时，实际上没有任何区别。但是，当多个对象具有相同的名称时，使用<strong>get_ *</strong> 命令将变得更加重要，它可以避免在引用哪种类型对象方面所带来的任何可能的混淆。假设有一个名为BIST_N1的网络和一个名为BIST_N1的端口，考虑以下SDC命令：</p>
<p>● <strong>set_load</strong> 0.05 BIST_N1</p>
<p>问题是要引用哪个BIST_N1？网络还是端口？在大多数情况下，最好明确表明对象的类型，例如：</p>
<p>● <strong>set_load</strong> 0.05 [<strong>get_nets</strong> BIST_N1]</p>
<p>现在再假设有一个时钟MCLK和另一个也称为MCLK的端口，考虑以下SDC命令：</p>
<p>● <strong>set_propagated_clock</strong> MCLK</p>
<p>该对象是引用名为MCLK的端口还是引用称为MCLK的时钟？在此特定情况下，它指的是时钟，因为这是<strong>set_propagated_clock</strong>命令的优先级所选择的。但是，要明确一点，最好明确表明对象类型，如下所示：</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_clocks</strong> MCLK]</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_ports</strong> MCLK]</p>
<p>有了这种明确的条件申明，就不必依赖优先级规则了，并且SDC命令会非常清楚。</p>
<h2 id="a.3-时序约束">A.3 时序约束</h2>
<p>本节将介绍与时序约束有关的SDC命令。</p>
<p><strong>create_clock</strong> <strong>-period</strong> period_value [<strong>-name</strong> clock_name] [<strong>-waveform</strong> edge_list] [<strong>-add</strong>] [source_objects] 命令可用于定义时钟。如果未指定clock_name，则时钟名称将是第一个源对象的名称。<strong>-period</strong>选项指定时钟周期，<strong>-add</strong>选项用于在已经具有时钟定义的引脚上创建时钟。否则，如果不使用此选项，则此时钟定义将覆盖该节点上任何其它现有的时钟定义。<strong>-waveform</strong>选项指定时钟的上升沿和下降沿（占空比），默认值为（0，period / 2）。如果时钟定义的节点位于另一个时钟之后的路径上，则它将阻塞该点之前一个时钟。</p>
<p>例子：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 20 <strong>-waveform</strong> {0 6} <strong>-name</strong> SYS_CLK [<strong>get_ports</strong> SYS_CLK]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CPU_CLK <strong>-period</strong> 2.33 <strong>-add</strong> [<strong>get_ports</strong> CPU_CLK]</p>
<p><strong>create_generated_clock</strong> [<strong>-name</strong> clock_name] [<strong>-source</strong> master_pin] [<strong>-edges</strong> edge_list] [<strong>-divide_by</strong> factor] [<strong>-multiply_by</strong> factor] [<strong>-duty_cycle</strong> percent] [<strong>-invert</strong>] [<strong>-edge_shift</strong> shift_list] [<strong>-add</strong>] [<strong>-master_clock</strong> clock] [<strong>-combinational</strong>] [source_objects] 命令可用于定义内部的衍生时钟。如果未指定<strong>-name</strong>，则时钟名称为第一个源对象的名称。<strong>-source</strong>指定衍生时钟的源是设计中的引脚或端口。如果有多个时钟输入源节点，必须使用<strong>-master_clock</strong>选项指定将这些时钟中的哪一个用作衍生时钟的源。<strong>-divide_by</strong>选项用于指定时钟的分频系数，与<strong>-multiply_by</strong>类似。<strong>-duty_cycle</strong>可以用于指定时钟的占空比。如果时钟的相位已反转，则可以指定<strong>-invert</strong>选项。除了使用时钟倍频或分频，还可以使用<strong>-edges</strong>和<strong>-edge_shift</strong>选项指定衍生时钟。<strong>-edges</strong>选项指定一个由三个数字组成的列表，该列表指定用于第一个上升沿、下一个下降沿和下一个上升沿的主时钟边沿。例如，可以将时钟分频器指定为<strong>-divide_by</strong> 2或<strong>-edges</strong> {1 3 5}。<strong>-edge_shift</strong>选项可以与<strong>-edges</strong>选项一起使用，以指定三个边沿中每个边沿的偏移量。</p>
<p>例子：</p>
<p>● <strong>create_generated_clock</strong> <strong>-divide_by</strong> 2 <strong>-source</strong> [<strong>get_ports</strong> sys_clk] <strong>-name</strong> gen_sys_clk [<strong>get_pins</strong> UFF/Q]</p>
<p>● <strong>create_generated_clock</strong> <strong>-add</strong> <strong>-invert</strong> <strong>-edges</strong> {1 2 8} <strong>-source</strong> [<strong>get_ports</strong> mclk] <strong>-name</strong> gen_clk_div</p>
<p>● <strong>create_generated_clock</strong> <strong>-multiply_by</strong> 3 <strong>-source</strong> [<strong>get_ports</strong> ref_clk] <strong>-master_clock</strong> clk10MHz [<strong>get_pins</strong> UPLL/CLKOUT] <strong>-name</strong> gen_pll_clk</p>
<p><strong>group_path</strong> [<strong>-name</strong> group_name] [<strong>-default</strong>] [<strong>-weight</strong> weight_value] [<strong>-from</strong> from_list] [<strong>-rise_from</strong> from_list] [<strong>-fall_from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-rise_to</strong> to_list] [<strong>-fall_to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_through</strong> through_list] [<strong>-fall_through</strong> through_list] 命令可以为指定的路径组命名。</p>
<p><strong>set_clock_gating_check</strong> [<strong>-setup</strong> setup_value] [<strong>-hold</strong> hold_value] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-high</strong>] [<strong>-low</strong>] [object_list] 命令可以提供对任何对象指定时钟门控检查的功能。时钟门控检查仅在具有时钟信号的逻辑门处执行，默认情况下建立时间和保持时间值为0。</p>
<p>例子：</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-setup</strong> 0.15 <strong>-hold</strong> 0.05 [<strong>get_clocks</strong> ck20m]</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-hold</strong> 0.3 [<strong>get_cells</strong> U0/clk_divider/UAND1]</p>
<p><strong>set_clock_groups</strong> [<strong>-name</strong> name] [<strong>-logically_exclusive</strong>] [<strong>-physically_exclusive</strong>] [<strong>-asynchronous</strong>] [<strong>-allow_paths</strong>] <strong>-group</strong> clock_list 命令指定了一组具有特定属性的时钟，并为该组分配了一个名称。</p>
<p><strong>set_clock_latency</strong> [<strong>-rayise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-source</strong>] [<strong>-late</strong>] [<strong>-early</strong>] [<strong>-clock</strong> clock_list] delay object_list 命令指定给定时钟的时钟延迟。有两种类型的延迟：网络延迟和源延迟。源延迟是时钟定义引脚与其源之间的时钟网络延迟，而网络延迟是时钟定义引脚与触发器时钟引脚之间的时钟网络延迟。</p>
<p>例子：</p>
<p>● <strong>set_clock_latency</strong> 1.86 [<strong>get_clocks</strong> clk250]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-late</strong> <strong>-rise</strong> 2.5 [<strong>get_clocks</strong> MCLK]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-late</strong> <strong>-fall</strong> 2.3 [<strong>get_clocks</strong> MCLK]</p>
<p><strong>set_clock_sense</strong> [<strong>-positive</strong>] [<strong>-negative</strong>] [<strong>-pulse</strong> pulse] [<strong>-stop_propagation</strong>] [<strong>-clock</strong> clock_list] pin_list 命令在引脚上设置时钟属性。</p>
<p><strong>set_clock_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] transition_clock_list 命令指定时钟定义点处的时钟过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_clock_transition</strong> <strong>-min</strong> 0.5 [<strong>get_clocks</strong> SERDES_CLK]</p>
<p>● <strong>set_clock_transition</strong> <strong>-max</strong> 1.5 [<strong>get_clocks</strong> SERDES_CLK]</p>
<p><strong>set_clock_uncertainty</strong> [<strong>-from</strong> from_clock] [<strong>-rise_from</strong> rise_from_clock] [<strong>-fall_from</strong> fall_from_clock] [<strong>-to</strong> to_clock] [<strong>-rise_to</strong> rise_to_clock] [<strong>-fall_to</strong> fall_to_clock] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-setup</strong>] [<strong>-hold</strong>] uncertainty [object_list] 命令指定了时钟或时钟到时钟传输的时钟不确定度。STA将从路径的数据需要到达时间中减去建立时间不确定度，并将保持时间不确定度增加到路径的数据需要到达时间中。</p>
<p>例子：</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-setup</strong> <strong>-rise</strong> <strong>-fall</strong> 0.2 [<strong>get_clocks</strong> CLK2]</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> [<strong>get_clocks</strong> HSCLK] <strong>-to</strong> [<strong>get_clocks</strong> SYSCLK] <strong>-hold</strong> 0.35</p>
<p><strong>set_data_check</strong> [<strong>-from</strong> from_object] [<strong>-to</strong> to_object] [<strong>-rise_from</strong> from_object] [<strong>-fall_from</strong> from_object] [<strong>-rise_to</strong> to_object] [<strong>-fall_to</strong> to_object] [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-clock</strong> clock_object] value 命令在两个数据引脚之间执行指定的检查。</p>
<p>例子：</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> [<strong>get_pins</strong> UBLK/EN] <strong>-to</strong> [<strong>get_pins</strong> UBLK/D] <strong>-setup</strong> 0.2</p>
<p><strong>set_disable_timing</strong> [<strong>-from</strong> from_pin_name] [<strong>-to</strong> to_pin_name] cell_pin_list 命令中断了指定单元内的时序弧。</p>
<p>例子：</p>
<p>● <strong>set_disable_timing</strong> <strong>-from</strong> A <strong>-to</strong> ZN [<strong>get_cells</strong> U1]</p>
<p><strong>set_false_path</strong> [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] 命令指定了STA不需要考虑的路径例外。</p>
<p>● <strong>set_false_path</strong> <strong>-from</strong> [<strong>get_clocks</strong> jtag_clk] <strong>-to</strong> [<strong>get_clocks</strong> sys_clk]</p>
<p>● <strong>set_false_path</strong> <strong>-through</strong> U1/A <strong>-through</strong> U4/ZN</p>
<p><strong>set_ideal_latency</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] delay object_list 命令用于为特定对象设置理想的延迟。</p>
<p><strong>set_ideal_network</strong> [<strong>-no_propagate</strong>] object_list 命令将指定设计中理想网络的源节点。</p>
<p><strong>set_ideal_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] transition_time object_list 命令将指定理想网络的过渡时间。</p>
<p><strong>set_input_delay</strong> [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-max</strong>] [<strong>-min</strong>] [<strong>-add_delay</strong>] [<strong>-network_latency_included</strong>] [<strong>-source_latency_included</strong>] delay_value port_pin_list 命令将指定相对于指定时钟的输入端口数据到达时间，默认为时钟的上升沿。<strong>-add_delay</strong>选项允许向该引脚或端口添加多个约束，可以使用此<strong>-add_delay</strong>选项将时钟设置为不同的时钟。默认情况下，会将发起时钟的时钟源延迟添加到输入延迟值中，但是当指定了<strong>-source_latency_included</strong>选项时，由于假设已将源网络延迟添加到了输入延迟值中，因此不再添加源网络延迟。<strong>-max</strong>选项指定的延迟用于建立时间和恢复时间检查，而<strong>-min</strong>选项指定的延迟用于保持时间和撤销时间检查。如果仅指定<strong>-min</strong>或<strong>-max</strong>或两者均未指定，则两者将使用相同的值。</p>
<p>例子：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> SYSCLK 1.1 [<strong>get_ports</strong> MDIO*]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> virtual_mclk 2.5 [<strong>all_inputs</strong>]</p>
<p><strong>set_max_delay</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] delay_value 命令用于设置指定路径上的最大延迟。这个命令用于指定两个任意引脚之间的延迟，而不是从一个触发器到另一个触发器的延迟。</p>
<p>例子：</p>
<p>● <strong>set_max_delay</strong> <strong>-from</strong> [<strong>get_clocks</strong> FIFOCLK] <strong>-to</strong> [<strong>get_clocks</strong> MAINCLK] 3.5</p>
<p>● <strong>set_max_delay</strong> <strong>-from</strong> [<strong>all_inputs</strong>] <strong>-to</strong> [<strong>get_cells</strong> UCKDIV/UFF1/D] 2.66</p>
<p><strong>set_max_time_borrow</strong> delay_value object_list 命令可用于设置在分析锁存器路径时可以借用的最长时间。</p>
<p>例子：</p>
<p>● <strong>set_max_time_borrow</strong> 0.6 [<strong>get_pins</strong> CORE/CNT_LATCH/D]</p>
<p><strong>set_min_delay</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] delay_value 命令用于设置指定路径上的最小延迟，该延迟可以在任意两个引脚之间。</p>
<p>例子：</p>
<p>● <strong>set_min_delay</strong> <strong>-from</strong> U1/S <strong>-to</strong> U2/A 0.6</p>
<p>● <strong>set_min_delay</strong> <strong>-from</strong> [<strong>get_clocks</strong> PCLK] <strong>-to</strong> [<strong>get_pins</strong> UFF/*/S]</p>
<p><strong>set_multicycle_path</strong> [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-start</strong>] [<strong>-end</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] path_multiplier 命令将路径指定为多周期路径，可以使用多个<strong>-through</strong>选项。如果多周期路径仅用于建立时间检查，请使用<strong>-setup</strong>选项，而如果多周期路径用于保持时间检查，请使用<strong>-hold</strong>选项。如果<strong>-setup</strong>或<strong>-hold</strong>均未指定，则默认为<strong>-setup</strong>且默认的保持时间周期为0。<strong>-start</strong>选项指定了时钟周期数使用的是发起时钟的 ，而<strong>-end</strong>选项指定使用的是捕获时钟的，默认值为<strong>-start</strong>。<strong>-hold</strong>选项指定的时钟周期数表示需要偏离默认多周期保持时间值0的时钟沿数。</p>
<p>例子：</p>
<p>● <strong>set_multicycle_path</strong> <strong>-start</strong> <strong>-setup</strong> <strong>-from</strong> [<strong>get_clocks</strong> PCLK] <strong>-to</strong> [<strong>get_clocks</strong> MCLK] 4</p>
<p>● <strong>set_multicycle_path</strong> <strong>-hold</strong> <strong>-from</strong> UFF1/Q <strong>-to</strong> UCNTFF/D 2</p>
<p>● <strong>set_multicycle_path</strong> <strong>-setup</strong> <strong>-to</strong> [<strong>get_pins</strong> UEDGEFF*] 4</p>
<p><strong>set_output_delay</strong> [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] [<strong>-level_sensitive</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-max</strong>] [<strong>-min</strong>] [<strong>-add_delay</strong>] [<strong>-network_delay_included</strong>] [<strong>-source_latency_included</strong>] delay_value port_pin_list 命令可以指定相对于时钟的输出所需时间，默认是上升沿。默认情况下，时钟源延迟会添加到输出延迟值中，但是当指定<strong>-source_latency_included</strong>选项时，不会添加时钟延迟值，因为会假定它已包含在输出延迟值中。<strong>-add_delay</strong>选项可用于在一个引脚/端口上指定多个<strong>set_output_delay</strong>。</p>
<p><strong>set_propagated_clock</strong> object_list 命令指定时钟延迟需要计算，即不是理想的。</p>
<p>● <strong>set_propagated_clock</strong> [<strong>all_clocks</strong>]</p>
<h2 id="a.4-环境命令">A.4 环境命令</h2>
<p>本节介绍了用于设置待分析设计环境的命令。</p>
<p><strong>set_case_analysis</strong> value port_or_pin_list 命令用于指定被设置为常数的端口或引脚。</p>
<p>例子：</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_pins</strong> UDFT/MODE_SEL]</p>
<p>● <strong>set_case_analysis</strong> 1 [<strong>get_ports</strong> SCAN_ENABLE]</p>
<p><strong>set_drive</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] resistance port_list 命令用于指定输入端口的驱动强度，它指定端口的外部驱动电阻，值为0表示驱动强度是最高的。</p>
<p>例子：</p>
<p>● <strong>set_drive</strong> 0 {CLK RST}</p>
<p><strong>set_driving_cell</strong> [<strong>-lib_cell</strong> lib_cell_name] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-library</strong> lib_name] [<strong>-pin</strong> pin_name] [<strong>-from_pin</strong> from_pin_name] [<strong>-multiply_by</strong> factor] [<strong>-dont_scale</strong>] [<strong>-no_design_rule</strong>] [<strong>-input_transition_rise</strong> rise_time] [<strong>-input_transition_fall</strong> fall_time] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] port_list 命令用于模拟驱动输入端口的单元的驱动电阻。</p>
<p>例子：</p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> BUFX4 <strong>-pin</strong> ZN [<strong>all_inputs</strong>]</p>
<p><strong>set_fanout_load</strong> value port_list 命令在输出端口上设置指定的扇出负载。</p>
<p>例子：</p>
<p>● <strong>set_fanout_load</strong> 5 [<strong>all_outputs</strong>]</p>
<p><strong>set_input_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] transition port_list 命令指定了输入端口上的过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_input_transition</strong> 0.2 [<strong>get_ports</strong> SD_DIN*]</p>
<p>● <strong>set_input_transition</strong> <strong>-rise</strong> 0.5 [<strong>get_ports</strong> GPIO*]</p>
<p><strong>set_load</strong> [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-subtract_pin_load</strong>] [<strong>-pin_load</strong>] [<strong>-wire_load</strong>] value objects 命令用于指定在设计中引脚或网络上的电容性负载的值。<strong>-subtract_pin_load</strong>选项表示从指定负载中减去引脚电容。</p>
<p>例子：</p>
<p>● <strong>set_load</strong> 50 [<strong>all_outputs</strong>]</p>
<p>● <strong>set_load</strong> 0.1 [<strong>get_pins</strong> UFF0/Q]</p>
<p>● <strong>set_load</strong> <strong>-subtract_pin_load</strong> 0.025 [<strong>get_nets</strong> UCNT0/NET5]</p>
<p><strong>set_logic_dc</strong> port_list 命令、<strong>set_logic_one</strong> port_list 命令以及<strong>set_logic_zero</strong> port_list 命令将指定的端口设置为不关心（don't care）、逻辑1或逻辑0。</p>
<p>例子：</p>
<p>● <strong>set_logic_dc</strong> SE</p>
<p>● <strong>set_logic_one</strong> TEST</p>
<p>● <strong>set_logic_zero</strong> [<strong>get_pins</strong> USB0/USYNC_FF1/Q]</p>
<p><strong>set_max_area</strong> area_value 命令指定了当前设计的最大面积限制。</p>
<p>例子：</p>
<p>● <strong>set_max_area</strong> 20000.0</p>
<p><strong>set_max_capacitance</strong> value object_list 命令指定了端口或设计中的最大电容。如果是设计，则指定了设计中所有引脚的最大电容。</p>
<p>● <strong>set_max_capacitance</strong> 0.2 [<strong>current_design</strong>]</p>
<p>● <strong>set_max_capacitance</strong> 1 [<strong>all_outputs</strong>]</p>
<p><strong>set_max_fanout</strong> value object_list 命令指定了端口或设计中的最大扇出值。如果是设计，则指定了设计中所有输出引脚的最大扇出值。</p>
<p>● <strong>set_max_fanout</strong> 16 [<strong>get_pins</strong> UDFT0/JTAG/ZN]</p>
<p>● <strong>set_max_fanout</strong> 50 [<strong>current_design</strong>]</p>
<p><strong>set_max_transition</strong> [<strong>-clock_path</strong>] [<strong>-data_path</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] value object_list 命令指定了端口或设计中的最大过渡时间。如果是设计，则指定了设计中所有引脚上的最大过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_max_transition</strong> 0.2 UCLKDIV0/QN</p>
<p><strong>set_min_capacitance</strong> value object_list 命令指定了设计中端口或引脚上的最小电容值。</p>
<p>例子：</p>
<p>● <strong>set_min_capacitance</strong> 0.05 UPHY0/UCNTR/B1</p>
<p><strong>set_operating_conditions</strong> [<strong>-library</strong> lib_name] [<strong>-analysis_type</strong> type] [<strong>-max</strong> max_condition] [<strong>-min</strong> min_condition] [<strong>-max_library</strong> max_lib] [<strong>-min_library</strong> min_lib] [<strong>-object_list</strong> objects] [condition] 命令可以设置用于时序分析的工作条件。分析类型可以是single（单个情况），bc_wc（最佳情况/最差情况）或者on_chip_variation（片上变化）。可以使用<strong>operating_conditions</strong>命令在库中定义工作条件。</p>
<p>例子：</p>
<p>● <strong>set_operating_conditions</strong> <strong>-analysis_type</strong> bc_wc</p>
<p>● <strong>set_operating_conditions</strong> WCCOM</p>
<p>● <strong>set_operating_conditions</strong> <strong>-analysis_type</strong> on_chip_variation</p>
<p><strong>set_port_fanout_number</strong> value port_list 命令可用于设置端口的最大扇出数。</p>
<p>例子：</p>
<p>● <strong>set_port_fanout_number</strong> 10 [<strong>get_ports</strong> GPIO*]</p>
<p><strong>set_resistance</strong> [<strong>-min</strong>] [<strong>-max</strong>] value list_of_nets 命令可用于设置指定网络上的电阻。</p>
<p>例子：</p>
<p>● <strong>set_resistance</strong> 10 <strong>-min</strong> U0/U1/NETA</p>
<p>● <strong>set_resistance</strong> 50 <strong>-max</strong> U0/U1/NETA</p>
<p><strong>set_timing_derate</strong> [<strong>-cell_delay</strong>] [<strong>-cell_check</strong>] [<strong>-net_delay</strong>] [<strong>-data</strong>] [<strong>-clock</strong>] [<strong>-early</strong>] [<strong>-late</strong>] derate_value [object_list] 命令指定了降额系数。</p>
<p><strong>set_wire_load_min_block_size</strong> size 命令指定了将线负载模型设置为“enclosed”时使用的最小的块大小。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_min_block_size</strong> 5000</p>
<p><strong>set_wire_load_mode</strong> mode_name 命令定义了如何对分层设计（hierarchical design）中的网络使用线负载模型的机制。mode_name可以是top，enclosure或segmented。top模式规定在顶层定义的线负载模型将用于所有较低级别上。enclosure模式规定完全封闭在模块中的网络的线负载模型用于该网络。segmented模式规定模块中的网络段使用该模块的线负载模型。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_mode</strong> enclosed</p>
<p><strong>set_wire_load_model</strong> <strong>-name</strong> model_name [<strong>-library</strong> lib_name] [<strong>-min</strong>] [<strong>-max</strong>] [object_list] 命令定义了用于当前设计或指定网络的线负载模型。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_model</strong> <strong>-name</strong> "eSiliconLightWLM"</p>
<p><strong>set_wire_load_selection_group</strong> [<strong>-library</strong> lib_name] [<strong>-min</strong>] [<strong>-max</strong>] group_name [object_list] 命令会在根据块的单元面积确定线负载模型时，为设计设置线负载选择组，该选择组通常在技术库中定义。</p>
<h2 id="a.5-多电压命令">A.5 多电压命令</h2>
<p>当设计中存在多电压岛（multi-voltage islands）时，以下命令适用。</p>
<p><strong>create_voltage_area</strong> <strong>-name</strong> name [<strong>-coordinate</strong> coordinate_list] [<strong>-guard_band_x</strong> float] [<strong>-guard_band_y</strong> float] cell_list</p>
<p><strong>set_level_shifter_strategy</strong> [<strong>-rule</strong> rule_type]</p>
<p><strong>set_level_shifter_threshold</strong> [<strong>-voltage</strong> float] [<strong>-percent</strong> float]</p>
<p><strong>set_max_dynamic_power</strong> power [unit] 命令指定了最大动态功率。</p>
<p>例子：</p>
<p>● <strong>set_max_dynamic_power</strong> 0 mw</p>
<p><strong>set_max_leakage_power</strong> power [unit] 命令指定了最大漏电功率。</p>
<p>例子：</p>
<p>● <strong>set_max_leakage_power</strong> 12 mw</p>
<h1 id="附录bsdf">附录B:SDF</h1>
<blockquote>
<p>本附录将介绍标准延迟标注格式，并说明了如何在仿真中执行反标。</p>
</blockquote>
<p>延迟格式描述了设计网表的单元延迟和互连走线延迟，无论设计是用两种主要硬件描述语言（VHDL或Verilog HDL）中的哪一种所描述的。</p>
<p>本章还会介绍仿真的反标（backannotation），STA的反标其实是一个简单直接的过程，其中DUA中的时序弧将由SDF所指定的延迟进行标注。</p>
<h2 id="b.1-什么是sdf">B.1 什么是SDF？</h2>
<p>SDF是指标准延迟格式（Standard Delay Format）。它是一个IEEE标准——IEEE Std1497，它是ASCII文本文件，它描述了时序信息和约束，其目的是用作各种工具之间的文本类型的时序信息交换媒介，它也可以用来描述需要它的工具的时序数据。由于它是IEEE标准，因此由一个工具生成的时序信息可以被支持该标准的许多其它工具所使用。SDF中的数据与工具和语言都无关，且包括了互连走线延迟、器件延迟以及时序检查的规范。</p>
<p>由于SDF是ASCII文件，因此它易于阅读，尽管对于实际设计而言，这些文件往往很大。但是，它是作为工具之间的交换媒介。经常在进行信息交换时，一个工具可能会在生成SDF文件时产生一个问题，而另一个读取SDF的工具可能无法正确读取SDF。读取SDF的工具可能会在读取SDF时产生一个错误或警告，或者它可能会错误地解释SDF中的值。在这种情况下，设计人员可能必须查看SDF文件，看看出了什么问题。本章介绍了SDF文件的基础知识，并提供了必要和足够的信息，以帮助理解和调试任何标注问题。</p>
<p>图B-1显示了如何使用SDF文件的典型流程。时序计算工具通常会生成时序信息存储在SDF文件中。然后，通过读取SDF的工具将该信息反标到设计中。请注意，完整的设计信息不会都存储到SDF文件中，而只会存储延迟值。例如，实例名称和实例的引脚名称将被存储到SDF文件中，因为它们对于指定实例相关或引脚相关的延迟是必需的。因此，必须为SDF生成工具和SDF读取工具提供相同的设计。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ecd6657bd53a0b42922cf29e0791ce96_720w.jpg" alt="图B-1"></p>
<p>一个设计可以具有多个与之关联的SDF文件。可以为一个设计创建一个SDF文件，在分层设计中，也可以为分层中的每个块创建多个SDF文件。在标注期间，每个SDF都将应用于适当的分层实例中，如图B-2所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e94cf2f197e57648d209e2e296787f33_720w.jpg" alt="图B-2"></p>
<p>SDF文件包含了用于反标和标注的时序数据。更具体地说，它包含：</p>
<p>● 单元延迟（Cell delays）</p>
<p>● 脉冲传播（Pulse propagation）</p>
<p>● 时序检查（Timing checks）</p>
<p>● 互连走线延迟（Interconnect delays）</p>
<p>● 时序环境（Timing environment）</p>
<p>引脚到引脚的延迟（pin-to-pin delay）和分布式延迟（distributed delay）都可以针对单元延迟进行建模。引脚到引脚的延迟使用<strong>IOPATH</strong>结构（construct）表示，这些结构定义了每个单元输入到输出的路径延迟。<strong>COND</strong>结构还可以用于额外指定有条件的引脚到引脚延迟。状态相关（state-dependent）的路径延迟也可以使用<strong>COND</strong>结构来指定，分布式延迟的建模是使用<strong>DEVICE</strong>结构指定的。</p>
<p>脉冲传播结构——<strong>PATHPULSE</strong>和<strong>PATHPULSEPERCENT</strong>可用于指定使用引脚到引脚延迟模型时允许传播到单元输出端口的毛刺大小。</p>
<p>可以在SDF中指定的时序检查包括：</p>
<p>● 建立时间：SETUP，SETUPHOLD</p>
<p>● 保持时间：HOLD，SETUPHOLD</p>
<p>● 恢复时间：RECOVERY，RECREM</p>
<p>● 撤销时间：REMOVAL，RECREM</p>
<p>● 最大偏斜：SKEW，BIDIRECTSKEW</p>
<p>● 最小脉冲宽度：WIDTH</p>
<p>● 最小周期：PERIOD</p>
<p>● 不变化：NOCHANGE</p>
<p>时序检查中的信号可能存在某些条件。在时序检查中允许使用负值，不支持负值的工具可以选择将其替换为零。</p>
<p>SDF描述中支持三种类型的互连走线建模。<strong>INTERCONNECT</strong>结构是最通用且最常用的，可用于指定点对点延迟（从源端到接收端），因此单个网络可以具有多个<strong>INTERCONNECT</strong>结构。<strong>PORT</strong>结构可用于指定负载端口处的网络延迟，假定网络只有一个源端驱动。<strong>NETDELAY</strong>结构可用于指定整个网络的延迟，而无需考虑其源端或接收端，因此是指定网络上延迟的最不具体的方法。</p>
<p>时序环境提供了设计在工作时所依据的信息，这些信息包括<strong>ARRIVAL</strong>，<strong>DEPARTURE</strong>，<strong>SLACK</strong>和<strong>WAVEFORM</strong>结构。这些结构主要用于标注，例如可用于综合。</p>
<h2 id="b.2-sdf格式">B.2 SDF格式</h2>
<p>SDF文件包含一个首部（header section），后跟一个或多个单元。每个单元代表设计中的一个区域或范围，它可以是库原语（primitive）或用户自定义的黑盒。</p>
<p><img src="https://pic1.zhimg.com/80/v2-32c338d91631d725594577be36353fe0_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1b4881894fc3ec6ff1263e2e99283d98_720w.png"></p>
<p>首部包含一般信息，除了层次结构分隔符、时间刻度（timescale）和SDF版本号外，都不会影响SDF文件的语义。默认情况下，层次结构分隔符<strong>DIVIDER</strong>是点字符（“.”）。通过以下方法，可以将其替换为“/”字符：</p>
<p>● （<strong>DIVIDER</strong> /）</p>
<p>如果首部中没有时间刻度信息，则默认值为1ns。否则，可以使用以下命令明确指定时间刻度<strong>TIMESCALE</strong>：</p>
<p>● （<strong>TIMESCALE</strong> 10ps）</p>
<p>也就是说，将SDF文件中指定的所有延迟值乘以10ps。</p>
<p>SDF版本号<strong>SDFVERSION</strong>是必需的，SDF文件的使用者会根据它来确保文件符合指定的SDF版本。首部中可能存在的其它信息（属于常规信息类别）包括日期、程序名称、版本和工作条件。</p>
<p><img src="https://pic3.zhimg.com/80/v2-577b099dcdbd269c15847aca12e30a66_720w.jpg"></p>
<p>首部之后是一个或多个单元的描述，每个单元在设计中代表一个或多个实例（使用通配符），单元可以是库原语或分层块（hierarchical block）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fe6bfaad0613dedb373ad17b1277fe91_720w.jpg"></p>
<p>单元的顺序很重要，因为数据是从上到下进行处理的。后面的单元描述可以覆盖前面的单元描述所指定的时序信息（通常，两次定义同一单元实例的时序信息并不常见）。另外，可以将时序信息标注为绝对值或增量的形式。如果时序信息使用增量的形式，它将会把新值添加到现有值中。而如果时序信息是绝对值，它将覆盖任何先前指定的时序信息。</p>
<p>单元实例可以是分层实例名称。用于层次结构分隔的分隔符必须符合首部中指定的分隔符。单元实例名称可以选择为“ * ”字符，即通配符，这表示指定类型的所有单元实例。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fc80b331cfbceb028f05ba6436b635a5_720w.jpg"></p>
<p>单元中可以描述四种类型的时序规范：</p>
<p>● <strong>DELAY</strong>：用于描述延迟</p>
<p>● <strong>TIMINGCHECK</strong>：用于描述时序检查</p>
<p>● <strong>TIMINGENV</strong>：用于描述时序环境</p>
<p>● <strong>LABEL</strong>：声明可用于描述延迟的时序模型变量。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-71e1306389fda36a3736c4355c3e6a5e_720w.jpg"></p>
<p><strong>DELAY</strong>时序规范有四种类型：</p>
<p>● <strong>ABSOLUTE</strong>：在反标期间替换单元实例的现有延迟值。</p>
<p>● <strong>INCREMETN</strong>：将新的延迟数据添加到单元实例的任何现有延迟值。</p>
<p>● <strong>PATHPULSE</strong>：指定设计输入和输出之间的脉冲传播极限。此极限值用于决定是将出现在输入上的脉冲传播到输出，还是将其标记为“ X ”，或者将其滤除。</p>
<p>● <strong>PATHPULSEPERCENT</strong>：除了值以百分比表示外，这与<strong>PATHPULSE</strong>完全相同。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-dd3ec3554236c12e4fa6fc701cd4b44c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8bc0512afe629aec62d694de4a60fec5_720w.png"></p>
<p>RN和Q是单元的输入端口和输出端口。第一个值3是脉冲抑制极限（pulse rejection limit），称为r-limit，它定义了可以出现在输出上的最窄脉冲。窄于此的任何脉冲都会被拒绝通过，也就是说，它将不会出现在输出上。第二个值7（如果存在）是错误极限（error limit），也称为e-limit。任何小于e-limit的脉冲都会导致输出为“ X ”。e-limit必须大于r-limit，如图B-3所示。 当出现小于3（r-limit）的脉冲时，该脉冲不会传播到输出；当脉冲宽度在3（r-limit）和7（e-limit）之间时，输出为X ；当脉冲宽度大于7（e-limit）时，脉冲会传播到输出且没有任何滤除（unfiltered）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7a44bc7feaf5240b72fc659a73e49b0d_720w.jpg" alt="图B-3"></p>
<p>可以使用<strong>ABSOLUTE</strong>或<strong>INCREMENT</strong>描述八种延迟定义：</p>
<p>● <strong>IOPATH</strong>：输入到输出路径的延迟。</p>
<p>● <strong>RETAIN</strong>：保留时间定义，可以用于指定输出端口在其相关输入端口改变后应保留其先前值的时间。</p>
<p>● <strong>COND</strong>：条件路径延迟，可以用于指定状态相关的输入到输出路径延迟。</p>
<p>● <strong>CONDELSE</strong>：默认路径延迟，可以用于指定条件路径的默认值。</p>
<p>● <strong>PORT</strong>：端口延迟，可以用于指定互连走线延迟，该延迟被建模为输入端口的延迟。</p>
<p>● <strong>INTERCONNECT</strong>：互连走线延迟，可以用于指定从其源端到接收端的整个网络的传播延迟。</p>
<p>● <strong>NETDELAY</strong>：网络延迟，可以用于指定从一个网络的所有源端到所有接收端的传播延迟。</p>
<p>● <strong>DEVICE</strong>：器件延迟，主要用于描述分布式时序模型，可以用于指定通过单元到输出端口的所有路径的传播延迟。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-26486eadc451e8cf4b3ba11d9a90c44d_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-000889b7625a146ea8cd833cbdd586d0_720w.jpg"></p>
<p>输入A上的值发生更改后，Y将保留其先前值50ps（低电平为40ps）。50ps是保持高电平的值，40ps是保持低电平的值，101ps是传播上升沿延迟，90ps是传播下降沿延迟，如图B-4所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8f5362a1813e5826d56cf53189078208_720w.jpg" alt="图B-4"></p>
<p><img src="https://pic3.zhimg.com/80/v2-064e1ab89c1059a05fa4327a5c3601f2_720w.jpg"></p>
<h3 id="延迟">延迟</h3>
<p>到目前为止，我们已经看过了许多不同形式的延迟，其实延迟规范还有其它形式。通常，可以将延迟指定为一个、两个、三个、六个或十二个令牌（token）的集合，这些令牌可用于描述以下过渡的延迟：0-&gt; 1、1-&gt; 0、0-&gt; Z，Z-&gt; 1，1-&gt; Z，Z-&gt; 0，0-&gt; X，X-&gt; 1,1-&gt; X，X-&gt; 0，X-&gt; Z，Z-&gt; X。下表展示了如何使用少于十二个延迟令牌来表示十二种过渡情况。</p>
<p><img src="https://pic3.zhimg.com/80/v2-418bcbad04cfac55e68b987108dd126a_720w.jpg"></p>
<p>以下是这些延迟的一些示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2411c1a4d95992b3c3cb7ad538f77938_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0efbda04e3b93496dae44e52e7d662ea_720w.jpg"></p>
<p>每个延迟令牌可以依次写为一个、两个或三个值，如以下示例所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a25316d9a9dc68a981aed38dd574ed02_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d7cdbec2a0e38c883521a18500fd5ece_720w.jpg"></p>
<p>一个SDF文件中的延迟值可以使用有符号的实数或以下形式的三元数组来编写：</p>
<p>● （ 8.0：3.6：9.8 ）</p>
<p>为了表示出设计在三个工艺工作条件下的最小、典型以及最大延迟，注释器通常会根据用户提供的选项来决定去选择哪个值。三元数组形式中的值是可选的，但是至少应有一个。例如，以下形式是规范的：</p>
<p>● （ ： ： 0.22）</p>
<p>● （ 1.001 ： ： 0.998 ）</p>
<p>未指定的值就不会去标注。</p>
<h3 id="时序检查-1">时序检查</h3>
<p>在以<strong>TIMINGCHECK</strong>关键字开头的部分中指定了时序检查的极限。在任何这些检查中，可以使用<strong>COND</strong>结构指定有条件的时序检查。在某些情况下，可以指定两个额外的条件检查<strong>SCOND</strong>和<strong>CCOND</strong>，它们与<strong>stamp event</strong>和<strong>check event</strong>关联。</p>
<p>以下是一组检查：</p>
<p>● <strong>SETUP</strong>：建立时间检查</p>
<p>● <strong>HOLD</strong>：保持时间检查</p>
<p>● <strong>SETUPHOLD</strong>：建立时间和保持时间检查</p>
<p>● <strong>RECOVERY</strong>：恢复时间检查</p>
<p>● <strong>REMOVAL</strong>：撤销时间检查</p>
<p>● <strong>RECREM</strong>：恢复时间和撤销时间检查</p>
<p>● <strong>SKEW</strong>：单向偏斜时序检查</p>
<p>● <strong>BIDIRECTSKEW</strong>：双向偏斜时序检查</p>
<p>● <strong>WIDTH</strong>：脉宽时序检查</p>
<p>● <strong>PERIOD</strong>：周期时序检查</p>
<p>● <strong>NOCHANGE</strong>：不变化时序检查</p>
<p>以下是一些例子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-5c5d7204f65836158e1103e50124ac1a_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-027858b082c45fdd460dbdd0967c8b01_720w.jpg"></p>
<h3 id="标签">标签</h3>
<p>标签可用于指定VHDL泛型（generics）或Verilog HDL参数的值。</p>
<p><img src="https://pic3.zhimg.com/80/v2-8cdfc771fcd6b908f0a9399b1cb84d12_720w.jpg"></p>
<h3 id="时序环境">时序环境</h3>
<p>有许多结构可用于描述设计的时序环境。但是，这些结构可用于标注，而不是用于反标，例如在逻辑综合工具中。这些未在本文中描述。</p>
<h2 id="b.2.1-例子">B.2.1 例子</h2>
<p>接下去，我们将为两个设计提供完整的SDF文件。</p>
<h3 id="全加器">全加器</h3>
<p>这是用于全加器（full-adder）电路的Verilog HDL网表（netlist）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0e7bc900139da441a2767d8fad090c30_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-caf8d96c333133e47484f32cf01fe8b8_720w.jpg"></p>
<p>以下是时序分析工具生成的完整SDF文件：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d23fbfd72155d7886d89e1b2f4e5476b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-77685b34c4fbbe8ace061a710aed5df5_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e12b065955a4de070114fddadcfbce8c_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e6a30e472c3bdae01ffa43bd9910ccb7_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-01c6fc556821612d5dbfe35a9cf647cc_720w.jpg"></p>
<p><strong>INTERCONNECT</strong>中的所有延迟均为0，因为这是布局前的数据，因此建模的是理想互连走线模型。</p>
<h3 id="十进制计数器">十进制计数器</h3>
<p>这是十进制计数器的Verilog HDL模型：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0748cd5cfa0dd22a9d106a3384bbe087_720w.jpg"></p>
<p>对应的完整SDF文件如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b21c8a0a1b09a6245240c95006952694_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4901921680558a65934ef446e58216cf_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3b63a6d8348af47f5bbda97888ac5391_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-7138bb34c6a3100db8aab1f592a929a6_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-03e59a8edcf0e9bd228bb44e0a2fa6c7_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d1e8d9de8ae1f68138500f12648c8969_720w.jpg"></p>
<h2 id="b.3-标注过程">B.3 标注过程</h2>
<p>在本节中，我们将介绍如何在HDL描述中进行SDF的标注（annotation）。SDF的标注可以通过多种工具执行，例如逻辑综合工具、仿真工具和静态时序分析工具。SDF标注器（annotator）是这些工具的组件，可用于读取SDF、解释并向设计中标注时序值。假定会使用与HDL模型一致的信息创建SDF文件，并且在反标期间使用相同的HDL模型。此外，SDF标注器还需要负责正确解释SDF中的时序值。</p>
<p>SDF标注器标注了反标时序的泛型和参数。如果在语法或映射（mapping）过程中不符合该标准，它将给出错误报告。如果一个SDF标注器不支持某些SDF结构，则不会产生任何错误，标注器将忽略这些错误。</p>
<p>如果SDF标注器未能修改反标时序的泛型，则在反标过程中不会修改泛型的值，即保持不变。</p>
<p>在仿真工具中，反标通常发生在规划（elaboration）阶段之后，紧接在负约束延迟计算之前。</p>
<h2 id="b.3.1-verilog-hdl">B.3.1 Verilog HDL</h2>
<p>在Verilog HDL中，标注的主要机制是指定块（specify block），指定块可以指定路径延迟和时序检查。实际延迟值和时序检查极限值是通过SDF文件指定的，映射是一种行业标准，在IEEE Std 1364中定义。</p>
<p>从SDF文件中获得并在Verilog HDL模块的指定块中标注的信息包括指定路径的延迟、参数值、时序检查约束极限值和互连走线延迟。向一个Verilog HDL模型进行标注时，将忽略SDF文件中的其它结构。SDF中的<strong>LABEL</strong>部分定义了参数值。通过将SDF结构与相应的Verilog HDL声明进行匹配，然后将现有的时序值替换为SDF文件中的时序值，即可完成反标。</p>
<p>下表显示了SDF延迟值如何映射到Verilog HDL延迟值：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9f1f317462c2611034a9a4b53741e0de_720w.jpg"></p>
<p>下表描述了SDF结构到Verilog HDL结构的映射：</p>
<p><img src="https://pic2.zhimg.com/80/v2-313db78cf9a45f6c105d3d1440348085_720w.jpg"></p>
<p>有关示例，请参见后面部分。</p>
<h2 id="b.3.2-vhdl">B.3.2 VHDL</h2>
<p>SDF到VHDL的标注是一个行业标准，它在VITAL ASIC建模规范的IEEE标准IEEE Std 1076.4中定义，该标准的其中一部分描述了SDF延迟到ASIC库的标注。在这里，我们仅介绍与SDF映射有关的VITAL标准的相关部分。</p>
<p>SDF可用于直接在符合VITAL的模型中修改反标时序泛型，只能使用SDF为符合VITAL的模型指定时序数据。有两种方法可以将时序数据传递到VHDL模型中：通过配置，或直接传递到仿真中去。SDF标注过程包括在仿真期间在符合VITAL的模型中映射SDF结构和相应的泛型。</p>
<p>在符合VITAL的模型中，存在着有关如何命名和声明泛型的规则，以确保可以在模型的时序泛型和相应的SDF时序信息之间建立映射。</p>
<p>时序泛型由泛型名称及其类型组成，名称指定时序信息的种类，类型指定时序值的种类。如果泛型名称不符合VITAL标准，则它不是时序泛型，也不会被标注。</p>
<p>下表显示了SDF延迟值如何映射到VHDL延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-866c35b13ece5c6ea2823a6dc2b7369a_720w.jpg"></p>
<p>在VHDL中，时序信息是通过泛型进行反标的。泛型名称遵循一定的规则，以便保持一致或从SDF结构中获取。利用每个时序泛型名称，可以指定条件边沿的可选后缀。边沿可以指定一个与时序信息相关联的边沿。</p>
<p>下表列出了各种时序泛型名称：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a44e7be49c593fa926151c78211ea37e_720w.jpg"></p>
<h2 id="b.4-映射示例">B.4 映射示例</h2>
<p>以下是将SDF结构映射到VHDL泛型（generic）和Verilog HDL声明（declaration）的示例。</p>
<h3 id="传播延迟-1">传播延迟</h3>
<p>● 从输入端口A到输出端口Y的传播延迟：上升时间为0.406，下降时间为0.339：</p>
<p><img src="https://pic3.zhimg.com/80/v2-ce8817f40cbe6944cae4e876a1141952_720w.jpg"></p>
<p>● 从输入端口OE到输出端口Y的传播延迟：上升时间为0.441，下降时间为0.409。最小、标准和最大延迟是相同的：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5ba1ce30b7681eeb36521d1b4fdb0149_720w.jpg"></p>
<p>● 从输入端口S0到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4520723ba1cbe4d6efeded2cc18fcc8b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-941b803367be3f8b623e9441c672e74e_720w.jpg"></p>
<p>● 从输入端口A到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic1.zhimg.com/80/v2-5910a4199d9cf0ccbde48394fb8c4fe4_720w.jpg"></p>
<p>● 从输入端口CK到输出端口Q的传播延迟：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0088f98f6ea741e7591f39e6fae58c8_720w.jpg"></p>
<p>● 从输入端口A到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0906839b82ae3746a30f2fbab837ae52_720w.jpg"></p>
<p>● 从输入端口CK到输出端口ECK的传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-958bf0a11aad37027a21df522b30032f_720w.jpg"></p>
<p>● 从输入端口CI到输出端口S的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-57e351f67f6ccce1466b610c8a1adf3e_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-16d981773c8041d428f2be9a89d1c7ff_720w.jpg"></p>
<p>● 从输入端口CS到输出端口S的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e31479125e64ea6a9f64df5d464553d6_720w.jpg"></p>
<p>● 从输入端口A到输出端口ICO的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-54d7a6401167320d44fac2bee4b25213_720w.jpg"></p>
<p>● 从输入端口A到输出端口CO的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-32182414760afe7846ba1e1ce8812077_720w.jpg"></p>
<p>● 从CK的上升沿到Q的延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-99e2051f91bb85807bf213162372cae9_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0e460d79ac68db88328a50ec20a72ba7_720w.jpg"></p>
<h3 id="输入建立时间">输入建立时间</h3>
<p>● D的上升沿与CK的上升沿之间的建立时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-74df5beb66d1ae66e712eb57ce3c325b_720w.jpg"></p>
<p>● D的下降沿与CK的上升沿之间的建立时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-cfc7c24f1b23b829bc2380713acddef2_720w.jpg"></p>
<p>● 输入端口E的上升沿与参考CK的上升沿之间的建立时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-be5f8683b8362378df8607312a4ce0f0_720w.jpg"></p>
<p>● 输入端口E的下降沿和参考CK的上升沿之间的建立时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-35d38d491de9b443e26b8a28d8c36356_720w.jpg"></p>
<p>● SE和CK之间的条件建立时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-69ee9e630b83697eb0fd27cd4ed80e6b_720w.jpg"></p>
<h3 id="输入保持时间">输入保持时间</h3>
<p>● D的上升沿与CK的上升沿之间的保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-747b90fc0b8da319d271419f537bc6c5_720w.jpg"></p>
<p>● RN与SN之间的保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e4046cfa14bff3712bcd1fc7d3080e0d_720w.jpg"></p>
<p>● 输入端口SI与参考端口CK之间的保持时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4e7ac1d79cc26faa847d30c9fe8cd02a_720w.jpg"></p>
<p>● E和CK上升沿之间的条件保持时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-a3437becbae9757ee567c0263df8c750_720w.jpg"></p>
<h3 id="输入建立和保持时间">输入建立和保持时间</h3>
<p>● 在D和CLK之间的建立时间与保持时间检查。这是一个有条件的检查，第一个延迟值是建立时间，第二个延迟值是保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-dd937a75ad7ee6c5db2dd4db88cc676d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-40c51c521d6435c7b62a5a430ca34902_720w.jpg"></p>
<h3 id="输入恢复时间">输入恢复时间</h3>
<p>● CLKA和CLKB之间的恢复时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-16f2fefab421960b02616ee979f19ec0_720w.jpg"></p>
<p>● CLKA上升沿与CLKB上升沿之间的条件恢复时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c83e876cd023698a3a33fa12f0d1773a_720w.jpg"></p>
<p>● SE与CK之间的恢复时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-efeb18f572104d6bfdef3af51d68903b_720w.jpg"></p>
<p>● RN与CK之间的恢复时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5ca9075bc61d1632d53c41a5a8196221_720w.jpg"></p>
<h3 id="输入撤销时间">输入撤销时间</h3>
<p>● E的上升沿与CK的下降沿之间的撤销时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b3caa9abbff61864a418a14693fd9ac5_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-699caacc53dd183477ea55a704c1b9ae_720w.png"></p>
<p>● CK的上升沿和SN之间的条件撤销时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3126ac8ac932e519a5e4df7905f0ba5b_720w.jpg"></p>
<h3 id="周期">周期</h3>
<p>● 输入CLKB的周期：</p>
<p><img src="https://pic1.zhimg.com/80/v2-020a171b7bb267280a44a3b0fa6c2fcc_720w.jpg"></p>
<p>● 输入端口EN的周期：</p>
<p><img src="https://pic3.zhimg.com/80/v2-25504e21962dff3d9b6769b8847b75de_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-05a0d9f7bf016ed54f14e5b0b30341b4_720w.jpg"></p>
<p>● 输入端口TCK的周期：</p>
<p><img src="https://pic1.zhimg.com/80/v2-24f6b097b58e8bc2565b7216f4f15e50_720w.jpg"></p>
<h3 id="脉宽">脉宽</h3>
<p>● CK上高脉冲的脉冲宽度：</p>
<p><img src="https://pic1.zhimg.com/80/v2-870910d6bcedcc59f797c11e7b6ece90_720w.jpg"></p>
<p>● CK上低脉冲的脉冲宽度：</p>
<p><img src="https://pic1.zhimg.com/80/v2-929c85b83c12d25707c2ae3c04d96528_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9e4066425d9adc9cdd95bec6a11b9c74_720w.jpg"></p>
<p>● RN上高脉冲的脉冲宽度：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d9cfe0e3981d15668e6b11cf0e5a4d37_720w.jpg"></p>
<h3 id="输入偏斜时间">输入偏斜时间</h3>
<p>● CK与TCK之间的偏斜：</p>
<p><img src="https://pic3.zhimg.com/80/v2-8a49393d63450f5c7aa992c55e2ea7aa_720w.jpg"></p>
<p>● SE和CK下降沿之间的偏斜：</p>
<p><img src="https://pic2.zhimg.com/80/v2-53cda8ce114c00c5586cfda867410581_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-16f953ab76a39bb1e7585312ebc8b9ca_720w.jpg"></p>
<h3 id="无变化的建立时间">无变化的建立时间</h3>
<p>SDF文件中的NOCHANGE结构将同时映射到VHDL中的tncsetup和tnchold泛型。</p>
<p>● D和CK下降沿之间无变化的建立时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35501310e16ec371aba334d7d748ec31_720w.jpg"></p>
<h3 id="无变化的保持时间">无变化的保持时间</h3>
<p>SDF文件中的NOCHANGE结构将同时映射到VHDL中的tncsetup和tnchold泛型。</p>
<p>● E和CLKA之间无变化的条件保持时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-17346e072ebd78d7d4c7ff1519bae456_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9251364fb786f794df968c1821e6dbf8_720w.jpg"></p>
<h3 id="端口延迟">端口延迟</h3>
<p>● 端口OE的延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-ca3ed5652ebb3b601eb1f6bcb62350b5_720w.jpg"></p>
<p>● 端口RN的延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d1def2fb828ac302521caf6a83c86fc3_720w.jpg"></p>
<h3 id="网络延迟">网络延迟</h3>
<p>● 连接到端口CKA的网络延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-bb573f4548409fcd60d58457b5fee1e6_720w.jpg"></p>
<h3 id="互连路径延迟">互连路径延迟</h3>
<p>● 从端口Y到端口D的互连路径延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-92c911cbd368a44d8fdc8b5d70840a25_720w.jpg"></p>
<h3 id="器件延迟">器件延迟</h3>
<p>● 实例uP的输出SM的器件延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-594d97d08b6dd15cd5a7fac8ae779262_720w.jpg"></p>
<h2 id="b.5-完整语法">B.5 完整语法</h2>
<p>以下是使用BNF格式显示的SDF的完整语法。终端（terminal）名称是大写的，关键字是粗体的，但是不区分大小写。起始的终端是delay_file：</p>
<p><img src="https://pic4.zhimg.com/80/v2-778ef72b2a25569041fc038d59b6b6c3_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-25318d1ed0e04a456481502b0b78d402_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-c4a97a21948d8413effe48b3f4b98fb2_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3712a766a742f058308daeb4733f8d73_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-72f6af6a036ef6a4345a84ec5d8717db_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-de80ee340df3748c82680bcb38abc0ee_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-8fc1c5592b3caeb7953e1a2f72f909ba_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c7df5901bd83557b3e0226bae3b859d3_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ce2cf75964e4d40841dc4aa72646215d_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-958c19cddf02f96d902b58b7a92fcd29_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-39f72aafdf5ecdb580cbb2482e05dfc0_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f12d07ad8763294f144ca9291f67c13b_720w.jpg"></p>
<h1 id="附录cspef">附录C:SPEF</h1>
<blockquote>
<p>本附录将介绍标准寄生参数提取格式（SPEF），它是IEEE Std 1481标准的一部分。</p>
</blockquote>
<h2 id="c.1-基础">C.1 基础</h2>
<p>SPEF允许以ASCII交换格式描述设计的寄生信息（R，L和C）。用户可以读取和检查SPEF文件中的值，尽管用户永远不会手动创建此文件。它主要用于将寄生信息从一个工具传递到另一个工具。图C-1显示了SPEF可以由诸如布局布线工具或寄生参数提取工具之类的工具生成，然后交由时序分析工具用于电路仿真或执行串扰分析。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d66bfe17d0657c476a9db91bc10399d7_720w.jpg" alt="图C-1"></p>
<p>寄生参数可以在许多不同的层次上表示。SPEF支持分布式（distributed）网络模型、（reduced）简化网络模型和（lumped）集总电容模型。在分布式网络模型（D_NET）中，网络走线的每段都有其自己的R和C。在简化网络模型（R_NET）中，在网络的负载引脚上考虑一个简化的R和C，而在网络的驱动引脚上考虑一个π模型（C-R-C）。在集总电容模型中，仅为整个网络指定一个电容。图C-2显示了物理网络走线的一个示例，图C-3显示了分布式网络模型，图C-4显示了简化的网络模型，图C-5显示了集总电容模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0826235775bf5a106ea18e42a61d1b82_720w.jpg" alt="图C-2"></p>
<p><img src="https://pic2.zhimg.com/80/v2-072247589e9f878fade00feb0c1ffb61_720w.jpg" alt="图C-3"></p>
<p><img src="https://pic4.zhimg.com/80/v2-60166c6d849bcaa4f16f21e8ff44fd73_720w.jpg" alt="图C-4"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ee7be67b2c83c0739da7df72acf5fa2a_720w.jpg" alt="图C-5"></p>
<p>互连寄生效应取决于工艺，SPEF支持最佳（best-case）、典型（typical）和最差（worst-case）三种情况。允许R、L和C值、端口压摆和负载使用此三种不同情况下的值。</p>
<p>通过提供一个包含网络名称和实例名称映射到索引的一个名称映射（name map），可以有效地减小SPEF文件的大小，更重要的是，所有较长名称仅出现在一个位置。</p>
<p>设计的SPEF文件可以拆分为多个文件，也可以分层。</p>
<h2 id="c.2-格式">C.2 格式</h2>
<p>SPEF文件的格式如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e1eb8bc8e1d1dc3c659322158db3aa0b_720w.jpg"></p>
<p><strong>header_definition</strong>包含了基本信息，例如SPEF版本号、设计名称以及R，L和C的单位。<strong>name_map</strong>指定了网络名称和实例名称到索引的映射。<strong>power_definition</strong>声明了电源网络和地网络。<strong>external_definition</strong>定义了设计的端口。<strong>define_definition</strong>中指出了SPEF还在其它文件中进行了描述的那些实例。<strong>internal_definition</strong>包含的是文件的核心——设计的寄生参数。</p>
<p>图C-6显示了<strong>header_definition</strong>的示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-484aac79a1305cbe5e8b710781ecd170_720w.jpg" alt="图C-6"></p>
<p><strong>SPEF</strong> name 指定了SPEF的版本号；</p>
<p><strong>DESIGN</strong> name 指定了设计的名称；</p>
<p><strong>DATE</strong> string 指定了创建文件时的时间戳；</p>
<p><strong>VENDOR</strong> string 指定了用于创建SPEF的供应商工具；</p>
<p><strong>PROGRAM</strong> string 指定了用于生成SPEF的程序；</p>
<p><strong>VERSION</strong> string 指定了用于创建SPEF的程序的版本号；</p>
<p><strong>DESIGN_FLOW</strong> string string string . . . 指定了在什么阶段创建SPEF文件。它描述了有关SPEF文件的信息，这些信息无法通过读取文件来获得。</p>
<p>预定义的字符串值为：</p>
<p>● <strong>EXTERNAL_LOADS：</strong>外部载荷在SPEF文件中完全指定。</p>
<p>● <strong>EXTERNAL_SLEWS：</strong>外部压摆在SPEF文件中完全指定。</p>
<p>● <strong>FULL_CONNECTIVITY：</strong>SPEF中存在逻辑网表连接。</p>
<p>● <strong>MISSING_NETS：</strong>SPEF文件中可能缺少某些逻辑网络。</p>
<p>● <strong>NETLIST_TYPE_VERILOG：</strong>使用Verilog HDL类型命名约定。</p>
<p>● <strong>NETLIST_TYPE_VHDL87：</strong>使用VHDL87命名约定。</p>
<p>● <strong>NETLIST_TYPE_VHDL93：</strong>使用VHDL93网表命名约定。</p>
<p>● <strong>NETLIST_TYPE_EDIF：</strong>使用EDIF类型命名约定。</p>
<p>● <strong>ROUTING_CONFIDENCE：</strong>（正整数）所有网络的默认走线置信度，基本上是寄生精度的水平。</p>
<p>● <strong>ROUTING_CONFIDENCE_ENTRY：</strong>补充走线置信度值。</p>
<p>● <strong>NAME_SCOPE_LOCAL | FLAT：</strong>指定了SPEF文件中的路径是相对于文件还是相对于设计顶层。</p>
<p>● <strong>SLEW_THRESHOLDS：</strong>（low_input_threshold_percent，high_input_threshold_percent）指定了设计的默认输入转换阈值。</p>
<p>● <strong>PIN_CAP NONE | INPUT_OUTPUT | INPUT_ONLY：</strong>指定了作为总电容一部分的引脚电容类型，默认值为INPUT_OUTPUT。</p>
<p><strong>DIVIDER /</strong> 指定了层次结构分隔符。可以使用的其它字符是" . " , " : "和" / "。</p>
<p><strong>DELIMITER ：</strong>指定了实例与其引脚之间的分隔符。可以使用的其它可能字符是" . " , " / " , " : " 或者 "|"。</p>
<p><strong>BUS_DELIMITER [ ]</strong> 指定了用于标识总线位的前缀和后缀。可以用于前缀和后缀的其他可能字符是" { " , " ( " , " &lt; " , " : "，" ."和" } " , " ) ", " &gt; "。</p>
<p><strong>T_UNIT</strong> 正整数 <strong>NS | PS</strong> 指定了时间单位。</p>
<p><strong>C_UNIT</strong> 正整数 <strong>PF | FF</strong> 指定了电容单位。</p>
<p><strong>R_UNIT</strong> 正整数 <strong>OHM| KOHM</strong> 指定了电阻单位。</p>
<p><strong>L_UNIT</strong> 正整数 <strong>HENRY | MH | UH</strong> 指定了电感单位。</p>
<p>SPEF文件中的注释可以两种形式出现：</p>
<p><img src="https://pic2.zhimg.com/80/v2-cd8ab4c3d088f43622badae784fe8745_720w.jpg"></p>
<p>图C-7显示了一个名称映射的示例。 它的形式为：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d58b398fa18b250b4bf1720d0d9831d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-830b7f416c518cc6939b4c2a2a344e0a_720w.jpg" alt="图C-7"></p>
<p>名称映射将指定名称到唯一整数值（它们的索引）的映射。名称映射有助于通过索引来对名称进行引用从而减小文件的大小，名称可以是网络名称或实例名称。考虑图C-7中的名称映射，以后可以使用它们的索引在SPEF文件中引用这些名称，例如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-aa1fd2b77bc88b929311c8607fde5a47_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d7541e59caead48893974062b457c9b8_720w.png"></p>
<p>因此，名称映射会通过使用其唯一的整数表示来避免重复长名称及其路径。</p>
<p><strong>power definition</strong>部分定义了电源和接地网络：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9e013a5dc7f8b677915b38c98830968d_720w.png"></p>
<p>以下是一些例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0bf96246e2c1639894272b3cacf6374_720w.png"></p>
<p><strong>external_definition</strong>包含了设计的逻辑和物理端口的定义。图C-8显示了逻辑端口的示例，逻辑端口可以以下形式描述：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4d9ee95769630326723c2f28d2e07d0c_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c5b9b4c86664f72d1053abbf0ecd5c55_720w.jpg" alt="图C-8"></p>
<p>其中<strong>port_name</strong>可以是形式为*正整数的端口索引。方向为I表示输入，O表示输出，B表示双向。连接属性（conn_attribute）是可选的，可以是以下属性：</p>
<p>● *<strong>C</strong> number number：端口的坐标。</p>
<p>● *<strong>L</strong> par_value：端口的电容负载。</p>
<p>● *<strong>S</strong> par_value par_value：定义端口上的波形。</p>
<p>● *<strong>D</strong> cell_type：定义端口的驱动单元。</p>
<p>可以使用以下命令定义SPEF文件中的物理端口：</p>
<p><img src="https://pic3.zhimg.com/80/v2-46131891dca3b3ae809ea9cc5c461a1a_720w.jpg"></p>
<p><strong>define definition</strong>部分定义了当前SPEF文件中引用的实例，但其寄生参数在其它SPEF文件中进行了描述：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4a4ace48312c1977d659dd31a8be32fe_720w.png"></p>
<p>当实例是物理分区（而不是逻辑层次结构）时，将使用*<strong>PDEFINE</strong>。以下有些例子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fc8d4ae3a1ab2e5d586321cd2cfd774d_720w.png"></p>
<p>这意味着将存在另一个带有*<strong>DESIGN</strong>值ddrphy的SPEF文件，该文件将包含设计ddrphy的寄生参数，其可能具有物理和逻辑层次结构。跨越层次边界的任何网络都必须描述为分布式网络（D_NET）。</p>
<p><strong>internal definition</strong>部分包含了SPEF文件的核心，即设计中网络的寄生参数。基本上有两种形式：分布式网络D_NET和简化网络R_NET。图C-9中为一个分布式网络定义的示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-283e7c120b5c5437c4781a02a3835ead_720w.jpg" alt="图C-9"></p>
<p>第一行中的*5426是网络的索引号（网络名称请参见名称映射），0.899466是网络上的总电容值。电容值是网络上所有电容的总和，其中包括假定为接地的交叉耦合电容，还包括负载电容。它可能包含也可能不包含引脚电容，具体取决于<strong>DESIGN_FLOW</strong>定义中的<strong>PIN_CAP</strong>设置。</p>
<p><strong>connectivity section</strong>描述了网络的驱动和负载引脚：</p>
<p><img src="https://pic2.zhimg.com/80/v2-682dad147f6f48ad51d7e59d10b1f675_720w.png"></p>
<p><em>I表示内部引脚（ </em> P表示端口），<em>14212：D表示实例</em>14212的D引脚，14212是一个索引号（有关实际名称需参见名称映射）。“ I”表示网络上的负载（输入引脚），“ O”表示网络上的驱动（输出引脚）。<em>C和 </em>D如先前在<strong>connection attributes</strong>中所定义的那样，<em>C定义了引脚的坐标，</em>D定义了引脚的驱动单元。</p>
<p><strong>capacitance section</strong>描述了分布式网络的电容，电容单位在之前已用* C_UNIT指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d2b4601149c0f392d43cba3646d01c3d_720w.jpg"></p>
<p>第一个数字是电容标识符。电容规范有两种形式： 第一种到第四种一种形式，第五种是另一种形式。第一种形式（第一至第四种）指定两个网络之间的交叉耦合电容，而第二种形式（id为5）指定接地电容。因此，在电容id1中，网络<em>5426和</em>5290之间的交叉耦合电容为0.217446；在电容id5中，接地电容为0.529736。请注意，第一个节点名称必须是所描述的D_NET的网络名称。网络索引后面的正整数（<em>5426：10278中的10278）指定内部节点或连接点。因此，电容id4表示在内部节点10278的网络</em>5426和内部节点9922的网络*5116之间存在耦合电容，该耦合电容的值为0.113918。</p>
<p><strong>resistance section</strong>描述了分布式网络的电阻，电阻单位在之前已用* R_UNIT指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-43c952ff95fe9602d9db81ec6a033e5d_720w.png"></p>
<p>第一个字段是电阻标识符。因此，该网络具有三个电阻部分。第一个在内部节点<em>5426：10278与</em>14212上的D引脚之间，电阻值为0.34。使用图C-10中所示的RC网络可以更好地理解电容和电阻部分。</p>
<p><img src="https://pic2.zhimg.com/80/v2-54692812f54dc062e6e3d425c15c9061_720w.jpg" alt="图C-10"></p>
<p>图C-11显示了分布式网络的另一个示例。该网络具有一个驱动和两个负载，网络上的总电容为2.69358。图C-12显示了与分布式网络相对应的RC网络。</p>
<p><img src="https://pic4.zhimg.com/80/v2-938002ad4792085b1bb900c3a4fab8ff_720w.jpg" alt="图C-11"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5e55c1dad59c315a8f334a8073ac1e67_720w.jpg" alt="图C-12"></p>
<p>通常，内部定义（internal definition）可以包含以下规范：</p>
<p>● <strong>D_NET</strong>：逻辑网络的分布式RC网络形式。</p>
<p>● <strong>R_NET</strong>：逻辑网络的简化RC网络形式。</p>
<p>● <strong>D_PNET</strong>：物理网络的分布式形式。</p>
<p>● <strong>R_PNET</strong>：物理网络的简化形式。</p>
<p>语法如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4fe6519e2a6a66d0ae1226635a95a8c8_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5cb28904839a93a2349824681e125ce4_720w.jpg"></p>
<p><strong>inductance section</strong>用于指定电感，其格式类似于电阻部分。 * V用于指定网络寄生参数的准确性。这些可以单独使用网络指定，也可以使用带有<strong>ROUTING_CONFIDENCE</strong>值的*** DESIGN_FLOW**语句进行全局指定，例如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-811c988ccd8701a6c6f2b9354a72beff_720w.png"></p>
<p>它指定了寄生参数是在最终单元布局和最终布线之后提取得到的，并且使用了3d提取。走线置信度的其它可能值为：</p>
<p>● 10：统计线负载模型</p>
<p>● 20：物理线负载模型</p>
<p>● 30：具有位置但没有单元布局的物理分区</p>
<p>● 40：使用基于斯坦纳树（steiner tree）的走线估计的单元位置</p>
<p>● 50：使用全局走线估计的单元位置</p>
<p>● 60：使用斯坦纳走线进行的最终单元布局</p>
<p>● 70：使用全局走线进行的最终单元布局</p>
<p>● 80：最终单元布局，最终走线，2d提取</p>
<p>● 90：最终单元布局，最终走线，2.5d提取</p>
<p>● 100：最终单元布局，最终走线，3d提取</p>
<p><strong>reduced net</strong>是从分布式网络形式简化而来的网络。网络上每个驱动都有一个驱动精简部分（driver reduction section）。驱动精简部分的形式为：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aeb44e379a12069929a4d96c43c79b10_720w.jpg"></p>
<p><em>C2_R1_C1表示在网络的驱动引脚上使用π模型的寄生参数。 </em> RC结构中的rc_value是指Elmore延迟（R * C）。 图C-13显示了简化后的网络的SPEF示例，图C-14以图形方式显示了RC网络。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2890bf55cf5daca5bf05c97e259f22b4_720w.jpg" alt="图C-13"></p>
<p><img src="https://pic1.zhimg.com/80/v2-3947f51106a7373e73b6fc25466226ec_720w.jpg" alt="图C-14"></p>
<p>可使用<em><strong>D_NET</strong>或</em><strong>R_NET</strong>结构描述集总电容模型（lumped capacitance model），该结构仅具有总电容而没有其它信息。以下是集总电容声明的示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ee64afd594898f8c63a77fbab14f1923_720w.jpg"></p>
<p>SPEF文件中的值可以采用三元数组的形式来表示工艺变化，例如：</p>
<p>● 0.243 ： 0.269 ： 0.300</p>
<p>最佳情况下值为0.243，典型情况下值为0.269，最差情况下值为0.300。</p>
<h2 id="c.3-完整语法">C.3 完整语法</h2>
<p>本节描述了SPEF文件的完整语法。</p>
<p>可以在字符前面加上反斜杠（）来对其进行转义。注释有两种形式：//开始注释直到行尾，而/ * . . . * /是多行注释。</p>
<p>在以下语法中，粗体字符如（，[是语法的一部分。所有结构均按字母顺序排列，起始符号为SPEF_file：</p>
<p><img src="https://pic3.zhimg.com/80/v2-07d727acd214247bedf57d671232a11e_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c8fb4e366e5154843f123975f1b02ffd_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0456819806173f4d5cfe1f07e3c1b856_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-95fcf79c19ee60fdf418eb1489b36fe3_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8e456c68bf7b3d4d80c8ec56a4a1d5e1_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-75d9df40768e4a338ec16bb3fb7e3770_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-4f8ba11df9dce8065baac3a18032fa70_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-947377e805d31cfbc32aadbab331ffbe_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a6c00e091dc1ae58f09bb13dd7128649_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-389fd37ea782a79b658f16808aa55c05_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e0da9791e613e059a2c949f966382c2f_720w.png"></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>Static Timing Analysis for Nanometer Designs:A Practical Approach(v2)</title>
    <url>/2022/07/13/Static-Timing-Analysis-for-Nanometer-Designs-A-Practical-Approach-v2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
<h1 id="绪论">绪论</h1>
<blockquote>
<p>众所周知，静态时序分析是IC工程师必备知识点，也是秋招中笔试面试的高频考点。<br>
网上不乏优秀视频课，如V3学院尤老师、小梅哥、IC创新学院邸志雄老师的课。<br>
《Static Timing Analysis for Nanometer Designs:A Practical Approach》，可堪称静态时序分析的“圣经”吧！<br>
由于网上找不到此书的翻译，因此笔者决定开坑进行对“圣经”的翻译~！希望可以在加深对静态时序分析的学习同时，完成这一本书的翻译方便大家以后更好地从中学习吧。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-8e02c51213dbc09e2bd57bd6df30a8c5_720w.jpg"></p>
<hr>
<p>本章节概述了纳米级（nanometer）设计下的静态时序仿真过程<br>
本章节解决了如下问题：</p>
<ul>
<li>什么是静态时序分析（static timing analysis）？</li>
<li>噪声（noise）与串扰（crosstalk）会带来什么影响 ？</li>
<li>如何使用静态时序分析？</li>
<li>在整个设计流程中的哪个阶段会应用静态时序分析？</li>
</ul>
<h2 id="纳米设计">纳米设计</h2>
<p>​ 在半导体器件中，金属互连走线通常用于在电路的各个部分之间建立连接以实现设计。众所周知，随着工艺技术的缩小，这些互连走线会影响设计的性能。对于深亚微米或纳米工艺技术，互连中的耦合会引起噪声和串扰——这两种情况都会限制设计的运行速度。虽然噪声和耦合效应在老一代技术中可以忽略不计，但它们在纳米技术中发挥着重要作用。因此，物理设计应考虑串扰和噪声的影响，然后设计验证应包括串扰和噪声的影响。</p>
<h2 id="什么是静态时序分析">什么是静态时序分析？</h2>
<p>​ 静态时序分析（也称为 STA）是可用于验证数字设计时序的众多技术之一。用于验证时序的另一种方法是时序仿真，它可以验证设计的功能和时序。术语时序分析用于指代这两种方法之一 - 静态时序分析或时序仿真。因此，时序分析只是指对时序问题的设计进行分析。</p>
<p>​ STA 是静态的，因为设计分析是静态执行的，不依赖于施加到输入引脚的数据值。这与基于仿真的时序分析形成对比，在基于仿真的时序分析中，对输入信号应用刺激，观察并验证结果行为，然后随着新输入刺激的应用而推进时间，并观察和验证新行为，依此类推。</p>
<p>​ 给定一个设计以及一组输入时钟定义和设计外部环境的定义，静态时序分析的目的是验证设计是否可以以额定速度运行。也就是说，设计可以在指定的时钟频率下安全运行，而不会出现任何时序违规。图 1-1 展示了静态时序分析的基本功能 。<strong>DUA</strong> 是被分析的设计。一些时序检查的例子是建立和保持检查。建立检查确保数据可以在给定的时钟周期内到达触发器。保持检查确保数据至少保持最短时间，从而不会出现意外的数据通过触发器：也就是说，它确保触发器正确捕获预期数据。这些检查确保正确的数据已准备就绪并可用于捕获并锁定新状态。</p>
<p>​</p>
<p><img src="https://img-blog.csdnimg.cn/2021080420153454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 静态时序分析更重要的方面是对整个设计进行一次分析，并对设计的所有可能路径和场景执行所需的时序检查。因此，STA 是一种用于验证设计时序的完整而详尽的方法。</p>
<p>​ 分析中的设计通常使用指定的硬件描述语言（例如 VHDL 或 Verilog HDL）。外部环境（包括时钟定义）通常使用 SDC或等效格式指定。 SDC 是一种时序约束规范语言。时序报告采用 ASCII 格式，通常有多列，每一列显示路径延迟的一个属性。</p>
<h2 id="为什么使用静态时序分析">为什么使用静态时序分析？</h2>
<p>​ 静态时序分析是对设计的所有时序检查的完整而详尽的验证。其他时序分析方法（例如仿真）只能验证设计中受激励影响的部分。通过时序仿真进行验证与所使用的测试向量一样详尽。模拟和验证具有 10-1亿个门的设计的所有时序条件非常缓慢，并且无法完全验证时序。因此，很难通过模拟进行详尽的验证。</p>
<p>​ 另一方面，静态时序分析提供了一种更快、更简单的方法来检查和分析设计中的所有时序路径是否存在任何时序违规。考虑到当今 ASIC 的复杂性，其中可能包含 10 到 1 亿个门，静态时序分析已成为详尽验证设计时序的必要条件。</p>
<h3 id="串扰和噪声crosstalk-and-noise">串扰和噪声（Crosstalk and Noise）</h3>
<p>​ 设计功能及其性能可能会受到噪声的限制。噪声是由于与其他信号的串扰或主输入或电源上的噪声而产生的。噪声影响可以限制设计运作频率，并且也可能导致功能故障。因此，一个设计实现必须经过验证证明它的稳健性，这意味着它可以在不影响设计的额定性能情况下承受噪声。</p>
<p>​ 基于逻辑仿真的验证无法处理串扰、噪声和片上变化的影响。</p>
<p>​ 本书中描述的分析方法不仅涵盖了传统的时序分析技术，还涵盖了噪声分析，以验证包括噪声影响在内的设计。</p>
<h2 id="设计流程">设计流程</h2>
<p>​ 本节主要描述本书其余部分使用的上下文中的 CMOS数字设计流程。还简要描述了它对 FPGA 和异步设计的适用性。</p>
<h3 id="cmos数字设计">CMOS数字设计</h3>
<p>​ 在 CMOS 数字设计流程中，静态时序分析可以在实现的许多不同阶段执行。图 1-2 显示了一个典型的流程。</p>
<p><img src="https://img-blog.csdnimg.cn/20210804215939871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ STA 很少在 RTL 级别完成，因为此时验证设计的功能性比验证时序更为重要。也不是所有的时序信息都可用，因为块的描述在行为级。一旦 RTL 级的设计被综合到门级，STA 用于验证设计的时序。STA 也可以在执行逻辑优化之前运行 - 目标是识别最差或关键的时序路径。 STA可以在逻辑优化后重新运行来查看是否仍有需要优化的失败路径，或确定关键路径。</p>
<p>​ 在物理设计开始时，时钟树被认为是理想的，即它们具有零延迟。一旦物理设计开始并且在时钟树构建之后，就可以执行 STA 来再次检查时序。实际上，在物理设计期间，可以在每一步执行 STA 以识别最差路径。</p>
<p>​ 在物理实现中，逻辑单元通过互连金属走线连接。金属走线的寄生 RC（电阻和电容）会影响通过这些走线的信号路径延迟。在典型的纳米设计中，互连的寄生效应可以解释设计中的大部分延迟和功耗。因此，任何设计分析都应评估互连对性能特征（速度、功率等）的影响。如前所述，信号走线之间的耦合会产生噪声，设计验证必须包括噪声对性能的影响。</p>
<p>​ 在逻辑设计阶段，由于没有与布局相关的物理信息，因此可以假设为理想互连；可能更有兴趣查看导致最坏路径的逻辑。此阶段使用的另一种技术是使用线载模型估算互连的长度。线载模型根据单元的扇出提供估计的 RC。</p>
<p>​ 在最终确定走线的布线（ <strong>routing</strong>）之前，实施工具使用布线距离的估计来获得布线的 RC 寄生效应。由于布线还没有最终确定，所以这个阶段称为全局布线阶段（<strong>global route</strong>），以区别于最终布线阶段（<strong>final route</strong>）。在物理设计的全局布线阶段，简化布线用于估计布线长度，布线估计用于确定计算布线延迟所需的电阻和电容。在这个阶段，不能包括耦合的影响。详细布线完成后，使用提取工具得到的实际 RC 值，可以分析耦合的影响。但是，物理设计工具可能仍会使用近似值来帮助改善计算 RC 值的运行时间。</p>
<p>​ 提取工具用于从布线设计中提取详细的寄生参数（RC 值）。这样的提取工具可以选择在迭代优化期间以较小的运行时间和较不精确的RC值获得寄生参数，也可以选择在最终验证过程中以较大的运行时间提取非常精确的RC值。</p>
<p>​ 总而言之，静态时序分析可以在门级网表上执行，具体取决于：</p>
<ol type="1">
<li>互连（interconnect）是怎么建模 的-——理想互连、线载模型、具有近似 RC 的全局布线或具有准确 RC 的真实布线。</li>
<li>时钟是怎么建模 的-——时钟是理想的（零延迟）还是传播的（实际延迟）。</li>
<li>是否包括信号之间的耦合——是否分析了任何串扰噪声。</li>
</ol>
<p>​ 图 1-2 似乎暗示 STA 是在实现步骤之外完成的，也就是说，STA 是在每个综合、逻辑优化和物理设计步骤之后完成的。实际上，这些步骤中的每一个都在其功能范围内执行集成（和增量）STA。例如，逻辑优化步骤中的时序分析引擎，它是用于识别优化器需要处理的关键路径。同样，布局工具中的集成时序分析引擎用于在布局逐步进行时保持设计的时序。</p>
<h3 id="fpga设计">FPGA设计</h3>
<p>​ STA 的基本流程在 FPGA 中仍然有效。尽管 FPGA 中的布线受限于通道，但提取寄生效应和执行 STA 的机制与 CMOS 数字设计流程相同。例如，STA执行时，可以假设互联是理想的，或者使用线载模型，假设时钟树是理想的或真实的，假设全局布线，或者使用真实布线进行寄生。</p>
<h3 id="异步设计">异步设计</h3>
<p>​ STA 的原理也适用于异步设计。人们可能对从设计中的一个信号到另一个信号的时序更感兴趣，而不是对可能不存在的情况进行建立和保持检查。因此，大多数检查可能是点对点时序检查，或偏斜 STA 检查。用于分析耦合引起的毛刺的噪声分析适用于任何设计——异步或同步。此外，噪声分析对时序的影响，包括耦合的影响，也适用于异步设计。</p>
<h2 id="不同设计阶段的sta">不同设计阶段的STA</h2>
<p>​ 在逻辑级（门级，还没有物理设计），STA可以使用：</p>
<ol type="1">
<li>理想互连或基于线载模型的互连。</li>
<li>具有延迟和抖动估计值的理想时钟。</li>
</ol>
<p>​ 在物理设计阶段，除了上述模式外，STA 还可以使用：</p>
<ol type="1">
<li>互连 -——范围可以从全局布线估计、具有近似提取的真实布线或具有准确signoff提取的真实路由。</li>
<li>时钟树 -——真正的时钟树。</li>
<li>包括和不包括串扰的影响</li>
</ol>
<h2 id="静态时序分析的局限性">静态时序分析的局限性</h2>
<p>​ 虽然时序和噪声分析在分析所有可能情况下的时序问题方面做得非常出色，但最先进的技术仍然不允许 STA 完全取代仿真。 这是因为在时序验证的一些方面不能被STA 完全捕获和验证。</p>
<p>​ STA的一些局限性：</p>
<ol type="1">
<li>复位顺序：检查在异步或同步复位后，所有触发器是否复位到其所需的逻辑值。这是无法使用静态计时分析进行检查的。芯片可能无法复位。这是因为某些声明（如信号的初始值）不会被合成，只能在模拟过程中进行验证。</li>
<li>X处理：STA技术只处理逻辑0和逻辑1（或者高和低）、上升和下降的逻辑域。设计中的未知值X会导致不确定值在设计中传播，这无法通过STA进行检查。尽管STA中的噪声分析可以通过设计分析和传播 glitches，但 glitches分析和传播的范围与作为基于模拟的纳米设计时序验证一部分的X处理非常不同。</li>
<li>PLL设置：PLL配置可能未正确加载或设置。</li>
<li>异步时钟域交叉：STA不检查是否使用了正确的时钟同步器。需要其他工具来确保在存在异步时钟域交叉的地方存在正确的时钟同步器。</li>
<li>IO接口时序：可能无法仅根据STA约束指定IO接口要求。例如，设计者可以使用SDRAM仿真模型为双数据速率（Double Data Rate，DDR）接口选择详细的电路级仿真。模拟的目的是确保可以以足够的余量读取和写入存储器，而且，如果有延迟锁相环（Delay Locked Loop，DLL），可以控制DLL以便在必要时对齐信号。</li>
<li>模拟和数字块之间的接口：由于STA不处理模拟块，验证方法需要确保这两种块之间的连接正确。</li>
<li>错误路径（False paths）：静态时序分析验证通过逻辑路径的时序是否满足所有约束，如果通过逻辑路径的时序不符合要求的规范，则标记违规。在许多情况下，STA 可能会将逻辑路径标记为失败路径，即使逻辑可能永远无法通过该路径传播。当系统应用程序从不使用这样的路径或者在故障路径的敏感化期间使用相互矛盾的条件时，就会发生这种情况。这种时序路径被称为虚假路径，因为它们永远无法实现。在设计中指定适当的时序约束（包括错误路径和多周期路径约束）时，STA 结果的质量会更好。在大多数情况下，设计人员可以利用设计的固有知识并指定约束条件，以便在 STA 期间消除错误路径。</li>
<li>FIFO 指针不同步：当两个期望同步的有限状态机实际上不同步时，STA 无法检测到问题。在功能仿真期间，两个有限状态机可能始终同步并同步变化。然而，在考虑延迟之后，有限状态机中的一个可能与另一个不同步，很可能是因为一个有限状态机比另一个更早退出复位。这种情况是STA无法检测到的。</li>
<li>时钟同步逻辑：STA无法检测时钟生成逻辑与时钟定义不匹配的问题。 STA 假设时钟发生器将提供时钟定义中指定的波形。可能对时钟发生器逻辑执行了错误的优化，例如导致在其中一条可能没有受到适当的约束路径上插入大延迟。或者，添加的逻辑可能会改变时钟的占空比。 STA 无法检测到这些潜在条件中的任何一个。</li>
<li>跨时钟周期的功能行为：静态时序分析无法建模或模拟跨时钟周期变化的功能行为。</li>
</ol>
<p>​ 尽管存在这些问题，STA 被广泛用于验证设计的时序，并且带有时序或带有单位延迟的仿真用于检查极端情况的备份，更简单地用于验证设计的正常功能模式。</p>
<h2 id="功率考虑">功率考虑</h2>
<p>​ 功耗是设计实施中的一个重要考虑因素。大多数设计需要在电路板和系统的功率预算内运行。由于符合标准和/或由于芯片必须在其中运行的电路板或系统上的热预算，也可能引起功率考虑。总功率和待机功率通常有单独的限制。待机功率限制通常适用于手持设备或电池供电设备。</p>
<p>​ 在大多数实际设计中，功率和时序通常是齐头并进的。设计人员希望使用更快（或更高速度）的单元来满足速度考虑，但可能会遇到可用功耗的限制。在为设计选择工艺技术和单元库时，功耗是一个重要的考虑因素。</p>
<h2 id="可靠性考虑">可靠性考虑</h2>
<p>​ 设计实现必须满足可靠性要求。如第 1.4.1 节所述，金属互连走线具有限制设计性能的寄生 RC。除了寄生效应之外，还需要设计金属走线宽度，同时考虑可靠性因素。例如，高速时钟信号需要足够宽才能满足可靠性考虑，例如电迁移。</p>
<h2 id="书的大纲">书的大纲</h2>
<p>​ 虽然静态时序分析从表面上看可能是一个非常简单的概念，但这种分析背后有很多背景知识。基本概念范围从单元延迟的准确表示到以最小的悲观计算最坏的路径延迟。计算单元延迟、组合块计时、时钟关系、多个时钟域和门控时钟的概念构成了静态时序分析的重要基础。为设计编写正确的 SDC 确实是一个挑战。</p>
<p>​ 这本书是按照自下而上的顺序编写的——首先介绍简单的概念，然后在后面的章节中介绍更高级的主题。本书首先介绍了准确的单元延迟（第 3 章）。以有效的方式估计或计算精确的互连延迟及其表示是第 4 章的主题。计算由单元和互连组成的路径的延迟是第 5 章的主题。信号完整性，即信号切换对相邻网络的影响以及它如何影响沿路径的延迟，是第 6 章的主题。准确地表示具有时钟定义和路径异常的 DUA 环境是第 7 章的主题。STA 中执行的时序检查的详细信息在第 6 章中描述8. 跨各种接口的 IO 时序建模是第 9 章的主题。最后，第 10 章详细介绍高级时序检查，例如片上变化、时钟门控检查、电源管理和统计时序分析。附录提供了 <strong>SDC（用于表示时序约束）、SDF（用于表示单元和网络的延迟）和 SPEF（用于表示寄生）</strong>的详细描述。</p>
<p>​ 第 7 章到第 10 章提供了 STA 验证的核心。前面的章节为更好地理解STA所需的nuts<br>
and bolts 知识提供了坚实的基础和详细描述。</p>
<h1 id="sta概念">STA概念</h1>
<blockquote>
<p>介绍 CMOS 逻辑的基础知识以及与静态时序分析相关的时序术语。</p>
</blockquote>
<h2 id="cmos-逻辑设计">CMOS 逻辑设计</h2>
<h3 id="mos基本结构">MOS基本结构</h3>
<p>​ 图2.1描述了MOS晶体管（NMOS和PMOS）的物理实现。源区和漏区之间的距离是MOS晶体管的沟道长度。用于构建 MOS 晶体管的最小沟道长度通常是 CMOS 技术工艺的最小特征尺寸。例如，0.25mm 技术允许制造沟道长度为 0.25mm 或更大的 MOS 晶体管。通过缩小通道几何形状，晶体管尺寸变得更小，随后在给定区域中可以封装更多晶体管。正如我们将在本章后面看到的，这也允许设计以更快的速度运行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809140101587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="cmos-逻辑门">CMOS 逻辑门</h3>
<p>​ CMOS 逻辑门是使用 NMOS 和 PMOS 晶体管构建的。图 2-2 显示了 CMOS 反相器的示例。根据输入的状态，CMOS 反相器有两种稳定状态。当输入 A 为低电平（Vss 或逻辑 0）时，NMOS 晶体管关闭，PMOS 晶体管开启，导致输出 Z 被拉至 Vdd，即逻辑 1。当输入 A 为高电平（Vdd 或逻辑 1）时，NMOS 晶体管导通，PMOS 晶体管关闭，导致输出 Z 被拉至 Vss，即逻辑 0。在上述两种状态中的任何一种状态下，CMOS 反相器都是稳定的，并且不会从输入 A 或电源 Vdd 汲取任何电流。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809140302345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ CMOS 反相器的特性可以扩展到任何 CMOS 逻辑门。在 CMOS 逻辑门中，输出节点通过上拉结构（由 PMOS 晶体管组成）连接到 Vdd，通过下拉结构（由 NMOS 晶体管组成）连接到 Vss。例如，图 2-3 显示了一个两输入 CMOS 与非门。在本例中，上拉结构由两个并联的 PMOS 晶体管组成，下拉结构由两个串联的 NMOS 晶体管组成。</p>
<p>​ 对于任何 CMOS 逻辑门，上拉和下拉结构都是互补的。对于逻辑 0 或逻辑 1 的输入，这意味着如果上拉级打开，下拉级将关闭，同样如果上拉级关闭，下拉级将被关闭在。下拉和上拉结构由 CMOS 门实现的逻辑功能控制。例如，在CMOS与非门中，控制下拉结构的功能是“A和B”，即在A和B都为逻辑1时开启下拉。同理，控制上拉结构的函数是“not A or not B”，即在A或B逻辑-0时开启上拉。这些特性确保基于控制上拉结构的功能将输出节点逻辑拉至 Vdd。由于下拉结构是由一个互补功能控制。</p>
<p>​ 对于逻辑 0 或逻辑 1 的输入，CMOS 逻辑门在稳定状态下不会从输入或电源汲取任何电流，因为上拉和下拉结构不能同时打开 1。 CMOS 逻辑的另一个重要方面是输入仅对前一级构成容性负载。</p>
<p>​ CMOS逻辑门是一个反相门，意思是单个开关输入（上升或下降）只能引起输出反方向开关，即输出不能与开关输入同方向开关。然而，CMOS 逻辑门可以级联以组合更复杂的逻辑功能 - 反相和非反相。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809141857950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="标准单元">标准单元</h3>
<p>​ 芯片中的大多数复杂功能通常使用基本构建块设计，这些构建块实现简单的逻辑功能，例如和、或、与非、与或反转、或与反转和触发器。这些基本构建块是预先设计的，被称为标准单元（standard cells）。标准单元的功能和时序是预先表征的，可供设计人员使用。然后，设计人员可以使用标准单元作为构建块来实现所需的功能。</p>
<p>​ 前一小节中描述的 CMOS 逻辑门的关键特性适用于所有 CMOS 数字设计。所有数字 CMOS 单元都设计为在输入处于稳定逻辑状态时没有从电源汲取电流（泄漏除外）。因此，大部分功耗与设计中的活动有关，并且是由设计中 CMOS 单元输入的充电和放电引起的。</p>
<p>​ 什么是逻辑 1 或逻辑 0？在 CMOS 单元中，两个值 VIHmin 和 VILmax 定义了限值。也就是说，任何高于 VIHmin 的电压值都被视为逻辑 1，而任何低于 VILmax 的电压值都被视为逻辑 0。参见图 2-4。具有 1.2V Vdd 电源的 CMOS 0.13mm 反相器单元的典型值为 VILmax 的 0.465V 和 VIHmin 的 0.625V。 VIHmin 和 VILmax 值源自电池的直流传输特性。直流传输特性在第 6.2.3 节中有更详细的描述。</p>
<p><img src="https://img-blog.csdnimg.cn/2021080914221793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 有关 CMOS 技术的更多详细信息，请参阅参考书目中列出的相关文本之一。</p>
<h2 id="cmos-单元的建模">CMOS 单元的建模</h2>
<p>​ 如果一个单元输出引脚驱动多个扇出单元，则单元输出引脚上的总电容是它所驱动的单元的所有输入电容之和加上构成网络的所有线段的电容之和加上驱动单元的输出电容。请注意，在 CMOS 单元中，单元的输入仅呈现电容性负载。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809142409726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 2-5 显示了一个单元格 G1 驱动其他三个单元格 G2、G3 和 G4 的示例。 Cs1、Cs2、Cs3 和 Cs4 是构成网络的线段的电容值。因此：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Total <span class="built_in">cap</span> (Output G1) = Cout(G1) + Cin(G2) + Cin(G3) +</span><br><span class="line">                        Cin(G4) + Cs1 + Cs2 + Cs3 + Cs4</span><br><span class="line"><span class="comment">#Cout 是单元的输出引脚电容。</span></span><br><span class="line"><span class="comment">#Cin 是单元的输入引脚电容。</span></span><br></pre></td></tr></table></figure>
<p>​ 这是当单元 G1 切换时需要充电或放电的电容，因此该总电容值会影响单元 G1 的时序。</p>
<p>​ 从时序的角度来看，我们需要对 CMOS 单元进行建模，以帮助我们分析通过单元的时序。对于每个输入引脚指定输入引脚电容。虽然大多数 CMOS 逻辑单元不包括输出引脚的引脚电容，但也可能存在输出引脚电容。</p>
<p>​ 当输出为逻辑 1 时，输出级的上拉结构开启，并提供从输出到 Vdd 的路径。类似地，当输出为逻辑 0 时，输出级的下拉结构提供了从输出到 Vss 的路径。当 CMOS 单元切换状态时，切换速度取决于输出网络上的电容充电或放电的速度。输出网络上的电容（图 2-5）分别通过上拉和下拉结构充电和放电。请注意，上拉和下拉结构中的通道对输出充电和放电路径构成电阻。充电和放电路径电阻是决定 CMOS 单元速度的主要因素。上拉电阻的倒数称为电池的输出高驱动。输出上拉结构越大，上拉电阻越小，单元的输出高驱动越大。更大的输出结构也意味着单元的面积更大。输出上拉结构越小，单元面积越小，其输出高驱动也越小。上拉结构的相同概念可以应用于决定下拉路径电阻和输出低电平驱动的下拉结构。通常，单元被设计为具有相似的驱动强度（大或小）用于上拉和下拉结构。</p>
<p>​ 输出驱动决定了可以驱动的最大容性负载。最大容性负载决定了扇出的最大数量，即它可以驱动多少个其他单元。较高的输出驱动对应于较低的输出上拉和下拉电阻，这允许电池在输出引脚上对较高的负载进行充电和放电。</p>
<p>​ 图 2-6 显示了 CMOS 单元的等效抽象模型。该模型的目标是抽象单元的时序行为，因此仅对输入和输出阶段进行建模。该模型不捕获单元固有延迟或电气行为。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809143255936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ CpinA 是输入 A 上单元的输入引脚电容。 Rdh 和 Rdl 是单元的输出驱动电阻，并根据单元驱动的负载确定输出引脚 Z 的上升和下降时间。该驱动器还决定了单元的最大扇出限制。</p>
<p>​ 图 2-7 显示了与图 2-5 相同的网络，但具有等效的单元模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809143413771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Cwire = Cs1 + Cs2 + Cs3 + Cs4</span><br><span class="line">Output charging delay (<span class="name">for</span> high or low) =</span><br><span class="line">                    Rout * (<span class="name">Cwire</span> + Cin2 +Cin3 + Cin4)</span><br></pre></td></tr></table></figure>
<p>​ 在上面的表达式中，Rout 是 Rdh 或 Rdl 之一，其中 Rdh 是上拉的输出驱动电阻，Rdl 是下拉的输出驱动电阻。</p>
<h2 id="开关波形">开关波形</h2>
<p>​ 当通过激活 SW0 开关将电压施加到 RC 网络时，如图 2-8(a) 所示，输出变为逻辑 1。假设 SW0 激活时输出为 0V，输出端的电压转换由以下等式描述：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?V%20%3D%20Vdd%20*%20%5B1%20-%20e%5E%7B%20-t/%28Rdh%20*%20Cload%29%7D%20%5D"></p>
<p>​ 这种上升的电压波形如图 2-8(b) 所示。乘积 (Rdh * Cload) 称为 RC 时间常数 - 通常这也与输出的转换时间有关。</p>
<p>​ 当输出从逻辑 1 变为逻辑 0 时，由于输入变化导致 SW0 断开连接并激活 SW1，输出转换如图 2-8(c) 所示。输出电容通过打开的 SW1 开关放电。这种情况下的电压转换由以下等式描述：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?V%20%3D%20Vdd%20*%20e%5E%7B-t/%28Rdl%20*%20Cload%29%7D"></p>
<p><img src="https://img-blog.csdnimg.cn/2021081012103514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在 CMOS 单元中，输出端充电和放电波形与图 2-8 中的 RC 充电和放电波形不同，因为 PMOS 上拉和 NMOS 下拉晶体管在短时间内同时导通。图 2-9 显示了 CMOS 反相器单元内输出从逻辑 1 切换到逻辑 0 的各个阶段的电流路径。图 2-9(a) 显示了上拉和下拉结构都打开时的电流。 之后，上拉结构关闭，电流如图 2-9(b) 所示。输出达到最终状态后，由于电容 Cload 已完全放电，因此没有电流流动。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810121919332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 2-10(a) 显示了 CMOS 单元输出端的代表性波形。请注意过渡波形如何逐渐向 Vss 轨道和 Vdd 轨道弯曲，波形的线性部分位于中间。</p>
<p>​ 在本文中，我们将使用如图 2-10(b) 所示的简单绘图来描绘一些波形。它显示了具有一些转换时间的波形，即从一种逻辑状态转换到另一种逻辑状态所需的时间。图2-10(c)示出了使用0跃迁时间的相同波形，即理想波形。我们将在本文中交替使用这两种形式来解释这些概念，但实际上，每个波形都有其真实的边缘特征，如图 2-10(a) 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810122118721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="传播延迟propagation-delay">传播延迟（Propagation Delay）</h2>
<p>​ 考虑一个 CMOS 反相器单元及其输入和输出波形。单元的<strong>传播延迟</strong>是根据开关波形上的一些测量点定义的。这些点是使用以下四个变量定义的：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入下降沿的阈值点：</span></span><br><span class="line">input_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"><span class="comment"># 输入上升沿的阈值点：</span></span><br><span class="line">input_threshold_pct_rise : <span class="number">50.0</span>;</span><br><span class="line"><span class="comment"># 输出下降沿的阈值点：</span></span><br><span class="line">output_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"><span class="comment"># 输出上升沿的阈值点：</span></span><br><span class="line">output_threshold_pct_rise : <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这些变量是用于描述单元库的命令集的一部分（该命令集在 Liberty中进行了描述）。这些阈值规格以 Vdd 或电源的百分比表示。大多数标准单元库的延迟测量通常使用 50% 阈值。</p>
<p>​ 上升沿是从逻辑 0 到逻辑 1 的过渡。下降沿是从逻辑 1 到逻辑 0 的转变。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810123207592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以图 2-11 逆变器单元及其引脚处的波形示例。传播延迟表示为：</p>
<ol type="1">
<li>输出下降延迟 (Tf)</li>
<li>输出上升延迟 (Tr)</li>
</ol>
<p>​ 一般来说，这两个值是不同的。图 2-11 显示了如何测量这两个传播延迟。</p>
<p>​ 如果我们查看理想波形，传播延迟就是两个边沿之间的延迟。如图 2-12 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081012340583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="波形转换slew-of-a-waveform">波形转换（Slew of a Waveform）</h2>
<p>​ 转换速率（ slew rate ）被定义为变化速率。在静态时序分析中，根据过渡（transition）是慢还是快来测量上升或下降的波形。转换（slew）通常用<strong>转换时间（transition time）</strong>来衡量，即信号在两个特定电平之间转换所花费的时间。请注意，转换时间实际上与转换速率成反比——转换时间越大，转换速度越慢，反之亦然。图2-10显示了CMOS单元输出的典型波形。在两端的波形是渐近的，很难确定准确的开始和结束的过渡点。因此，转换时间是根据特定的阈值水平来定义的。例如， 转换阈值设置可以是:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># Falling edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">70.0</span>;</span><br><span class="line"></span><br><span class="line"># Rising edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">70.0</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这些值被指定为Vdd的百分比。<strong>阈值设置（threshold settings）</strong>指定下降的反转为下降沿达到Vdd的70%和30%的时间差。同样地，<strong>上升设置</strong>指定上升幅度是上升边达到Vdd的30%和70%的时间差。如图2-13所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810124746610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个例子如图2-14显示，下降边的转换（slew）测量为20-80(80%到20%)，上升边测量为10-90(10%到90%)。这里是本例的阈值设置。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810125014894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># Falling edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">20.0</span>;</span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line"># Rising edge thresholds:</span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">10.0</span>;</span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">90.0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="信号之间的偏差skew-between-signals">信号之间的偏差（Skew between Signals）</h2>
<p>​ <strong>偏差（skew）</strong>是两个或多个信号（可能是数据、时钟或两者）之间的时间差。例如，如果一个时钟树有500个端点，偏移量为50ps，则表示最长路径和最短时钟路径之间的延迟差为50ps。图2-15显示了时钟树的示例。时钟树的起点通常是定义时钟的节点。时钟树的端点通常是同步元件（如触发器 flip-flops）的时钟引脚。<strong>时钟延迟（ Clock latency）</strong>是从时钟源到终点所花费的总时间。<strong>时钟偏移（Clock skew）</strong>是时钟树端点处到达时间的差异。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810130309549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个理想的时钟树是一个假设时钟源具有无限驱动的树，也就是说，时钟可以无延迟地驱动无限源。此外，假设时钟树中存在的任何单元具有零延迟。</p>
<p>​ 在逻辑设计的早期阶段，STA通常使用理想的时钟树执行，因此分析的重点是数据路径。在理想的时钟树中，时钟偏移默认为0ps。可以使用<strong>set_clock_Latency</strong>命令显式指定时钟树的延迟。以下示例对时钟树的延迟进行建模：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_clock_latency <span class="number">2.2</span> [get_clocks BZCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Both rise and fall latency is 2.2ns.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use options -rise and -fall if different.</span></span><br></pre></td></tr></table></figure>
<p>​ 时钟树的时钟偏移也可以通过使用set_Clock_INDUCTION命令显式指定其值来表示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_clock_uncertainty <span class="number">0.250</span> -setup <span class="selector-attr">[get_clocks BZCLK]</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty <span class="number">0.100</span> -hold <span class="selector-attr">[get_clocks BZCLK]</span></span><br></pre></td></tr></table></figure>
<p>​ <strong>set_clock_uncertainty</strong>指定一个窗口，在该窗口内可以出现时钟边沿。时钟边沿时序的不确定性，是为了考虑几个因素，例如时钟周期抖动（ clock period jitter ）和用于时序验证的附加裕度（additional margins）。每一个真实的时钟源都有一个有限的抖动——一个时钟边沿可以出现的窗口。clock period jitter由所使用的时钟发生器的类型决定。实际上，没有理想的时钟，也就是说，所有时钟都有有限的抖动，在指定时钟不确定性时，应包括时钟周期抖动。</p>
<p>​ 在实现时钟树之前，时钟不确定性还必须包括实现的预期时钟偏差。</p>
<p>​ 可以为建立检查（ setup checks ）和保持检查（hold checks）指定不同的时钟不确定性。保持检查不需要将时钟抖动包含在不确定性中，因此通常为hold指定较小的时钟不确定性值。</p>
<p>​ 图 2-16 显示了设置不确定性为 250ps 的时钟示例。图 2-16(b) 显示在传播到下一个触发器阶段的逻辑的时间中，如何去除不确定性。这相当于验证设计以更高的频率运行。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081013300295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上所述，<strong>set_clock_uncertainty</strong> 还可用于对任何附加裕度（additional margins）进行建模。例如，设计人员可能会在设计过程中使用 50ps 的时序余量作为额外坏情况的考虑（additional pessimism）。该组件可以添加并包含在 <strong>set_clock_uncertainty</strong> 命令中。通常，在实现时钟树之前，<strong>set_clock_uncertainty</strong> 命令用于指定一个值，该值包括时钟抖动加上估计的时钟偏斜加上额外坏情况的考虑（additional pessimism）。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_clock_latency <span class="number">2.0</span> [get_clocks USBCLK]</span><br><span class="line"></span><br><span class="line">set_clock_uncertainty <span class="number">0.2</span> [get_clocks USBCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The 200ps may be composed of 50ps clock jitter,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 100ps clock skew and 50ps additional pessimism.</span></span><br></pre></td></tr></table></figure>
<p>​ 稍后我们将看到 <strong>set_clock_uncertainty</strong> 如何影响建立和保持检查。最好将时钟不确定性视为最终<strong>偏斜（slack）</strong>计算的偏移量。</p>
<h2 id="时序弧timing-arcs-and-unateness">时序弧（Timing Arcs and Unateness）</h2>
<p>​ 每个cell都有多个时序弧。例如，组合逻辑单元（如and、or、nand、nor 、adder单元）从单元的每个输入到每个输出具有时序弧。顺序单元（如触发器flip-flops ）具有从时钟到输出的时序弧，和关于时钟的数据管脚的时序约束。每个时序弧都有一个时序感测（timing sense），即输入上不同类型的转换如何改变输出。如果输入上的上升过渡导致输出上升（或不改变），而输入上的下降过渡导致输出下降（或不改变），则为<strong>正时序弧（positive unate）</strong>。例如，and和or类型单元格的计时弧为正。见图2-17（a）。</p>
<p>​ <strong>负时序弧（negative unate）</strong>是指，输入上的上升过渡导致输出有下降过渡（或不改变）和在输入上的下降过渡，使输出具有上升过渡（或不改变）。例如，nand和nor类型单元的时序弧为负。见图2-17（b）。</p>
<p>​ 在<strong>non-unate时序弧</strong>中，输出转换不能仅从输入的变化方向确定，还取决于其他输入的状态。例如，异或（xor）单元（异或）中的时序弧是<strong>non-unate</strong>的。1见图2-17（c）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810135249557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ <strong>Unateness</strong> 对于时序非常重要，因为它指定了边沿（过渡transitions）如何在单元格中传播以及它们如何在单元格的输出中显示。</p>
<p>​ 人们可以利用时序弧的<strong>non-unateness</strong>性，例如当使用异或<strong>（xor ）</strong>单元时，翻转时钟的极性。参见图2-18中的示例。如果输入<strong>POLCTRL</strong>为逻辑-0，则单元<strong>UXOR0</strong>输出上的时钟<strong>DDRCLK</strong>与输入时钟<strong>MEMCLK</strong>具有相同的极性。如果<strong>POLCTRL</strong>是逻辑1，则单元<strong>UXOR0</strong>输出上的时钟与输入时钟<strong>MEMCLK</strong>的极性相反。</p>
<p>​</p>
<p><img src="https://img-blog.csdnimg.cn/20210810140906591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="最小和最大时序路径min-and-max-timing-paths">最小和最大时序路径（Min and Max Timing Paths）</h2>
<p>​ 逻辑通过逻辑路径传播的总延迟称为<strong>路径延迟（path delay）</strong>。这相当于通过路径上各种逻辑单元和网络的延迟之和。通常，逻辑可以通过多条路径传播到所需的目标点。实际路径取决于逻辑路径上其他输入的状态。如图 2-19 示例。由于到达目的地的路径有多条，因此可以得到到达目的点的最大时间和最小时间。最大时间和最小时间对应的路径分别称为最大路径和最小路径。两个端点之间的最大路径是具有最大延迟的路径（也称为最长路径）。同样地，最小路径是延迟最小的路径（也称为最短路径）。</p>
<p>​ 数据路径示例如图2-19所示。UFF1和UFF3之间的最大路径假定是通过UNAND0、UBUF2、UOR2和UNAND6单元的路径。UFF1和UFF3之间的最小路径被认为是通过UOR4和UNAND6单元的路径。注意，在这个例子中，最大值和最小值是与目的点(即触发器UFF3的D引脚)相关的。</p>
<p>​ 最大路径通常被称为<strong>late path</strong>，而最小路径通常被称为<strong>early path</strong>。</p>
<p>​ 当考虑从UFF1到UFF3等触发器到触发器路径时，其中一个触发器启动数据，另一个触发器捕获数据。在本例中，由于UFF1启动数据，因此UFF1被称为启动触发器。因为UFF3捕获数据，所以UFF3被称为捕获触发器。请注意，启动和捕获术语总是与触发器到触发器路径有关。例如，UFF3将成为通往捕获UFF3产生的数据的触发器路径的启动触发器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810142219455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="时钟域clock-domains">时钟域（Clock Domains）</h2>
<p>​ 在同步逻辑设计中，一个周期时钟信号锁存计算到触发器中的新数据。新的数据输入是基于前一个时钟周期的触发器值。因此，锁存数据用于计算下一个时钟周期的数据。</p>
<p>​ 一个时钟通常为多个触发器服务。由一个时钟服务的一组触发器称为其时钟域。在典型设计中，可能存在多个时钟域。例如，200个触发器可以由USBCLK计时，1000个触发器可以由时钟MEMCLK馈送。图2-20描述了触发器和时钟。在本例中，我们说有两个时钟域。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810144453255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个令人感兴趣的问题是时钟域是彼此相关还是相互独立。答案取决于是否存在从一个时钟域开始并在另一个时钟域结束的任何数据路径。如果没有这样的路径，我们可以安全地说这两个时钟域是彼此独立的。这意味着没有从一个时钟域开始并在另一个时钟域结束的定时路径。</p>
<p>​ 如果确实存在跨越时钟域的数据路径(参见图2-21)，则必须决定这些路径是否是真实的。真实路径的一个例子是，具有2倍速度时钟的触发器驱动到具有1倍速度时钟的触发器中。错误路径的一个例子是，设计者明确地将时钟同步器逻辑放置在两个时钟域之间。在这种情况下，即使看起来存在从一个时钟域到下一个时钟域的时序路径，它也不是真正的时序路径，因为数据不受限制在一个时钟周期内通过同步器逻辑传播。这样的路径被称为假路径(不是真实路径)，因为时钟同步器确保数据正确地从一个域传递到下一个域。可以使用<strong>set_false_path</strong>规范指定时钟域之间的假路径，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_false_path -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks USBCLK]</span></span><br><span class="line"></span><br><span class="line">-<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks MEMCLK]</span></span><br><span class="line"></span><br><span class="line"># This specification is explained in more detail in Chapter <span class="number">8</span>.</span><br></pre></td></tr></table></figure>
<p>​ 即使未在图2-21中描述，时钟域交叉也可能以两种方式发生，即从USBCLK时钟域到MEMCLK时钟域，以及从MEMCLK时钟域到USBCLK时钟域。这两种情况都需要在STA中正确理解和处理。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081014483352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 讨论时钟域之间路径的原因是什么？通常，一种设计具有大量时钟，并且在时钟域之间可以有无数条路径。识别哪些时钟域交叉是真实的，哪些时钟交叉不是真实的是时序验证工作的一个重要部分。这使设计人员能够专注于仅验证真正时序路径。</p>
<p>​ 图2-22显示了时钟域的另一个示例。多路复用器选择一个时钟源——它是一个或另一个，取决于设计的操作模式。只有一个时钟域，但有两个时钟，这两个时钟被认为是互斥的，因为一次只有一个时钟是活动的。因此，在该示例中，重要的是要注意，USBCLK和USBCLKx2的两个时钟域之间永远不可能存在路径（假设多路复用器控制是静态的，并且这种路径在设计中的其他地方不存在）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810150540411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="操作条件operating-conditions">操作条件（Operating Conditions）</h2>
<p>​ 静态定时分析通常在特定操作条件下执行*****。操作条件定义为工艺、电压和温度（<strong>Process, Voltage and Temperature PVT）</strong>的组合。单元延迟和互连延迟是根据指定的操作条件计算的。</p>
<p>******STA 可以在具有不同电压的单元的设计上执行。稍后我们将看到这些是如何处理的。 STA 也可以统计执行，这在第 10 章中描述。*</p>
<p>​ 半导体代工厂为数字设计提供了三种制造工艺模型：慢工艺模型、典型工艺模型和快速工艺模型。慢速和快速工艺模型代表了铸造厂制造过程的极端角落。对于稳健设计，该设计在制造过程的极端角落以及温度和电源的极端环境中得到验证。图 2-23(a) 显示了cell delays如何随工艺角变化。图 2-23(b) 显示cell delays如何随电源电压变化，图 2-23(c) 显示cell delays如何随温度变化。因此，决定用于各种静态时序分析的工作条件非常重要。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810151148148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ STA 使用何种操作条件的选择还取决于单元库可用的操作条件。三个标准操作条件是：</p>
<ol type="1">
<li>WCS（Worst-Case Slow）：过程（process）缓慢，温度（temperature）最高（比如 125C），电压（voltage）最低（比如标称 1.2V 减 10%）。对于使用低电源的纳米技术，可能还有另一个最坏情况的慢角，对应于慢工艺、最低电源和最低温度。低温下的延迟并不总是小于高温下的延时 。这是因为纳米技术降低了与电源相关的设备阈值电压（Vt）裕度。在这种情况下，在低电源条件下，轻负载电池在低温下的延迟高于高温下的延迟。对于高Vt（更高的阈值，更大的延迟）或甚至是标准Vt（常规阈值，更低的延迟）小区来说尤其如此。这种延迟在较低温度下增加的反常行为称为温度反转。见图2-23（c）。</li>
<li>TYP (Typical)：过程（process）是典型的，温度（temperature）是标称的（比如25C），电压（voltage）是标称的（比如1.2V）。</li>
<li>BCF（Best-Case Fast）：过程（process）快速，温度（temperature）最低（比如-40℃），电压（voltage）最高（比如标称1.2V加10%）。</li>
</ol>
<p>​ 功率分析的环境条件通常与静态定时分析的环境条件不同。对于功率分析，工作条件可能为：</p>
<ol type="1">
<li>ML (Maximal Leakage)：过程很快，温度最高（比如125C），电压也最高（比如1.2V加10%）。该角对应于最大泄漏功率。对于大多数设计，此角也对应于最大有功功率。</li>
<li>TL (Typical Leakage)：过程是典型的，温度最高（比如125C），电压为标称值（比如1.2V）。这是指大多数设计中泄漏具有代表性的情况，因为在正常操作中，由于功率损耗，芯片温度会更高。</li>
</ol>
<p>​ 静态定时分析基于为STA加载和链接的库。可以使用<strong>set_operating_conditions</strong>命令明确指定设计的操作条件。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_operating_conditions “WCCOM” -library mychip</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the operating condition called WCCOM defined in the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cell library mychip.</span></span><br></pre></td></tr></table></figure>
<p>​ 单元库在各种操作条件下可用，选择用于分析的操作条件取决于为STA加载的内容。</p>
<h1 id="标准单元库standard-cell-library">标准单元库（Standard Cell Library）</h1>
<blockquote>
<p>​ 描述了常用库单元描述中的时序相关信息。本章仅关注与时序、串扰和功率分析相关的属性，尽管库单元包含多个属性。纳米技术中对时序的主要影响是互连。</p>
</blockquote>
<p>​ 除了时序信息外，库单元描述还包含几个属性（attributes），如单元面积和功能，这些属性与时序无关，但在RTL合成过程中相关。在本章中，我们只关注与时序和功率计算相关的属性（attributes）。</p>
<p>​ 可以使用各种标准格式来描述库单元。虽然各种格式的内容基本相似，但我们已经使用Liberty语法描述了库单元示例。</p>
<p>​ 本章的开始部分描述了线性和非线性时序模型（linear and the non-linear timing models ），然后是第3.7节描述的纳米技术的高级时序模型。</p>
<h2 id="引脚电容pin-capacitance">引脚电容（Pin Capacitance）</h2>
<p>​ 单元的每个输入和输出都可以指定引脚处的电容。在大多数情况下，电容仅针对单元输入而不是输出指定，即大多数单元库中的输出引脚电容为 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">pin (INP1) &#123;</span><br><span class="line"></span><br><span class="line">capacitance: <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">rise_capacitance: <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">rise_capacitance_range: (<span class="number">0.48</span>, <span class="number">0.52</span>);</span><br><span class="line"></span><br><span class="line">fall_capacitance: <span class="number">0.45</span>;</span><br><span class="line"></span><br><span class="line">fall_capacitance_range: (<span class="number">0.435</span>, <span class="number">0.46</span>);</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上面的示例显示了输入 <strong>INP1</strong> 的引脚电容值的一般规范。在最基本的形式中，引脚电容被指定为单个值（在上例中为 0.5 个单位）。 （电容单位通常是皮法，并在库文件的开头指定）。单元描述还可以为<strong>rise_capacitance</strong>（0.5 个单位）和<strong>fall_capacitance</strong>（0.45 个单位）指定单独的值，它们指的是用于引脚INP1 上的上升和下降转换的值。也可以将<strong>rise_capacitance</strong> 和<strong>fall_capacitance</strong> 值指定为一个范围，并在说明中指定下限和上限值。</p>
<h2 id="时序建模timing-modeling">时序建模（Timing Modeling）</h2>
<p>​ 单元时序模型旨在为设计环境中单元的各种实例提供准确的时序。时序模型通常是从单元的详细电路模拟中获得，以模拟单元运行的实际场景。为单元的每个时序弧指定时序模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810161210759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 让我们首先考虑一个简单的逆变器逻辑单元的时序弧，如图3-1所示，因为它是一个逆变器，在输入端的上升（下降）转变导致输出处的下降（上升）转变。单元的两种延迟特性是：</p>
<ol type="1">
<li>Tr：输出上升延迟</li>
<li>Tf：输出下降延迟</li>
</ol>
<p>​ 请注意，延迟是基于单元库中定义的阈值点来测量的（参见第2.4节），通常为50%Vdd。因此，从输入超过其阈值点到输出超过其阈值点，测量延迟。</p>
<p>​ 通过逆变器单元的时序电弧延迟取决于两个因素：</p>
<ol type="1">
<li>输出负载（output load），即逆变器输出引脚的电容负载。</li>
<li>输入端信号的转换时间（transition time）。</li>
</ol>
<p>​ 延迟值与负载电容直接相关——负载电容越大，延迟越大。在大多数情况下，延迟随着输入转换时间的增加而增加。在某些情况下，输入阈值（用于测量延迟）与单元的内部开关点有显着差异。在这种情况下，通过单元的延迟可能会表现出相对于输入转换时间的非单调行为 - 较大的输入转换时间可能会产生较小的延迟，尤其是在输出负载较轻的情况下。</p>
<p>​ 单元输出的转换（slew）主要取决于输出电容——输出转换时间随着输出负载的增加而增加。因此，根据单元类型及其输出负载，输入处的大转换（大转换时间）可以改善输出处。图 3-2 显示了单元输出的转换时间可以根据单元输出的负载而改善或恶化的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810162357165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="线性时序模型linear-timing-model">线性时序模型（Linear Timing Model）</h3>
<p>​ 一个简单的时序模型是线性延迟模型，其中单元的延迟和输出转换时间表示为两个参数的线性函数：<strong>输入转换时间和输出负载电容</strong>。通过单元的延迟 D 的线性模型的一般形式如下所示。</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?D%20%3D%20D0%20+%20D1%20*%20S%20+%20D2%20*%20C"></p>
<p>​ 其中 D0、D1、D2 是常数，S 是输入转换时间，C 是输出负载电容。线性延迟模型在亚微米技术的输入转换时间和输出电容范围内不准确因此，大多数单元库目前使用更复杂的模型，例如非线性延迟模型。</p>
<h3 id="非线性延迟模型non-linear-delay-model">非线性延迟模型（Non-Linear Delay Model）</h3>
<p>​ 大多数单元库都包含表（table）模型，用于指定单元的各种时序弧的延迟和时序检查。一些用于纳米技术的较新的时序库还提供了基于电流源的高级时序模型（例如 CCS、ECSM 等），本章稍后将对其进行介绍。table型称为 NLDM（非线性延迟模型），用于延迟、输出转换或其他时序检查。</p>
<p>​ table模型捕获了通过单元输入引脚的输入转换时间和单元输出的总输出电容的各种组合的延迟。</p>
<p>​ 延迟的 NLDM 模型以二维形式呈现，两个独立变量是<strong>输入转换时间（</strong>nput transition time <strong>）</strong>和<strong>输出负载电容</strong>（output load capacitance），table中的条目表示延迟。以下是典型逆变器单元的此类table示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">pin (<span class="variable constant_">OUT</span>) &#123;</span><br><span class="line"></span><br><span class="line">max_transition : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;INP1&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_rise</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values (  <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0513, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.1018, 0.2327, 0.6476&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1334, 0.2973, 0.7252&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values (  <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0617, 0.1537,  0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.0918, 0.2027,  0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1034, 0.2273,  0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在上面的示例中，描述了输出引脚 <strong>OUT</strong> 的延迟。单元描述的这一部分包含从引脚 INP1 到引脚 OUT 的时序弧的上升和下降延迟模型，以及引脚 OUT 上的 <strong>max_transition</strong> 允许时间。上升和下降延迟（对于输出引脚）有单独的模型，它们分别标记为 <strong>cell_rise</strong> 和 <strong>cell_fall</strong>。索引的类型和表查找索引的顺序在查找表模板 <strong>delay_template_3x3</strong> 中描述。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lu_table_template</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">variable_1 : input_net_transition;</span><br><span class="line"></span><br><span class="line">variable_2 : total_output_net_capacitance;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入转换和输出电容可以是任意顺序，即variable_1可以是输出电容。但是，这些名称在库中的所有模板中通常是一致的。 */</span></span><br></pre></td></tr></table></figure>
<p>​ 此查找表模板指定表中的第一个变量是输入转换时间，第二个变量是输出电容。表值像嵌套循环一样指定，其中第一个索引 (<strong>index_1</strong>) 是外部（或变化最小）变量，第二个索引 (<strong>index_2</strong>) 是内部（或变化最大）变量，依此类推。每个变量有三个条目，因此它对应于一个 3×3 表。在大多数情况下，表的条目也像表一样格式化，然后可以将第一个索引 (<strong>index_1</strong>) 视为行索引，而第二个索引 (<strong>index_2</strong>) 变得等效于列索引。索引值（例如 1000）是虚拟占位符，它们被 <strong>cell_fall</strong> 和 <strong>cell_rise</strong> 延迟表中的实际索引值覆盖。指定索引值的另一种方法是在模板定义中指定索引值，而不是在 <strong>cell_rise</strong> 和 <strong>cell_fall</strong> 表中指定它们。这样的模板看起来像这样：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lu_table_template</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">variable_1 : input_net_transition;</span><br><span class="line"></span><br><span class="line">variable_2 : total_output_net_capacitance;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.7</span>&quot;);</span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.16</span>, <span class="number">0.35</span>, <span class="number">1.43</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 根据延迟表，0.3ns 的输入下降转换时间和 0.16pf 的输出负载将对应于 0.1018ns 的反相器上升延迟。由于输入端的下降跃迁导致逆变器输出上升，上升延迟的表查找涉及反相器输入处的下降转换。</p>
<p>​ 这种在表格中将延迟表示为两个变量（转换时间和电容）的函数的形式称为非线性延迟模型，因为延迟随输入转换时间和负载电容的非线性变化在此类表中表示。</p>
<p>​ 表模型也可以是 3 维的——一个例子是具有互补输出 Q 和 QN 的触发器，这在第 3.8 节中进行了描述。</p>
<p>​ NLDM 模型不仅用于延迟，还用于单元输出的转换时间，其特征在于输入转换时间和输出负载。因此，有单独的二维表用于计算单元的输出上升和下降转换时间。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">pin (<span class="variable constant_">OUT</span>) &#123;</span><br><span class="line"></span><br><span class="line">max_transition : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;INP&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.1 */</span> <span class="string">&quot;0.0417, 0.1337, 0.4680&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.3 */</span> <span class="string">&quot;0.0718, 0.1827, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.7 */</span> <span class="string">&quot;0.1034, 0.2173, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0817, 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.1018, 0.2327, 0.7676&quot;</span>, \</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1334, 0.2973, 0.8452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 有两个这样的过渡时间表：rise_transition 和fall_transition。如第 2 章所述，转换时间是根据特定的转换阈值测量的，通常是电源的 10%-90%。</p>
<p>​ 如上所示，具有 NLDM 模型的逆变器单元具有下表：</p>
<ul>
<li>Rise delay</li>
<li>Fall delay</li>
<li>Rise transition</li>
<li>Fall transition</li>
</ul>
<p>​ 给定这种单元的输入转换时间和输出电容，如图 3-3 所示，从 cell_rise 表中获得 15ps 输入转换时间（下降）和 10fF 负载的上升延迟，从20ps 输入转换时间（上升）和 10fF 负载的 cell_fall 表。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810185804406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 指定单元正在反转的信息在哪里？该信息被指定为时序弧的<strong>timing_sense</strong> 字段的一部分。在某些情况下，此字段未指定，但应从引脚功能派生。</p>
<p>​ 对于示例反相器单元，时序弧为<strong>negative_unate</strong>，这意味着输出引脚转换方向与输入引脚转换方向相反（负）。因此，cell_rise 表查找对应于输入引脚的下降转换时间。</p>
<h4 id="非线性延迟模型查找示例example-of-non-linear-delay-model-lookup">非线性延迟模型查找示例（Example of Non-Linear Delay Model Lookup）</h4>
<p>​ 本节通过示例说明表模型的查找。如果输入转换时间和输出电容对应于表条目，则表查找是微不足道的，因为时序值直接对应于表中的值。下面的示例对应于查找不对应于表中任何可用条目的一般情况。在这种情况下，使用二维内插来提供结果时序值。为表插值选择每个维度中两个最近的表索引。考虑输入转换时间为 0.15ns 和输出电容为 1.16pF 的下降转换表（上面指定的示例表）。下面再现了与二维插值相关的下降过渡表的相应部分。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3 . . .&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;. . . 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;. . . 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;. . . 0.2327, 0.7676&quot;</span></span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>​ 在下面的公式中，两个 index_1 值表示为 x1 和 x2；两个index_2值分别记为y1和y2，对应的表值分别记为T11、T12、T21和T22。</p>
<p>如果 (x0, y0) 需要查表，则通过插值获得查找值 T00，由下式给出：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?T00%3D%20x20*%20y20*%20T11+%20x20*%20y01*%20T12+%20x01*%20y20*%20T21+%20x01*%20y01*%20T22"></p>
<p>这里</p>
<p>x01= (x0- x1) / (x2- x1)<br>
x20= (x2- x0) / (x2- x1)<br>
y01= (y0- y1) / (y2- y1)<br>
y20= (y2- y0) / (y2- y1)</p>
<p>​ 用 0.15 代替 index_1 和 1.16 代替 index_2 导致 fall_transition 值：</p>
<p>T00= 0.75 * 0.25 * 0.1937 + 0.75 * 0.75 * 0.7280 +<br>
0.25 * 0.25 * 0.2327 + 0.25 * 0.75 * 0.7676 = 0.6043</p>
<p>​ 请注意，上述等式对于内插和外推均有效 - 即当指数 (x0, y0) 位于指数的特征范围之外时。例如，对于 index_1 为 0.05 和 index_2 为 1.7 的表查找，获得下降过渡值如下：</p>
<p>T00= 1.25 * (-0.25) * 0.1937 + 1.25 * 1.25 * 0.7280 +<br>
(-0.25) * (-0.25) * 0.2327 + (-0.25) * 1.25 * 0.7676<br>
= 0.8516</p>
<h3 id="阈值规格和转换时间降额threshold-specifications-and-slew-derating">阈值规格和转换时间降额（Threshold Specifications and Slew Derating）</h3>
<p><strong>slew（即transition time）</strong>值基于库中指定的测量阈值。大多数上一代库（0.25 毫米或更早）使用 10% 和 90% 作为压摆或转换时间的测量阈值。</p>
<p>​ 选择转换阈值以对应于波形的线性部分。随着技术变得越来越精细，实际波形最线性的部分通常在 30% 到 70% 之间。因此，大多数新一代时序库将转换测量点指定为 Vdd 的 30% 和 70%。但是，由于之前测量的转换时间在 10% 到 90% 之间，因此在填充库时测量的转换时间通常在 30% 到 70% 之间加倍。这由通常指定为 0.5 的转换降额系数指定。 30% 和 70% 的转换阈值（转换降额为 0.5）导致等效的测量点为 10% 和 90%。阈值设置示例如下所示。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Threshold definitions */</span></span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">30.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">70.0</span>;</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">30.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">70.0</span>;</span><br><span class="line"></span><br><span class="line">input_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">input_threshold_pct_rise : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">output_threshold_pct_fall : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">output_threshold_pct_rise : <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">slew_derate_from_library : <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p>​ 上述设置指定库表中的转换时间必须乘以 0.5 才能获得与转换阈值 (30-70) 设置相对应的转换时间。这意味着转换表中的值（以及相应的索引值）实际上是 10-90 个值。在表征过程中，转换是在 30-70 处测量的，库中的转换数据对应于将测量值外推到 10% 到 90% ((70 - 30)/(90 - 10) = 0.5)。</p>
<p>​ 具有一组不同转换阈值设置的另一个示例可能包含：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Threshold definitions 20/80/1 */</span></span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">20.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">20.0</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">80.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* slew_derate_from_library not specified */</span></span><br></pre></td></tr></table></figure>
<p>​ 在这个 20-80 转换率阈值设置的示例中，没有指定 <strong>slew_derate_from_library</strong>（暗示默认值为 1.0），这意味着库中的转换时间数据没有降额。转换表中的值直接对应于 20-80 表征的转换值。见图 3-4 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810194438619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是单元库中转换阈值设置的另一个示例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : <span class="number">20.00</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">80.00</span>;</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : <span class="number">20.00</span>;</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">80.00</span>;</span><br><span class="line"></span><br><span class="line">slew_derate_from_library : <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure>
<p>​ 在这种情况下，slew_derate_from_library 设置为 0.6，并且将特征转换跳变点指定为 20% 和 80%。这意味着库中的转换表数据对应于 0% 到 100% ((80 - 20)/(100 - 0) = 0.6) 外推值。如图 3-5 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810194924432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 指定slew降额时，延迟计算期间内部使用的slew值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library_transition_time_value * slew_derate</span><br></pre></td></tr></table></figure>
<p>​ 这是延迟计算工具内部使用的转换，对应于特征转换阈值测量点。</p>
<h2 id="时序模型组合单元timing-models---combinational-cells">时序模型——组合单元（Timing Models - Combinational Cells）</h2>
<p>​ 让我们考虑两个输入和单元格的时序弧。该单元格的两个时序弧都是positive_unate；因此，输入引脚上升对应于输出上升，反之亦然。</p>
<p><img src="https://img-blog.csdnimg.cn/20210810200940748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于二输入and单元，有四种延迟：</p>
<ul>
<li>A -&gt; Z: Output rise</li>
<li>A -&gt; Z: Output fall</li>
<li>B -&gt; Z: Output rise</li>
<li>B -&gt; Z: Output fall</li>
</ul>
<p>​ 这意味着对于 NLDM 模型，将有四个表模型用于指定延迟。类似地，也将有四个这样的表模型用于指定输出转换时间。</p>
<h3 id="延迟和转换模型delay-and-slew-models">延迟和转换模型（Delay and Slew Models）</h3>
<p>​ 一个三输入 nand 单元的输入 INP1 到输出 OUT 的时序模型示例如下所示。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">pin (<span class="variable constant_">OUT</span>) &#123;</span><br><span class="line"></span><br><span class="line">max_transition : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;INP1&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_rise</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0513, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1018, 0.2327, 0.6476&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1334, 0.2973, 0.7252&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0417, 0.1337, 0.4680&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0718, 0.1827, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2173, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0617, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0918, 0.2027, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2273, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0817, 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1018, 0.2327, 0.7676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1334, 0.2973, 0.8452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在此示例中，使用两个单元延迟表 <strong>cell_rise</strong> 和 <strong>cell_fall</strong> 以及两个转换表<strong>rise_transition</strong> 和 <strong>fall_transition</strong> 来描述从 <strong>INP1</strong> 到 <strong>OUT</strong> 的时序弧的特性。输出 <strong>max_transition</strong> 值也包含在上面的示例中。</p>
<p><strong>Positive or Negative Unate</strong></p>
<p>​ 如第 2.7 节所述，<strong>nand</strong> 单元示例中的时序弧为<strong>negative unate</strong>，这意味着输出引脚转换方向与输入引脚转换方向相反（负）。因此，<strong>cell_rise</strong> 表查找对应于输入引脚的下降转换时间。另一方面，通过<strong>and</strong>单元格或<strong>or</strong>单元格的时序弧是<strong>positive unate</strong>，因为输出转换与输入转换的方向相同。</p>
<h3 id="通用组合块general-combinational-block">通用组合块（General Combinational Block）</h3>
<p>​ 考虑具有三个输入和两个输出的组合块。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811145716416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 像这样的块可以有许多时序弧。通常，时序弧可以从块的每个输入到每个输出。如果从输入到输出的逻辑路径是non-inverting 或 positive unate，则输出具有与输入相同的极性。如果是反相逻辑路径是negative unate，则输出与输入极性相反；因此，当输入上升时，输出下降。这些时序弧表示通过块的传播延迟。</p>
<p>​ 一些通过组合单元格的时序弧可以是positive unate 也可以是negative unatee。一个例子是通过两输入异或单元的时序弧。两输入异或（ xor ）单元的输入处的转换 可导致输出转换沿相同或相反的转换方向，具体取决于单元的另一个输入的逻辑状态。这些时序弧可以被描述为non-unate或两组不同的 positive unate 和 negative unate 时序模型，它们依赖于状态。此类依赖于状态的表在第 3.5 节中有更详细的描述。</p>
<h2 id="时序模型顺序单元timing-models---sequential-cells">时序模型——顺序单元（Timing Models - Sequential Cells）</h2>
<p>​ 考虑图 3-8 中所示的顺序单元的时序弧。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811150517858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于同步输入（synchronous inputs），例如引脚 D（或 SI、SE），有以下时序弧：</p>
<ul>
<li>Setup check arc (rising and falling)</li>
<li>Hold check arc (rising and falling)</li>
</ul>
<p>​ 对于异步输入（asynchronous inputs），例如 pin CDN，有以下时序弧：</p>
<ul>
<li>Recovery check arc</li>
<li>Removal check arc</li>
</ul>
<p>​ 对于触发器的同步输出，例如引脚 Q 或 QN，有以下时序弧：</p>
<ul>
<li>CK-to-output propagation delay arc (rising and falling)</li>
</ul>
<p>​ 所有同步时序弧都与时钟的有效边沿有关，时钟的边沿使顺序单元捕获数据。此外，时钟引脚和异步引脚等清零，可以进行脉宽定时检查。图 3-9 显示了使用各种信号波形的时序检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811151034861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="同步检查建立和保持synchronous-checks-setup-and-hold">同步检查：建立和保持（Synchronous Checks: Setup and Hold）</h3>
<p>​ 需要建立和保持同步时序检查，以便通过时序单元正确传递数据。这些检查验证数据输入在时钟的有效边沿是明确的，并且正确的数据在有效边沿被锁存。这些时序检查验证数据输入在活动时钟边沿附近是否稳定。当数据输入必须保持稳定时，激活时钟之前的最短时间称为建立时间（setup time）。从超过阈值的最新数据信号（通常为Vdd的50%）到超过其阈值的活动时钟边缘（通常为Vdd的50%）的时间间隔是<strong>setup time</strong>。类似地，保持时间（hold time）是数据输入必须在时钟活动边缘之后保持稳定的最短时间。从超过其阈值的活动时钟边缘到超过其阈值的最早数据信号的时间间隔是<strong>hold time</strong>。如前所述，时序单元时钟的有效边沿是导致时序单元捕获数据的上升沿或下降沿。</p>
<p><strong>建立和保持检查示例（Example of Setup and Hold Checks）</strong></p>
<p>​ 顺序单元的同步管脚的setup 和hold constraints通常以二维表格的形式描述，如下所示。下面的示例显示触发器数据引脚的setup 和hold时序信息。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">pin (D) &#123;</span><br><span class="line"></span><br><span class="line">direction : input;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : <span class="string">&quot;setup_rising&quot;</span>;</span><br><span class="line"></span><br><span class="line">rise_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;0.063, 0.093,  0.112&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span> <span class="string">&quot;0.526, 0.644,  0.824&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span> <span class="string">&quot;0.720, 0.839,  0.930&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fall_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;0.762, 0.895,  0.969&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span> <span class="string">&quot;0.804, 0.952,  0.166&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span> <span class="string">&quot;0.159, 0.170,  0.245&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : <span class="string">&quot;hold_rising&quot;</span>;</span><br><span class="line"></span><br><span class="line">rise_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>(  <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;-0.220, -0.339, -0.584&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span> <span class="string">&quot;-0.247, -0.381, -0.729&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span> <span class="string">&quot;-0.398, -0.516, -0.864&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fall_constraint (<span class="string">&quot;setuphold_template_3x3&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">index_1</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">index_2</span>(<span class="string">&quot;0.4, 0.57, 0.84&quot;</span>);<span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>(  <span class="comment">/*  0.4  0.57  0.84 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;-0.028,  -0.397, -0.489&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.57 */</span>  <span class="string">&quot;-0.408,  -0.527, -0.649&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.84 */</span>  <span class="string">&quot;-0.705,  -0.839, -0.580&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上面的示例显示了输入管脚D上相对于顺序单元的时钟CK的上升沿的设setup 和hold constraints。二维模型是根据受约束的_-pin（D）和相关的_-pin（CK）处的过渡时间建立的。 二维查找表基于库中描述的模板<strong>setuphold_template_3x3。</strong>对于上述示例，查找表模板<strong>setuphold_template_3x3</strong>描述为：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lu_table_template</span>(setuphold_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">variable_1 : constrained_pin_transition;</span><br><span class="line"></span><br><span class="line">variable_2 : related_pin_transition;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">1000</span>, <span class="number">1001</span>, <span class="number">1002</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*受约束管脚和相关管脚可以是任意顺序，即variable_1可以是相关管脚转换。但是，这些名称通常在库中的所有模板中都是一致的*/</span></span><br></pre></td></tr></table></figure>
<p>​ 与前面的示例一样，表中的设置值被指定为一个嵌套循环，第一个索引index_1是外部（或变化最小）变量，第二个索引index_2是内部（或变化最大）变量，依此类推。因此，当D引脚上升过渡时间为0.4ns，CK引脚上升过渡时间为0.84ns时，D引脚上升沿的设置约束为0.112ns—该值从rise_constraint 表中读取。对于D引脚的下降沿，setup constraint将检查设置表的fall_constraint表。对于过渡时间与索引值不对应的setup and hold constraint表的查找，第3.2节中描述的non-linear model查找的一般程序适用。</p>
<p>​ 请注意，setup constraint的rise_constraint和fall_constraint表指的是constrained_pin。使用的时钟转换由timing_type 确定，该类型指定单元是上升沿触发还是下降沿触发。</p>
<p><strong>建立和保持检查中的负值（Negative Values in Setup and Hold Checks）</strong></p>
<p>​ 请注意，上面示例中的一些hold值为负值。这是可以接受的，并且通常发生在从触发器引脚到数据内部锁存点的路径长于相应的时钟的路径时。</p>
<p>​ 因此，负 hold check意味着触发器的数据管脚可以在时钟管脚之前改变，并且仍然满足hold time check。</p>
<p>​ 触发器的setup值也可以为负值。这意味着在触发器的引脚上，数据可以在时钟引脚之后更改，并且仍然满足setup time check。</p>
<p>​ setup和hold都可以是负数吗？不。为使setup和hold检查一致，setup和hold值之和应为正值。因此，如果setup（或hold）检查包含负值，则相应的hold（或setup）应为正值，以便setup加上hold值为正值。有关负hold值的示例，请参见图3-10。由于setup必须在hold之前进行，因此setup加hold是一个正数。setup加hold time是要求数据信号稳定的区域宽度。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811154415788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于触发器，在扫描数据输入引脚上有一个负的hold时间是有帮助的。这在时钟偏移（clock skew）方面提供了灵活性，并且可以消除几乎所有缓冲器插入的需要，以便在scan mode中修复hold冲突（scan mode是触发器串行连接形成扫描链的模式-触发器的输出通常串行连接到下一个触发器的扫描数据输入引脚；这些连接用于测试性）。</p>
<p>​ 与同步数据输入上的setup 或 hold check类似，有约束检查控制异步管脚。下面将描述这些。</p>
<h3 id="异步检查asynchronous-checks">异步检查（Asynchronous Checks）</h3>
<p><strong>恢复和去除检查（Recovery and Removal Checks）</strong></p>
<p>​ 异步引脚（如Asynchronous clear或Asynchronous set）覆盖单元格的任何同步行为。当异步引脚激活时，输出由异步引脚控制，而不是由数据输入中的时钟锁存控制。但是，当异步引脚变为非活动时，时钟的活动边缘开始在数据输入中锁定。异步恢复和删除约束检查验证异步引脚在下一个活动时钟边缘已明确返回到非活动状态。</p>
<p>​ <strong>恢复时间（recovery time）</strong>是异步输入在下一个有效时钟沿之前被取消置位后稳定的最短时间。</p>
<p>​ 类似地，<strong>移除时间（removal time）</strong>是有效时钟边沿之后异步引脚必须保持有效状态才能取消置位的最短时间。</p>
<p>​ 异步删除和恢复检查分别在第 8.6 节和第 8.7 节中描述。</p>
<p><strong>脉冲宽度检查（Pulse Width Checks）</strong></p>
<p>​ 除了同步和异步时序检查之外，还有一项检查可确保单元输入引脚的脉冲宽度满足最低要求。例如，如果时钟引脚的脉冲宽度小于指定的最小值，则时钟可能无法正确锁存数据。也可以为相关的同步和异步引脚指定脉冲宽度检查。可以为高脉冲和低脉冲指定最小脉冲宽度检查。</p>
<p><strong>恢复、去除和脉冲宽度检查示例（Example of Recovery, Removal and Pulse Width Checks）</strong></p>
<p>​ 下面给出了触发器异步清除引脚 CDN 的恢复时间、移除时间和脉冲宽度检查的示例。恢复和移除检查是针对时钟引脚 CK 的。由于恢复和移除检查是为置位的异步引脚定义的，因此下面的示例中仅存在上升约束。引脚 CDN 的最小脉冲宽度检查是针对低脉冲。由于 CDN 引脚为低电平有效，因此该引脚上的高脉冲宽度没有限制，因此未指定。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">pin</span>(<span class="params">CDN</span>) &#123;</span><br><span class="line"></span><br><span class="line">direction : input;</span><br><span class="line"></span><br><span class="line">capacitance : <span class="number">0.002236</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CDN&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : min_pulse_width;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_constraint</span>(<span class="params">width_template_3x1</span>) &#123; <span class="comment">/*low pulse check*/</span></span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.032  0.504  0.788 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.034,  0.060,  0.377&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : recovery_rising;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_constraint</span>(<span class="params">recovery_template_3x3</span>) &#123; <span class="comment">/* CDN rising */</span></span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.032  0.504  0.788 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.032 */</span>  <span class="string">&quot;-0.198,  -0.122, 0.187&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.504 */</span>  <span class="string">&quot;-0.268,  -0.157, 0.124&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.788 */</span>  <span class="string">&quot;-0.490,  -0.219, -0.069&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CP&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : removal_rising;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_constraint</span>(<span class="params">removal_template_3x3</span>) &#123; <span class="comment">/* CDN rising */</span></span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Data transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.032, 0.504, 0.788&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( <span class="comment">/*  0.032  0.504  0.788 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.032 */</span>  <span class="string">&quot;0.106, 0.167,  0.548&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.504 */</span>  <span class="string">&quot;0.221, 0.381,  0.662&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.788 */</span>  <span class="string">&quot;0.381, 0.456,  0.778&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传播延迟propagation-delay-1">传播延迟（Propagation Delay）</h3>
<p>​ 顺序单元的传播延迟是从时钟的有效边沿到输出的上升沿或下降沿。这是负边沿触发的触发器的传播延迟弧示例，从时钟引脚 CKN 到输出 Q。这是一个非同步的时序弧，因为时钟的有效边沿可能导致上升或下降输出 Q 上的边缘。这是延迟表：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CKN&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : falling_edge;</span><br><span class="line"></span><br><span class="line">timing_sense : non_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_rise</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.16  0.35  1.43 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.0513, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.3 */</span>  <span class="string">&quot;0.1018, 0.2327, 0.6476&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.7 */</span>  <span class="string">&quot;0.1334, 0.2973, 0.7252&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0417, 0.1337, 0.4680&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0718, 0.1827, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2173, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0617, 0.1537, 0.5280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0918, 0.2027, 0.5676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1034, 0.2273, 0.6452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_transition</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.3, 0.7&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.16, 0.35, 1.43&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0817, 0.1937, 0.7280&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1018, 0.2327, 0.7676&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.1334, 0.2973, 0.8452&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 与前面的示例一样，输出延迟以输入转换时间和输出引脚电容的二维表表示。然而，在本例中，要使用的输入转换时间是 CKN 引脚的下降转换时间，因为这是一个下降沿触发的触发器。这由上面示例中的构造timing_type 指示。上升沿触发触发器将指定rising_edge 作为其timing_type。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CKP&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : rising_edge;</span><br><span class="line"></span><br><span class="line">timing_sense : non_unate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cell_rise</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态相关模型state-dependent-models">状态相关模型（State-Dependent Models）</h2>
<p>​ 在许多组合块中，输入和输出之间的时序弧取决于块中其他引脚的状态。输入和输出引脚之间的这些时序弧可以是positive unate, negative unat，或者都是positive unate弧，都是negative unat 弧。一个例子是 xor 或 xnor 单元，其中输出的时序可以是positive unate 或negative unat。在这种情况下，时序行为可能会因模块其他输入的状态而异。通常，描述了取决于引脚状态的多个时序模型。这种模型被称为<strong>状态相关模型（state-dependent models）</strong>。</p>
<p><strong>XOR、XNOR 和顺序单元（XOR, XNOR and Sequential Cells）</strong></p>
<p>考虑一个两输入异或单元的例子。当另一个输入 A2 为逻辑 0 时，从输入 A1 到输出 Z 的时序路径为正值。当输入 A2 为逻辑 1 时，从 A1 到 Z 的路径为负 unate。这两个时序模型是使用状态相关模型指定的。当 A2 为逻辑 0 时，从 A1 到 Z 的时序模型指定如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (Z) &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">direction</span> : output;</span><br><span class="line"></span><br><span class="line">max_capacitance : <span class="number">0.0842</span>;</span><br><span class="line"></span><br><span class="line">function : <span class="string">&quot;(A1Â2)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A1&quot;</span>;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">sdf_cond : <span class="string">&quot;A2 == 1&#x27;b0&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : positive_unate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cell_rise</span>(delay_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.0272</span>, <span class="number">0.0576</span>, <span class="number">0.1184</span>&quot;); <span class="comment">/* Input slew */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.0102</span>, <span class="number">0.0208</span>, <span class="number">0.0419</span>&quot;); <span class="comment">/* Output load */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>( \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.0581</span>, <span class="number">0.0898</span>, <span class="number">0.2791</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.0913</span>, <span class="number">0.1545</span>, <span class="number">0.2806</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.0461</span>, <span class="number">0.0626</span>, <span class="number">0.2838</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 使用 when 条件指定依赖于状态的条件。虽然单元模型摘录仅说明了 cell_rise 延迟，但其他时序模型（cell_fall、rise_transition 和 fall_transition 表）也指定了相同的 when 条件。为另一个 when 条件指定单独的时序模型 - 对于 A2 为逻辑 1 的情况。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">timing</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A1&quot;</span>;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">sdf_cond : <span class="string">&quot;A2 == 1&#x27;b1&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : negative_unate;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cell_fall</span>(<span class="params">delay_template_3x3</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.0272, 0.0576, 0.1184&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.0102, 0.0208, 0.0419&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">values</span>( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0784, 0.1019, 0.2269&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0943, 0.1177, 0.2428&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.0997, 0.1796, 0.2620&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ sdf_cond 用于指定生成 SDF 时要使用的计时弧的条件 - 请参阅第 3.9 节中的示例和附录 B 中描述的 COND 构造。</p>
<p>​ 状态相关模型用于各种类型的时序弧。许多时序单元使用状态相关模型指定建立或保持时序约束。接下来指定使用状态相关模型进行保持约束的扫描触发器的示例。在这种情况下，指定了两组模型 - 一组在扫描启用引脚 SE 处于活动状态时，另一组在扫描启用引脚处于非活动状态时。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (D) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_type : hold_rising;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!SE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fall_constraint</span>(hold_template_3x3) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">index_1</span>(&quot;<span class="number">0.08573</span>, <span class="number">0.2057</span>, <span class="number">0.3926</span>&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">index_2</span>(&quot;<span class="number">0.08573</span>, <span class="number">0.2057</span>, <span class="number">0.3926</span>&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>(&quot;-<span class="number">0.05018</span>, -<span class="number">0.02966</span>, -<span class="number">0.00919</span>&quot;,\</span><br><span class="line"></span><br><span class="line">&quot;-<span class="number">0.0703</span>, -<span class="number">0.05008</span>, -<span class="number">0.0091</span>&quot;,\</span><br><span class="line"></span><br><span class="line">&quot;-<span class="number">0.1407</span>, -<span class="number">0.1206</span>, -<span class="number">0.1096</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 当 SE 引脚为逻辑 0 时使用上述模型。一个类似的模型用 when 条件 SE 指定为 logic-1。</p>
<p>​ 一些时序关系是使用状态相关和非状态相关模型指定的。在这种情况下，如果单元的状态已知并且包含在状态相关模型之一中，则时序分析将使用状态相关模型。如果状态相关模型不涵盖单元格的条件，则使用来自非状态相关模型的时序。考虑一种情况，其中hold constraint仅由逻辑 0 处的 SE 的一个 when 条件指定，并且没有为逻辑 1 处的 SE 指定单独的状态相关模型。在这种情况下，如果 SE 设置为逻辑 1，则使用来自非状态相关模型的保持约束。如果保持约束没有非状态依赖模型，则不会有任何 active hold constraint！</p>
<p>​ 可以为时序库中的任何属性指定状态相关模型。因此，对于power,leakage power, transition time, rise and fall delays, timing constraints等，可能存在状态相关的规范。下面给出了状态相关leakage power规范的示例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">leakage_power</span>() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;A1 !A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">259.8</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">leakage_power</span>() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;A1 A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">282.7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="黑匣子的接口时序模型">黑匣子的接口时序模型</h2>
<p>​ 本节介绍黑匣子（任意模块或块）的 IO 接口的时序弧。时序模型捕获黑盒 IO 接口的时序。黑盒接口模型可以具有组合以及顺序时序弧。一般来说，这些弧也可以是状态相关的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811162815116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于图 3-11 所示的示例，时序弧可以放置在以下类别下：</p>
<ul>
<li>输入到输出组合弧（Input to output combinational arc:）：这对应于从输入到输出的直接组合路径，例如从输入端口 FIN 到输出端口 FOUT。</li>
<li>输入顺序弧（Input sequential arc）：这被描述为连接到触发器 D 引脚的输入的建立或保持时间。通常，在连接到触发器的 D 引脚之前，模块的输入可能存在组合逻辑。这方面的一个例子是在端口 DIN 上相对于时钟 ACLK 的设置检查。</li>
<li>异步输入弧（Asynchronous input arc）：这类似于触发器的输入异步引脚的恢复或移除时序约束。一个例子是触发器 UFF0 的异步清除引脚的输入 ARST。</li>
<li>输出顺序弧（Output sequential arc）：这类似于时钟输出连接到触发器Q 的输出传播时序。一般来说，触发器输出和模块输出之间可以有组合逻辑。一个例子是从时钟 BCLK 到触发器 UFF1 输出到输出端口 DOUT 的路径。</li>
</ul>
<p>​ 除了上面的时序弧，还可以对黑匣子的外部时钟引脚进行脉宽检查。也可以定义内部节点并在这些内部节点上定义生成的时钟以及指定进出这些节点的定时弧。总之，黑盒模型可以具有以下时序弧：</p>
<ul>
<li>组合逻辑路径的输入输出时序弧。</li>
<li>从同步输入到相关时钟引脚的建立和保持时序弧。</li>
<li>相关时钟引脚的异步输入的恢复和移除时序弧。</li>
<li>从时钟引脚到输出引脚的输出传播延迟。</li>
</ul>
<h2 id="高级时序建模advanced-timing-modeling">高级时序建模（Advanced Timing Modeling）</h2>
<p>​ 时序模型（例如 NLDM）表示通过基于输出负载电容和输入转换时间的时序弧的延迟。实际上，电池输出看到的负载由电容和互连电阻组成。由于 NLDM 方法假设输出负载是纯电容性的，因此互连电阻成为一个问题。即使互连电阻不为零，当互连电阻的影响很小时，也可以使用这些 NLDM 模型。在存在电阻互连的情况下，延迟计算方法通过获得单元输出处的等效有效电容来改进 NLDM 模型。延迟计算工具中使用的“有效”电容方法获得等效电容，该电容在单元的输出端具有与具有 RC 互连的单元相同的延迟。有效电容方法在第 5.2 节中作为延迟计算的一部分进行了描述。</p>
<p>​ 随着特征尺寸的缩小，由于波形变得高度非线性，互连电阻的影响会导致很大的不准确性。各种建模方法为单元输出驱动器提供了额外的精度。从广义上讲，这些方法通过等价电流源驱动的输出状态建模获得更高的精度。</p>
<p>这些方法的示例是 - CCS（Composite Current Source复合电流源）或 ECSM（Effective<br>
Current Source Model有效电流源模型）。例如，CCS 时序模型通过使用随时间变化和电压相关的电流源为单元输出驱动器建模提供了额外的精度。通过指定不同场景下接收器引脚电容1和输出充电电流的详细模型来提供时序信息。接下来描述 CCS 模型的细节。</p>
<h3 id="接收器引脚电容receiver-pin-capacitance">接收器引脚电容（Receiver Pin Capacitance）</h3>
<p>​ 接收器引脚电容对应于为 NLDM 模型指定的输入引脚电容。与 NLDM 模型的引脚电容不同，CCS 模型允许在转换波形的不同部分分别指定接收器电容。由于互连 RC 和等效输入非线性电容（由于来自单元内输入设备的米勒效应），接收器电容值在转换波形上的不同点发生变化。因此，该电容在波形的初始（或前导）部分与波形的尾随部分被不同地建模。</p>
<p>​ 接收器引脚电容可以在引脚级别指定（如在 NLDM 模型中），其中通过该引脚的所有时序弧都使用该电容值。或者，接收器电容可以在定时弧级指定，在这种情况下，可以为不同的定时弧指定不同的电容模型。下面描述这两种指定接收器引脚电容的方法。</p>
<p><strong>在引脚级别指定电容</strong></p>
<p>当在引脚级别指定时，接下来给出接收器引脚电容的一维表规范示例。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (IN) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">receiver_capacitance1_rise (&quot;Lookup_table_4&quot;) &#123;</span><br><span class="line"></span><br><span class="line">index_1: (<span class="string">&quot;0.1, 0.2, 0.3, 0.4&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>(&quot;<span class="number">0.001040</span>, <span class="number">0.001072</span>, <span class="number">0.001074</span>, <span class="number">0.001085</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ index_1 指定该引脚输入转换时间的索引。一维表中的value指定了波形前导部分输入引脚处上升波形的接收器电容。</p>
<p>​ 上面显示的receiver_capacitance1_rise 类似，receiver_capacitance2_rise 指定输入上升波形尾部的上升电容。下降电容（下降输入波形的引脚电容）分别由属性receiver_capacitance1_fall 和receiver_capacitance2_fall 指定。</p>
<p><strong>在定时电弧级别指定电容</strong></p>
<p>​ 接收器引脚电容也可以用时序弧指定为输入转换时间和输出负载的二维表。下面给出了时序弧级别的规范示例。此示例指定了引脚 IN 波形前导部分的接收器引脚上升电容，作为输入引脚 IN 的转换时间和输出引脚 OUT 的负载的函数。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN&quot;</span> ;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">receiver_capacitance1_rise (&quot;Lookup_table_4x4&quot;) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">index_1</span>(&quot;<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>&quot;); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">index_2</span>(&quot;<span class="number">0.01</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.8</span>&quot;); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">values</span>(&quot;<span class="number">0.001040</span> , <span class="number">0.001072</span> , <span class="number">0.001074</span> , <span class="number">0.001075</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.001148</span> , <span class="number">0.001150</span> , <span class="number">0.001152</span> , <span class="number">0.001153</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.001174</span> , <span class="number">0.001172</span> , <span class="number">0.001172</span> , <span class="number">0.001172</span>&quot;, \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.001174</span> , <span class="number">0.001171</span> , <span class="number">0.001177</span> , <span class="number">0.001174</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上面的例子指定receiver_capacitance1_rise 的模型。该库包括receiver_capacitance2_rise、receiver_capacitance1_fall 和receiver_capacitance2_fall 规范的类似定义。</p>
<p>上面的例子指定了receiver_capacitance1_rise 的模型。该库包括receiver_capacitance2_rise、receiver_capacitance1_fall 和receiver_capacitance2_fall 规范的类似定义。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811165515440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="输出电流">输出电流</h3>
<p>​ 在 CCS 模型中，非线性时序用输出电流表示。输出电流信息被指定为依赖于输入转换时间和输出负载的查找表。</p>
<p>​ 输出电流针对输入转换时间和输出电容的不同组合而指定。对于这些组合中的每一个，都指定输出电流波形。本质上，这里的波形是指指定为时间函数的输出电流值。使用output_current_fall 指定的下降输出波形的输出电流示例如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN&quot;</span> ;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">output_current_fall () &#123;</span><br><span class="line"></span><br><span class="line">    vector (&quot;LOOKUP_TABLE_1x1x5&quot;) &#123;</span><br><span class="line"></span><br><span class="line">    reference_time : <span class="number">5.06</span>; <span class="comment">/* Time of input crossing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    threshold */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">index_1</span>(&quot;<span class="number">0.040</span>&quot;); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">index_2</span>(&quot;<span class="number">0.900</span>&quot;); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">index_3</span>(&quot;<span class="number">5.079</span>e+<span class="number">00</span>, <span class="number">5.093</span>e+<span class="number">00</span>, <span class="number">5.152</span>e+<span class="number">00</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">5.170</span>e+<span class="number">00</span>, <span class="number">5.352</span>e+<span class="number">00</span>&quot;);<span class="comment">/* Time values */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output charging current: */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">values</span>(&quot;-<span class="number">5.784</span>e-<span class="number">02</span>, -<span class="number">5.980</span>e-<span class="number">02</span>, -<span class="number">5.417</span>e-<span class="number">02</span>,</span><br><span class="line"></span><br><span class="line">    -<span class="number">4.257</span>e-<span class="number">02</span>, -<span class="number">2.184</span>e-<span class="number">03</span>&quot;);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ reference_time 属性是指输入波形越过延迟阈值的时间。 index_1 和 index_2 是指输入转换时间和使用的输出负载，index_3 是时间。 index_1 和 index_2（输入转换时间和输出电容）只能有一个值。 index_3 是指时间值，表值是指相应的输出电流。因此，对于给定的输入转换时间和输出负载，可以使用作为时间函数的输出电流波形。还指定了其他输入转换时间和输出电容组合的附加查找表。</p>
<p>​ 使用 output_current_rise 指定的上升输出波形的输出电流的描述类似。</p>
<h3 id="模型串扰噪声分析models-for-crosstalk-noise-analysis">模型串扰噪声分析（Models for Crosstalk Noise Analysis）</h3>
<p>​ 本节介绍用于串扰噪声（或毛刺glitch）分析的 CCS 模型。这些被描述为 CCSN（CCS noise）模型。 CCS noise模型是结构模型，代表单元内不同的 CCB（Channel Connected Blocks通道连接块）。</p>
<p>​ 什么是CCB？ CCB是指单元的源漏通道连接部分。例如，单级单元（如反相器、与非单元和非单元）仅包含一个 CCB——整个单元通过使用一个通道连接区域连接。多级单元，例如和单元，或或单元，包含多个 CCB。</p>
<p>​ CCSN 模型通常指定为由单元输入驱动的第一个 CCB，以及驱动单元输出的最后一个 CCB。这些是使用稳态电流、输出电压和传播噪声模型指定的。</p>
<p>​ 对于单级组合单元，如 nand 和 nor 单元，CCS 噪声模型是为每个时序弧指定的。这些单元只有一个 CCB，因此模型是从单元的输入引脚到输出引脚。</p>
<p>​ 下面描述了一个 nand 单元的示例模型：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123; <span class="comment">/* First stage CCB */</span></span><br><span class="line"></span><br><span class="line">is_needed : true;</span><br><span class="line"></span><br><span class="line">stage_type : both; <span class="comment">/*CCB contains pull-up and pull-down*/</span></span><br><span class="line"></span><br><span class="line">is_inverting : true;</span><br><span class="line"></span><br><span class="line">miller_cap_rise : <span class="number">0.8</span>;</span><br><span class="line"></span><br><span class="line">miller_cap_fall : <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">dc_current (ccsn_dc) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;-<span class="number">0.9</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.35</span>, <span class="number">1.8</span>&quot;); <span class="comment">/* Input voltage */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;-<span class="number">0.9</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.35</span>, <span class="number">1.8</span>&quot;); <span class="comment">/* Output voltage*/</span></span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">1.56</span>, <span class="number">0.42</span>, . . .&quot;); <span class="comment">/* Current at output pin */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">output_voltage_rise () &#123;</span><br><span class="line"></span><br><span class="line">vector (ccsn_ovrf) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.01</span>&quot;); <span class="comment">/* Rail-to-rail input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.001</span>&quot;); <span class="comment">/* Output net capacitance */</span></span><br><span class="line"></span><br><span class="line">index_3 (&quot;<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.8</span>&quot;); <span class="comment">/* Time */</span></span><br><span class="line"></span><br><span class="line">values (&quot;<span class="number">0.27</span>, <span class="number">0.63</span>, <span class="number">0.81</span>&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">output_voltage_fall () &#123;</span><br><span class="line"></span><br><span class="line">vector (ccsn_ovrf) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.01</span>&quot;); <span class="comment">/* Rail-to-rail input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.001</span>&quot;); <span class="comment">/* Output net capacitance */</span></span><br><span class="line"></span><br><span class="line">index_3 (&quot;<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>&quot;); <span class="comment">/* Time */</span></span><br><span class="line"></span><br><span class="line">values (&quot;<span class="number">0.81</span>, <span class="number">0.63</span>, <span class="number">0.27</span>&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">propagated_noise_low () &#123;</span><br><span class="line"></span><br><span class="line">vector (ccsn_pnlh) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.5</span>&quot;); <span class="comment">/* Input glitch height */</span></span><br><span class="line"></span><br><span class="line">index_2 (&quot;<span class="number">0.6</span>&quot;); <span class="comment">/* Input glitch width */</span></span><br><span class="line"></span><br><span class="line">index_3 (&quot;<span class="number">0.05</span>&quot;); <span class="comment">/* Output net capacitance */</span></span><br><span class="line"></span><br><span class="line">index_4 (&quot;<span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.7</span>&quot;); <span class="comment">/* Time */</span></span><br><span class="line"></span><br><span class="line">values (&quot;<span class="number">0.19</span>, <span class="number">0.23</span>, <span class="number">0.19</span>, <span class="number">0.11</span>&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">propagated_noise_high () &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 我们现在描述 CCS noise模型的属性。属性 ccsn_first_stage 表示该模型用于 nand 单元的第一阶段 CCB。如前所述，nand cell只有一个CCB。属性 is_needed 几乎总是正确的，但对于非功能性单元（例如称重单元和天线单元）的除外。值为 both 的 stage_type 指定此阶段具有上拉和下拉结构。 miller_cap_rise 和 miller_cap_fall 分别代表上升和下降输出转换的<strong>米勒电容</strong>。</p>
<p><em>由于输入和输出端子之间的电容放大，米勒电容解释了反相级等效输入电容的增加。</em></p>
<p><strong>直流电流（DC Current）</strong></p>
<p>​ dc_current 表代表输入和输出引脚电压的不同组合的输出引脚上的直流电流。 index_1 指定输入电压，index_2 指定输出电压。二维表中的值指定了 CCB 输出端的直流电流。输入电压和输出电流均以库单位指定（通常为Volt 和 mA）。对于从输入 IN1 到 nand 单元的 OUT 的示例 CCS 噪声模型，-0.9V 的输入电压和 0V 的输出电压导致输出端的直流电流为 0.42mA。</p>
<p><strong>输出电压（Output Voltage）</strong></p>
<p>​ output_voltage_rise 和 output_voltage_fall 结构分别包含 CCB 输出上升和下降的时序信息。这些被指定为 CCB 输出节点的多维表。多维表被组织成多个表，指定不同input transition time和output net capacitances的上升和下降输出电压。每个表都有 index_1 指定rail-to-rail 输入转换时间速率，index_2 指定输出净电容。 index_3 指定输出电压跨越特定阈值点的次数（在本例中为 0.9V 的 Vdd 电源的 30%、70% 和 90%）。在每个多维表中，电压交叉点是固定的，在index_3中指定了CCB输出节点与电压交叉时的时间值。</p>
<p><strong>传播噪声（Propagated Noise）</strong></p>
<p>​ 传播噪声高和传播噪声低模型指定多维表，这些表通过 CCB 提供噪声传播信息。这些模型表征从 CCB 输入到输出的串扰毛刺（或噪声）传播。表征在输入端使用对称三角波。传播噪声的多维表被组织成多个表，指定 CCB 输出端的毛刺波形。这些多维表包含：</p>
<ul>
<li>input glitch magnitude (in index_1),</li>
<li>input glitch width (in index_2),</li>
<li>CCB output net capacitance (in index_3), and</li>
<li>time (in index_4).</li>
</ul>
<p>​ CCB 输出电压（或通过 CCB 传播的噪声）在表中指定。</p>
<p><strong>两级单元的噪声模型（Noise Models for Two-Stage Cells）</strong></p>
<p>​ 就像单级单元一样，两级单元（例如and cells 和 or cells）的 CCS 噪声模型通常被描述为时序弧的一部分。由于这些单元包含两个单独的 CCB，噪声模型分别为 ccsn_first_stage 和另一个为 ccsn_last_stage 指定。例如，对于双输入and单元，CCS 噪声模型由第一阶段和最后阶段的单独模型组成。这在接下来说明。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (OUT) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN1 to internal node between stages */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123; <span class="comment">/* Internal node to output */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timing () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;IN2&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN2 to internal node between stages */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internal node to output */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same as from IN1 */</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>
<p>为 IN2 指定的 ccsn_last_stage 中的模型与为 IN1 描述的 ccsn_last_stage 中的模型相同。</p>
<p><strong>多级和顺序单元的噪声模型（Noise Models for Multi-stage and Sequential Cells）</strong></p>
<p>​ 复杂组合或顺序单元的 CCS 噪声模型通常作为引脚规范的一部分进行描述。这不同于单级或两级单元，如 nand、nor 和，或者 CCS 噪声模型通常在引脚对基础上指定为时序弧的一部分。复杂的多级和顺序单元通常由所有输入引脚的 ccsn_first_stage 模型和输出引脚的另一个 ccsn_last_stage 模型描述。这些单元的 CCS 噪声模型不是时序弧的一部分，但通常是为引脚指定的。</p>
<p>​ 如果输入和输出之间的内部路径多达两个 CCB 级，噪声模型也可以表示为引脚对时序弧的一部分。通常，多级单元描述可以将一些 CCS 噪声模型指定为引脚对时序弧的一部分，而其他一些噪声模型可以通过引脚描述指定。</p>
<p>​ 下面的示例具有使用引脚描述以及部分时序弧指定的 CCS 噪声模型。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (CDN) &#123;</span><br><span class="line"></span><br><span class="line">        . . .</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">pin (CP) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">pin (D) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">pin (Q) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CDN&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_first_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pin (QN) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="built_in">ccsn_last_stage</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    . . .</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​ 请注意，上面触发器单元的一些 CCS 模型是用引脚定义的。那些在输入引脚上定义的引脚规范被指定为 ccsn_first_stage，输出引脚 QN 的 CCS 模型被指定为 ccsn_last_stage。此外，两级 CCS 噪声模型被描述为 CDN 到 Q 的时序弧的一部分。因此，此示例表明单元可以将 CCS 模型指定为引脚规范的一部分和时序组的一部分。</p>
<h3 id="其他噪声模型">其他噪声模型</h3>
<p>​ 除了上述 CCS noise模型外，一些单元库还可以提供其他模型来表征噪声。其中一些模型在 CCS noise模型出现之前就在使用了。如果 CCS noise模型可用，则不需要这些附加模型。为了完整性，我们在下面描述了一些早期的噪声模型。</p>
<p>​ DC 裕度模型（Models for DC margin）：DC 裕度是指单元输入引脚允许的最大 DC 变化，它可以使单元保持稳定状态，即不会在输出端引起毛刺。例如，输入低电平的直流裕度是指输入引脚处的最大直流电压值，而不会在输出端引起任何转换。</p>
<p>​ 抗噪模型（Models for noise immunity）：抗噪模型指定输入引脚允许的毛刺幅度。这些通常根据以毛刺宽度和输出电容作为两个指标的二维表来描述。表中的值对应于输入引脚允许的毛刺幅度。这意味着任何小于指定幅度和宽度的毛刺都不会通过单元传播。可以指定抗噪模型的不同变体，例如：</p>
<ul>
<li>noise_immunity_high</li>
<li>noise_immunity_low</li>
<li>noise_immunity_above_high (overshoot)</li>
<li>noise_immunity_below_low (undershoot).</li>
</ul>
<h2 id="功耗建模power-dissipation-modeling">功耗建模（Power Dissipation Modeling）</h2>
<p>​ 单元库包含与单元中的功耗相关的信息。这包括有功功率以及待机或泄漏功率。顾名思义，有功功率与设计中的活动有关，而待机功率是在待机模式下消耗的功率，这主要是由于泄漏造成的。</p>
<h3 id="有功功率active-power">有功功率（Active Power）</h3>
<p>​ 有功功率与单元输入和输出引脚的活动有关。单元中的有功功率来自输出负载的充电以及内部开关。这两者通常分别称为output switching power 和 internal switching power。</p>
<p>​ 输出开关功率（output switching power）与单元类型无关，仅取决于输出容性负载、开关频率和单元的电源。内部开关功率取决于单元的类型，因此该值包含在单元库中。下面描述库中内部开关电源的规格。</p>
<p>​ 内部开关电源在单元库中称为 internal power。这是当单元的输入或输出有活动时单元内的功耗。对于组合电池，输入引脚转换会导致输出切换，从而产生内部开关电源。例如，只要输入切换（在输入处有上升或下降转换），逆变器单元就会消耗功率。库中的内部电源描述为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">pin (<span class="variable constant_">Z1</span>) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">power_down_function : <span class="string">&quot;!VDD + VSS&quot;</span>;</span><br><span class="line"></span><br><span class="line">related_power_pin : <span class="variable constant_">VDD</span>;</span><br><span class="line"></span><br><span class="line">related_ground_pin : <span class="variable constant_">VSS</span>;</span><br><span class="line"></span><br><span class="line">internal_power () &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line">power (template_2x2) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.1, 0.4&quot;</span>); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.05, 0.1&quot;</span>); <span class="comment">/* Output capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/*  0.05  0.1 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.1 */</span>  <span class="string">&quot;0.045, 0.050&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.4 */</span>  <span class="string">&quot;0.055, 0.056&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 上例显示了从输入引脚 A 到电池输出引脚 Z1 的功耗。模板中的 2x2 表是根据引脚 A 的输入转换和引脚 Z1 的输出电容。请注意，虽然该表包括输出电容，但表中的值仅对应于内部开关，不包括输出电容的贡献。这些值代表每个开关转换（上升或下降）在电池中耗散的内部能量。这些单位源自库中的其他单位（通常电压以伏特 (V) 为单位，电容以皮法 (pF) 为单位，这映射到以皮焦 (pJ) 为单位的能量）。因此，库中的内部功率实际上指定了每次转换消耗的内部能量。</p>
<p>​ 除了功率表之外，上面的示例还说明了电源引脚、接地引脚和断电功能的规范，该功能指定了电池可以断电的条件。这些构造允许在不同电源可能断电的设计和场景中使用多个电源。下图显示了每个单元的电源引脚规格。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">cell (NAND2) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">pg_pin (VDD) &#123;</span><br><span class="line"></span><br><span class="line">pg_type : primary_power;</span><br><span class="line"></span><br><span class="line">voltage_name : COREVDD1;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pg_pin (VSS) &#123;</span><br><span class="line"></span><br><span class="line">pg_type : primary_ground;</span><br><span class="line"></span><br><span class="line">voltage_name : COREGND1;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 电源规范语法允许单独构造上升和下降功率（指输出检测）。就像时序弧一样，功率规范也可以与状态相关。例如，异或单元的状态相关功耗可以指定为依赖于各种输入的状态。</p>
<p>​ 对于组合单元，开关功率是在输入输出引脚对的基础上指定的。然而，对于具有互补输出 Q 和 QN 的触发器等时序单元，CLK-&gt;Q 转换也会导致 CLK-&gt;QN 转换。因此，库可以将内部开关功率指定为一个三维表，如下所示。下面示例中的三个维度分别是 CLK 的输入压摆和 Q 和 QN 的输出电容。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">pin (Q) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="title function_">internal_power</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;CLK&quot;</span>;</span><br><span class="line"></span><br><span class="line">equal_or_opposite_output : <span class="string">&quot;QN&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">rise_power</span>(<span class="params">energy_template_3x2x2</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.02, 0.2, 1.0&quot;</span>); <span class="comment">/* Clock transition */</span></span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.005, 0.2&quot;</span>); <span class="comment">/* Output Q capacitance */</span></span><br><span class="line"></span><br><span class="line">index_3 (<span class="string">&quot;0.005, 0.2&quot;</span>); <span class="comment">/* Output QN capacitance */</span></span><br><span class="line"></span><br><span class="line">values ( <span class="comment">/* 0.005  0.2 */</span> <span class="comment">/*  0.005  0.2 */</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.02 */</span> <span class="string">&quot;0.060, 0.070&quot;</span>,  <span class="string">&quot;0.061,  0.068&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0.2 */</span> <span class="string">&quot;0.061, 0.071&quot;</span>,  <span class="string">&quot;0.063,  0.069&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.0 */</span> <span class="string">&quot;0.062, 0.080&quot;</span>,  <span class="string">&quot;0.068,  0.075&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fall_power</span>(<span class="params">energy_template_3x2x2</span>) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (<span class="string">&quot;0.02, 0.2, 1.0&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_2 (<span class="string">&quot;0.005, 0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">index_3 (<span class="string">&quot;0.005, 0.2&quot;</span>);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.070, 0.080&quot;</span>, <span class="string">&quot;0.071, 0.078&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.071, 0.081&quot;</span>, <span class="string">&quot;0.073, 0.079&quot;</span>, \</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0.066, 0.082&quot;</span>, <span class="string">&quot;0.068, 0.085&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 即使输出或内部状态没有转换，也可以消耗开关功率。一个常见的例子是在触发器的时钟引脚上切换的时钟。触发器在每次时钟切换时消耗功率 - 通常是由于触发器单元内部的反相器的切换。即使触发器输出不切换，时钟引脚切换引起的功率也会耗散。因此，对于时序单元，输入引脚功率是指单元内部的功耗，即输出不转换时的功耗。下面是输入引脚电源规格的示例。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">cell (DFF) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">pin (CLK) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">rise_power () &#123;</span><br><span class="line"></span><br><span class="line">power (template_3x1) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.4</span>&quot;); <span class="comment">/* Input transition */</span></span><br><span class="line"></span><br><span class="line">values ( /*  <span class="number">0.1</span>  <span class="number">0.25</span>  <span class="number">0.4</span> */ \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.045</span>, <span class="number">0.050</span>,  <span class="number">0.090</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fall_power () &#123;</span><br><span class="line"></span><br><span class="line">power (template_3x1) &#123;</span><br><span class="line"></span><br><span class="line">index_1 (&quot;<span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.4</span>&quot;);</span><br><span class="line"></span><br><span class="line">values ( \</span><br><span class="line"></span><br><span class="line">&quot;<span class="number">0.045</span>, <span class="number">0.050</span>, <span class="number">0.090</span>&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 此示例显示了 CLK 引脚切换时的电源规格。这表示即使输出不切换时时钟切换导致的功耗。</p>
<p><strong>时钟引脚的功率是否被重复计算了（Double Counting Clock Pin Power?）</strong></p>
<p>​ 请注意，触发器还包含由于 CLK-&gt;Q 转换引起的功耗。因此，重要的是 CLK-&gt;Q 功率规格表中的值不包括由于对应于输出 Q 不切换时的条件的 CLK 内部功率的贡献。</p>
<p>​ 上述准则是指应用工具使用功率表的一致性，并确保在功率计算过程中不会重复计算由于时钟输入而指定的内部功率。</p>
<h3 id="泄露功率leakage-power">泄露功率（Leakage Power）</h3>
<p>​ 大多数标准单元都设计为仅在输出或状态发生变化时才耗散功率。当电池通电但没有活动时消耗的任何功率都是由于非零泄漏电流。泄漏可能是由于 MOS 器件的亚阈值电流或由于通过栅极氧化物的隧道电流。在前几代 CMOS 工艺技术中，漏电功率一直可以忽略不计，在设计过程中也不是主要考虑因素。然而，随着技术的缩小，泄漏功率变得越来越重要，与有功功率相比不再可以忽略不计。</p>
<p><em>高 Vt 单元是指阈值电压高于工艺技术标准的单元。</em></p>
<p>​ 上所述，泄漏功率贡献来自两种现象：MOS 器件中的亚阈值电流和栅极氧化物隧穿。通过使用高 Vt 单元，可以降低亚阈值电流；然而，由于高 Vt 单元的速度降低，因此需要进行权衡。高 Vt 单元具有较小的泄漏但速度较慢。类似地，低 Vt 单元具有更大的泄漏但允许更快的速度。通过切换到高（或低）Vt 单元，栅极氧化物隧道效应不会显着改变。因此，控制泄漏功率的一种可能方式是使用高 Vt 单元。与高 Vt 和标准 Vt 单元之间的选择类似，设计中使用的单元强度是泄漏和速度之间的权衡。更高强度的单元具有更高的泄漏功率，但提供更高的速度。与电源管理相关的权衡在第 10.6 节中详细描述。</p>
<p>​ 亚阈值 MOS 泄漏与温度具有很强的非线性相关性。在大多数工艺技术中，随着器件结温从 25C 增加到 125C，亚阈值泄漏会增加 10 到 20 倍。栅极氧化物隧道效应的贡献相对于温度或器件的 Vt 而言是相对不变的。在 100 纳米及以上工艺技术中可忽略不计的栅极氧化物隧道效应，已成为 65 纳米或更精细技术在较低温度下泄漏的重要因素。例如，对于 65nm 或更精细的工艺技术，栅极氧化物隧道泄漏可能等于室温下的亚阈值泄漏。在高温下，亚阈值泄漏仍然是泄漏功率的主要贡献者。</p>
<p>​ 为库中的每个单元指定了泄漏功率。例如，逆变器单元可能包含以下规格：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">cell_leakage_power : <span class="number">1.366</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这是单元中耗散的泄漏功率 - 泄漏功率单位在库的标题中指定，通常以纳瓦为单位。通常，泄漏功率取决于单元的状态，并且可以使用 when 条件指定状态相关值。</p>
<p>​ 例如，INV1 单元格可以具有以下规范：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">cell_leakage_power : <span class="number">0.70</span>;</span><br><span class="line"></span><br><span class="line">leakage_power() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!I&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">1.17</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leakage_power() &#123;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;I&quot;</span>;</span><br><span class="line"></span><br><span class="line">value : <span class="number">0.23</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 其中 I 是 INV1 单元的输入引脚。应该注意的是，规范包括一个默认值（在when条件之外），并且默认值通常是在when条件内指定的泄漏值的平均值。</p>
<h2 id="单元库其他属性other-attributes-in-cell-library">单元库其他属性（Other Attributes in Cell Library）</h2>
<p>​ 除了时序信息之外，库中的单元描述还指定了时序弧的区域、功能和 SDF 条件。本节简要介绍了这些内容；有关更多详细信息，请参阅 Liberty 手册。</p>
<p><strong>面积规格（Area Specification）</strong></p>
<p>​ area规范提供了一个单元格或单元格组的面积。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">area : <span class="number">2.35</span>;</span><br></pre></td></tr></table></figure>
<p>​ 以上指定单元格的面积为 2.35 个面积单位。这可以代表单元使用的实际硅面积，也可以是面积的相对量度。</p>
<p><strong>功能规格（Function Specification）</strong></p>
<p>​ function规范指定引脚（或引脚组）的功能。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">pin (Z) &#123;</span><br><span class="line"></span><br><span class="line">function: <span class="string">&quot;IN1 &amp; IN2&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 以上指定了两个输入and单元的 Z 引脚的功能。</p>
<p><strong>SDF条件（SDF Condition）</strong></p>
<p>​ SDF 条件属性支持标准延迟格式 (SDF) 文件生成和反注释期间的条件匹配。正如when为时序分析的状态相关模型指定条件一样，SDF注释的状态相关时序使用的相应规范由sdf_cond表示。</p>
<p>​ 以下示例说明了这一点：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">related_pin : <span class="string">&quot;A1&quot;</span>;</span><br><span class="line"></span><br><span class="line">when : <span class="string">&quot;!A2&quot;</span>;</span><br><span class="line"></span><br><span class="line">sdf_cond : <span class="string">&quot;A2 == 1&#x27;b0&quot;</span>;</span><br><span class="line"></span><br><span class="line">timing_sense : positive_unate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cell_rise</span>(delay_template_7x7) &#123;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表征和操作条件characterization-and-operating-conditions">表征和操作条件（Characterization and Operating Conditions）</h2>
<p>单元库指定了创建库的特征和操作条件。例如，库的标题可能包含以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">nom_process : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">nom_temperature : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nom_voltage : <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">voltage_map(COREVDD1, <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">voltage_map(COREGND1, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">operating_conditions(&quot;BCCOM&quot;)&#123;</span><br><span class="line"></span><br><span class="line">process : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">temperature : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">voltage : <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">tree_type : <span class="string">&quot;balanced_tree&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 标称环境条件（指定为 nom_process、nom_temperature 和 nom_voltage）指定了表征库的过程、电压和温度。操作条件指定使用该库中的单元的条件。如果特性和工作条件不同，延迟计算时得到的时序值需要降额；这是通过使用库中指定的降额因子（k 因子）来实现的。</p>
<p>​ 在不同于用于表征的条件下使用降额获得时序值会导致时序计算不准确。仅当在感兴趣的条件下表征库不可行时才采用降额程序。</p>
<p><strong>什么是过程变量？（What is the Process Variable?）</strong></p>
<p>​ 与作为物理量的温度和电压不同，该过程不是可量化的量。出于数字表征和验证的目的，它可能是一种缓慢、典型或快速的过程。因此， 1.0（或任何其他值）的过程值是什么意思？答案如下。</p>
<p>​ 库表征是一个耗时的过程，并且表征不同工艺角的库可能需要数周时间。过程变量设置允许使用以特定过程角为特征的库用于不同过程角的时序计算。过程的 k 因子可用于降低从特征过程到目标过程的延迟。如上所述，降额因子的使用会在时序计算过程中引入不准确性。跨工艺条件降额特别不准确，很少使用。总而言之，指定不同过程值（例如 1.0 或任何其他值）的唯一功能是允许在很少（如果曾经）使用的条件下降额。</p>
<h3 id="使用k因子降额">使用K因子降额</h3>
<p>​ 如上所述，降额因子（称为 k 因子）用于在操作条件与特征条件不同时获得延迟。 k 因子是近似因子。库中 k 因子的示例如下所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* k-factors */</span></span><br><span class="line"></span><br><span class="line">k_process_cell_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_cell_leakage_power : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_cell_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_fall_transition : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_hold_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_hold_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_internal_power : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_min_pulse_width_high : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_min_pulse_width_low : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_pin_cap : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_recovery_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_recovery_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_rise_transition : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_setup_fall : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_setup_rise : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">k_process_wire_cap : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_process_wire_res : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_temp_cell_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_cell_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_fall_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_temp_hold_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_hold_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_min_pulse_width_high : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_min_pulse_width_low : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_min_period : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_rise_propagation : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_fall_propagation : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_recovery_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_recovery_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_rise_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_temp_setup_fall : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_temp_setup_rise : <span class="number">0.0012</span>;</span><br><span class="line"></span><br><span class="line">k_volt_cell_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_cell_rise : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_fall_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_volt_hold_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_hold_rise : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_min_pulse_width_high : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_min_pulse_width_low : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_min_period : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_rise_propagation : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_fall_propagation : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_recovery_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_recovery_rise : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_rise_transition : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">k_volt_setup_fall : -<span class="number">0.42</span>;</span><br><span class="line"></span><br><span class="line">k_volt_setup_rise : -<span class="number">0.42</span>;</span><br></pre></td></tr></table></figure>
<p>​ 这些因素用于在延迟计算期间操作条件的过程、电压或温度与库中的标称条件不同时获得时序。请注意，k_volt 因子为负，这意味着延迟随着电压供应的增加而减少，而 k_temp 因子是正的，这意味着延迟通常随着温度的升高而增加（除了在 2.10 节中描述的表现出温度反转现象的电池）。 k 因子的使用方法如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">Result with derating = Original_value *</span><br><span class="line"></span><br><span class="line">( 1 + k_process * DELTA_Process</span><br><span class="line"></span><br><span class="line"><span class="addition">+ k_volt * DELTA_Volt</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ k_temp * DELTA_Temp)</span></span><br></pre></td></tr></table></figure>
<p>​ 例如，假设一个库在 1.08V 和 125C 下具有慢速过程模型。如果要获得 1.14V 和 100C 的延迟，则慢速工艺模型的单元上升延迟可通过下式获得：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Derated_delay = Library_delay *</span><br><span class="line"></span><br><span class="line">( <span class="number">1</span> + k_volt_cell_rise * 0.06</span><br><span class="line"></span><br><span class="line">- k_temp_cell_rise * <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>​ 假设使用了上面概述的 k_factors，则前面的等式映射为：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Derated_delay = Library_delay * (<span class="number">1</span> - <span class="number">0.42</span> * 0.06 - 0.0012 * <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">= Library_delay * <span class="number">0.9448</span></span><br></pre></td></tr></table></figure>
<p>​ 降额条件下的延迟计算为原始延迟的 94.48%。</p>
<h3 id="库单元library-units">库单元（Library Units）</h3>
<p>​ 单元描述具有库单位方面的所有值。这些单位是使用 Liberty 命令集在库文件中声明的。电压、时间、电容和电阻的单位声明如下例所示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">library(&quot;my_cell_library&quot;) &#123;</span><br><span class="line"></span><br><span class="line">voltage_unit : <span class="string">&quot;1V&quot;</span>;</span><br><span class="line"></span><br><span class="line">time_unit : <span class="string">&quot;1ns&quot;</span>;</span><br><span class="line"></span><br><span class="line">capacitive_load_unit (<span class="number">1.000000</span>, pf);</span><br><span class="line"></span><br><span class="line">current_unit : <span class="number">1</span>mA;</span><br><span class="line"></span><br><span class="line">pulling_resistance_unit : <span class="string">&quot;1kohm&quot;</span>;</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在本文中，我们假设库时间单位以纳秒 (ns) 为单位，电压以伏特 (V) 为单位，每次跃迁的内部功率以皮焦 (pJ) 为单位，泄漏功率以纳瓦 (nW) 为单位，电容值为以皮法 (pF) 为单位，电阻值以 Kohms 为单位，面积单位为平方微米 (mm2)，除非明确指定以帮助解释。</p>
<h1 id="互连寄生interconnect-parasitics">互连寄生（Interconnect Parasitics）</h1>
<blockquote>
<p>​ 本章概述了处理和表示互连寄生的各种技术，用于设计的时序验证。</p>
</blockquote>
<p>在数字设计中，<strong>连接标准单元和模块引脚的导线称为网络（net）</strong>。net通常只有一个驱动，而它可以驱动多个扇出单元或块。物理实现后，net可以在芯片的多个金属层上移动。不同的金属层可以有不同的电阻和电容值。对于等效电学表示，通常将net分成若干段，每个段由等效寄生参数表示。我们将互连迹线（interconnect trace）称为段的同义词，也就是说，它是特定金属层上网络的一部分。</p>
<h2 id="互连rlcrlc-for-interconnect">互连RLC（RLC for Interconnect ）</h2>
<p>​ 互连电阻来自设计实现中各种金属层和通孔中的互连走线。图 4-1 显示了穿过各种金属层和通孔的示例网络。因此，互连电阻可以被认为是单元的输出引脚和扇出单元的输入引脚之间的电阻。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811223318663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 互连电容的贡献也来自金属走线，包括接地电容以及相邻信号路径之间的电容。</p>
<p>​ 电感是由电流回路引起的。通常，电感的影响在芯片内可以忽略，仅在封装和板级分析时考虑。在芯片级设计中，电流回路又窄又短——这意味着电流返回路径是通过靠近布线的电源或接地信号。在大多数情况下，时序分析不考虑片上电感。对片上电感分析的任何进一步描述超出了本书的范围。接下来描述互连电阻和电容的表示。</p>
<p>​ 一段互连走线的电阻和电容 (RC) 理想地由分布式 RC 树表示，如图 4-2 所示。在该图中，RC 树的总电阻和电容 - 分别为 Rt 和 Ct -—对应于 Rp* L 和 Cp* L，其中 Rp、Cpare 每单位长度的走线互连电阻和电容值，L 是走线长度。 Rp、Cp 值通常从提取的各种配置的寄生参数中获得，由 ASIC 代工厂提供。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811224212859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Rt%3D%20Rp*%20L"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Ct%3D%20Cp*%20L"></p>
<p>​ RC 互连可以用各种简化模型表示。这些在下面的小节中进行了描述。</p>
<h3 id="t--model">T -model</h3>
<p>​ 在 T 模型表示中，总电容 Ct 建模为连接在电阻树的中间。总电阻 Rt 分为两部分（每部分都是 Rt/2），Ct连接在电阻树的中点，如图 4-3 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811224538943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="pi--model">Pi -model</h3>
<p>​ 在图 4-4 所示的 Pi 模型中，总电容 Ct 分为两部分（每部分为 Ct/2）并连接在电阻的任一侧。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811224759975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 更准确的分布RC树的表示是通过将Rt和Ct分解成多个部分得到的。对于分解成的N段，R和C的每一个中间段都是Rt/ N和Ct/ N。末端段可以按照T-model或Pi-model的概念建模。图4-5为末端段采用T-model的N段，图4-6为末端段采用Pi-model的N段。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811225427529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通过对 RC 互连建模的广泛概述，我们现在描述如何在<strong>布局前阶段（ pre-layout）（通过估计）或布局后阶段（post-layout）（通过详细提取）</strong>利用寄生互连。下一节描述了预布局过程中寄生互连的建模。</p>
<h2 id="线载模型wireload-models">线载模型（Wireload Models）</h2>
<p>​ 在布局规划或布局之前，线载模型可用于估计电容、电阻和互连引起的面积开销。线载模型用于根据网络的扇出数量估计网络的长度。线载模型取决于块的面积，不同面积的设计可以选择不同的线载模型。线载模型还将估计的网络长度映射到电阻、电容和相应的布线面积开销。</p>
<p>​ 块内的平均线长与块的大小密切相关；平均net长度随着块大小的增加而增加。图 4-7 显示，对于不同的区域（芯片或块大小），通常会使用不同的线载模型来确定寄生参数。因此，该图描绘了较小尺寸块的较小电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811225832869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是线载模型的示例。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">wire_load (“wlm_conservative”) &#123;</span><br><span class="line"></span><br><span class="line">resistance : <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">capacitance : <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">area : <span class="number">0.05</span>;</span><br><span class="line"></span><br><span class="line">slope : <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">1</span>, <span class="number">2.6</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">2</span>, <span class="number">2.9</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">3</span>, <span class="number">3.2</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">4</span>, <span class="number">3.6</span>);</span><br><span class="line"></span><br><span class="line">fanout_length (<span class="number">5</span>, <span class="number">4.1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ <strong>resistance</strong>是互连线单位长度的电阻值，<strong>capacitance</strong>是互连线单位长度的电容值，<strong>area</strong>是互连线单位长度的面积开销，<strong>slope</strong>是用于扇出-长度（<strong>fanout_length</strong>）表中未指定的数据点的外推斜率。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811230104270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 线载模型说明了如何将线的长度描述为扇出的函数。上面的例子如图 4-8 所示。对于表中未明确列出的任何扇出数，互连长度是使用具有指定斜率的线性外推法获得的。例如，扇出 8 会导致以下结果：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Length = 4.1 + (8 - 5) <span class="emphasis">* 0.5 = 5.6 units</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Capacitance = Length *</span> cap<span class="emphasis">_coeff(1.1) = 6.16 units</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Resistance = Length * res_</span>coeff(5.0) = 28.0 units</span><br><span class="line"></span><br><span class="line">Area overhead due to interconnect = Length <span class="emphasis">* area_coeff(0.05)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">= 0.28 area units</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">互连线长度 = 4.1 + （8 - 5） *</span> 0.5 = 5.6</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">电容值 = 5.6 <span class="emphasis">* 1.1 = 6.16</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">电阻值 = 5.6 *</span> 5 =28.0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">面积开销 = 5.6 <span class="emphasis">* 0.05 = 0.28</span></span><br></pre></td></tr></table></figure>
<p>​ length, capacitance, resistance 和 area的单位在liberty中指定。</p>
<h3 id="互连树interconnect-trees">互连树（Interconnect Trees）</h3>
<p>​ 一旦确定了预布局互连的电阻和电容估计值，比如 Rwire 和 Cwire，下一个问题就是互连的结构。互连RC结构如何相对于驱动单元定位？这很重要，因为从驱动引脚到负载引脚的互连延迟取决于互连的结构。通常，互连延迟取决于路径上的互连电阻和电容。因此，此延迟可能因网络所采用的拓扑而异。</p>
<p>​ 对于预布局估计，互连 RC 树可以使用以下三种不同表示法之一来表示（见图 4-9）。请注意，在三种情况中的每一种情况下，总互连长度（以及电阻和电容估计值）都相同。</p>
<ul>
<li>最佳情况树（Best-case tree）：</li>
</ul>
<p>​ 在最佳情况树中，假设目标（负载）引脚在物理上与驱动相邻。因此，在通向目标引脚的路径中，没有任何导线电阻。来自其他扇出引脚的所有导线电容和引脚电容仍充当驱动引脚上的负载。</p>
<ul>
<li>平衡树（ Balanced tree）：</li>
</ul>
<p>​ 在这种情况下，假设每个目标引脚都位于互连线的单独部分。到目的地的每条路径都会看到总导线电阻和电容的相等部分。</p>
<ul>
<li>最坏情况树（Worst-case tree）：</li>
</ul>
<p>​ 在这种情况下，假设所有目标引脚都位于线路的远端。因此，每个目标引脚都会看到总导线电阻和总导线电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231129319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="指定线载模型specifying-wireload-models">指定线载模型（Specifying Wireload Models）</h3>
<p>​ 使用以下命令指定线载模型：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_wire_load_model “wlm_cons” -library “lib_stdcell”</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令表示使用单元库lib_stdcell中的线负载模型wlm_cons</span></span><br></pre></td></tr></table></figure>
<p>​ 当网络跨越层次边界时，可以根据线载模式将不同的线载模型应用于每个层次边界中网络的不同部分。这些线载模式是：</p>
<ul>
<li>top</li>
<li>enclosed</li>
<li>segmented</li>
</ul>
<p>​ 可以使用 set_wire_load_mode 规范指定线载模式，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_wire_load_mode enclosed</span><br></pre></td></tr></table></figure>
<p>​ 在<strong>top</strong>线载模式下，层次结构内的所有网络都继承顶层的线载模型，即忽略低层模块中指定的任何线载模型。因此，顶级线载模型优先。对于图 4-10 所示的示例，块 B1 中指定的 wlm_cons 线载模型优先于块 B2、B3 和 B4 中指定的所有其他线载模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231729233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在<strong>enclosed</strong>线载模式下，完全包围网络的块的线载模型用于整个网络。对于图 4-11 所示的示例，网络 NETQ 包含在块 B2 中，因此块 B2 的线载模型 wlm_light 用于该网络。完全包含在块 B3 中的其他网络使用 wlm_aggr 线载模型，而完全包含在块 B5 中的网络使用 wlm_typ 线载模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231810122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在<strong>segmented</strong>线负载模式下，网络的每段（segment）都从包含该段的块中获取其线负载模型，网络的每个部分都在该层次内使用适当的线负载模型。图4-12举例说明了一个网络NETQ，它的三段分别在三个块中。B3块中此网络的扇出互连使用wlm_aggr线负载模型，B4块中使用wlm_typ线负载模型，B2块中使用wlm_light线负载模型。</p>
<p><img src="https://img-blog.csdnimg.cn/20210811231852215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通常，根据模块的芯片面积选择线载模型。但是，这些可以根据用户的判断进行修改或更改。例如，可以为 0 到 400 之间的块区域选择线载模型 wlm_aggr，为 400 到 1000 之间的区域选择线载模型 wlm_typ，以及为 1000 或更高的区域选择线载模型 wlm_cons。线载模型通常在单元库中定义 - 但是用户也可以定义自定义线载模型。可以选择在单元库中将默认线载模型指定为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">default_wire_load: <span class="string">&quot;wlm_light&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​ 在单元库中定义了基于面积选择线载模型的线载选择组。这是一个这样的例子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">wire_load_selection (WireAreaSelGrp)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">0</span>, <span class="number">50000</span>, &quot;wlm_light&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">50000</span>, <span class="number">100000</span>, &quot;wlm_cons&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">100000</span>, <span class="number">200000</span>, &quot;wlm_typ&quot;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wire_load_from_area</span>(<span class="number">200000</span>, <span class="number">500000</span>, &quot;wlm_aggr&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 一个单元库可以包含许多这样的选择组。通过使用 set_wire_load_selection_group 规范，可以选择特定的一个用于 STA。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_wire_load_selection_group WireAreaSelGrp</span><br></pre></td></tr></table></figure>
<p>​ 本节描述了在物理实现之前，即在预布局阶段期间对估计寄生参数的建模。下一节描述了从布局中提取的寄生参数的表示。</p>
<h2 id="提取寄生参数的表示representation-of-extracted-parasitics">提取寄生参数的表示（Representation of Extracted Parasitics）</h2>
<p>​ 从布局中提取的寄生参数可以用三种格式描述：</p>
<ul>
<li>详尽寄生参数格式 ：Detailed Standard Parasitic Format（DSPF）</li>
<li>精简寄生参数格式 ：Reduced Standard Parasitic Format（RSPF）</li>
<li>标准寄生参数格式 ：Standard Parasitic Extraction Format（SPEF）</li>
</ul>
<p>​ 一些工具提供了寄生生物的专有二进制表示，如SBPF；这有助于保持较小的文件大小，并加快工具对寄生生物的读取。下面简要介绍上述三种格式。</p>
<h3 id="详细标准寄生格式detailed-standard-parasitic-format">详细标准寄生格式（Detailed Standard Parasitic Format）</h3>
<p><em>电路模拟器可读的格式，如SPICE。更多信息，请参阅[NAG75]或任何关于模拟集成电路设计或模拟的书籍</em>。</p>
<p>​ 使用DSPF格式时，详尽的寄生参数以<strong>SPICE</strong>格式表示。<strong>SPICE</strong>中的Comment语句用于表明单元类型、单元引脚及其电容。电阻和电容值采用标准<strong>SPICE</strong>语法，并且单元实例也包含在此表示格式中。这种格式的优势在于，DSPF文件可以用作<strong>SPICE</strong>仿真器本身的输入。但是，缺点是DSPF语法过于详细和冗长，导致模块的总文件大小非常大。因此，这种格式在实际中仅用于相对较小的一组网络。</p>
<p>​ 这里是一个示例DSPF文件，它描述了从主输入IN到缓冲器BUF的输入引脚a的互连，以及从BUF的输出引脚OUT到主输出引脚OUT的另一个网络。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.SUBCKT</span> <span class="selector-tag">TEST_EXAMPLE</span> <span class="selector-tag">OUT</span> <span class="selector-tag">IN</span></span><br><span class="line"></span><br><span class="line">* <span class="selector-tag">Net</span> <span class="selector-tag">Section</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">GROUND_NET</span> <span class="selector-tag">VSS</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">NET</span> <span class="selector-tag">IN</span> <span class="number">4.9</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">P</span> (IN I <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">4.1</span>)</span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">I</span> (<span class="attribute">BUF1</span>:A BUF A I <span class="number">0.0</span> <span class="number">0.7</span> <span class="number">4.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C1</span> <span class="selector-tag">IN</span> <span class="selector-tag">VSS</span> <span class="number">2.3</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C2</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">A</span> <span class="selector-tag">VSS</span> <span class="number">2.6</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">R1</span> <span class="selector-tag">IN</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">A</span> <span class="number">4.8</span><span class="selector-tag">E00</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">NET</span> <span class="selector-tag">OUT</span> <span class="number">4.47</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">S</span> (<span class="attribute">OUT</span>:<span class="number">1</span> <span class="number">8.3</span> <span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">P</span> (OUT O <span class="number">0.0</span> <span class="number">8.3</span> <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">*|<span class="selector-tag">I</span> (<span class="attribute">BUF1</span>:OUT BUF1 OUT O <span class="number">0.0</span> <span class="number">4.9</span> <span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C3</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">OUT</span> <span class="selector-tag">VSS</span> <span class="number">3.5</span><span class="selector-tag">E-02PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C4</span> <span class="selector-tag">OUT</span>:<span class="number">1</span> <span class="selector-tag">VSS</span> <span class="number">4.9</span><span class="selector-tag">E-03PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">C5</span> <span class="selector-tag">OUT</span> <span class="selector-tag">VSS</span> <span class="number">4.8</span><span class="selector-tag">E-03PF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">R2</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">OUT</span> <span class="selector-tag">OUT</span>:<span class="number">1</span> <span class="number">12.1</span><span class="selector-tag">E00</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">R3</span> <span class="selector-tag">OUT</span>:<span class="number">1</span> <span class="selector-tag">OUT</span> <span class="number">8.3</span><span class="selector-tag">E00</span></span><br><span class="line"></span><br><span class="line">*<span class="selector-tag">Instance</span> <span class="selector-tag">Section</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">X1</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">A</span> <span class="selector-tag">BUF1</span>:<span class="selector-tag">OUT</span> <span class="selector-tag">BUF</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ENDS</span></span><br></pre></td></tr></table></figure>
<p>​ DSPF中的非标准<strong>SPICE</strong>语句是以 * |开头，并具有以下格式：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*|I(InstancePinName InstanceName PinName PinType PinCap X Y)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|P(PinName PinType PinCap X Y)</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|NET NetName NetCap</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|S(SubNodeName X Y)</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|GROUND_NET NetName</span></span><br></pre></td></tr></table></figure>
<h3 id="精简标准寄生格式reduced-standard-parasitic-format">精简标准寄生格式（Reduced Standard Parasitic Format）</h3>
<p>​ 在RSPF表示中，寄生以简化形式表示。简化格式包括电压源和受控电流源。RSPF格式也是SPICE文件，因为它可以读入类似SPICE的模拟器。RSPF格式要求减少详细的寄生并映射到减少的格式中。因此，这是RSPF表示的一个缺点，因为寄生提取过程的重点通常是提取精度，而不是简化为类似RSPF的紧凑格式。RSPF表示的另一个限制是双向信号流不能用这种格式表示。</p>
<p>​ 下面是一个RSPF文件的示例。原始设计和等效表示如图4-13所示。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> Design Name : TEST1</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Date : 7 September 2002</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Time : 02:00:00</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Resistance Units : 1 ohms</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Capacitance Units : 1 pico farads</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*| RSPF 1.0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>| DELIMITER &quot;<span class="emphasis">_&quot;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">.SUBCKT TEST1 OUT IN</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*| GROUND_</span>NET VSS</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|NET CP 0.075PF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|DRIVER CKBUF<span class="emphasis">_Z CKBUF Z</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*|S (CKBUF_</span>Z<span class="emphasis">_OUTP 0.0 0.0)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">R1 CKBUF_</span>Z CKBUF<span class="emphasis">_Z_</span>OUTP 8.85</span><br><span class="line"></span><br><span class="line">C1 CKBUF<span class="emphasis">_Z_</span>OUTP VSS 0.05PF</span><br><span class="line"></span><br><span class="line">C2 CKBUF<span class="emphasis">_Z VSS 0.025PF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*|LOAD SDFF1_</span>CP SDFF1 CP</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*|S (SDFF1_CP_INP 0.0 0.0)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">E1 SDFF1_CP_INP VSS CKBUF_Z VSS 1.0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">R2 SDFF1_CP_INP SDFF1_CP 52.0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">C3 SDFF1_CP VSS 0.1PF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>|LOAD SDFF2<span class="emphasis">_CP SDFF2 CP</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*|S (SDFF2_</span>CP<span class="emphasis">_INP 0.0 0.0)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">E2 SDFF2_</span>CP<span class="emphasis">_INP VSS CKBUF_</span>Z VSS 1.0</span><br><span class="line"></span><br><span class="line">R3 SDFF2<span class="emphasis">_CP_</span>INP SDFF2<span class="emphasis">_CP 43.5</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">C4 SDFF2_</span>CP VSS 0.1PF</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*Instance Section</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">X1 SDFF1_Q SDFF1_QN SDFF1_D SDFF1_CP SDFF1_CD VDD VSS SDFF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">X2 SDFF2_Q SDFF2_QN SDFF2_D SDFF2_CP SDFF2_CD VDD VSS SDFF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">X3 CKBUF_Z CKBUF_A VDD VSS CKBUF</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">.ENDS</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">.END</span></span><br></pre></td></tr></table></figure>
<p>​ 此文件具有以下功能：</p>
<ul>
<li>在每个扇出单元的输入引脚上都使用0.1pF的电容（C3和C4）和电阻（R2和R3）对引脚到引脚（pin-to-pin）的互连延迟进行建模，电阻值的选取原则是使RC延迟对应于引脚到引脚的互连延迟。驱动单元输出引脚上的π型负载模拟了通过该单元的延迟。</li>
<li>输入端的RC元件由理想电压源（E1和E2）驱动，该电压源等于驱动单元输出端的电压。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210811232851569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="标准寄生交换格式standard-parasitic-extraction-format">标准寄生交换格式（Standard Parasitic Extraction Format）</h3>
<p>​ SPEF 是一种紧凑的格式，可以表示详细的寄生参数。下面显示了具有两个扇出的网络示例。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*D_NET NET_27 0.77181</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>CONN</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*I *</span>8:Q O <span class="emphasis">*L 0 *</span>D CELL1</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*I *</span>10:I I <span class="emphasis">*L 12.3</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>CAP</span><br><span class="line"></span><br><span class="line">1 <span class="emphasis">*9:0 0.00372945</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2 *</span>9:1 0.0206066</span><br><span class="line"></span><br><span class="line">3 <span class="emphasis">*9:2 0.035503</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4 *</span>9:3 0.0186259</span><br><span class="line"></span><br><span class="line">5 <span class="emphasis">*9:4 0.0117878</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6 *</span>9:5 0.0189788</span><br><span class="line"></span><br><span class="line">7 <span class="emphasis">*9:6 0.0194256</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">8 *</span>9:7 0.0122347</span><br><span class="line"></span><br><span class="line">9 <span class="emphasis">*9:8 0.00972101</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">10 *</span>9:9 0.298681</span><br><span class="line"></span><br><span class="line">11 <span class="emphasis">*9:10 0.305738</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">12 *</span>9:11 0.0167775</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*RES</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1 *</span>9:0 <span class="emphasis">*9:1 0.0327394</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">2 *</span>9:1 <span class="emphasis">*9:2 0.116926</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3 *</span>9:2 <span class="emphasis">*9:3 0.119265</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">4 *</span>9:4 <span class="emphasis">*9:5 0.0122066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">5 *</span>9:5 <span class="emphasis">*9:6 0.0122066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">6 *</span>9:6 <span class="emphasis">*9:7 0.0122066</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">7 *</span>9:8 <span class="emphasis">*9:9 0.142205</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">8 *</span>9:9 <span class="emphasis">*9:10 3.85904</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">9 *</span>9:10 <span class="emphasis">*9:11 0.142205</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">10 *</span>9:12 <span class="emphasis">*9:2 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">11 *</span>9:13 <span class="emphasis">*9:6 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">12 *</span>9:1 <span class="emphasis">*9:9 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">13 *</span>9:5 <span class="emphasis">*9:10 1.33151</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">14 *</span>9:12 <span class="emphasis">*8:Q 0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">15 *</span>9:13 <span class="emphasis">*10:I 0</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">*</span>END</span><br></pre></td></tr></table></figure>
<p>​ 寄生参数 R 和 C 的单位在 SPEF 文件的开头指定。附录 C 中提供了对 SPEF 的更详细描述。 由于其表示的紧凑性和完整性，SPEF 是表示设计中寄生效应的首选格式。</p>
<h2 id="表示耦合电容representing-coupling-capacitances">表示耦合电容（Representing Coupling Capacitances）</h2>
<p>​ 上一节说明了将网络电容表示为接地电容（grounded capacitances）的情况。由于纳米技术中的大多数电容是侧壁电容（sidewall capacitances），这些电容的正确表示是信号到信号耦合电容（coupling capacitance）。</p>
<p>​ DSPF 中耦合电容的表示是原始 DSPF 标准的附加内容，因此不是唯一的。耦合电容在两组耦合网络之间复制。这意味着 DSPF 不能直接读入 SPICE，因为两组网络中的耦合电容是重复的。一些输出 DSPF 的工具通过在两个耦合网络中包含一半的耦合电容来解决这种差异。</p>
<p>​ RSPF 是简化的表示，因此不适合表示耦合电容。</p>
<p>​ SPEF 标准以统一和明确的方式处理耦合电容，因此是当对串扰时序感兴趣时选择的提取格式。此外，SPEF 是文件大小方面的紧凑表示，用于表示有和没有耦合的寄生效应。</p>
<p>​ 如附录 C 中所述，管理文件大小的机制之一是在文件开头设置名称目录。许多提取工具现在在 SPEF 文件的开头指定一个网络名称目录（将网络名称映射到索引），以避免重复网络名称的冗长。这显着减小了文件大小。 SPEF 的附录中显示了名称为目录的示例。</p>
<h2 id="分层方法hierarchical-methodology">分层方法（Hierarchical Methodology）</h2>
<p>​ 大型复杂设计在物理设计过程中通常需要分层方法来进行寄生提取和时序验证。在这种情况下，块的寄生参数在块级别被提取，然后可以在更高层次的层次结构中使用。</p>
<p>​ 一个块的布局提取寄生参数可用于与布局尚未完成的另一个块的时序验证。在这种情况下，布局完整块的布局提取寄生参数通常与基于线载模型的pre-layout块的估计寄生参数一起使用。</p>
<p>​ 在分层流的情况下，顶级布局已完成但块仍表示为黑盒（pre-layou），基于线载模型的寄生参数估计可用于较低级别的块以及布局提取的寄生参数最高水平。块的布局完成后，可以将顶部的布局提取寄生参数和块缝合在一起。</p>
<h3 id="在布局中复制块block-replicated-in-layout">在布局中复制块（Block Replicated in Layout）</h3>
<p>​ 如果一个设计块在布局中被多次复制，则一个实例的寄生提取可以用于所有实例。这要求对于块的各种实例化，块的布局在所有方面都相同。例如，从块内布线的网络来看，布局环境应该没有区别。这意味着块级网络不与块外的任何网络电容耦合。实现这一点的一种方法是确保没有顶层网络在块上布线，并且在块边界附近布线的网络有足够的屏蔽或间距。</p>
<h2 id="减少关键网络寄生效应reducing-parasitics-for-critical-nets">减少关键网络寄生效应（Reducing Parasitics for Critical Nets）</h2>
<p>​ 本节简要概述了管理关键网络寄生效应影响的常用技术。</p>
<h3 id="降低互连电阻reducing-interconnect-resistance">降低互连电阻（Reducing Interconnect Resistance）</h3>
<p>​ 对于关键网络，保持低转换值（或快速转换时间）很重要，这意味着应降低互连电阻。通常，有两种方法可以实现低电阻：</p>
<ul>
<li>宽走线（Wide trace）：走线比最小宽度更宽可降低互连电阻，而不会导致寄生电容显着增加。因此，减少了总的 RC 互连延迟和转换时间。</li>
<li>上层（较厚）金属布线（Routing in upper (thicker) metals）：上层金属层通常具有低电阻率，可用于布线关键信号。低互连电阻减少了互连延迟以及目标引脚的转换时间。</li>
</ul>
<h3 id="增加线距increasing-wire-spacing">增加线距（Increasing Wire Spacing）</h3>
<p>​ 增加走线之间的间距会降低网络的耦合电容和总电容。大耦合电容会增加串扰，避免串扰是在相邻走线中长距离布线的网络的重要考虑因素。</p>
<h3 id="相关网络的寄生参数parasitics-for-correlated-nets">相关网络的寄生参数（Parasitics for Correlated Nets）</h3>
<p>​ 在很多情况下，一组网络必须在时序上匹配。一个例子是高速 DDR 接口的字节通道内的数据信号。由于字节通道内的所有信号看到相同的寄生信号很重要，因此所有信号都在同一金属层中布线。例如，虽然金属层 M2 和 M3 具有相同的平均值和相同的统计变化，但这些变化是独立的，因此这两个金属层中的寄生变化不会相互跟踪。因此，如果关键信号的时序匹配很重要，那么每个金属层的布线必须相同。</p>
<h1 id="延迟计算delay-calculation">延迟计算（Delay Calculation）</h1>
<blockquote>
<p>解释了如何为布局前和布局后时序验证计算单元延迟和路径延迟。本章扩展了前面章节中描述的概念，介绍了整个设计的时序。本章概述了用于 pre-layout 和 post-layout时序验证的基于单元设计的延迟计算。</p>
</blockquote>
<p>前几章重点介绍了互连和单元库的建模。单元和互连建模技术用于获得设计时序。</p>
<h2 id="概述overview">概述（Overview）</h2>
<h3 id="延迟计算基础delay-calculation-basics">延迟计算基础（Delay Calculation Basics）</h3>
<p>​ 典型的设计包括各种组合单元和顺序单元。我们使用图5-1所示的示例的逻辑片段来描述延迟计算的概念。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812001608262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><em>标准单元库通常不为单元输出指定引脚电容。</em></p>
<p>​ 每个单元的库描述指定每个输入引脚的引脚电容值。因此，设计中的每个网络都有一个电容负载，它是网络中每个扇形输出的引脚电容负载加上互连的任何贡献的总和。为了简单起见，本节不考虑互连的贡献，这些贡献将在后面的章节中描述。在不考虑互连寄生的情况下，图5-1中的内部网络NET0具有由UAND1和UNOR2单元的输入引脚电容组成的网络电容。输出O1具有UNOR2单元的引脚电容加上逻辑块输出的任何电容负载。输入I1和I2具有对应于UAND1和UINV0单元的引脚电容。通过这种抽象，图5-1中的逻辑设计可以用图5-2中所示的等效表示来描述。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812001957161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如第3章所述，单元库包含各种时序弧的NLDM定时模型。非线性模型表示为输入过渡时间和输出电容的二维表格。逻辑单元的输出跃迁时间也被描述为一个二维表，表示输入跃迁和网络总输出电容。因此，如果在逻辑块的输入端指定了输入转换时间（或转换slew），则可以从库单元描述中获得通过UINV0单元和UAND1单元（对于输入I1）的时序弧的输出转换时间和延迟。通过扇出单元扩展相同的方法，则可以获得通过UAND1单元的另一条时序弧（从NET0到O1）以及通过UNOR2单元的过渡时间和延迟。对于多输入单元（如UAND1），不同的输入引脚可以提供不同的输出过渡时间值。扇出网络过渡时间的选择取决于转换合并选项，如第5.4节所述。使用上述方法，可根据输入引脚的过渡时间和输出引脚的电容获得通过任何逻辑单元的延迟。</p>
<h3 id="互连延迟计算delay-calculation-with-interconnect">互连延迟计算（Delay Calculation with Interconnect）</h3>
<p><strong>预布局时序（Pre-layout Timing）</strong></p>
<p>​ 如第4章所述，在预布局时序验证期间，使用线性负载模型估算了互连寄生参数。在许多情况下，线性负载模型中的电阻贡献被设置为0。在这种情况下，线性负载贡献纯粹是电容性的，上一节中描述的延迟计算方法适用于获得设计中所有时序弧的延迟。</p>
<p>​ 在线性性负载模型包括互连电阻影响的情况下，NLDM模型与单元延迟的总网络电容一起使用。由于互连是电阻式的，因此从驱动单元的输出到扇出单元的输入引脚会有额外的延迟。</p>
<p><strong>布局后时序（Post-layout Timing）</strong></p>
<p>​ 金属走线的寄生参数映射到驱动单元和目标单元之间的RC网络中。使用图5-1的示例，网络的互连电阻如图5-3所示。内部网络（如图5-1中的NET0）映射到多个子节点，如图5-3所示。因此，逆变单元UINV0的输出负载由RC结构组成。由于NLDM表格是关于输入转换和输出电容的，因此输出引脚处的电阻负载意味着NLDM表格不直接适用。下一节将介绍使用具有电阻互连的NLDM。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812002829549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="使用有效电容的单元延迟cell-delay-using-effective-capacitance">使用有效电容的单元延迟（Cell Delay using Effective Capacitance）</h2>
<p>​ 如上所述，当单元输出端的负载包括互连电阻时，NLDM模型不能直接使用。相反，采用“有效”电容法来处理电阻效应。</p>
<p>​ 有效电容法试图找到可用作等效负载的单个电容，以便原始设计以及具有等效电容负载的设计在单元输出的定时方面表现相似。这种等效单电容被称为<strong>有效电容（effective capacitance）</strong>。</p>
<p>​ 图5-4（a）所示为扇出端带有RC互连的单元。RC互连由图5-4（b）所示的等效RC PI网络表示。有效电容的概念是获得等效输出电容Ceff（如图5-4（c）所示），其通过电池的延迟与RC负载的原始设计相同。一般来说，RC负载的电池输出波形与单个电容负载的波形非常不同。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812003116665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图5-5显示了总电容、有效电容和实际RC互连的单元输出波形的代表性波形。选择有效电容Ceff时，应确保图5-4（c）中单元输出端的延迟（在过渡中点测量）与图5-4（a）中的延迟相同。如图5-5所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812003230102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 关于PI等效表示，有效电容可表示为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Ceff%20%3D%20C1%20+%20k%20*%20C2%2C%200%20%3C%3D%20k%20%3C%3D%201"></p>
<p>​ 其中C1为近端电容，C2为远端电容，如图5-4（b）所示。k值介于0和1之间。在互连电阻可忽略不计的情况下，有效电容几乎等于总电容。这可以通过在图5-4（b）中将R设置为0来直接解释。类似地，如果互连电阻相对较大，则有效电容几乎等于近端电容C1（图5-4（b））。这可以通过将R增加到极限情况来解释，在极限情况下，R变为无穷大（本质上是一个开路）。</p>
<p>​ 有效电容是以下各项的函数：</p>
<ul>
<li>驱动单元</li>
<li>从驱动单元看，负载的特性或负载的输入阻抗</li>
</ul>
<p>​ 对于给定的互连线，输出驱动较弱的单元将比驱动较强的单元具有更大的有效电容。因此有效电容的值将介于最小值C1（对于较大的互连电阻或者较强的驱动单元）与最大值C1+C2（对于小到可忽略的互连电阻或较弱的驱动单元）之间。注意，目标引脚的转换要晚于驱动单元的输出。近端电容充电速度比远端电容快的现象也被称为互连线的电阻屏蔽效应（resistive shielding effect），因为驱动单元只能看到一部分远端电容。</p>
<p>​ 与通过在库中直接查找NLDM模型计算延迟不同，延迟计算工具通过迭代程序获得有效电容。在算法方面，第一步是获得实际RC负载的单元输出所看到的驱动点阻抗。使用二阶AWE或Arnoldi算法1等任何方法计算实际RC负载的驱动点阻抗。计算有效电容的下一步是在两种情况下，将转移的电荷等效到过渡的中点。当使用实际RC负载（基于驱动点阻抗）时，电池输出处转移的电荷与使用有效电容作为负载时的电荷传输量相匹配，请注意，电荷转移仅在过渡中点之前匹配。该过程从有效电容的估计开始，然后迭代更新估计值。在大多数实际情况下，有效电容值在少量迭代内收敛。</p>
<p>​ 因此，有效电容近似是计算单元延迟的良好模型。然而，使用有效电容获得的输出摆幅与电池输出的实际波形不一致。单元输出处的波形，尤其是波形后半部分的波形，不能用有效电容近似表示。请注意，在典型场景中，感兴趣的波形不在单元输出处，而是在互连的目标点处，即扇出单元的输入管脚处。</p>
<p>​ 有多种方法可以计算互连终点处的延迟和波形。在许多实现中，有效电容程序还计算驱动单元的等效戴维南电压源。戴维南源由一个斜坡源和一个串联电阻Rd组成，如图5-6所示。串联电阻Rd对应于电池输出级的下拉（或上拉）电阻。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081213310699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 本节介绍了使用有效电容替代RC互连来计算通过驱动单元的延迟。有效电容的计算还提供了等效的戴维宁电压源模型，然后将其用于获取通过RC互连的时序。接下来将具体介绍获取通过RC互连时序信息的过程。</p>
<h2 id="互连延迟interconnect-delay">互连延迟（Interconnect Delay）</h2>
<p>​ 如第4章所述，网络的互连寄生通常由RC电路表示。RC互连可以是预布局或后布局。虽然布局后寄生互连可包括与相邻网络的耦合，但基本延迟计算将所有电容（包括耦合电容）视为对地电容。图5-7显示了网络及其驱动单元和扇出单元的寄生示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812134515330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 采用有效电容法，分别获得了通过驱动单元和通过互连的延迟。有效电容法通过驱动单元以及单元输出端的等效戴维南源提供延迟。然后使用戴维南源分别计算通过互连的延迟。互连部分具有一个输入和与目的地管脚一样多的输出。使用互连输入端的等效戴维南电压源，计算每个目标引脚的延迟。如图5-6所示。</p>
<p>​ 在布局前进行分析时，RC互连结构由RC树类型决定，而RC互连结构又决定了互连线延迟。4.2节中已详细介绍了三种类型的RC互连树表示形式，所选的RC树类型通常在库中定义。通常，最坏情况（worst-case）的慢速库会选择最坏情况的RC树，因为该类型的树提供了最大的互连线延迟。类似地，最佳情况（best-case）的RC树结构中不包括从源引脚到目标引脚的任何电阻，通常在最佳情况的快速工艺角时被选择。因此，最佳情况RC树的互连延迟等于零。典型（typical）情况RC树和最坏情况RC树的互连延迟的处理方式与布局后RC互连一样。</p>
<h3 id="elmore延迟">Elmore延迟</h3>
<p>​ Elmore延迟适用于RC树。什么是RC树？RC树满足以下三个条件：</p>
<ul>
<li>具有单个输入（源）节点。</li>
<li>没有任何电阻回路。</li>
<li>所有电容都位于节点和接地之间。</li>
</ul>
<p>​ Elmore延迟可以看作是找到每段的延迟，即R与下游电容的乘积，然后取各延迟之和。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812140213384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 到各个中间节点的延迟表示为：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">Td1= C1* R1;</span><br><span class="line"></span><br><span class="line">Td2= C1* R1+ C2* (R1+ R2);</span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line">Tdn= S(i=<span class="number">1</span>,N) Ci(S(j=<span class="number">1</span>,i) Rj); <span class="comment"># Elmore delay equation</span></span><br></pre></td></tr></table></figure>
<p>​ Elmore延迟在数学上考虑的是脉冲响应的第一时刻。 现在，我们将Elmore延迟模型进行如下简化表示：互连线的寄生电阻与电容分别为Rwire和Cwire，互连线远端的引脚电容由负载电容Cload来建模。等效的RC网络可以简化为π模型或T模型，分别如前面章节四中图4-4和图4-3所示。两种模型都具有如下走线延迟（基于Elmore延迟方程）：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Rwire*%20%28Cwire/%202%20+%20Cload%29"></p>
<p>​ 这是因为Cload在其充电路径中看到整个导线电阻，而Cwire电容在T表示中看到Rwire/2，在PI表示中Cwire/2在其充电路径中看到Rwire。上述方法也可以扩展到更复杂的互连结构。</p>
<p>​ 下面给出了使用带平衡RC树（以及最坏情况RC树）的线负载模型计算网络Elmore延迟的示例。</p>
<p>​ 使用平衡RC树模型时，网络的电阻和电容在网络的各个分支之间平均分配（假设扇出为N）。对于具有引脚负载Cpin的分支，使用平衡RC树的延迟为：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">net delay = (<span class="name">Rwire/</span> N) * (<span class="name">Cwire/</span> (<span class="number">2</span> * N) + Cpin)</span><br></pre></td></tr></table></figure>
<p>​ 使用最坏情况RC树模型时，网络的每个分支终点都考虑了网络的电阻和整个电容。此时的延迟值如下所示，这里的Cpins是所有扇出的总引脚负载：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Net delay = Rwire* (<span class="name">Cwire/</span> <span class="number">2</span> + Cpins)</span><br></pre></td></tr></table></figure>
<p>​ 图5-9显示了一个设计示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812141848894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果我们使用最坏情况RC树模型来计算网络N1的延迟，我们将得到：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Net delay = Rwire* (<span class="name">Cwire/2</span> + Cpins)</span><br><span class="line"></span><br><span class="line">          = <span class="number">0.3</span> * (<span class="number">0.5</span> + <span class="number">2.3</span>) = <span class="number">0.84</span></span><br></pre></td></tr></table></figure>
<p>​ 如果我们使用平衡树模型，我们得到网络N1的两个分支的以下延迟：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Net delay to NOR2 input pin = (<span class="number">0.3</span>/2) * (<span class="number">0.5</span>/2 + <span class="number">1.3</span>)</span><br><span class="line"></span><br><span class="line">                            = <span class="number">0.2325</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Net delay to BUF input pin= (<span class="number">0.3</span>/2) * (<span class="number">0.5</span>/2 + <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">                            = <span class="number">0.1875</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶互连延迟估计higher-order-interconnect-delay-estimation">高阶互连延迟估计（Higher Order Interconnect Delay Estimation）</h3>
<p>​ 如上所述，Elmore延迟是脉冲响应的第一个时刻。AWE（Asymptotic Waveform Evaluation渐近波形评估）、Arnoldi或其他方法匹配高阶响应矩。通过考虑高阶估计，可以获得更高的互连延迟计算精度。</p>
<h3 id="全芯片延迟计算full-chip-delay-calculation">全芯片延迟计算（Full Chip Delay Calculation）</h3>
<p>​ 到目前为止，本章描述了单元延迟的计算以及单元输出端的互连。因此，给定单元输入端的过渡时间，可以计算通过单元的延迟和单元输出端的互连线的延迟。互连远端（目的地或汇点）的过渡时间是下一级的输入，整个设计过程中都会重复此过程，这样就计算出了设计中每个时序弧的延迟。</p>
<h2 id="转换合并slew-merging">转换合并（Slew Merging）</h2>
<p>​ 当多个转换（slew）到达一个公共点时会发生什么情况，例如在多输入单元或多驱动网络的情况下？这种公共点称为转换合并点（slew merge point）。选择哪个slew在slew merge point向前传播？考虑图5-10所示的2输入单元。</p>
<p><img src="https://img-blog.csdnimg.cn/2021081215150016.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于引脚 A 上的信号变化，引脚 Z 处的转换提前到达但上升缓慢（缓慢s转换）。由于引脚 B 上的信号变化，引脚 Z 处的转换延迟到达，但上升很快（快速转换）。在转换合并点，例如 pin Z应该选择哪个slew进行进一步传播？</p>
<p>​ 根据如下所述执行的时序分析的类型(最大或最小)，这些转换值中的任何一个都可能是正确的。</p>
<p>​ 执行最大路径分析时有两种可能性：</p>
<ul>
<li>最差转换传播（Worst slew propagation）：此模式选择合并点的最差转换进行传播。这将是图5-10(A)中的slew。对于通过管脚A-&gt;Z的时序路径，此选择是精确的，但对于通过管脚B-&gt;Z的任何时序路径则是悲观的。</li>
<li>最差到达传播（Worst arrival propagation）：此模式选择合并点的最差到达时间进行传播。这与图5-10(b)中的摆动相对应。在这种情况下选择的摆幅对于通过管脚B-&gt;Z的时序路径是精确的，但是对于通过管脚A-&gt;Z的时序路径是乐观的。</li>
</ul>
<p>​ 同样，执行最小路径分析时有两种可能性：</p>
<ul>
<li>最佳转换传播（Best slew propagation）：此模式选择要传播的合并点处的最佳转换。这将是图5-10(b)中的回转。对于通过管脚B-&gt;Z的定时路径，该选择是精确的，但是对于通过管脚A-&gt;Z的任何时序路径，该选择较小。对于通过A-&gt;Z的路径，路径延迟小于实际值，因此对于最小路径分析是悲观的。</li>
<li>最佳到达传播（Best arrival propagation）：此模式选择合并点的最佳到达时间进行传播。这与图5-10(A)中的转换slew相对应。这种情况下选择的slew对于通过管脚A-&gt;Z的时序路径是精确的，但是选择的值大于通过管脚B-&gt;Z的定时路径的实际值。对于通过B-&gt;Z的路径，路径延迟大于实际值，因此对于最小路径分析是乐观的。</li>
</ul>
<p>​ 设计者可以在静态时序分析环境之外执行延迟计算以生成SDF。在这种情况下，延迟计算工具通常使用最差的转换传播（worst slew propagation）。所得到的SDF对于最大路径分析是足够的，但是对于最小路径分析可能是乐观的。</p>
<p>​ 大多数静态时序分析工具使用最差和最好的转换传播作为它们的默认设置，因为它以保守的方式限制了分析。但是，在分析特定路径时，可以使用精确的转换传播。准确的转换传播可能需要在时序分析工具中启用一个选项。因此，重要的是要了解静态时序分析工具中默认使用的转换传播模式，并了解其可能过于悲观的情况。</p>
<h2 id="不同的转换阈值different-slew-thresholds">不同的转换阈值（Different Slew Thresholds）</h2>
<p>​ 通常，库指定单元角色化过程中使用的<strong>转换(转换时间)【slew (transition time)】</strong>阈值。问题是，当具有一组转换阈值的单元驱动具有不同组转换阈值设置的其他单元时，会发生什么情况？考虑图5-11所示的情况，其中特征为20-80转换阈值的单元驱动两个扇出单元；一个转换阈值为10-90，另一个转换阈值为30-70，转换降低率为0.5。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812152816468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 单元格U1的转换设置在单元库中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : 20.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : 80.00</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">slew_derate_from_library : 1.00</span><br><span class="line"></span><br><span class="line">input_threshold_pct_fall : 50.00</span><br><span class="line"></span><br><span class="line">output_threshold_pct_fall : 50.00</span><br><span class="line"></span><br><span class="line">input_threshold_pct_rise : 50.00</span><br><span class="line"></span><br><span class="line">output_threshold_pct_rise : 50.00</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : 20.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : 80.00</span><br></pre></td></tr></table></figure>
<p>​ 来自另一个库的单元格U2可以具有如下定义的转换设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : 10.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : 90.00</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">slew_derate_from_library : 1.00</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : 10.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : 90.00</span><br></pre></td></tr></table></figure>
<p>​ 来自另一个库的单元格U3可以具有如下定义的转换设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slew_lower_threshold_pct_rise : 30.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_rise : 70.00</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">slew_derate_from_library : 0.5</span><br><span class="line"></span><br><span class="line">slew_lower_threshold_pct_fall : 30.00</span><br><span class="line"></span><br><span class="line">slew_upper_threshold_pct_fall : 70.00</span><br></pre></td></tr></table></figure>
<p>​ 上面只显示了U2和U3的转换相关设置；输入和输出阈值的延迟相关设置为50%，上面没有显示。延迟计算工具根据连接网络的单元的转换阈值计算转换时间。图5-11显示了U1/Z处的转换如何与该引脚上的开关波形相对应。利用U1/Z的等效戴维南源获得扇出单元输入端的开关波形。根据U2/A和U3/A的波形及其转换阈值，延迟计算工具计算U2/A和U3/A的转换。请注意，U2/A的转换基于10-90设置，而用于U3/A的转换基于30-70设置，然后根据库中指定的slew_derate 0.5递减。此示例说明如何根据扇出单元的切换波形和转换阈值设置计算扇出单元输入端的转换时间。</p>
<p>​ 在可能不考虑互连电阻的预布局（pre-layout）设计阶段时，可以按以下方式计算具有不同阈值的网络处的转换时间。例如，10%-90%转换阈值和20%-80%转换阈值之间的关系为：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">slew2080 / (<span class="number">0.8</span> - <span class="number">0.2</span>) = slew1090 /(<span class="number">0.9</span> - <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p>​ 因此，具有 10-90 个测量点的 500ps 转换对应于具有 20-80 个测量点的 (500ps * 0.6) / 0.8 = 375ps 转换。类似地，具有 20-80 个测量点的 600ps 转换对应于具有 10-90 个测量点的 (600ps * 0.8) / 0.6 = 800ps 转换。</p>
<h2 id="个同的电压域different-voltage-domains">个同的电压域（Different Voltage Domains）</h2>
<p>​ 典型的设计可能对芯片的不同部分使用不同的电源电平。在这种情况下，电平转换单元用于不同电源域之间的接口。电平转换单元在一个电源域接受输入并在另一个电源域提供输出。例如，标准单元输入可以是 1.2V，其输出可以是降低的电源，可能是 0.9V。图 5-12 显示了一个示例</p>
<p><img src="https://img-blog.csdnimg.cn/20210812154006234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，延迟是根据 50% 阈值点计算的。对于接口单元的不同引脚，这些点处于不同的电压。</p>
<h2 id="路径延迟计算path-delay-calculation">路径延迟计算（Path Delay Calculation）</h2>
<p>​ 一旦每个时序弧的所有延迟都可用，设计中单元的时序就可以表示为时序图。通过组合单元的时序可以表示为从输入到输出的时序弧。类似地，互连由从源到每个目的地（或汇）点的相应弧表示为单独的时序弧。一旦整个设计由相应的弧线注释，计算路径延迟涉及将沿路径的所有网络和单元时序弧线相加。</p>
<h3 id="组合路径延迟combinational-path-delay">组合路径延迟（Combinational Path Delay）</h3>
<p>​ 考虑串联的三个逆变器，如图 5-13 所示。在考虑从网络 N0 到网络 N3 的路径时，我们同时考虑上升沿和下降沿路径。假设在网络 N0 处有一个上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812160505527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 可以指定第一个逆变器输入端的 transition time (or slew)；如果没有这样的规范，则假定过渡时间为 0（对应于理想步长）。输入 UINVa/A 的转换时间是通过使用上一节中指定的互连延迟模型来确定的。相同的延迟模型也用于确定网络 N0 的延迟 Tn0。</p>
<p>​ 基于在UINVa的输出处的负载的RC获得在输出UINVa / Z的有效电容。然后在输入UINVa / A，并在输出UINVa / Z等效有效负荷的转换时间是用于获得单元输出下降延迟。</p>
<p>​ 引脚 UINVa/Z 处的等效戴维南源模型用于通过使用互连模型确定引脚 UINVb/A 处的转换时间。互连模型还用于确定网络 N1 上的延迟 Tn1。</p>
<p>​ 一旦知道输入 UINVb/A 处的转换时间，就可以类似地使用通过 UINVb 计算延迟的过程。 UINVb/Z 处的 RC 互连和 UINVc/A 引脚的引脚电容用于确定 N2 处的有效负载。 UINVb/A 的转换时间用于确定通过反相器 UINVb 的上升延迟，依此类推。</p>
<p>​ 最后阶段的负载由提供的任何明确的负载规范确定，或者在没有规范的情况下仅使用网络 N3 的线负载。</p>
<p>​ 上述分析假设在网络 N0 处有一个上升沿。对于网络 N0 上的下降沿的情况，可以进行类似的分析。因此，在这个简单的示例中，有两条时序路径具有以下延迟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tfall= Tn0rise+ Tafall+ Tn1fall+ Tbrise+ Tn2rise+ Tcfall+ Tn3fall</span><br><span class="line"></span><br><span class="line">Trise= Tn0fall+ Tarise+ Tn1rise+ Tbfall+ Tn2fall+ Tcrise+ Tn3rise</span><br></pre></td></tr></table></figure>
<p>​ 通常，由于驱动单元输出端的戴维南源模型不同，通过互连的上升和下降延迟可能不同。</p>
<h3 id="触发器的路径path-to-a-flip-flop">触发器的路径（Path to a Flip-flop）</h3>
<p><strong>输入到触发器路径（Input to Flip-flop Path）</strong></p>
<p>​ 考虑如图5-14从输入SDT到触发器UFF1的路径的时序。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812161429433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 我们需要同时考虑上升沿和下降沿路径。对于输入 SDT 上升沿的情况，数据路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn1rise+%20Tafall+%20Tn2fall+%20Tbuf1fall+%20Tn3fall+%20Tbrise+%20Tn4rise"></p>
<p>​ 同样，对于输入 SDT 的下降沿，数据路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn1fall+%20Tarise+%20Tn2rise+%20Tbuf1rise+%20Tn3rise+%20Tbfall+%20Tn4fall"></p>
<p>​ 输入 MCLK 上升沿的捕获时钟路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn5rise+%20Tbuf2rise+%20Tn6rise"></p>
<p><strong>触发器到触发器路径（Flip-flop to Flip-flop Path）</strong></p>
<p>​ 图 5-15 显示了两个触发器和相应时钟路径之间的数据路径示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812162002320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ UFF0/Q 上升沿的数据路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tck2qrise+%20Tn1rise+%20Tafall+%20Tn2fall+%20Tbfall+%20Tn3fall"></p>
<p>​ 输入 PCLK 上升沿的启动时钟路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn4rise+%20T5rise+%20Tn5arise"></p>
<p>​ 输入 PCLK 上升沿的捕获时钟路径延迟为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tn4rise+%20T5rise+%20Tn5brise+%20T6rise+%20Tn6rise"></p>
<p>​ 请注意，需要考虑单元的完整性，因为边缘方向在通过单元时可能会发生变化。</p>
<h3 id="多路径multiple-paths">多路径（Multiple Paths）</h3>
<p>​ 在任意两点之间，可以有许多路径。最长的路径是花费时间最长的路径；这也称为最坏路径、延迟路径或最大路径。最短的路径是需要最短时间的路径；这也称为最佳路径、早期路径或最小路径。</p>
<p>​ 通过图 5-16 中的时序弧查看逻辑和延迟。两个触发器之间最长的路径是通过单元 UBUF1、UNOR2 和 UNAND3。两个触发器之间的最短路径是通过单元 UNAND3。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812162514247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="裕量计算slack-calculation">裕量计算（Slack Calculation）</h2>
<p>​ 裕量（Slack）是信号需要到达时间（Required Time）与实际到达时间（Arrival Time）之差。在图5-17中，要求数据在7ns时保持稳定才能满足建立时间（setup）要求。但是，数据在1ns时就已稳定。因此，裕量为6ns（= 7ns-1ns）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210812163011691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 假设所需的数据时间是从捕获触发器的设置时间获得的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Slack = Required_time - <span class="type">Arrival_time</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Required_time</span> <span class="operator">=</span> Tperiod - Tsetup(capture_flip_flop)</span><br><span class="line"></span><br><span class="line">= <span class="number">10</span> - <span class="number">3</span> = 7<span class="type">ns</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Arrival_time</span> <span class="operator">=</span> 1<span class="type">ns</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Slack</span> <span class="operator">=</span> <span class="number">7</span> - <span class="number">1</span> = 6ns</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">需要到达时间Required_Time = Tperiod - Tsetup = <span class="number">10</span> - <span class="number">3</span> = 7ns</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">实际到达时间Arrival_Time = 1ns</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">裕量Slack = Required_Time - Arrival_Time = <span class="number">7</span> - <span class="number">1</span> = 6ns</span><br></pre></td></tr></table></figure>
<p>​ 同样，如果两个信号之间的偏斜（skew）要求为100ps，并且测得的偏斜为60ps，则偏斜的裕量为40ps（= 100ps-60ps）。</p>
<h1 id="串扰和噪声crosstalk-and-noise-1">串扰和噪声（Crosstalk and Noise）</h1>
<blockquote>
<p>在纳米技术中，串扰的影响在设计的信号完整性中起着重要作用。本章描述相关的噪声和串扰分析，即毛刺分析和串扰分析。这些技术使 ASIC 从时序的角度表现稳定运行。</p>
</blockquote>
<p>在深亚微米技术中，串扰对设计的信号完整性起着重要作用。串扰噪声是指两个或多个信号之间活动的无意耦合。相关的噪声和串扰分析技术，即故障分析和串扰分析，允许在静态时序分析期间包括这些影响，本章对此进行了描述。这些技术可用于使ASIC性能稳定。</p>
<h2 id="概述overview-1">概述（Overview）</h2>
<p>​ 噪声（noise）是指影响芯片正常运行的非期望或无意影响。在纳米技术中，噪声会影响设备的功能或时序。</p>
<p>​ 为什么会有噪声和信号完整性？</p>
<p>​ 噪声在深亚微米技术中扮演重要角色的原因有几个：</p>
<ul>
<li>金属层数量的增加：例如，0.25mm 或 0.3mm 工艺有四到五个金属层，在 65nm 和 45nm 工艺几何结构中增加到十个或更多金属层。图 4-1 描绘了金属互连的多层。</li>
<li>垂直主导金属纵横比：这意味着与早期工艺几何形状中的宽而细不同，线又细又高。因此，更大比例的电容由侧壁耦合电容组成，该电容映射到相邻线之间的线对线电容。</li>
<li>更精细的几何形状带来更高的布线密度：因此，在紧密的物理距离上封装了更多的金属线。</li>
<li>更多数量的交互设备和互连：因此，更多的有源标准单元和信号走线被封装在相同的硅区域中，从而导致更多的交互。</li>
<li>由于频率更高，波形更快：：快速边沿速率会导致更多的电流尖峰以及对相邻迹线和单元的更大耦合影响。</li>
<li>更低的电源电压：电源电压的降低为噪声留下了很小的余量。</li>
</ul>
<p>​ 在本章中，我们特别研究了串扰噪声的影响。串扰噪声是指两个或多个信号之间的无意耦合活动。串扰噪声是由管芯上相邻信号之间的电容耦合引起的。这会导致网络上的开关活动对耦合信号造成意外影响。 受影响的信号称为受害者（victim），而产生影响的信号称为攻击者（aggressor）。请注意，两个耦合的网络可能会相互影响，并且通常一个网络可能既是受害者又是攻击者。</p>
<p>​ 图 6-1 显示了几个信号线耦合在一起的示例。描述了耦合互连的分布式 RC 提取与几个驱动器和扇出单元。在此示例中，网络 N1 和 N2 将 Cc1 Cc4 作为它们之间的耦合电容，而 Cc2 Cc5 是网络 N2 和 N3 之间的耦合电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816105032486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><em>一些分析工具将毛刺（glitch）称为噪声。同样，一些工具使用串扰（crosstalk ）来指代串扰对延迟的影响。</em></p>
<p>​ 从广义上讲，串扰有两种类型的噪声影响 - 毛刺（glitch）指的是由于相邻干扰源的开关活动耦合而在稳定的受害信号上引起的噪声，以及由开关耦合引起的时序变化（串扰增量延迟）受害者的活动与攻击者的转换活动。这两种类型的串扰噪声的在接下来的两个部分进行说明。</p>
<h2 id="串扰毛刺分析crosstalk-glitch-analysis">串扰毛刺分析（Crosstalk Glitch Analysis）</h2>
<h3 id="基础知识basics">基础知识（Basics）</h3>
<p>​ 由于开关攻击者通过耦合电容传输的电荷，稳定的信号网络可能会出现毛刺（正或负）。图 6-2 说明了由上升的攻击者网络的串扰引起的正毛刺。两个网络之间的耦合电容被描述为一个集总电容 Cc 而不是分布式耦合，这是为了简化下面的说明，而又不失一般性。在提取的网表的典型表示中，耦合电容可能分布在多个段上，如前面第 6.1 节中所见。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816111131981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在此示例中，NAND2 单元 UNAND0 对其输出网络（标记为 Aggressor）进行切换和充电。一些电荷也通过耦合电容 Cc 转移到受害网络并导致正毛刺。转移的电荷量与攻击者和受害网络之间的耦合电容 Cc 直接相关。在受害网络的接地电容上传输的电荷会导致该网络出现故障。由于传输的电荷通过驱动单元 INV2 的下拉阶段耗散，因此受害网络上的稳定值（在这种情况下为 0 或低）恢复。</p>
<p>​ 引起的毛刺的大小取决于多种因素。其中一些因素是：</p>
<ul>
<li>攻击者网络和受害者之间的耦合电容：耦合电容越大，毛刺的幅度越大。</li>
<li>攻击者网络的转换（slew）：攻击者网络的转换速度越快，毛刺的幅度就越大。通常，更快的转换是因为驱动攻击者网络的单元具有更高的输出驱动强度。</li>
<li>受害网络接地电容：受害网络上的接地电容越小，毛刺的幅度越大。</li>
<li>受害网络驱动强度：驱动受害网络的单元的输出驱动强度越小，毛刺的幅度越大。</li>
</ul>
<p>​ 总体而言，虽然受害网络上的稳定值得到恢复，但毛刺会由于下述原因影响电路的功能。</p>
<ul>
<li>毛刺幅度可能大到足以被扇出单元视为不同的逻辑值（例如，逻辑 0 处的受害者可能表现为扇出单元的逻辑 1）。这对于顺序单元（触发器、锁存器）或存储器尤其重要，其中时钟故障或异步设置/复位可能对设计的功能造成灾难性影响。类似地，锁存器输入端数据信号上的毛刺会导致不正确的数据被锁存，如果在输入数据时出现毛刺，这也可能是灾难性的。</li>
<li>即使受害网络不驱动顺序单元，宽毛刺也可能通过受害网络的扇出传播并到达顺序单元输入，对设计造成灾难性后果。</li>
</ul>
<h3 id="毛刺类型types-of-glitches">毛刺类型（Types of Glitches）</h3>
<p>​ 毛刺具有许多不同种类：</p>
<p><strong>上升和下降毛刺（Rise and Fall Glitches）</strong></p>
<p>​ 前面小节中的讨论说明了受害者网络上的<strong>上升毛刺（Rise Glitch）</strong>，该受害者网络一直稳定在低电平。类似的情况是在稳定的高电平信号上出现负毛刺，电平下降切换的攻击者网络会在稳定的高电平信号上引起<strong>下降毛刺（Fall Glitch）</strong>。</p>
<p><strong>过冲和欠冲毛刺（Overshoot and Undershoot Glitches）</strong></p>
<p>​ 当一个上升的攻击者与一个稳定高电平的受害者网络结合时会发生什么？仍然存在使受害网络电压高于其稳定高值的毛刺。这种毛刺称为<strong>过冲毛刺（overshoot glitch）</strong>。类似地，当耦合到稳定的低电平受害网络时，下降的攻击者会导致受害网络上出现<strong>欠冲毛刺</strong>（<strong>Undershoot Glitches</strong>）。</p>
<p>​ 图 6-3 说明了由串扰引起的所有四种毛刺情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816113509497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上一小节所述，毛刺由耦合电容、攻击者转换和受害者网络的驱动强度决定。毛刺计算基于开关攻击者注入的电流量、受害者网络的RC互连以及驱动受害者网络的单元的输出阻抗。详细的毛刺计算基于库模型；用于计算的相关噪声模型是第3章中描述的标准单元库模型的一部分。第3.7节中的输出 dc_current模型与单元的输出阻抗相关。</p>
<h3 id="毛刺阈值和传播glitch-thresholds-and-propagation">毛刺阈值和传播（Glitch Thresholds and Propagation）</h3>
<p>​ 如何确定网络上的毛刺是否可以通过扇出单元传播？正如前面的小节所讨论的，由开关干扰源耦合引起的毛刺可以通过扇出单元传播，具体取决于扇出单元和毛刺属性，例如毛刺高度和毛刺宽度。这种分析可以基于直流或交流噪声阈值。 DC 噪声分析仅检查毛刺幅度并且是保守的，而 AC 噪声分析检查其他属性，例如毛刺宽度和扇出单元输出负载。下面描述了在毛刺的 DC 和 AC 分析中使用的各种阈值指标。</p>
<p><strong>直流阈值（DC Thresholds）</strong></p>
<p>​ DC 噪声容限（noise margin）是用于检查毛刺幅度的检查，指的是确保正确的逻辑功能同时，单元输入的 DC 噪声限制。例如，只要输入保持在单元的 VIL 最大值以下，反相器单元的输出就可以是高的（即，保持在 VOH 的最小值以上）。类似地，只要输入保持在 VIH 最小值以上，反相器单元的输出就可以是低的（即保持在 VOL 最大值以下）。这些限制是根据单元的直流传输特性获得的，并且可以填充在单元库中。</p>
<p>​ VOH 是被视为逻辑 1 或高的输出电压范围。 VIL 是被视为逻辑零或低的输入电压范围。 VIH 是被视为逻辑 1 的输入电压范围。 VOL 是被视为逻辑零的输出电压范围。图 6-4 给出了逆变器单元输入-输出直流传输特性的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816115208725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ VILmax 和 VIHmin 限制也称为 DC 裕度限制。基于 VIH 和 VIL 的直流裕度是稳态噪声限值。因此，这些可以用作确定毛刺是否会通过扇出单元传播的过滤器。 DC 噪声容限限制适用于单元的每个输入引脚。通常，对于rise_glitch（输入低）和fall_glitch（输入高），DC 裕度限制是分开的。 DC 裕度的模型可以指定为单元库描述的一部分。无论毛刺的宽度如何，低于 DC 裕度限制的毛刺（例如，低于扇出引脚 VILmax 的上升毛刺）都无法通过扇出传播。因此，保守的毛刺分析检查峰值电压电平（对于所有毛刺）是否满足扇出单元的 VIL 和 VIH 电平。只要所有网络满足扇出单元的 VIL 和 VIH 水平，尽管存在任何毛刺，就可以得出结论，毛刺对设计的功能没有影响（因为毛刺不会导致输出改变）。</p>
<p>​ 图 6-5 显示了直流裕度限制的示例。对于设计中的所有网络，DC 噪声容限也可以固定为相同的限制。可以设置最大的可容忍噪声（或毛刺）幅度，高于该幅度的噪声可以通过单元传播到输出引脚。通常，此检查可确保毛刺电平小于 VILmax 且大于 VIHmin。高度通常表示为电源的百分比。因此，如果 DC 噪声容限设置为 30%，则表明任何大于电压摆幅 30% 的毛刺高度都被识别为潜在毛刺，它可以通过单元传播并可能影响设计的功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816120651510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 并非所有幅度大于直流噪声容限的毛刺都能改变单元的输出。在确定毛刺是否会传播到输出时，毛刺的宽度也是一个重要的考虑因素。单元输入处的窄毛刺通常不会对单元输出造成任何影响。然而，无论信号噪声宽度如何，直流噪声容限仅使用恒定的最坏情况值。参见图 6-6。这提供了噪声抑制水平，它是对单元噪声容限的非常保守的估计。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816120828210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>交流阈值（AC Thresholds）</strong></p>
<p>​ 如上小节所述，毛刺分析的 DC 裕度限制是保守的，因为这些限制是在最坏情况下分析设计的。 DC 裕量限制验证即使毛刺任意宽，也不会影响设计的正常运行。</p>
<p>​ 在大多数情况下，设计可能无法通过保守的 DC 噪声分析限制。因此，必须验证毛刺对毛刺宽度和单元输出负载的影响。通常，如果毛刺很窄或者如果扇出单元具有大的输出电容，则毛刺不会影响正常的功能操作。毛刺宽度和输出电容的影响都可以用扇出单元的惯性来解释。通常，单级单元将停止比通过单元的延迟窄得多的任何输入毛刺。这是因为对于窄毛刺，毛刺在扇出单元可以响应之前就结束了。因此，非常窄的毛刺不会对电池产生任何影响。由于输出负载增加了通过单元的延迟，因此增加输出负载具有将输入端毛刺的影响降至最低的效果，尽管它具有增加单元延迟的不利影响。</p>
<p>​ AC 噪声抑制如图 6-7 所示（对于固定输出电容）。深色阴影区域代表良好或可接受的毛刺，因为这些毛刺太窄或太短，或两者兼而有之，因此对单元的功能行为没有影响。浅阴影区域表示不良或不可接受的毛刺，因为这些毛刺太宽或太高，或既宽又高，因此在单元输入端的这种毛刺会影响单元的输出。在毛刺较宽的极限情况下，毛刺阈值对应于DC噪声裕量，如图6-7所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816123436993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于给定的单元，增加输出负载会增加噪声容限，因为它会增加惯性延迟和可以通过单元的毛刺宽度。下面通过一个例子来说明这种现象。图 6-8(a) 显示了一个无负载的逆变器单元，其输入端有一个正毛刺。输入毛刺高于单元的直流裕度，并导致逆变器输出出现毛刺。图 6-8(b) 显示了在其输出端带有一些负载的相同逆变器单元。输入端相同的输入毛刺会导致输出上的毛刺小得多。如果逆变器单元的输出负载更高，如图 6-8(c) 所示，则逆变器单元的输出没有任何毛刺。因此，增加输出端的负载会使单元更不受从输入端传播到输出端的噪声的影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816133000422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上所述，低于 AC 阈值（图 6-7 中的 AC 噪声抑制区域）的毛刺可以被忽略，或者可以认为扇出单元不受此类毛刺的影响。 AC 阈值（或抗扰度）区域取决于输出负载和毛刺宽度。如第3章中所述，抗扰度模型（noise immunity model）包括上述AC噪声抑制的影响，3.7节中介绍的<strong>propagated_noise</strong>模型除了对通过单元的传播进行建模外，还包括了AC噪声阈值的影响。</p>
<p>​ 如果毛刺大于 AC 阈值会发生什么？在毛刺幅度超过 AC 阈值的情况下，单元输入处的毛刺会在单元输出处产生另一个毛刺。输出毛刺高度和宽度是输入毛刺宽度和高度以及输出负载的函数。此信息在单元库中进行了表征，其中包含输出毛刺幅度和宽度的详细表格或函数，作为输入引脚毛刺幅度、毛刺宽度和输出引脚负载的函数。毛刺传播由包含在库单元描述中的<strong>propagated_noise</strong>模型控制。<strong>propagated_noise</strong>（低和高）模型在第 3 章中详细描述。</p>
<p>​ 基于以上内容，在扇出单元的输出处计算毛刺，并在扇出网络上进行相同的检查（以及毛刺传播到扇出），依此类推。</p>
<p>虽然我们在上面的讨论中使用了通用术语“毛刺”，但应注意，这分别适用于前一小节中提到的所有类型的毛刺：上升毛刺（由早期模型中的<strong>propagated_noise_high</strong>或<strong>noise_immunity_high</strong>建模），下降毛刺（由早期模型中的<strong>propagated_noise_low</strong>或<strong>noise_immunity_low</strong>建模），过冲毛刺（由<strong>noise_immunity_above_high</strong>建模）和欠冲毛刺（由<strong>noise_immunity_below_low</strong>建模）。</p>
<p>​ 总之，单元的不同输入对毛刺阈值有不同的限制，毛刺阈值是毛刺宽度和输出电容的函数。这些限制对于输入高（低转换毛刺）和输入低（高转换毛刺）是分开的。噪声分析会检查毛刺的峰值和宽度，并分析它是否可以被忽略或它是否可以传播到扇出。</p>
<h3 id="多个干扰源的噪声累积noise-accumulation-with-multiple-aggressors">多个干扰源的噪声累积（Noise Accumulation with Multiple Aggressors）</h3>
<p>​ 图 6-9 描述了由于单个攻击者网络切换和在受害网络上引入串扰毛刺引起的耦合。一般而言，受害网络可以电容耦合到许多网络。当多个网络同时切换时，由于有多个攻击者，串扰耦合噪声对受害者的影响更加复杂。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816133759845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于多个攻击者引起的耦合的大多数分析都会添加由于每个攻击者引起的毛刺效应，并计算对受害者的累积影响。这可能看起来很保守，但它确实表明了受害者最坏的情况。另一种方法是使用 RMS（均方根）方法。使用 RMS 选项时，受害设备上的毛刺幅度是通过取个别攻击者引起的毛刺的均方根来计算的。</p>
<h3 id="干扰源时序相关性aggressor-timing-correlation">干扰源时序相关性（Aggressor Timing Correlation）</h3>
<p>​ 对于由多个干扰源引起的串扰毛刺，分析必须包括干扰源网络的时序相关性，并确定多个干扰源是否可以同时切换。 STA 从攻击者网络的时序窗口中获取此信息。在时序分析过程中，得到网络最早和最晚的切换时间。这些时间代表网络可以在一个时钟周期内切换的时序窗口。切换窗口（上升和下降）提供有关攻击者网络是否可以一起切换的必要信息。</p>
<p>​ 根据多个干扰源是否可以同时切换，将单个干扰源造成的毛刺组合起来用于受害网络。作为第一步，毛刺分析为每个潜在干扰源分别计算四种类型的毛刺（上升、下降、欠冲和过冲）。下一步结合来自各个干扰源的故障贡献。多个干扰源可以针对每种类型的毛刺单独组合。例如，考虑耦合到攻击者网络 A1、A2、A3 和 A4 的受害者网络 V。在分析过程中，A1、A2 和 A4 可能会导致上升和过冲毛刺，而只有 A2 和 A3 会导致欠冲和下降毛刺。</p>
<p>​ 考虑另一个示例，其中当攻击者网络转换时，四个攻击者网络会导致上升的毛刺。图 6-10 显示了由每个攻击者网络引起的时序窗口和毛刺幅度。根据时序窗口，毛刺分析确定导致最大毛刺的干扰源切换的最坏可能组合。在这个例子中，切换窗口区域被分为四个 bin - 每个 bin 显示可能的干扰源切换。图 6-10 还描述了来自每个干扰源的毛刺贡献。 Bin 1 具有 A1 和 A2 切换，这可能导致 0.21 (= 0.11+ 0.10) 的毛刺幅度。 Bin 2 具有 A1、A2 和 A3 切换，这会导致毛刺幅度为 0.30 (= 0.11+ 0.10+ 0.09)。 Bin 3 具有 A1 和 A3 切换，这会导致毛刺幅度为 0.20 (= 0.11 +0.09)。 Bin 4 具有 A3 和 A4 切换，这会导致毛刺幅度为 0.32 (= 0.09+ 0.23)。</p>
<p>​ 因此，bin 4 具有 0.32 的最坏可能的毛刺幅度。请注意，不使用时序窗口的分析将预测组合毛刺幅度为 0.53 (= 0.11+ 0.10+ 0.09 +0.23)，这可能过于悲观。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816134634802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="干扰源功能相关性aggressor-functional-correlation">干扰源功能相关性（Aggressor Functional Correlation）</h3>
<p>​ 对于多个干扰源，通过考虑网络可能切换的切换窗口，使用时序窗口减少了分析中的悲观情绪。此外，另一个需要考虑的因素是各种信号之间的功能相关性。例如，scan（在DFT test mode） 控制信号仅在扫描模式期间切换，并且在设计的功能或任务模式期间稳定。因此，在功能模式期间，扫描控制信号不会对其他信号造成毛刺。扫描控制信号只能是扫描模式期间的干扰源。在某些情况下，测试时钟和功能时钟是相互排斥的，因此测试时钟仅在测试期间当功能时钟关闭时才有效。在这些设计中，由测试时钟控制的逻辑和由功能时钟控制的逻辑创建了两组不相交的干扰源。在这种情况下，测试时钟控制的干扰源不能与功能时钟控制的其他干扰源结合进行最坏情况噪声计算。功能相关的另一个例子是两个干扰源，它们是彼此的补充（逻辑相反）。在这种情况下，信号及其补码不能在相同方向上切换以计算串扰噪声。</p>
<p>​ 图 6-11 显示了网络 N1 与其他三个网络 N2、N3 和 N4 耦合的示例。在功能关联中，需要考虑网络的功能。假设网络 N4 是一个常数（例如，模式设置网络），因此不能成为网络 N1 上的干扰源，尽管它是耦合的。假设 N2 是一个网络，它是调试总线的一部分，但在功能模式下处于稳定状态。因此，网络 N2 不能成为网络 N1 的干扰源。假设网络 N3 携带功能数据，只有网络 N3 可以被视为网络 N1 的潜在干扰源。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816135228719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="串扰延迟分析crosstalk-delay-analysis">串扰延迟分析（Crosstalk Delay Analysis）</h2>
<h3 id="基础知识basics-1">基础知识（Basics）</h3>
<p>​ 纳米设计中典型网络的电容提取由许多相邻导体的贡献组成。其中一些是接地电容，而其他许多来自作为其他信号网络一部分的走线。接地电容和信号间电容如图 6-1 所示。在基本延迟计算期间，所有这些电容都被视为网络总电容的一部分（不考虑任何串扰）。当相邻网络稳定（或未切换）时，信号间电容可被视为接地。当相邻网络切换时，通过耦合电容的充电电流会影响网络的时序。根据攻击者网络切换的方向，从网络上看到的等效电容可以更大或更小。这在下面的一个简单示例中进行了解释。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816135701239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 6-12 显示了网络 N1，它有一个到相邻网络（标记为 Aggressor）的耦合电容 Cc 和一个到地的电容 Cg。此示例假设网络 N1 在输出端具有上升过渡，并根据攻击者网络是否同时切换来考虑不同的场景。</p>
<p>​ 如下文所述，驱动单元在各种情况下所需的电容性电荷可能不同。</p>
<ul>
<li>攻击者网络处于稳定状态：在这种情况下，网络N1的驱动单元将提供电荷使Cg和Cc充电至Vdd。因此，该网络的驱动单元提供的总电荷为（Cg + Cc）* Vdd。这种情况可以进行基本的延迟计算，因为在这种情况下未考虑来自攻击者网络的串扰。表6-13中为此情况下在网络N1电平切换前后Cg和Cc中的电荷量：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210816141300400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>攻击者网络朝同方向切换电平： 在这种情况下，往同方向电平切换的攻击者网络可以起辅助驱动单元的作用。如果攻击者网络同时以相同的转换slew（相同的transition time）进行电平切换，则驱动单元提供的总电荷仅为（Cg * Vdd ）。如果攻击者网络的转换比N1网络转换更快，则所需的实际电荷可能甚至小于（Cg * Vdd），因为攻击者网络也可以为Cg提供充电电流。因此，在攻击者朝相同方向切换电平时，来自驱动单元的所需电荷会小于表6-13中描述的攻击者处于稳定状态时的所需电荷。因此，当攻击者网络朝相同方向切换电平时会导致网络N1切换电平的延迟更短， 延迟的减少被标记为负串扰延迟（negative crosstalk delay）。这种情况请参见表6-14，通常会在进行最小路径分析时考虑此情况。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021081614141976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<ul>
<li>攻击者网络朝相反方向切换电平：在这种情况下，耦合电容需要从-Vdd充电到Vdd。因此在电平切换前后，耦合电容上的电荷变化量为（2 * Cc * Vdd），网络N1的驱动单元以及攻击者网络均需要提供额外的电荷。这种情况会导致网络N1切换电平的延迟更大，延迟的增加被标记为正串扰延迟（positive crosstalk delay）。这种情况请参阅表6-15，通常会在进行最大路径分析时考虑此情况。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210816141630904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 上面的例子说明了 Cc 在各种情况下的充电以及它如何影响交换网络的延迟（标记为 N1）。该示例仅考虑网络 N1 处的上升过渡，但类似的分析也适用于下降过渡。</p>
<h3 id="正负串扰positive-and-negative-crosstalk">正负串扰（Positive and Negative Crosstalk）</h3>
<p>​ 基本延迟计算（没有任何串扰）假设驱动单元为网络总电容 Ctotal (= Cground +Cc) 的轨到轨（rail-to-rail）转换提供所有必要的电荷。如前一小节所述，当耦合（攻击者）网络和受害者网络在相反方向切换时，耦合电容 Cc 所需的电荷更大。在相反方向上的攻击者切换增加了受害网络的驱动单元所需的电荷量，并增加了受害网络的驱动单元和互连的延迟。</p>
<p>​ 类似地，当耦合（攻击者）网络和受害者网络在同一方向切换时，Cc 上的电荷在受害者和攻击者转换之前和之后保持不变。这减少了受害网络的驱动单元所需的电荷。减少了驱动单元和受害网络互连的延迟。</p>
<p>​ 如上所述，受害者和攻击者的并发切换会影响受害者转换的时间。根据干扰源的切换方向，串扰延迟效应可以是正的（减缓受害转换）或负的（加速受害转换）。</p>
<p>​ 图 6-16 显示了正串扰延迟效应的示例。当受害网络发生下降过渡时，攻击者网络正在上升。相反方向的攻击者网络切换增加了受害网络的延迟。正串扰会影响驱动单元和互连——这两者的延迟都会增加。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816142120804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图6-17显示了串扰延迟为负的情况。攻击者网络与受害者网络同时上升，攻击者网络与受害者网络朝相同方向的电平切换可减少受害者网络的延迟。如前所述，负串扰（negative crosstalk）会影响驱动单元和互连线的时序，两者的延迟都会减小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816142342734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 注意，最差的正串扰延迟和最差的负串扰延迟会分别针对上升和下降延迟进行计算。一般来说，由于串扰而导致的最大上升时间、最小上升时间、最大下降时间、最大下降时间延迟的干扰源是不同的，这将在下面的小节中进行介绍。</p>
<h3 id="多个干扰源的累积accumulation-with-multiple-aggressors">多个干扰源的累积（Accumulation with Multiple Aggressors）</h3>
<p>​ 具有多个干扰源的串扰延迟分析涉及对每个干扰源的串扰造成的影响进行累加。这类似于第 6.2 节中描述的串扰毛刺分析。当多个网络同时切换时，由于多个攻击者，对受害者的串扰延迟效应会变得更加复杂。</p>
<p>​ 由于多个干扰源引起的耦合的大多数分析都会添加每个攻击者的增量贡献并计算对受害者的累积影响。这可能看起来很保守，但它确实表明受害设备上的最坏情况串扰延迟。</p>
<p>​ 与用于串扰毛刺分析的多个干扰源的分析类似，也可以使用均方根 (RMS) 来添加贡献，这比单个贡献的直和更不悲观。</p>
<h3 id="攻击者-受害者时间相关性aggressor-victim-timing-correlation">攻击者-受害者时间相关性（Aggressor Victim Timing Correlation）</h3>
<p>​ 串扰延迟分析的时序相关处理在概念上类似于第 6.2 节中描述的串扰毛刺分析的时序相关。串扰会影响受害者的延迟，前提是攻击者可以与受害者同时切换。这是使用攻击者和受害者的时序窗口确定的。如第 6.2 节所述，时序窗口表示网络可以在一个时钟周期内切换的最早和最晚切换时间。如果攻击者和受害者的时序窗口重叠，则计算串扰对延迟的影响。对于多个攻击者，多个攻击者的时序窗口也进行了类似的分析。计算各种时序仓中的可能影响，并考虑串扰延迟影响最严重的时序仓进行延迟分析。</p>
<p>​ 考虑下面的示例，其中三个攻击者网络可以影响受害者网络的时间。攻击者网络 (A1, A2, A3) 电容耦合到受害者网络 (V) 并且它们的时序窗口与受害者网络重叠。图 6-18 显示了时序窗口和每个干扰源可能造成的串扰延迟影响。基于时序窗口，串扰延迟分析确定引起最大串扰延迟影响的干扰源切换的最坏可能组合。在这个例子中，时间窗口重叠区域被分成三个 bin - 每个 bin 显示可能的攻击者切换。 Bin 1 具有 A1 和 A2 切换，这会导致串扰延迟影响为 0.26 (= 0.12 +0.14)。 Bin 2 具有 A1 切换，这会导致 0.14 的串扰延迟影响。 Bin 3 具有 A3 切换，可导致 0.23 的串扰延迟影响。因此，bin 1 具有 0.26 的最坏可能的串扰延迟影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816150505788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如前所述，串扰延迟分析将分别计算四种类型的串扰延迟。串扰延迟的四种类型是：正上升延迟（上升沿提前到达）、负上升延迟（上升沿滞后到达）、正下降延迟和负下降延迟。通常，在这四种情况下，网络可以具有不同的攻击者组合。例如，受害者网络具有攻击者网络A1、A2、A3和A4。在串扰延迟分析过程中，A1、A2、A4可能对正上升和负下降延迟有影响，而A2和A3对负上升和正下降延迟有影响。</p>
<h3 id="攻击者-受害者功能相关性aggressor-victim-functional-correlation">攻击者-受害者功能相关性（Aggressor Victim Functional Correlation）</h3>
<p>​ 除了时序窗口，串扰延迟计算还可以考虑各种信号之间的功能相关性。例如，扫描控制信号仅在扫描模式期间切换并且在设计的功能或任务模式期间稳定。因此，扫描控制信号在功能模式期间不能成为干扰源。在扫描模式期间，扫描控制信号只能是干扰源，在这种情况下，这些信号不能与其他功能信号组合以进行最坏情况噪声计算。</p>
<p>​ 功能相关的另一个例子是两个干扰源互为补充的场景。在这种情况下，信号及其补码永远不能在相同方向上切换以计算串扰噪声。当可用时，可以利用这种类型的函数相关信息，从而通过确保只有实际可以一起切换的信号作为干扰源被包括在内，从而使串扰分析结果不悲观。</p>
<h2 id="使用串扰延迟进行时序验证timing-verification-using-crosstalk-delay">使用串扰延迟进行时序验证（Timing Verification Using Crosstalk Delay）</h2>
<p>​ 需要为设计中的每个单元和互连线计算以下四种类型的串扰延迟影响：</p>
<ul>
<li>正上升延迟（Positive rise delay）：上升沿提前到达</li>
<li>负上升延迟（Negative rise delay）：上升沿滞后到达</li>
<li>正下降延迟（Positive fall delay）：下降沿提前到达</li>
<li>负下降延迟（Negative fall delay）：下降沿滞后到达</li>
</ul>
<p>​ 然后在时序分析期间利用串扰延迟贡献来验证最大和最小路径（setup and hold checks）。启动和捕获触发器的时钟路径处理方式不同。本节描述了用于建立和保持检查的数据路径和时钟路径分析的详细信息。</p>
<h3 id="建立时间分析setup-analysis">6.4.1建立时间分析（Setup Analysis）</h3>
<p>​ 具有串扰分析功能的 STA 使用数据路径和时钟路径的最坏情况串扰延迟来验证设计。考虑图 6-19 中所示的逻辑，其中数据路径和时钟路径上的各种网络可能会发生串扰。建立时间检查的最坏情况是启动时钟路径（launch clock path）和数据路径都具有正串扰，而捕获时钟路径（capture clock path）具有负串扰。发射时钟路径和数据路径上的正串扰贡献延迟了数据到达捕获触发器。此外，捕获时钟路径上的负串扰导致捕获触发器提前计时。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816152033601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 基于以上描述，建立时间（或最大路径）分析假设：</p>
<ul>
<li>发起时钟路径出现正串扰延迟，因此发起数据较迟。</li>
<li>数据路径出现正串扰延迟，因此数据到达目的地需要更长的时间。</li>
<li>捕获时钟路径出现负串扰延迟，因此数据被捕获触发器提早捕获。</li>
</ul>
<p>​ 由于建立时间检查的启动和捕获时钟沿不同（通常相隔一个时钟周期），公共时钟路径（图 6-19）可能对启动和捕获时钟沿有不同的串扰贡献。</p>
<h3 id="保持时间分析hold-analysis">6.4.2保持时间分析（Hold Analysis）</h3>
<p>​ STA 的最坏情况保持时间（或最小路径）分析类似于上一小节中描述的最坏情况设置分析。根据图 6-19 中所示的逻辑，当启动时钟路径和数据路径都具有负串扰并且捕获时钟路径具有正串扰时，会发生保持时间检查的最坏情况。发射时钟路径和数据路径上的负串扰贡献导致数据提前到达捕获触发器。此外，捕获时钟路径上的正串扰导致捕获触发器的时钟延迟。</p>
<p>​ 与时钟路径公共部分上的串扰相关的保持时间和建立时间分析之间存在一个重要区别。对于保持时间分析，启动和捕获时钟边沿通常是相同的边沿。通过公共时钟部分的时钟沿不能对启动时钟路径和捕获时钟路径具有不同的串扰贡献。因此，最坏情况保持时间分析消除了公共时钟路径中的串扰影响。</p>
<p>​ 因此，具有串扰的STA最差情况保持时间（或最小路径）分析将假定：</p>
<ul>
<li>发起时钟（不包括公共时钟路径部分）的串扰延迟影响为负，因此可以较早地发起数据；</li>
<li>数据路径的串扰延迟影响为负，因此数据会较早到达目的地；</li>
<li>捕获时钟（不包括公共时钟路径部分）的串扰延迟影响为正，因此捕获触发器会较迟地捕获数据</li>
</ul>
<p>​ 如上所述，保持时间分析不考虑对时钟树公共部分的串扰影响。仅针对时钟树的非公共部分计算启动时钟的正串扰贡献和捕获时钟的负串扰贡献。在用于保持分析的 STA 报告中，公共时钟路径可能会显示启动时钟路径和捕获时钟路径的不同串扰贡献。然而，来自公共时钟路径的串扰贡献作为单独的行项目被移除，标记为公共路径悲观消除。 STA 报告中常见路径悲观消除的示例在第 10.1 节中提供。</p>
<p>​ 如前一小节所述，建立时间分析涉及时钟的两个不同边沿，它们可能会在时序上受到不同的影响。因此，在建立时间分析期间，对启动和捕获时钟路径都考虑了公共路径串扰贡献。</p>
<p>​ 时钟信号至关重要，因为时钟树上的任何串扰都会直接转化为时钟抖动并影响设计的性能。因此，应特别考虑减少时钟信号上的串扰。一种常见的噪声避免方法是时钟树的屏蔽——这将在第 6.6 节中详细讨论。</p>
<h2 id="计算复杂性computational-complexity">计算复杂性（Computational Complexity）</h2>
<p>​ 大型纳米设计通常过于复杂，无法在合理的周转时间内分析每个耦合电容。典型网络的寄生提取包含与许多相邻信号的耦合电容。大型设计通常需要为寄生提取和串扰延迟和毛刺分析进行适当的设置。选择这些设置是为了提供可接受的分析精度，同时确保 CPU 要求仍然可行。本节介绍一些可用于分析大型纳米设计的技术。</p>
<p><strong>分层设计和分析（Hierarchical Design and Analysis）</strong></p>
<p>​ 第 4.5 节介绍了验证大型设计的分层方法。类似的方法也适用于降低提取和分析的复杂性。</p>
<p>​ 对于大型设计，在一次运行中获得寄生提取通常是不切实际的。可以单独提取每个分层块的寄生参数。这反过来又要求在设计实现中使用分层设计方法。这意味着分层块内的信号和块外的信号之间没有耦合。这可以通过在块上不布线或通过在块上添加屏蔽层来实现。此外，信号网络不应靠近模块边界布线，靠近模块边界布线的任何网络都应屏蔽。这避免了与来自其他块的网络的任何耦合。</p>
<p><strong>耦合电容滤波（Filtering of Coupling Capacitances）</strong></p>
<p>​ 即使对于中等大小的模块，寄生效应通常也会包括大量非常小的耦合电容。可以在提取或分析过程中过滤小耦合电容。</p>
<p>这样的过滤是基于以下原则的：</p>
<ul>
<li>较小的值：在串扰或噪声分析中，可以忽略非常小的耦合电容，例如低于1fF。在提取过程中，数值较小的耦合电容可以视为接地电容。</li>
<li>耦合比：耦合对受害者网络的影响是基于耦合电容相对于受害者网络总电容的相对值。具有较小耦合比（例如低于0.001）的攻击者网络可以从串扰延迟分析或串扰毛刺分析中排除。</li>
<li>合并小型干扰源：可以将影响很小的多个干扰源映射为一个较大的虚拟干扰源。这可能有点悲观，但可以简化分析。可以通过切换干扰源的子集来缓解一些悲观度，干扰源的确切子集可以通过统计方法来确定。</li>
</ul>
<h2 id="噪声避免技术noise-avoidance-techniques">噪声避免技术（Noise Avoidance Techniques）</h2>
<p>​ 前面的部分描述了串扰效应的影响和分析。在本节中，我们将介绍一些可在物理设计阶段使用的噪声避免技术。</p>
<ul>
<li>屏蔽（Shielding）：此方法要求将屏蔽线放置在关键信号的任一侧。屏蔽连接到电源或接地导轨。关键信号的屏蔽确保关键信号没有主动干扰源，因为同一金属层中最近的邻居是固定电位的屏蔽走线。虽然不同金属层中的路径可能存在一些耦合，但大多数耦合电容是由于同一层中的电容耦合。由于不同金属层（上方和下方）通常会正交走线，这样跨层的电容耦合会最小化。因此，将屏蔽线放置在同一金属层中可确保关键信号的耦合最小。在由于布线拥塞而无法使用接地或电源轨进行屏蔽的情况下，具有低开关活动（例如在功能模式期间固定的扫描控制）的信号可以作为关键信号的直接邻居进行布线。这些屏蔽方法可确保不会因相邻设备的电容耦合而产生串扰。</li>
<li>线间距（Wire spacing）：这减少了与相邻网络的耦合。</li>
<li>快速转换率（Fast slew rate）：网络上的快速转换率意味着网络不易受串扰影响，并且本质上不受串扰效应的影响。</li>
<li>保持良好的稳定电源（Maintain good stable supply）：这对于减少由于电源变化引起的抖动而不是串扰很重要。由于电源上的噪声，时钟信号上可能会引入大量噪声。应添加足够的去耦电容以将电源噪声降至最低。</li>
<li>保护环（Guard ring）：基板中的保护环（或双保护环）有助于保护关键模拟电路免受数字噪声的影响。</li>
<li>深 n 阱（Deep n-well）：这与上述类似，因为模拟部分具有深 n 阱有助于防止噪声耦合到数字部分。</li>
<li>隔离块（Isolating a block）：在分层设计流程中，可以将布线晕圈（halos）添加到块的边界；此外，还可以将隔离缓冲器（isolation buffers）添加到块的每个IO中。</li>
</ul>
<h1 id="配置-sta-环境configuring-the-sta-environment">配置 STA 环境（Configuring the STA Environment）</h1>
<blockquote>
<p>第 7 章是后续章节的先决条件。它描述了如何配置时序分析环境。描述了指定时钟、IO 特性、伪路径和多周期路径的方法。</p>
</blockquote>
<p>正确约束的说明对于分析STA结果非常重要。应准确指定设计环境，以便STA分析能够识别设计中的所有时序问题。STA的准备包括设置时钟、指定IO定时特性以及指定伪路径和多周期路径。在继续下一章关于时间验证之前，彻底理解本章非常重要。</p>
<h2 id="什么是sta环境what-is-the-sta-environment">什么是STA环境？（What is the STA Environment?）</h2>
<p>​ 大多数数字设计都是同步的，从上一个时钟周期计算的数据锁存在活动时钟边缘的触发器中。考虑图7-1所示的典型同步设计，假设分析设计（DUA）与其他同步设计相互作用。这意味着DUA从时钟触发器接收数据，并将数据输出到DUA外部的另一个时钟触发器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816171100811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 要在此设计上执行STA，需要指定触发器的时钟，以及通向设计的所有路径和退出设计的所有路径的时序约束。</p>
<p>​ 图7-1中的示例假设只有一个时钟，C1、C2、C3、C4和C5表示组合块。组合块C1和C5不在所分析的设计范围内。</p>
<p>​ 在典型设计中，从一个时钟域到另一个时钟域可以有多个时钟，具有多条路径。以下各节介绍如何在此类场景中指定环境。</p>
<h2 id="指定时钟specifying-clocks">指定时钟（Specifying Clocks）</h2>
<p>​ 要定义时钟，我们需要提供以下信息：</p>
<ul>
<li>时钟源（Clock source）：它可以是设计的端口，也可以是设计内部单元的引脚（通常是时钟生成逻辑的一部分）。</li>
<li>周期（Period）：时钟的周期。</li>
<li>占空比（Duty cycle）：高电平持续时间（正相位）和低电平持续时间（负相位）。</li>
<li>边沿时间（Edge times）：上升沿和下降沿的时刻。</li>
</ul>
<p>​ 图7-2显示了基本定义。通过定义时钟，所有内部时序路径（所有触发器到触发器路径）都受到约束；这意味着所有内部路径都可以仅使用时钟规格进行分析。时钟规范规定触发器到触发器的路径必须占用一个周期。我们将在后面描述如何放宽这一要求（一个周期时间）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816171510415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是一个基本的时钟约束规范：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">create_clock \</span><br><span class="line"></span><br><span class="line"><span class="deletion">-name SYSCLK \</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-period 20 \</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-waveform &#123;0 5&#125; \</span></span><br><span class="line"></span><br><span class="line">[get_ports2SCLK]</span><br></pre></td></tr></table></figure>
<p>​ 时钟的名称为SYSCLK，在端口SCLK处定义。SYSCLK的周期指定为20个单位-如果未指定，则默认时间单位为纳秒(通常，时间单位指定为技术库的一部分。）波形中的第一个参数指定上升沿出现的时间，第二个参数指定下降沿出现的时间。</p>
<p>​ <strong>waveform</strong>选项中可以指定任意数量的边。但是，所有边缘必须在一个周期内。沿时间从时间零点后的第一个上升沿开始交替，然后是下降沿，然后是上升沿，依此类推。这意味着<strong>waveform</strong>列表中的所有时间值必须是单调递增的。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-waveform &#123;time_rise time_fall time_rise time_fall ...&#125;</span></span><br></pre></td></tr></table></figure>
<p>​ 此外，必须指定偶数条边。 <strong>waveform</strong>选项指定一个时钟周期内的波形，然后该时钟周期自身重复。</p>
<p>​ 如果未指定<strong>waveform</strong>选项，默认值为：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-waveform &#123;0, period/2&#125;</span></span><br></pre></td></tr></table></figure>
<p>​ 这里是一个没有波形规范的时钟规范示例（见图7-3）。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">5</span> <span class="selector-attr">[get_ports SCAN_CLK]</span></span><br></pre></td></tr></table></figure>
<p>​ 在此约束中，由于未指定<strong>-name</strong>选项，因此时钟的名称与端口的名称相同，即SCAN_CLK。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816174503166.png" alt="img"></p>
<p>​ 以下是时钟约束的另一个示例，其中波形的边沿在一个周期的中间位置（见图7-4）。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_clock -name BDYCLK -period <span class="number">15</span> \</span><br><span class="line"></span><br><span class="line">-waveform &#123;<span class="number">5</span> <span class="number">12</span>&#125; <span class="selector-attr">[get_ports GBLCLK]</span></span><br></pre></td></tr></table></figure>
<p>​ 时钟的名称为BDYCLK，在端口GBLCLK处定义。实际上，保持时钟名称与端口名称相同是一个好主意。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816174641550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这里有更多的时钟约束示例。</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="comment"># See Figure 7-5(a):</span></span><br><span class="line"></span><br><span class="line">create_clock -period 10 -<span class="keyword">waveform</span> &#123;<span class="number">5</span> <span class="number">10</span>&#125; [get_ports FCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a clock with the rising edge at 5ns and the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># falling edge at 10ns.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See Figure 7-5(b):</span></span><br><span class="line"></span><br><span class="line">create_clock -period 125 \</span><br><span class="line"></span><br><span class="line">-<span class="keyword">waveform</span> &#123;<span class="number">100</span> <span class="number">150</span>&#125; [get_ports ARMCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Since the first edge has to be rising edge,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the edge at 100ns is specified first and then the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># falling edge at 150ns is specified. The falling edge</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># at 25ns is automatically inferred.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021081617482936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># See Figure 7-6(a):</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">1.0</span> -waveform &#123;<span class="number">0.5</span> <span class="number">1.375</span>&#125; MAIN_CLK</span><br><span class="line"></span><br><span class="line"><span class="comment"># The first rising edge and the next falling edge</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># is specified. Falling edge at 0.375ns is inferred</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># automatically.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See Figure 7-6(b):</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">1.2</span> -waveform &#123;<span class="number">0.3</span> <span class="number">0.4</span> <span class="number">0.8</span> <span class="number">1.0</span>&#125; JTAG_CLK</span><br><span class="line"></span><br><span class="line"><span class="comment"># Indicates a rising edge at 300ps, a falling edge at 400ps,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a rising edge at 800ps and a falling edge at 1ns, and this</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pattern is repeated every 1.2ns.</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">1.27</span> \</span><br><span class="line"></span><br><span class="line">-waveform &#123;<span class="number">0</span> <span class="number">0.635</span>&#125; [get_ports clk_core]</span><br><span class="line"></span><br><span class="line">create_clock -name TEST_CLK -period <span class="number">17</span> \</span><br><span class="line"></span><br><span class="line">-waveform &#123;<span class="number">0</span> <span class="number">8.5</span>&#125; -add [get_ports &#123;ip_io_clk[<span class="number">0</span>]&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -add option allows more than one clock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specification to be defined at a port.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210816175123952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><em>锁相环PLL（Phase-locked loop）：在专用集成电路中常用来产生高频时钟 。</em></p>
<p>​ 除上述属性外，还可以选择指定时钟源处的转换时间。在某些情况下，例如某些PLL模型的输出或输入端口，该工具无法自动计算过渡时间。在这种情况下，明确指定时钟源处的转换时间非常有用。这是使用<strong>set_clock_transition</strong>命令指定的。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_clock_transition -rise <span class="number">0.1</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br><span class="line"></span><br><span class="line">set_clock_transition -fall <span class="number">0.12</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br></pre></td></tr></table></figure>
<p>​ 这个约束仅适用于理想时钟，一旦构建了时钟树就将其忽略，因为此时将会使用时钟引脚上的实际过渡时间。如果在输入端口上定义了时钟，也可以使用<strong>set_input_transition</strong>命令（参见7.7节）来约束时钟的转换。</p>
<h3 id="时钟不确定性clock-uncertainty">时钟不确定性（Clock Uncertainty）</h3>
<p>​ 可以使用 set_clock_uncertainty 约束指定时钟周期的时序不确定性。不确定性可用于模拟可以减少有效时钟周期的各种因素。这些因素可以是时钟抖动和任何其他可能希望用于时序分析的悲观因素。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_clock_uncertainty -setup <span class="number">0.2</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -hold <span class="number">0.05</span> <span class="selector-attr">[get_clocks CLK_CONFIG]</span></span><br></pre></td></tr></table></figure>
<p>​ 注意，建立时间检查的时钟不确定度将减少可用的有效时钟周期，如图7-7所示。对于保持时间检查，时钟不确定度将用作需要满足的额外时序裕量。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816180618575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下命令可用于指定跨时钟边界路径上的时钟不确定度，称为时钟间不确定度（inter-clock uncertainty）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> VIRTUAL_SYS_CLK -<span class="selector-tag">to</span> SYS_CLK \</span><br><span class="line"></span><br><span class="line">-hold <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> VIRTUAL_SYS_CLK -<span class="selector-tag">to</span> SYS_CLK \</span><br><span class="line"></span><br><span class="line">-setup <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> SYS_CLK -<span class="selector-tag">to</span> CFG_CLK -hold <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -<span class="selector-tag">from</span> SYS_CLK -<span class="selector-tag">to</span> CFG_CLK -setup <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<p>​ 图 7-8 显示了两个不同时钟域 SYS_CLK 和 CFG_CLK 之间的路径。根据上述时钟间不确定性约束，100ps 用作建立时间检查的不确定性，50ps 用作保持时间检查的不确定性。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816180942927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="时钟延迟clock-latency">时钟延迟（Clock Latency）</h3>
<p>​ 可以使用<strong>set_clock_latency</strong>命令指定时钟的延迟。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Rise clock latency on MAIN_CLK is 1.8ns:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency <span class="number">1.8</span> -rise [get_clocks MAIN_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fall clock latency on all clocks is 2.1ns:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency <span class="number">2.1</span> -fall [all_clocks]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -rise, -fall refer to the edge at the clock pin of a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flip-flop.</span></span><br></pre></td></tr></table></figure>
<p>​ 时钟延迟有两种类型：网络延迟（network latency）和源延迟（source latency）。网络延迟是从时钟定义点 (create_clock) 到触发器时钟引脚的延迟。源延迟，也称为插入延迟（insertion delay），是从时钟源到时钟定义点的延迟。源延迟可以代表片上或片外延迟。图 7-9 显示了这两种情况。触发器时钟引脚的总时钟延迟是源延迟和网络延迟的总和。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816181315130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 下面是一些指定源和网络延迟的示例命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Specify a network latency (no -source option) of 0.8ns for</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rise, fall, max and min:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 0.8 [get_clocks CLK_CONFIG]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a source latency:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 1.9 -<span class="built_in">source</span> [get_clocks SYS_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a min source latency:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 0.851 -<span class="built_in">source</span> -min [get_clocks CFG_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a max source latency:</span></span><br><span class="line"></span><br><span class="line">set_clock_latency 1.322 -<span class="built_in">source</span> -max [get_clocks CFG_CLK]</span><br></pre></td></tr></table></figure>
<p>​ 源延迟和网络延迟之间的一个重要区别是：一旦为设计建立了时钟树，就可以忽略网络延迟（假设指定了<strong>set_propagated_clock</strong>命令）。但是，即使在建立时钟树之后，源延迟也会保留。网络延迟是在进行时钟树综合（Clock Tree Synthesis）之前对时钟树延迟的估计值。在时钟树综合完成后，从时钟源到触发器时钟引脚的总时钟延迟是源延迟加上时钟树从时钟定义点到触发器的实际延迟。</p>
<p>​ 生成时钟在下一节中描述，虚拟时钟在 7.9 节中描述。</p>
<h2 id="生成时钟generated-clocks">生成时钟（Generated Clocks）</h2>
<p>​ 生成时钟是从主时钟派生的时钟。主时钟是使用 <strong>create_clock</strong> 命令定义的时钟。</p>
<p>​ 在基于主时钟的设计中生成新时钟时，可以将新时钟定义为生成时钟。例如，如果时钟有一个 3 分频电路，则可以在该电路的输出端定义一个生成时钟。这个定义是必需的，因为 STA 不知道分频逻辑输出端的时钟周期已经改变，更重要的是新的时钟周期是什么。图 7-10 显示了生成时钟的示例，该时钟是主时钟 CLKP 的 2 分频。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816181909431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKP 10 [get_pins UPLL0/CLKOUT]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a master clock with name CLKP of period 10ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with 50% duty cycle at the CLKOUT pin of the PLL.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">create_generated_clock -name CLKPDIV2 -<span class="built_in">source</span> UPLL0/CLKOUT \</span><br><span class="line"></span><br><span class="line">-divide_by 2 [get_pins UFF0/Q]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a generated clock with name CLKPDIV2 at the Q</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pin of flip-flop UFF0. The master clock is at the CLKOUT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pin of PLL. And the period of the generated clock is double</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># that of the clock CLKP, that is, 20ns.</span></span><br></pre></td></tr></table></figure>
<p>​ 可以在触发器的输出端口定义一个新时钟是主时钟，而非生成时钟吗？答案是肯定的，这确实是可能的，但是它也有一些缺点。定义主时钟而不是生成时钟会创建一个新的时钟域。通常这不是问题，除了在设置STA约束时需要处理更多的时钟域外。相反，将新时钟定义为生成时钟不会创建新的时钟域，并且生成时钟会被认为与其主时钟同相，生成时钟不需要进行额外的约束。因此，尽量将内部新生成的时钟定义为生成时钟，而不是将其声明为另一个主时钟。</p>
<p>​ 主时钟和生成时钟之间的另一个重要区别是时钟源的概念。在主时钟中，时钟的源点位于主时钟的定义点。在生成时钟中，时钟源是主时钟的源，而不是生成时钟的源。这意味着在时钟路径报告中，时钟路径的起点始终是主时钟定义点。这是生成时钟相对于定义新主时钟的一大优势，因为对于新主时钟的情况不会自动包含源延迟。</p>
<p>​ 图 7-11 显示了一个多路复用器的示例，其两个输入都有时钟。在这种情况下，无需在多路复用器的输出上定义时钟。如果选择信号设置为常数，多路复用器的输出会自动获得正确的时钟传播。如果多路复用器的选择引脚不受约束，则两个时钟都通过多路复用器传播以供 STA 使用。在这种情况下，STA 可能会报告 TCLK 和 TCLKDIV5 之间的路径。请注意，这种路径是不可能的，因为选择线只能选择多路复用器输入之一。在这种情况下，可能需要设置一条错误路径或指定这两个时钟之间的独占时钟关系，以避免报告错误路径。这当然假设设计中其他地方的 TCLK 和 TCLKDIV5 之间没有路径。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816182406213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果多路复用器选择信号不是静态的并且可以在设备操作期间发生变化，会发生什么情况？在这种情况下，会对多路复用器输入端进行时钟门控（clock gating）检查。时钟门控检查在第 10 章中解释；这些检查确保多路复用器输入处的时钟相对于多路复用器选择信号安全切换。</p>
<p>​ 图 7-12 显示了一个示例，其中时钟 SYS_CLK 由触发器的输出进行门控。由于触发器的输出可能不是常数，因此处理这种情况的一种方法是在和单元的输出处定义一个与输入时钟相同的生成时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816182624967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_clock 0.1 [get_ports SYS_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a master clock of period 100ps with 50%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># duty cycle.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">create_generated_clock -name CORE_CLK -divide_by 1 \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> SYS_CLK [get_pins UAND1/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a generated clock called CORE_CLK at the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output of the and cell and the clock waveform is</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># same as that of the master clock.</span></span><br></pre></td></tr></table></figure>
<p>​ 下一个示例是频率高于源时钟频率的生成时钟。图 7-13 显示了波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816182823594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_clock -period 10 -waveform &#123;0 5&#125; [get_ports PCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a master clock with name PCLK of period 10ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with rise edge at 0ns and fall edge at 5ns.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name PCLKx2 \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> [get_ports PCLK] \</span><br><span class="line"></span><br><span class="line">-multiply_by 2 [get_pins UCLKMULTREG/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a generated clock called PCLKx2 from the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># master clock PCLK and the frequency is double that of</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the master clock. The generated clock is defined at the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output of the flip-flop UCLKMULTREG.</span></span><br></pre></td></tr></table></figure>
<p>​ 请注意，-multiply_by 和 -divide_by 选项指的是时钟频率，即使在主时钟定义中指定了时钟周期。</p>
<p><strong>时钟门控单元输出的主时钟示例（Example of Master Clock at Clock Gating Cell Output）</strong></p>
<p>​ 考虑图7-14中所示的时钟门控示例，两个时钟分别输入进一个与门单元中，问题是与门单元的输出是什么呢？如果与门单元的输入均为时钟，则可以安全地在与门单元的输出端定义一个新的主时钟，因为该单元的输出与任何一个输入时钟都没有相位关系的可能性很小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816183141286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">create_clock -name SYS_CLK -period <span class="number">4</span> -waveform &#123;<span class="number">0</span> <span class="number">2</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_pins UFFSYS/Q]</span></span><br><span class="line"></span><br><span class="line">create_clock -name CORE_CLK -period <span class="number">12</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_pins UFFCORE/Q]</span></span><br><span class="line"></span><br><span class="line">create_clock -name MAIN_CLK -period <span class="number">12</span> -waveform &#123;<span class="number">0</span> <span class="number">2</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_pins UAND2/Z]</span></span><br><span class="line"></span><br><span class="line"># Create <span class="selector-tag">a</span> master clock instead of <span class="selector-tag">a</span> generated clock</span><br><span class="line"></span><br><span class="line"># at the output of the and cell.</span><br></pre></td></tr></table></figure>
<p>​ 在内部引脚上创建时钟的一个缺点是它会影响路径延迟计算并迫使设计人员手动计算源延迟。</p>
<p><strong>使用Edge和Edge_shift选项生成时钟（Generated Clock using Edge and Edge_shift Options）</strong></p>
<p>​ 图 7-15 显示了生成时钟的示例。除了两个异相时钟之外，还会生成一个 2 分频时钟。图中还显示了时钟的波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816183432972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 下面给出了该示例中所有时钟的定义。衍生时钟的定义使用了<strong>-edges</strong>选项，这是定义衍生时钟的另一种方法。该选项采用源主时钟{上升，下降，上升}的边沿列表，以形成新的衍生时钟。主时钟的第一个上升沿是沿1，第一个下降沿是沿2，下一个上升沿是沿3，依此类推。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_clock 2 [get_ports DCLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Name of clock is DCLK, has period of 2ns with a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rise edge at 0ns and a fall edge at 1ns.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name DCLKDIV2 -edges &#123;2 4 6&#125; \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> DCLK [get_pins UBUF2/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The generated clock with name DCLKDIV2 is defined at</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the output of the buffer. Its waveform is formed by</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># having a rise edge at edge 2 of the source clock,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fall edge at edge 4 of the source clock and the next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rise edge at edge 6 of the source clock.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name PH0CLK -edges &#123;3 4 7&#125; \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> DCLK [get_pins UAND0/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The generated clock PH0CLK is formed using</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the 3, 4, 7 edges of the source clock.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name PH1CLK -edges &#123;1 2 5&#125; \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">source</span> DCLK [get_pins UAND1/Z]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The generated clock with name PH1CLK is defined at</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the output of the and cell and is formed with</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># edges 1, 2 and 5 of the source clock.</span></span><br></pre></td></tr></table></figure>
<p>​ 如果生成时钟的第一个边沿是下降沿怎么办？考虑生成的时钟 G3CLK，如图 7-16 所示。可以通过指定边沿 5、7 和 10 来定义此类生成的时钟，如下面的时钟约束所示。自动推断 1ns 处的下降沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816194947185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_generated_clock -name G3CLK -edges &#123;<span class="number">5</span> <span class="number">7</span> <span class="number">10</span>&#125; \</span><br><span class="line"></span><br><span class="line">-source DCLK <span class="selector-attr">[get_pins UAND0/Z]</span></span><br></pre></td></tr></table></figure>
<p>​ -edge_shift 选项可与 -edges 选项结合使用，以指定相应边沿的任何移位以形成新生成的波形。它指定边列表中每个边的移动量（以时间为单位）。这是使用此选项的示例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_clock -period 10 -waveform &#123;0 5&#125; [get_ports MIICLK]</span><br><span class="line"></span><br><span class="line">create_generated_clock -name MIICLKDIV2 -<span class="built_in">source</span> MIICLK \</span><br><span class="line"></span><br><span class="line">-edges &#123;1 3 5&#125; [get_pins UMIICLKREG/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a divide-by-2 clock.</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name MIIDIV2 -<span class="built_in">source</span> MIICLK \</span><br><span class="line"></span><br><span class="line">-edges &#123;1 1 5&#125; -edge_shift &#123;0 5 0&#125; [get_pins UMIIDIV/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates a divide-by-2 clock with a duty cycle different</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from the source clock&#x27;s value of 50%.</span></span><br></pre></td></tr></table></figure>
<p>​ 边沿列表中的边沿列表必须按非递减顺序排列，但同一边沿可用于两个条目以指示独立于源时钟占空比的时钟脉冲。上例中的 -edge_shift 选项指定第一个边沿是通过将（源时钟的边沿 1）移动 0ns 获得的，第二个边沿是通过将（源时钟的边沿 1）移动 5ns 获得的，第三个边沿是通过以下方式获得的将（源时钟的边沿 5）移动 0ns。图 7-17 显示了波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816195804748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>使用Invert 选项生成的时钟（Generated Clock using Invert Option）</strong></p>
<p>​ 这是生成时钟的另一个示例；这个使用 -invert 选项。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>period <span class="number">10</span> [get_ports <span class="type">CLK</span>]</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">NCLKDIV2</span> <span class="operator">-</span>divide_by <span class="number">2</span> <span class="operator">-</span>invert \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source <span class="type">CLK</span> [get_pins <span class="type">UINVQ</span><span class="operator">/</span><span class="type">Z</span>]</span><br></pre></td></tr></table></figure>
<p>​ -invert 选项在应用所有其他生成的时钟选项后将反转应用于生成的时钟。图 7-18 显示了生成这种反相时钟的原理图。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816200520277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>生成时钟的时钟延迟（Clock Latency for Generated Clocks）</strong></p>
<p>​ 也可以为生成的时钟指定时钟延迟。在生成时钟上指定的源延迟指定了从主时钟定义到生成时钟定义的延迟。因此，到由生成时钟驱动的触发器的时钟引脚的总时钟延迟是主时钟的源延迟、生成时钟的源延迟和生成时钟的网络延迟之和。如图 7-19 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816200716786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 一个生成时钟可以有另一个生成时钟作为其源，即可以有生成时钟的生成时钟，以此类推。但是，生成的时钟只能有一个主时钟。生成时钟的更多示例将在后面的章节中描述。</p>
<p><strong>典型时钟生成场景（Typical Clock Generation Scenario）</strong></p>
<p>​ 图 7-20 显示了时钟分布如何出现在典型 ASIC 中的场景。振荡器在芯片外部并产生低频（典型值 10-50 MHz）时钟，片上 PLL 将其用作参考时钟以生成高频低抖动时钟（典型值 200-800 MHz） .然后将该 PLL 时钟馈送到时钟分频器逻辑，该逻辑为 ASIC 生成所需的时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816200902113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在时钟分配的一些分支上，可能有时钟门，用于在必要时关闭设计的非活动部分的时钟以节省功耗。 PLL 的输出端还可以有一个多路复用器，以便在必要时可以绕过 PLL。</p>
<p>​ 在进入设计的芯片输入引脚上为参考时钟定义了一个主时钟，在 PLL 的输出端定义了第二个主时钟。 PLL 输出时钟与参考时钟没有相位关系。因此，输出时钟不应是参考时钟的生成时钟。最有可能的是，时钟分频器逻辑生成的所有时钟都被指定为 PLL 输出的主时钟的生成时钟。</p>
<h2 id="约束输入路径constraining-input-paths">约束输入路径（Constraining Input Paths）</h2>
<p>​ 本节将介绍输入路径的约束。这里需要注意的一点是，STA无法检查不受约束的路径上的任何时序，因此需要约束所有路径以进行时序分析。在后面的章节中会介绍一些示例，其中一些示例可能并不关心某些逻辑，因而这些输入路径可能可以不用约束。例如，设计人员可能并不在乎一些输入控制信号的时序，因此可能并不需要进行本节中将要介绍的时序检查。但是，本节假定我们要约束全部的输入路径。</p>
<p>​ 图 7-21 显示了被分析设计 (DUA) 的输入路径。触发器 UFF0 位于设计外部，并向设计内部的触发器 UFF1 提供数据。数据通过输入端口 INP1 连接。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816201705213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ CLKA 的时钟定义指定了时钟周期，它是两个触发器 UFF0 和 UFF1 之间可用的总时间量。外部逻辑所用的时间是 Tclk2q，即启动触发器 UFF0 的 CK 到 Q 延迟，加上 Tc1，即通过外部组合逻辑的延迟。因此，输入引脚 INP1 上的延迟规范定义了 Tclk2q 加上 Tc1 的外部延迟。在本例中，此延迟是相对于时钟 CLKA 指定的。</p>
<p>​ 这是输入延迟约束。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">Tclk2q</span> <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="type">Tc1</span>  <span class="number">0.6</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span>clock <span class="type">CLKA</span> <span class="operator">-</span>max [expr <span class="type">Tclk2q</span> <span class="operator">+</span> <span class="type">Tc1</span>] \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">INP1</span>]</span><br></pre></td></tr></table></figure>
<p>​ 该约束指定输入 INP1 上的外部延迟为 1.5ns，这与时钟 CLKA 相关。假设 CLKA 的时钟周期为 2ns，则 INP1 引脚的逻辑只有 500ps (= 2ns - 1.5ns) 可用于在设计内部传播。此输入延迟规范映射到输入约束，即 Tc2 加上 UFF1 的 Tsetup 必须小于 500ps，触发器 UFF1 才能可靠地捕获触发器 UFF0 启动的数据。请注意，上面的外部延迟被指定为最大数量。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816202533838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 让我们考虑同时考虑最大和最小延迟的情况，如图 7-22 所示。以下是此示例的限制条件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">15</span> -waveform &#123;<span class="number">5</span> <span class="number">12</span>&#125; [get_ports CLKP]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">clock</span> CLKP -<span class="built_in">max</span> <span class="number">6.7</span> [get_ports INPA]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">clock</span> CLKP -<span class="built_in">min</span> <span class="number">3.0</span> [get_ports INPA]</span><br></pre></td></tr></table></figure>
<p>​ INPA 的最大和最小延迟源自 CLKP 到 INPA 的延迟。最大和最小延迟分别指最长和最短路径延迟。这些通常也可能对应于最坏情况下的慢速（最大时序角）和最佳情况下的快速（最小时序角）。因此，最大延迟对应于最大拐角处的最长路径延迟，最小延迟对应于最小拐角处的最短路径延迟。在我们的示例中，1.1ns 和 0.8ns 是 Tck2q 的最大和最小延迟值。组合路径延迟 Tc1 的最大延迟为 5.6ns，最小延迟为 2.2ns。 INPA 上的波形显示了数据到达设计输入的窗口以及预期稳定的时间。从 CLKP 到 INPA 的最大延迟为 6.7ns (= 1.1ns +5.6ns)。最小延迟为 3ns (= 0.8ns+ 2.2ns)。这些延迟是根据时钟的有效边沿指定的。在给定外部输入延迟的情况下，设计内部的可用建立时间是慢角（slow corner）下的8.3ns（= 15ns-6.7ns）和快角（fast corner）下的12ns（= 15ns-3.0ns）中的最小值。因此，8.3ns是用来可靠地捕获DUA内部数据的可用时间。</p>
<p>​ 以下是输入约束的更多示例。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_input_delay -clock clk_core <span class="number">0.5</span> <span class="selector-attr">[get_ports bist_mode]</span></span><br><span class="line"></span><br><span class="line">set_input_delay -clock clk_core <span class="number">0.5</span> <span class="selector-attr">[get_ports sad_state]</span></span><br></pre></td></tr></table></figure>
<p>​ 由于未指定<strong>max</strong>或<strong>min</strong>选项，因此500ps这个值将同时用于最大延迟和最小延迟。此外部输入延迟是相对于时钟clk_core的上升沿指定的（如果输入延迟是相对于时钟的下降沿指定的，则必须使用<strong>-clock_fall</strong>选项）。</p>
<h2 id="约束输出路径constraining-output-paths">约束输出路径（Constraining Output Paths）</h2>
<p>​ 本节将借助以下三个说明性示例描述输出路径的约束。</p>
<p><strong>示例 A</strong></p>
<p>​ 图 7-23 显示了通过分析设计的输出端口的路径示例。 Tc1 和 Tc2 是通过组合逻辑的延迟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816203740975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时钟 CLKQ 的周期定义了触发器 UFF0 和 UFF1 之间的总可用时间。外部逻辑的总延迟为 Tc2 加 Tsetup。该总延迟 Tc2 Tsetup 必须指定为输出延迟规范的一部分。请注意，输出延迟是相对于捕获时钟指定的。数据必须及时到达外部触发器UFF1以满足其建立时间要求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">Tc2</span>  <span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="type">Tsetup</span> <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock <span class="type">CLKQ</span> <span class="operator">-</span>max [expr <span class="type">Tc2</span> <span class="operator">+</span> <span class="type">Tsetup</span>] \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">OUTB</span>]</span><br></pre></td></tr></table></figure>
<p>​ 这指定相对于时钟边沿的最大外部延迟为 Tc2 加 Tsetup；并且应该对应5ns的延迟。可以类似地指定最小延迟。</p>
<p><strong>示例 B</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210816204314813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 7-24 显示了具有最小和最大延迟的示例。最大路径延迟为 7.4ns（= 最大 Tc2 加上 Tsetup = 7 0.4）。最小路径延迟为 -0.2ns（= 最小 Tc2 减去 Thold = 0 - 0.2）。因此输出约束为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">20</span> -waveform &#123;<span class="number">0</span> <span class="number">15</span>&#125; [get_ports CLKQ]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> CLKQ -<span class="built_in">min</span> <span class="number">-0.2</span> [get_ports OUTC]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> CLKQ -<span class="built_in">max</span> <span class="number">7.4</span> [get_ports OUTC]</span><br></pre></td></tr></table></figure>
<p>​ 图 7-24 中的波形显示了何时 OUTC 必须稳定才能被外部触发器可靠地捕获。这描述了数据必须在所需的稳定区域开始之前在输出端口准备好，并且必须保持稳定直到稳定区域结束。这映射到 DUA 内部输出端口 OUTC 的逻辑时序要求。</p>
<p><strong>示例 C</strong></p>
<p>​ 这是显示输入和输出规范的另一个示例。该模块有两个输入，DATAIN 和 MCLK，以及一个输出 DATAOUT。图 7-25 显示了预期的波形。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816204919108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">100</span> -waveform &#123;<span class="number">5</span> <span class="number">55</span>&#125; [get_ports MCLK]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">25</span> -<span class="built_in">max</span> -<span class="built_in">clock</span> MCLK [get_ports DATAIN]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">5</span> -<span class="built_in">min</span> -<span class="built_in">clock</span> MCLK [get_ports DATAIN]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_output_delay <span class="number">20</span> -<span class="built_in">max</span> -<span class="built_in">clock</span> MCLK [get_ports DATAOUT]</span><br><span class="line"></span><br><span class="line">set_output_delay <span class="number">-5</span> -<span class="built_in">min</span> -<span class="built_in">clock</span> MCLK [get_ports DATAOUT]</span><br></pre></td></tr></table></figure>
<h2 id="时序路径组timing-path-groups">时序路径组（Timing Path Groups）</h2>
<p>​ 设计中的时序路径可被视为路径的集合。每条路径都有一个起点和一个终点（a startpoint and an endpoint）。有关一些示例路径，请参见图 7-26。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816205341683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在STA中，时序路径是根据有效的起点和终点（valid startpoints and valid endpoints）来划分的。有效的起点包括：输入端口或者同步器件（如触发器和存储器）的时钟引脚。有效的终点包括：输出端口或者同步器件的数据输入引脚。因此，有效的时序路径包括：</p>
<ul>
<li>从输入端口到输出端口</li>
<li>从输入端口到触发器或存储器的数据输入引脚</li>
<li>从一个触发器或存储器的时钟引脚到另一个触发器或存储器的数据输入引脚</li>
<li>从一个触发器或存储器的时钟引脚到输出端口</li>
</ul>
<p>​ 图7-26中的有效时序路径包括：</p>
<ul>
<li>输入端口A到输出端口Z</li>
<li>输入端口A到触发器UFFA的D引脚</li>
<li>触发器UFFA的CK引脚到触发器UFFB的D引脚</li>
<li>触发器UFFB的CK引脚到输出端口Z</li>
</ul>
<p>​ 时序路径可以根据与路径终点相关的时钟分为不同<strong>时序路径组（path groups）</strong>。因此，每个时钟都有一组与之相关的时序路径。还有一个<strong>默认时序路径组（default path group）</strong>，其中包括了所有non-clocked（异步）路径。</p>
<p>在图7-27的示例中，时序路径分组为：</p>
<ul>
<li>CLKA组：输入端口A到触发器UFFA的D引脚</li>
<li>CLKB组：触发器UFFA的CK引脚到触发器UFFB的D引脚</li>
<li>默认组：输入端口A到输出端口Z、触发器UFFB的CK引脚到输出端口Z</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210816210303673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ <strong><em>*静态时序分析和报告通常对每个路径组分别执行。*</em></strong></p>
<h2 id="外部属性建模modeling-of-external-attributes">外部属性建模（Modeling of External Attributes）</h2>
<p>​ 虽然 create_clock、set_input_delay 和 set_output_delay 足以约束设计中的所有路径以执行时序分析，但这些不足以为模块的 IO 引脚获得准确的时序。还需要以下属性来准确地对设计环境进行建模。对于输入，需要指定输入的转换。可以使用以下方式提供此信息：</p>
<ul>
<li><strong>set_drive*<em>（此命令已过时，不推荐使用。）*</em></strong></li>
<li><strong>set_driving_cell</strong></li>
<li><strong>set_input_transition</strong></li>
</ul>
<p>​ 对于输出，需要指定输出引脚看到的容性负载。这是通过使用以下命令约束指定的：</p>
<ul>
<li><strong>set_load</strong></li>
</ul>
<h3 id="驱动强度建模modeling-drive-strengths">驱动强度建模（Modeling Drive Strengths）</h3>
<p>​ <strong>set_drive</strong>和<strong>set_driving_cell</strong>约束用于对驱动模块输入端口的外部单元的驱动强度进行建模。在没有这些约束的默认情况下，假定所有输入都具有无限的驱动强度，即输入引脚的过渡时间为0。</p>
<p>​ <strong>set_drive</strong>明确指定了DUA输入引脚上的驱动电阻值，该电阻值越小，驱动强度越高，电阻值为0表示无限的驱动强度。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816211046175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_drive <span class="number">100</span> UCLK</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies a drive resistance of 100 on input UCLK.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Rise drive is different from fall drive:</span></span><br><span class="line"></span><br><span class="line">set_drive -rise <span class="number">3</span> [all_inputs]</span><br><span class="line"></span><br><span class="line">set_drive -fall <span class="number">2</span> [all_inputs]</span><br></pre></td></tr></table></figure>
<p>​ 输入端口的驱动用于计算第一个单元的转换时间。指定的驱动值还用于计算存在任何 RC 互连时从输入端口到第一个单元的延迟。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">Delay_to_first_gate =</span><br><span class="line"></span><br><span class="line">(<span class="name">drive</span> * load_on_net) + interconnect_delay</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">延迟值 = （驱动强度 * 网络负载） + 互连线延迟</span><br></pre></td></tr></table></figure>
<p>​ set_driving_cell 命令提供了一种更方便、更准确的方法来描述端口的驱动能力。 set_driving_cell 可用于指定驱动输入端口的单元。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816211526653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_driving_cell -lib_cell INV3 \</span><br><span class="line"></span><br><span class="line">-library slow <span class="selector-attr">[get_ports INPB]</span></span><br><span class="line"></span><br><span class="line"># The <span class="selector-tag">input</span> INPB is driven by an INV3 cell</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">from</span> library slow.</span><br><span class="line"></span><br><span class="line">set_driving_cell -lib_cell INV2 \</span><br><span class="line"></span><br><span class="line">-library tech13g <span class="selector-attr">[all_inputs]</span></span><br><span class="line"></span><br><span class="line"># Specifies that the cell INV2 <span class="selector-tag">from</span> <span class="selector-tag">a</span> library tech13g is</span><br><span class="line"></span><br><span class="line"># the driving cell for <span class="attribute">all</span> inputs.</span><br><span class="line"></span><br><span class="line">set_driving_cell -lib_cell BUFFD4 -library tech90gwc \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_ports &#123;testmode[3]</span>&#125;]</span><br><span class="line"></span><br><span class="line"># The <span class="selector-tag">input</span> testmode<span class="selector-attr">[3]</span> is driven by <span class="selector-tag">a</span> BUFFD4 cell</span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">from</span> library tech90gwc.</span><br></pre></td></tr></table></figure>
<p>​ 与驱动规范一样，输入端口的驱动单元用于计算第一个单元的转换时间，并在存在任何互连时计算从输入端口到第一个单元的延迟。</p>
<p>​ set_driving_cell 命令的一个警告是，由于输入端口上的容性负载而导致的驱动单元的增量延迟作为输入上的附加延迟包括在内。</p>
<p>​ 作为上述方法的替代方法，set_input_transition 命令提供了一种在输入端口表达转换的便捷方式。可以选择指定参考时钟。以下是图 7-30 中所示示例的规范以及其他示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816211750305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_input_transition <span class="number">0.85</span> <span class="selector-attr">[get_ports INPC]</span></span><br><span class="line"></span><br><span class="line"># Specifies an <span class="selector-tag">input</span> <span class="attribute">transition</span> of <span class="number">850</span>ps on port INPC.</span><br><span class="line"></span><br><span class="line">set_input_transition <span class="number">0.6</span> <span class="selector-attr">[all_inputs]</span></span><br><span class="line"></span><br><span class="line"># Specifies <span class="selector-tag">a</span> <span class="attribute">transition</span> of <span class="number">600</span>ps on <span class="attribute">all</span> <span class="selector-tag">input</span> ports.</span><br><span class="line"></span><br><span class="line">set_input_transition <span class="number">0.25</span> <span class="selector-attr">[get_ports SD_DIN*]</span></span><br><span class="line"></span><br><span class="line"># Specifies <span class="selector-tag">a</span> <span class="attribute">transition</span> of <span class="number">250</span>ps on <span class="attribute">all</span> ports with</span><br><span class="line"></span><br><span class="line"># pattern SD_DIN*.</span><br><span class="line"></span><br><span class="line"># Min and max values can optionally be specified using</span><br><span class="line"></span><br><span class="line"># the -min and -max options.</span><br></pre></td></tr></table></figure>
<p>​ 总之，需要输入端的转换值来确定输入路径中第一个单元的延迟。在没有此约束的情况下，假设理想的过渡值为 0，这可能不现实。</p>
<p><strong>7.7.2 容性负载建模（Modeling Capacitive Load）</strong></p>
<p>​ <strong>set_load</strong>约束在输出端口上设置了电容性负载，以模拟由输出端口驱动的外部负载。默认情况下，端口上的电容性负载为0。可以将负载显式地指定为电容值或某个单元的输入引脚电容。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816212347576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">set_load 5 [get_ports OUTX]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Places a 5pF load on output port OUTX.</span></span><br><span class="line"></span><br><span class="line">set_load 25 [all_outputs]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets 25pF load capacitance on all outputs.</span></span><br><span class="line"></span><br><span class="line">set_load -pin_load 0.007 [<span class="keyword">get_ports</span> &#123;shift_write[<span class="number">31</span>]&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Place 7fF pin load on the specified output port.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A load on the net connected to the port can be</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># specified using the -wire_load option.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If neither -pin_load nor -wire_load option is used,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the default is the -pin_load option.</span></span><br></pre></td></tr></table></figure>
<p>​ 指定输出负载很重要，因为该值会影响驱动输出的单元的延迟。在没有这样的规范的情况下，假设负载为 0，这可能是不现实的。</p>
<p>​ set_load 命令还可用于在设计中指定内部网络上的负载。下面是一个例子：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_load <span class="number">0.25</span> [get_nets UCNT5/NET6]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the net capacitance to be 0.25pF.</span></span><br></pre></td></tr></table></figure>
<h2 id="设计规则检查design-rule-checks">设计规则检查（Design Rule Checks）</h2>
<p>​ STA中两个常用的设计规则是最大过渡时间-<strong>max_transition</strong>和最大电容-<strong>max_capacitance</strong>。这些规则将会检查设计中的所有端口和引脚是否满足过渡时间和电容的规定约束。这些规则可以使用以下命令指定：</p>
<ul>
<li><strong>set_max_transition</strong></li>
<li><strong>set_max_capacitance</strong></li>
</ul>
<p>​ 作为STA的一部分，任何设计规则的违例（violation）均以裕量（slack）的形式报告。以下是些例子：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_max_transition <span class="number">0.6</span> IOBANK</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets a limit of 600ps on IOBANK.</span></span><br><span class="line"></span><br><span class="line">set_max_capacitance <span class="number">0.5</span> [current_design]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Max capacitance is set to 0.5pf on all nets in</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># current design.</span></span><br></pre></td></tr></table></figure>
<p>网络上的电容是通过将所有引脚电容加上任何IO负载再加上网络上的任何互连电容的总和计算得出的。下图7-32为一个示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210816212753559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Total <span class="built_in">cap</span> on net N1 =</span><br><span class="line"></span><br><span class="line">pin <span class="built_in">cap</span> of UBUF1:pin/A +</span><br><span class="line"></span><br><span class="line">pin <span class="built_in">cap</span> of UOR2:pin/B +</span><br><span class="line"></span><br><span class="line">load <span class="built_in">cap</span> specified on output port OUTP +</span><br><span class="line"></span><br><span class="line">wire/routing <span class="built_in">cap</span></span><br><span class="line"></span><br><span class="line">= 0.05 + 0.03 + 0.07 + 0.02</span><br><span class="line"></span><br><span class="line">= 0.17pF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Total <span class="built_in">cap</span> on net N2 =</span><br><span class="line"></span><br><span class="line">pin <span class="built_in">cap</span> of UBUF2/A +</span><br><span class="line"></span><br><span class="line">wire/routing <span class="built_in">cap</span> from input to buffer</span><br><span class="line"></span><br><span class="line">= 0.04 + 0.03</span><br><span class="line"></span><br><span class="line">= 0.07pF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">网络N1的总电容 = UBUF1的A引脚电容 + UOR2的B引脚电容 + OUTP的输出负载电容 + 走线互连电容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> = 0.05 + 0.03 + 0.07 + 0.02 = 0.17 pF</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">网络N2的总电容 = UBUF2的A引脚电容 + 走线互连电容</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> = 0.03 + 0.04 = 0.07 pF</span><br></pre></td></tr></table></figure>
<p>​ 过渡时间是延迟计算的一部分。对于图7-32中的示例（假设UBUF2单元使用线性延迟模型）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Transition time on pin UBUF2/A =</span><br><span class="line"></span><br><span class="line">drive of 21<span class="emphasis">* total cap on net N2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">= 2 *</span> 0.07 = 0.14ns = 140ps</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Transition time on output port OUTP =</span><br><span class="line"></span><br><span class="line">drive resistance of UBUF2/Z <span class="emphasis">* total cap of net N1 =</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1 *</span> 0.17 = 0.17ns = 170ps</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> UBUF2的A引脚过渡时间 = 2 <span class="emphasis">* 网络N2的总电容</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">                     = 2 *</span> 0.07 = 0.14ns = 140ps</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">输出端口OUTP过渡时间 = UBUF2的Z引脚的驱动电阻 <span class="emphasis">* 网络N1的总电容</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">                    = 1 *</span> 0.17 = 0.17ns = 170ps</span><br></pre></td></tr></table></figure>
<p>​ 还可以为设计指定其他设计规则检查，比如：<strong>set_max_fanout</strong>（指定设计中所有引脚的扇出约束），<strong>set_max_area</strong>（用于设计）。但是，这些检查适用于综合（synthesis）而非STA。</p>
<h2 id="虚拟时钟virtual-clocks">虚拟时钟（Virtual Clocks）</h2>
<p>​ 虚拟时钟是存在但不与设计的任何引脚或端口相关联的时钟。它用作 STA 分析中的参考，以指定相对于时钟的输入和输出延迟。图 7-33 显示了一个适用虚拟时钟的示例。分析中的设计从 CLK_CORE 获取时钟，但驱动输入端口 ROW_IN 的时钟是 CLK_SAD。在这种情况下，如何指定输入端口 ROW_IN 上的 IO 约束？同样的问题发生在输出端口 STATE_O 上。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816213259546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 为了处理这种情况，可以定义一个不指定源端口或引脚的虚拟时钟。在图 7-33 的示例中，为 CLK_SAD 和 CLK_CFG 定义了虚拟时钟。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">create_clock -<span class="keyword">name</span> VIRTUAL_CLK_SAD -period <span class="number">10</span> -waveform <span class="comment">&#123;2 8&#125;</span></span><br><span class="line"></span><br><span class="line">create_clock -<span class="keyword">name</span> VIRTUAL_CLK_CFG -period <span class="number">8</span> \</span><br><span class="line"></span><br><span class="line">-waveform <span class="comment">&#123;0 4&#125;</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">10</span> [get_ports CLK_CORE]</span><br></pre></td></tr></table></figure>
<p>​ 定义了这些虚拟时钟后，可以相对于该虚拟时钟指定 IO 约束。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLK_SAD -<span class="built_in">max</span> <span class="number">2.7</span> \</span><br><span class="line"></span><br><span class="line">[get_ports ROW_IN]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> VIRTUAL_CLK_CFG -<span class="built_in">max</span> <span class="number">4.5</span> \</span><br><span class="line"></span><br><span class="line">[get_ports STATE_O]</span><br></pre></td></tr></table></figure>
<p>​ 图 7-34 显示了输入路径上的时序关系。这将被分析设计中的输入路径限制为 5.3ns 或更小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816214101770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图 7-35 显示了输出路径上的时序关系。这将被分析设计中的输出路径限制为 3.5ns 或更小。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816214502403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ -min 选项在 set_input_delay 和 set_output_delay 约束中指定时，用于验证快速（或最小）路径。使用虚拟时钟只是限制输入和输出 (IO) 的一种方法；设计人员也可以选择其他方法来约束 IO。</p>
<h2 id="完善时序分析refining-the-timing-analysis">完善时序分析（Refining the Timing Analysis）</h2>
<p>用于约束分析的四个常用命令是：</p>
<ul>
<li><strong>set_case_analysis</strong> ：在单元的引脚或输入端口上指定常量值。</li>
<li><strong>set_disable_timing</strong> ：中断单元的时序弧。</li>
<li><strong>set_false_path</strong> ：指定实际不存在的路径，这意味着在STA中不需要检查这些路径。</li>
<li><strong>set_multicycle_path</strong> ：指定可能花费超过一个时钟周期的路径。</li>
</ul>
<p>第8章将详细讨论<strong>set_false_path</strong>和<strong>set_multicycle_path</strong>约束。</p>
<h3 id="指定非活动信号specifying-inactive-signals">指定非活动信号（Specifying Inactive Signals）</h3>
<p>​ 在设计中，某些信号在芯片的特定模式下会具有恒定值。例如，如果芯片中具有DFT（可测性设计）逻辑，则在正常功能模式下，芯片的TEST引脚将一直为0。为STA指定这样的常量值通常很有用，除了不必报告任何不相关的路径之外，这还有助于减少分析空间。例如，如果未将TEST引脚设置为常数，则可能会存在一些奇怪的长路径，而这些长路径在功能模式下永远不会存在。通过使用<strong>set_case_analysis</strong>约束来指定此类常数信号。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_case_analysis <span class="number">0</span> TEST</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[3]</span>&#125;]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[2]</span>&#125;]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[1]</span>&#125;]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="selector-attr">[get_ports &#123;testmode[0]</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>​ 如果设计具有多种功能模式，而只需要分析其中一种功能模式，则可以使用<strong>set_case_analysis</strong>来指定要分析的模式。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_case_analysis <span class="number">1</span> func_mode<span class="selector-attr">[0]</span></span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> func_mode<span class="selector-attr">[1]</span></span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">1</span> func_mode<span class="selector-attr">[2]</span></span><br></pre></td></tr></table></figure>
<p>​ 请注意，可以在设计中的任何引脚上指定案例分析。案例分析的另一个常见应用是设计可以在多个时钟上运行，并且适当时钟的选择由多路复用器控制。为了使 STA 分析更容易并减少 CPU 运行时间，对每个时钟选择分别进行 STA 是有益的。图 7-36 显示了多路复用器选择具有不同设置的不同时钟的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210816215020860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">set_case_analysis <span class="number">1</span> <span class="type">UCORE</span><span class="operator">/</span><span class="type">UMUX0</span><span class="operator">/</span><span class="type">CLK_SEL</span>[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">1</span> <span class="type">UCORE</span><span class="operator">/</span><span class="type">UMUX1</span><span class="operator">/</span><span class="type">CLK_SEL</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">set_case_analysis <span class="number">0</span> <span class="type">UCORE</span><span class="operator">/</span><span class="type">UMUX2</span><span class="operator">/</span><span class="type">CLK_SEL</span>[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>​ 第一个 set_case_analysis 导致为 MIICLK 选择 PLLdiv16。 PLLdiv8 的时钟路径被阻塞，不会通过多路复用器传播。因此，没有使用时钟 PLLdiv8 分析时序路径（假设时钟在多路复用器之前没有进行任何翻转）。类似地，最后一个 set_case_analysis 导致为 ADCCLK 选择 SCANCLK，并阻塞 CLK200 的时钟路径。</p>
<h3 id="打破单元格中的时序弧breaking-timing-arcs-in-cells">打破单元格中的时序弧（Breaking Timing Arcs in Cells）</h3>
<p>​ 每个单元都有从其输入到输出的时序弧，并且时序路径可能会通过这些时序弧中的其中一个。在某些情况下，单元中的一条路径可能无法发生。例如可能有这样一种情况，其中时钟连接到多路复用器的选择端，而多路复用器的输出是数据路径的一部分。在这种情况下，中断多路复用器选择引脚和输出引脚之间的时序弧可能很有用。图7-37为一个示例，通过多路复用器选择端的路径不是有效的数据路径。可以使用<strong>set_disable_timing</strong>命令来中断这种时序弧。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_disable_timing -<span class="selector-tag">from</span> S -<span class="selector-tag">to</span> Z <span class="selector-attr">[get_cells UMUX0]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210816215423784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于时序弧不再存在，因此需要分析的时序路径更少。另一个类似用法的例子是禁用触发器的最小时钟脉冲宽度检查。</p>
<p>​ 使用<strong>set_disable_timing</strong>命令需要格外小心，因为它会删除通过指定引脚的所有时序路径。在可能的情况下，最好使用<strong>set_false_path</strong>和<strong>set_case_analysis</strong>命令。</p>
<h2 id="点对点规范point-to-point-specification">点对点规范（Point-to-Point Specification）</h2>
<p>​ 可以通过使用<strong>set_min_delay</strong>和<strong>set_max_delay</strong>命令来约束点对点路径，这将引脚到引脚之间的路径延迟限制在了命令指定值内。该约束将覆盖所有默认的单周期时序路径以及此类路径的任何多周期路径约束。<strong>set_max_delay</strong>约束了指定路径的最大延迟，而<strong>set_min_delay</strong>约束了指定路径的最小延迟。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_max_delay <span class="number">5.0</span> -<span class="selector-tag">to</span> UFF0/D</span><br><span class="line"></span><br><span class="line"># <span class="attribute">All</span> paths <span class="selector-tag">to</span> D-pin of flip-flop should take <span class="number">5</span>ns max.</span><br><span class="line"></span><br><span class="line">set_max_delay <span class="number">0.6</span> -<span class="selector-tag">from</span> UFF2/<span class="selector-tag">Q</span> -<span class="selector-tag">to</span> UFF3/D</span><br><span class="line"></span><br><span class="line"># <span class="attribute">All</span> paths between the two flip-flops should take <span class="selector-tag">a</span></span><br><span class="line"></span><br><span class="line"># max of <span class="number">600</span>ps.</span><br><span class="line"></span><br><span class="line">set_max_delay <span class="number">0.45</span> -<span class="selector-tag">from</span> UMUX0/Z -through UAND1/<span class="selector-tag">A</span> -<span class="selector-tag">to</span> UOR0/Z</span><br><span class="line"></span><br><span class="line"># Sets max delay for the specified paths.</span><br><span class="line"></span><br><span class="line">set_min_delay <span class="number">0.15</span> -<span class="selector-tag">from</span> &#123;UAND0/<span class="selector-tag">A</span> UXOR1/<span class="selector-tag">B</span>&#125; -<span class="selector-tag">to</span> &#123;UMUX2/SEL&#125;</span><br></pre></td></tr></table></figure>
<p>​ 在上述示例中，需要注意的是，使用非标准的内部引脚将迫使它们成为起点和终点，并在这些点处分割路径。</p>
<p>​ 还可以类似地指定从一个时钟到另一个时钟的点对点约束。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set_max_delay <span class="number">1.2</span> -<span class="keyword">from</span> [get_clocks SYS_CLK] \</span><br><span class="line"></span><br><span class="line">-to [get_clocks CFG_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># All paths between these two clock domains are restricted</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># to a max of 1200ps.</span></span><br><span class="line"></span><br><span class="line">set_min_delay <span class="number">0.4</span> -<span class="keyword">from</span> [get_clocks SYS_CLK] \</span><br><span class="line"></span><br><span class="line">-to [get_clocks CFG_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The min delay between any path between the two</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clock domains is specified as 400ps.</span></span><br></pre></td></tr></table></figure>
<p>​ 如果路径上有多个时序约束，例如时钟频率约束、<strong>set_max_delay</strong>和<strong>set_min_delay</strong>，则最严格的那个约束是始终用于检查的约束。多个时序约束可能是先应用某些全局（global）约束，然后再应用某些局部（local）约束。</p>
<h2 id="路径分割path-segmentation">路径分割（Path Segmentation）</h2>
<p>​ 路径分段（path segmentation）是指将时序路径分解为可以进行时序分析的较小路径。</p>
<p>​ 时序路径具有起点和终点，可以使用<strong>set_input_delay</strong>和<strong>set_output_delay</strong>命令在时序路径上创建其它起点和终点。通常在单元的输出引脚上指定<strong>set_input_delay</strong>来定义新起点，而通常在单元的输入引脚上指定<strong>set_output_delay</strong>来定义新终点。这些约束定义了新的时序路径，它是原始时序路径的子集。</p>
<p>​ 考虑图7-38中所示的路径。为SYSCLK定义时钟后，待分析的时序路径即为从UFF0 / CK到UFF1 / D。如果仅对报告从UAND2 / Z到UAND6 / A的路径延迟感兴趣，则可以使用以下两个命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">STARTPOINT</span> [get_pins <span class="type">UAND2</span><span class="operator">/</span><span class="type">Z</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="type">ENDPOINT</span> [get_pins <span class="type">UAND6</span><span class="operator">/</span><span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">0</span> <span class="variable">$STARTPOINT</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="number">0</span> <span class="variable">$ENDPOINT</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210816220118351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 定义这些约束会导致从UFF0 / CK到UFF1 / D的原始时序路径被分段，并分别在UAND2 / Z和UAND6 / A处创建内部起点和内部终点。现在，时序报告将明确显示此新路径。请注意，还会自动创建另外两条时序路径，一条从UFF0 / CK到UAND2 / Z，另一条从UAND6 / A到UFF1 / D。因此，原始的时序路径已被分为了三个部分，每个部分分别进行时序分析。</p>
<p>​ set_disable_timing、set_max_delay 和 set_min_delay 命令也会导致时序路径被分段。</p>
<h1 id="时序验证timing-verification">时序验证（Timing Verification）</h1>
<blockquote>
<p>描述了时序检查，这个各种时序检查是作为各种时序分析的一部分执行。其中包括amongst others - setup、保持和异步恢复和移除检查。这些时序检查旨在彻底验证被分析设计的时序。</p>
</blockquote>
<p>两个主要检查是建立时间检查和保持时间检查。一旦在触发器的时钟引脚上定义了时钟，就会自动推断出该触发器的建立时间检查和保持时间检查。时序检查通常在多种条件下执行，包括最坏情况下的慢速条件和最佳情况下的快速条件。通常，最坏情况下的慢速条件对于建立时间检查至关重要，而最佳情况下的快速条件对于保持时间检查至关重要-尽管保持时间检查也可能在最坏情况下的慢速条件下执行。</p>
<p>本章中给出的示例假设网络延迟为零；这样做是为了简单，不会改变本文提出的概念。</p>
<h2 id="建立时间时序检查setup-timing-check">建立时间时序检查（Setup Timing Check）</h2>
<p>​ 建立时间检查（setup timing check）验证时钟和触发器的数据引脚之间的时序关系，以便满足建立时间要求。换句话说，建立时间检查确保数据在触发器输入之前在触发器的输入端可用。在时钟的有效边沿到达触发器之前，数据应该稳定一段时间，即触发器的建立时间。这一要求确保数据被可靠地捕获到触发器中。图 8-1 显示了典型触发器的建立时间要求。建立时间检查验证触发器的建立时间要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210817185011986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通常，有一个发起触发器（用于发起数据的触发器）和捕获触发器（用于捕获数据的触发器），这个捕获触发器的建立时间要求必须满足。建立时间检查将验证从发起触发器到捕获触发器的最长（或最大）路径，这两个触发器的时钟可以相同也可以不同。建立时间检查是从发起触发器中时钟的第一个有效沿到捕获触发器中时钟后面最接近的那个有效沿。建立时间检查将确保上一个时钟周期发起的数据准备好在一个周期后被捕获。</p>
<p><img src="https://img-blog.csdnimg.cn/20210817185456886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 现在我们研究一个简单的示例，如图8-2所示，其中发起触发器和捕获触发器具有相同的时钟。时钟CLKM的第一个上升沿在<strong>Tlaunch</strong>时间后出现在发起触发器的时钟引脚上，由该时钟沿发起的数据出现在触发器<strong>UFF1</strong>的D引脚的所需时间为<strong>Tlaunch + Tck2q + Tdp</strong>。时钟CLKM的第二个上升沿（通常在一个周期后检查建立时间）出现在捕获触发器<strong>UFF1</strong>的时钟引脚上的时间为<strong>Tcycle + Tcapture</strong>。这两个时间之差必须大于触发器UFF1的建立时间要求，以确保触发器UFF1可靠地捕获数据。</p>
<p>​ 建立时间检查可以用数学公式表示：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tlaunch+%20Tck2q+%20Tdp%3C%20Tcapture+%20Tcycle-%20Tsetup"></p>
<p>​ 其中Tlaunch是发起触发器UFF0的时钟树延迟，Tdp是组合逻辑数据路径的延迟，Tcycle是时钟周期，Tcapture是捕获触发器UFF1的时钟树延迟。</p>
<p>​ 换句话说，数据到达捕获触发器D引脚所花费的总时间必须小于时钟传输到捕获触发器所花费的时间加上时钟周期再减去建立时间要求。</p>
<p>​ 由于建立时间检查受到<strong>-max</strong>的约束，因此建立时间检查始终使用最长或最大的时序路径。出于同样的原因，通常在延迟最大的慢工艺角（slow corner）下执行建立时间检查。</p>
<h3 id="触发器到触发器路径flip-flop-to-flip-flop-path">触发器到触发器路径（Flip-flop to Flip-flop Path）</h3>
<p>​ 以下是一份建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820100554269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 该报告中显示发起触发器（由<strong>Startpoint</strong>指定）的实例名称为UFF0，由时钟CLKM的上升沿触发。捕获触发器（由<strong>Endpoint</strong>指定）为UFF1，也由时钟CLKM的上升沿触发。路径组（<strong>Path Group</strong>）显示它属于路径组CLKM。如上一章所述，设计中的所有路径都基于捕获触发器的时钟归类为路径组。路径类型（<strong>Path Type</strong>）显示此报告中的延迟均为最大路径延迟，表明这是建立时间检查。这是因为建立时间检查对应于通过逻辑的最大（或最长路径）延迟。注意，保持时间检查对应于通过逻辑的最小（或最短路径）延迟。</p>
<p>​ <strong>Incr</strong>列显示了指定端口或引脚的单元或网络延迟增量，<strong>Path</strong>列显示了数据实际到达和需要到达的路径累积延迟，这是用于此示例的时钟约束：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">    <span class="selector-attr">[get_ports CLKM]</span></span><br><span class="line"></span><br><span class="line">set_clock_uncertainty -setup <span class="number">0.3</span> <span class="selector-attr">[all_clocks]</span></span><br><span class="line"></span><br><span class="line">set_clock_transition -rise <span class="number">0.2</span> <span class="selector-attr">[all_clocks]</span></span><br><span class="line"></span><br><span class="line">set_clock_transition -fall <span class="number">0.15</span> <span class="selector-attr">[all_clocks]</span></span><br></pre></td></tr></table></figure>
<p>​ 启动路径（ <strong>launch path</strong>）需要 0.26ns 才能到达触发器 UFF1 的 D 引脚 - 这是到达捕获触发器输入的时间。捕获边沿（建立时间检查时为一个周期）为10ns。为该时钟指定了 0.3ns 的时钟不确定性（<strong>clock uncertainty</strong>） - 因此，时钟周期减少了不确定性余量。时钟不确定性包括由于时钟源中的抖动（ <strong>jitter</strong> ）和用于分析的任何其他时序裕量而导致的周期时间变化。触发器的建立时间 0.04ns（称为库建立时间<strong>library setup time</strong>）从总捕获路径中扣除，产生所需的时间为 9.66ns。由于到达时间为 0.26ns，因此该时序路径上存在 9.41ns 的正裕量（ <strong>positive<br>
slack</strong>）。请注意，所需时间和到达时间之间的差异可能看起来为 9.40 ns - 但实际值​​是 9.41 ns，出现在报告中。之所以存在异常，是因为报告仅显示小数点后两位，而内部计算和存储的值比报告的值具有更高的精度。</p>
<p>​ 时序报告中的时钟网络延迟（<strong>clock network delay</strong>）是什么？为什么将其标记为<strong>ideal</strong>？时序报告中的这一行表明时钟树被认为是<strong>ideal</strong>的，时钟路径中的任何缓冲器（<strong>buffer</strong>）都假定为零延迟。一旦构建了时钟树，就可以将时钟网络标记为“<strong>propagated</strong>”，从而使得时钟路径显示实际延迟值，如下一个示例时序报告中所示：0.11ns延迟是发起时钟上的时钟网络延迟，而0.12ns延迟是捕获触发器上的时钟网络延迟。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082010421111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时序路径报告可以选择包含扩展的时钟路径，即明确显示时钟树。这是一个这样的例子。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820104322715.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820104352977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，时钟缓冲器 UCKBUF0、UCKBUF1 和 UCKBUF2 出现在上面的路径报告中，并提供了如何计算时钟树延迟的详细信息。</p>
<p>​ 如何计算第一个时钟单元 UCKBUF0 的延迟？如前几章所述，单元延迟是根据单元的输入转换时间和输出电容计算的。因此，问题是在时钟树中第一个单元的输入处使用什么转换时间。可以使用 <strong>set_input_transition</strong> 命令明确指定第一个时钟单元输入引脚上的转换时间（或转换）。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_input_transition -rise <span class="number">0.3</span> <span class="selector-attr">[get_ports CLKM]</span></span><br><span class="line"></span><br><span class="line">set_input_transition -fall <span class="number">0.45</span> <span class="selector-attr">[get_ports CLKM]</span></span><br></pre></td></tr></table></figure>
<p>​ 在上面显示的 <strong>set_input_transition</strong> 命令中，我们将输入上升转换时间指定为 0.3ns，将下降转换时间指定为 0.45ns。在没有输入转换命令的情况下，在时钟树的原点假设理想的转换，这意味着上升和下降转换时间都是 0ns。</p>
<p>​ 时序报告中的“<strong>r”</strong>和“<strong>f”</strong>字符表示时钟或数据信号的上升沿（和下降沿）。上一个时序路径报告中显示了一条从UFF0 / Q的下降沿开始到UFF1 / D的上升沿结束的路径。由于UFF1 / D可以为0或1，因此也可以有一条路径在UFF1 / D的下降沿结束。以下就是这样一条路径：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820104910404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820104951692.png" alt="img"></p>
<p>​ 注意，触发器时钟引脚的边沿（称为有效边沿<strong>active edge</strong>）保持不变。它只能是上升或下降有效沿，具体取决于触发器是由上升沿触发的还是由下降沿触发的。</p>
<p>​ 什么是时钟源延迟（<strong>clock source latency</strong>）？ 这也被称为插入延迟（<strong>insertion delay</strong>），是时钟从其源端传播到待分析设计的时钟定义点所花费的时间，如图8-3所示，这对应于设计之外的时钟树延迟。例如，如果该设计是较大模块的一部分，则时钟源延迟是指直到待分析设计时钟引脚为止的时钟树延迟。可以使用<strong>set_clock_latency</strong>命令明确指定此延迟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820105246379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_clock_latency -source -rise <span class="number">0.7</span> <span class="selector-attr">[get_clocks CLKM]</span></span><br><span class="line"></span><br><span class="line">set_clock_latency -source -fall <span class="number">0.65</span> <span class="selector-attr">[get_clocks CLKM]</span></span><br></pre></td></tr></table></figure>
<p>​ 如果没有这样的命令，则假定延迟为 0。这是早期路径报告中使用的假设。请注意，源延迟不会影响设计内部且具有相同启动时钟和捕获时钟的路径。这是因为相同的延迟被添加到启动时钟路径和捕获时钟路径。然而，这种延迟确实会影响经过分析设计的输入和输出的时序路径。</p>
<p>​ 如果没有<strong>-source</strong>选项，则<strong>set_clock_latency</strong>命令将定义时钟网络延迟，这是从DUA中时钟定义点到触发器的时钟引脚的延迟。时钟网络延迟用于在建立时钟树之前（即在时钟树综合之前）对通过时钟路径的延迟进行建模。一旦建立了时钟树并标记为了“已传播”（propagated），便会忽略此时钟网络延迟约束。<strong>set_clock_latency</strong>命令也可用于对从主时钟到其衍生时钟的延迟进行建模，如7.3节所述。当时钟生成逻辑不是设计的一部分时，该命令也可用于建模片外时钟延迟。</p>
<h3 id="触发器路径的输入input-to-flip-flop-path">触发器路径的输入（Input to Flip-flop Path）</h3>
<p>​ 这是通过输入端口到触发器的路径报告示例。图 8-4 显示了与输入路径和时钟波形相关的原理图。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820110055339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820110145903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820110415499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 首先要注意的是第一行中的<strong>input port clocked by VIRTUAL_CLKM</strong>。如7.9节中所述，该时钟可以被认为是驱动设计输入端口INA的虚拟触发器，该虚拟触发器的时钟为<strong>VIRTUAL_CLKM</strong>。此外，从该虚拟触发器的时钟引脚到输入端口INA的最大延迟指定为2.55ns，在报告中显示为<strong>input external delay</strong>。可以使用以下SDC命令指定这些参数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">create_clock -name VIRTUAL_CLKM -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">-<span class="built_in">max</span> <span class="number">2.55</span> [get_ports INA]</span><br></pre></td></tr></table></figure>
<p>​ 请注意，虚拟时钟VIRTUAL_CLKM的定义没有与设计中任何引脚相关，这是因为它是在设计之外定义的（它是虚拟的）。输入延迟约束<strong>set_input_delay</strong>指定了相对于虚拟时钟的延迟。</p>
<p>​ 输入路径从端口INA开始，如何计算连接到端口INA的第一个单元UINV1的延迟呢？一种方法是指定输入端口INA的驱动单元，该驱动单元用于确定驱动强度，从而确定端口INA上的转换时间，然后用于计算单元UINV1的延迟。在输入端口INA上没有任何转换时间约束的情况下，将假定端口上的过渡时间是理想的，即过渡时间为0ns。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_driving_cell -lib_cell BUFF \</span><br><span class="line"></span><br><span class="line">    -library lib013lwc <span class="selector-attr">[get_ports INA]</span></span><br></pre></td></tr></table></figure>
<p>​ 图8-4还展示了如何进行建立时间检查。数据必须到达UFF2 / D的时间为9.85ns，但是数据实际到达的时间为2.65ns，因此该报告显示该路径的正裕量为7.2ns。</p>
<p><strong>具有实际时钟的输入路径（Input Path with Actual Clock）</strong></p>
<p>​ 也可以根据实际时钟指定输入到达时间；这些不一定必须针对虚拟时钟进行指定。实际时钟的示例是设计中内部引脚或输入端口上的时钟。图 8-5 描述了一个示例，其中端口 CIN 上的输入约束是相对于输入端口 CLKP 上的时钟指定的。此约束指定为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">set_input_delay <span class="operator">-</span>clock <span class="type">CLKP</span> <span class="operator">-</span>max <span class="number">4.3</span> [get_ports <span class="type">CIN</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021082011165374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这里是这个约束对应的输入路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820111749641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820111818649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，起始点（Startpoint）与预期一致，将输入端口的延迟参考时钟指定为了CLKP。</p>
<h3 id="触发器到输出路径flip-flop-to-output-path">触发器到输出路径（Flip-flop to Output Path）</h3>
<p>​ 与上述输入端口约束类似，输出端口可以相对于虚拟时钟或设计的内部时钟、输入时钟端口或输出时钟端口受到约束。这是一个示例，显示了相对于虚拟时钟约束的输出引脚 ROUT。输出约束如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_output_delay -clock VIRTUAL_CLKP \</span><br><span class="line"></span><br><span class="line">    -max <span class="number">5.1</span> <span class="selector-attr">[get_ports ROUT]</span></span><br><span class="line"></span><br><span class="line">set_load <span class="number">0.02</span> <span class="selector-attr">[get_ports ROUT]</span></span><br></pre></td></tr></table></figure>
<p>​ 为了确定最后一个单元连接到输出端口的延迟，需要指定该端口上的负载，上面使用了<strong>set_load</strong>命令来指定输出负载。请注意，端口ROUT可能在DUA内部具有负载，而<strong>set_load</strong>约束指定的是额外的负载，即来自DUA外部的负载。在没有<strong>set_load</strong>命令约束的情况下，将假定外部负载的值为0（这可能不现实，因为该设计很可能会在其它设计中使用）。下图8-6显示了具有虚拟时钟的虚拟触发器的时序路径：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820112148155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通过输出端口的路径报告如下所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820112251974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820112447403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820112520645.png" alt="img"></p>
<p>​ 注意，指定的输出延迟在报告中显示为<strong>output external delay</strong>，其作用类似于虚拟触发器所需的建立时间。</p>
<h3 id="输入到输出路径input-to-output-path">输入到输出路径（Input to Output Path）</h3>
<p>​ 设计也可以具有从输入端口到输出端口的纯组合逻辑路径。可以像我们前面看到的输入和输出路径一样，对路径进行约束和时序分析。下图8-7显示了这种路径的一个示例，虚拟时钟同时用于指定输入和输出端口上的约束。</p>
<p>​ 以下是输入和输出延迟约束：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">max</span> <span class="number">3.6</span> [get_ports INB]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">max</span> <span class="number">5.8</span> [get_ports POUT]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820112757669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是一个时序路径报告，它经过从输入INB到输出POUT的组合逻辑。请注意，任何内部时钟延迟（如果存在）都不会对该路径报告产生影响。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820112902336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820112946739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820113036158.png" alt="img"></p>
<h3 id="频率直方图frequency-histogram">频率直方图（Frequency Histogram）</h3>
<p>​ 如果要绘制一个典型设计的建立时间裕量与路径数的频率直方图，则如图8-8所示。根据设计的状态（是否进行了优化） ，对于未优化的设计，零裕量（<strong>zero slack</strong>）线将更靠近右侧，而对于优化后的设计则更趋向于左侧。对于没有时序违例的设计（即没有路径的裕度为负），整个曲线将在零裕量线的右侧。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820113238363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是一个以文本形式显示的直方图，通常可以由静态时序分析工具生成。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082011334270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 前两个索引表示裕量的范围，第三个索引是该裕量范围内的路径数，例如，有941条路径的裕量范围为410ps至415ps。直方图表明该设计没有时序违例的路径，即所有路径均具有正的裕量，而关键路径的裕量值在375ps至380ps之间。</p>
<p>​ 难以满足时序要求的设计会使直方图的驼峰向左偏大，也就是说，许多路径的裕量值接近于零。通过观察频率直方图可以得出的另一结果是：可以进一步优化设计以实现零裕量的可能性，即时序收敛有多困难。如果违例路径的数量少并且负裕量值也很小，则设计相对比较容易满足所需的时序。但是，如果违例路径的数量很大并且负裕量值也很大，则这意味着设计将需要付出很大努力才能满足所需的时序。</p>
<h2 id="保持时间检查hold-timing-check">保持时间检查（Hold Timing Check）</h2>
<p>​ <strong>保持时间检查</strong>确保正在改变的触发器输出值不会传递到捕获触发器并在触发器有机会捕获其原始值之前覆盖其输出。此检查基于触发器的保持要求。触发器的保持约束要求被锁存的数据应该在时钟的有效边沿之后的指定时间内保持稳定。图 8-9 显示了典型触发器的保持要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820113626338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 就像建立时间检查一样，保持时间检查是在发起触发器（发起数据的触发器）和捕获触发器（捕获数据的触发器以及必须满足其保持时间要求的触发器）之间进行保持时间检查的。这两个触发器的时钟可以相同也可以不同。保持检查是从启动触发器时钟的一个有效边沿到捕获触发器的同一时钟边沿。因此，保持检查与时钟周期无关。保持检查在捕获触发器时钟的每个有效边沿上执行。</p>
<p>​ 现在我们来看一个简单的示例，如图8-10所示，其中发起触发器和捕获触发器具有相同的时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820113936169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 考虑时钟CLKM的第二个上升沿。时钟上升沿发起的数据需要Tlaunch + Tck2q + Tdp时间到达捕获触发器UFF1的D引脚。时钟的同一边沿需要Tcapture时间才能到达捕获触发器的时钟引脚，目的是使捕获触发器在下一个时钟周期捕获来自发起触发器的数据。如果在同一时钟周期内捕获数据，则捕获触发器中的预期数据（来自上一个时钟周期）将被覆盖，因此保持时间检查旨在确保捕获触发器中的目标数据不会被覆盖。保持时间检查可验证这两个时间之差（捕获触发器的数据到达时间和时钟到达时间）必须大于捕获触发器的保持时间，这样触发器上的数据才不会被覆盖，并且捕获到可靠的数据。</p>
<p>​ 保持时间检查可以用数学公式表示为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?Tlaunch+%20Tck2q+%20Tdp%3E%20Tcapture+%20Thold"></p>
<p>​ 其中<strong>Tlaunch</strong>是发起触发器的时钟树延迟，<strong>Tdp</strong>是组合逻辑数据路径中的延迟，<strong>Tcapture</strong>是捕获触发器的时钟树延迟。换句话说，由时钟边沿发起的数据到达捕获触发器D引脚所需的总时间必须大于时钟同一边沿到达捕获触发器所需的时间加上保持时间。这样可以确保UFF1 / D保持稳定状态，直到触发器的时钟引脚UFF1 / CK时钟上升沿之后的保持时间为止。</p>
<p>​ 保持时间检查对捕获触发器的数据路径施加了最小值（<strong>-min</strong>）约束，需要确定到捕获触发器D引脚的最快路径。这意味着将始终使用最短时序路径来进行保持时间检查，同样，通常在 fast timing corner下进行保持时间检查。</p>
<p>​ 即使设计中只有一个时钟，时钟树也会导致时钟在发起触发器和捕获触发器处的到达时间大不相同。为了确保可靠的数据捕获，捕获触发器的时钟沿必须在数据可改变之前到达。保持时间检查可确保（见图8-11）：</p>
<ul>
<li>当前数据发起时钟沿（<strong>Setup launch edge</strong>）的下一个时钟沿发起的数据不被当前数据捕获时钟沿（<strong>Setup receiving edge</strong>）所捕获。</li>
<li>当前数据发起时钟沿发起的数据不被当前数据捕获时钟沿的前一个时钟沿所捕获。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210820114337494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果发起时钟和捕获时钟都属于同一时钟域，则这两个保持时间检查实质上是相同的。但是，当发起时钟和捕获时钟处于不同频率或处于不同时钟域时，以上两个保持时间检查就有可能是不同的。在这种情况下，最差的保持时间检查就是所要报告的检查。上图8-11说明了这两个保持时间检查。</p>
<p>​ UFF0是发起触发器，UFF1是捕获触发器。建立时间检查在这一个数据发起时钟沿（Setup launch edge）和这一个数据捕获时钟沿（Setup receiving edge）之间。下一个数据发起时钟沿（Subsequent launch edge）不得以太快的速度传播数据，因为这可能会导致这一个数据捕获时钟沿没有时间可靠地捕获这一个数据。此外，这一个数据发起时钟沿同样不得以太快的速度传播数据，因为这可能会导致前一个数据捕获时钟沿（Preceding receiving edge）没有时间可靠地捕获前一个数据。在上述各种情况中，最差情况的保持时间检查对应于最严格的保持时间检查。</p>
<p>​ 稍后将在8.3节和8.8节中分别讨论更通用的时钟，例如用于多周期路径和多频率路径的时钟。讨论内容将涵盖建立时间检查和保持时间检查之间的关系，尤其是如何从建立时间检查中推断出保持时间检查。虽然建立时间违例会导致设计的工作频率降低，但保持时间违例会“杀死”（kill）设计，即设计在任何频率下都无法运行。因此，了解保持时间检查并解决任何违例行为非常重要。</p>
<h3 id="触发器到触发器路径flip-flop-to-flip-flop-path-1">触发器到触发器路径（Flip-flop to Flip-flop Path）</h3>
<p>​ 本节基于图 8-2 中描述的示例说明了触发器到触发器的保持路径。以下是第 8.1 节中设置检查路径示例的保持时序检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820114719336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820114811548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 注意，路径类型（<strong>Path Type</strong>）为最小值(<strong>min</strong>)，表示使用了最短路径的单元延迟值，这对应于保持时间检查。库保持时间（<strong>library hold time</strong>）指定了触发器UFF1的保持时间。如前3.4节所述，触发器的保持时间也可以为负。请注意，发起和捕获路径都是从时钟CLKM的上升沿（触发器的有效沿）开始计算的。时序报告显示，新数据最早可以到达UFF1、同时又可以安全地捕获上一个时钟周期数据的时间为0.19ns。由于新数据的实际到达时间为0.33ns，因此报告显示正的保持时间裕量（<strong>slack</strong>）为0.14ns。</p>
<p>​ 图8-12显示了时钟信号到达发起和捕获触发器时钟引脚的时间，以及数据在捕获触发器处的最早允许到达时间和实际到达时间。由于数据实际到达的时间晚于数据所需到达的时间（允许的最早到达时间），因此满足保持时间要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820115423487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>保持时间裕量计算（Hold Slack Calculation）</strong></p>
<p>​ 需要注意的一点是，为建立时间和保持时间的时序报告计算裕量值的方式有所不同。在建立时间报告中，会计算数据实际到达时间和数据需要到达时间，然后将需要到达时间减去实际到达时间，从而得到建立时间的裕量值。但是，在保持时间报告中，当我们把需要到达时间减去实际到达时间后，负的结果将转化为正的裕量值（表示满足保持时间要求），而正的结果将转化为负的裕量值（表示保持时间违例）。</p>
<h3 id="触发器路径的输入input-to-flip-flop-path-1">触发器路径的输入（Input to Flip-flop Path）</h3>
<p>​ 接下来描述来自输入端口的保持时序检查。有关示例，请参见图 8-4。输入端口上的最小延迟使用虚拟时钟指定为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_input_delay -<span class="built_in">clock</span> VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">min</span> <span class="number">1.1</span> [get_ports INA]</span><br></pre></td></tr></table></figure>
<p>​ 这是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820120652343.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820120737240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"> <strong>input external delay</strong>中的值为输入延迟约束命令中的指定值。在0时刻的VIRTUAL_CLKM上升沿和CLKM上升沿之间进行保持时间检查。UFF2在不违反其保持时间的情况下捕获数据所需的到达时间为0.25ns，这表明数据应在0.25ns之后到达。由于数据实际上在1.2ns才到达，因此显示出0.95ns的正裕量。</p>
<h3 id="触发器到输出路径flip-flop-to-output-path-1">触发器到输出路径（Flip-flop to Output Path）</h3>
<p>​ 这是一个输出端口的保持时序检查。有关示例，请参见图 8-6。输出端口命令显示为：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_output_delay -<span class="built_in">clock</span> VIRTUAL_CLKP \</span><br><span class="line"></span><br><span class="line">    -<span class="built_in">min</span> <span class="number">2.5</span> [get_ports ROUT]</span><br></pre></td></tr></table></figure>
<p>​ 输出延迟是相对于虚拟时钟指定的。这是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820121939421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，<strong>output external delay</strong>中的值为输出延迟约束命令中的指定值。</p>
<p><strong>触发器到具有实际时钟的输出路径（Flip-flop to Output Path with Actual Clock）</strong></p>
<p>​ 有一条输出端口保持时间检查的路径，如图8-13所示。请注意，最小输出延迟是相对于实际时钟指定的。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_output_delay -clock CLKP -min <span class="number">3.5</span> <span class="selector-attr">[get_ports QOUT]</span></span><br><span class="line"></span><br><span class="line">set_load <span class="number">0.55</span> <span class="selector-attr">[get_ports QOUT]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820122345439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="输入到输出路径input-to-output-path-1">输入到输出路径（Input to Output Path）</h3>
<p>​ 这是对输入到输出路径的保持时间检查，如图8-7所示。端口的约束为：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">set_load -pin_load <span class="number">0.15</span> <span class="selector-attr">[get_ports POUT]</span></span><br><span class="line"></span><br><span class="line">set_output_delay -clock VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -min <span class="number">3.2</span> <span class="selector-attr">[get_ports POUT]</span></span><br><span class="line"></span><br><span class="line">set_input_delay -clock VIRTUAL_CLKM \</span><br><span class="line"></span><br><span class="line">    -min <span class="number">1.8</span> <span class="selector-attr">[get_ports INB]</span></span><br><span class="line"></span><br><span class="line">set_input_transition <span class="number">0.8</span> <span class="selector-attr">[get_ports INB]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820122855475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 输入端口和输出端口上的延迟约束是相对于虚拟时钟指定的，因此，保持时间检查是在该虚拟时钟的上升沿（默认有效沿<strong>default active</strong>）处执行的。</p>
<h2 id="多周期路径multicycle-paths">多周期路径（Multicycle Paths）</h2>
<p>​ 在某些情况下，两个触发器之间的数据路径可能需要一个以上的时钟周期才能传播通过逻辑。在这种情况下，这条组合逻辑路径会被定义为<strong>多周期路径（multicycle path）</strong>。虽然数据还是会在每个时钟沿上都被捕获触发器捕获，但我们需要告知STA在指定数量的时钟周期之后才会出现有效的捕获时钟沿。</p>
<p>​ 图8-14是一个示例。由于数据路径最多需要三个时钟周期，因此应指定三个周期的多周期建立时间检查。为此需要指定如下的多周期建立时间约束：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">10</span> <span class="selector-attr">[get_ports CLKM]</span></span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">3</span> -setup \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/Q]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF1/D]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820123349565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 多周期建立时间约束规定，建立时间检查时从UFF0 / CK到UFF1 / D的路径最多可以花费三个时钟周期，这意味着设计每三个周期才会使用一次UFF1 / Q引脚上输出的数据，而不是每个周期都使用。</p>
<p>​ 以下是一份具有多周期约束的建立时间路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820123524421.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820123605367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820123645997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 注意，现在捕获触发器的时钟沿距离发起触发器的时钟沿三个时钟周期，为30ns。</p>
<p>​ 现在，我们来检查一下多周期路径上的保持时间检查。在最常见的情况下，我们希望保持时间检查保持不变（与单周期路径一致），如图8-14所示，这样可使数据在三个时钟周期之内任意进行改变。只有指定多周期保持时间为2，才可以获得与单周期建立时间检查情况相同的保持时间检查。这是因为在没有这样的多周期保持时间约束的情况下，默认的保持时间检查是在建立时间捕获沿的前一个有效时钟沿上执行的，这显然不是我们希望的。我们需要将执行保持时间检查的时钟沿移动到默认时钟沿之前的两个周期，因此指定了多周期保持时间为2。预期的检查如图8-15所示，通过多周期保持时间约束，数据路径的最小延迟可以小于一个时钟周期。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> -hold -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/Q]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF1/D]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820125642805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 多周期保持时间约束命令中的周期数指定了从默认保持时间检查沿（建立时间捕获沿之前的一个有效沿）需要移回多少个时钟周期。 以下是一份保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820130625460.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820130702753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820130747793.png" alt="img"></p>
<p>​ 由于此路径的多周期建立时间约束为3，因此其默认保持时间检查是在建立时间捕获沿之前的有效时钟沿上执行的。在大多数设计中，如果最大路径（或建立时间）需要N个时钟周期，则大于（N-1）个时钟周期的最小路径约束是不可行的。通过指定两个周期的多周期保持时间约束，可以将保持时间检查时钟沿移回到数据发起沿处（即0ns处），如上面的路径报告中所示。</p>
<p>​ 因此在大多数设计中，指定为N（周期）的多周期建立时间约束应伴随着指定为N-1（周期）的多周期保持时间约束。</p>
<p>​ 如果指定了N个周期的多周期建立时间约束，但缺少了相应的N-1个周期的多周期保持时间约束，会发生什么情况呢？在这种情况下，会在建立时间捕获沿之前的一个周期时钟沿上执行保持时间检查。图8-16显示了仅约束多周期建立时间为3个周期时，进行这种保持时间检查的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820130943855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如图所示，这规定了数据只能在建立时间捕获沿之前的一个周期内进行改变。因此，数据路径必须具有至少两个时钟周期的最小延迟才能满足此要求。以下是这种情况的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820131046634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820131130925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820131219273.png" alt="img"></p>
<p><strong>跨时钟域（Crossing Clock Domains）</strong></p>
<p>​ 让我们考虑在周期相同的两个不同时钟之间存在多周期路径的情况。（时钟周期也不同的情况将在本章后面进行介绍）</p>
<p>​ 例子1：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p>​ 多周期建立时间约束指定了给定路径的时钟周期数，如图8-17所示。默认建立时间捕获沿总是与发起沿相隔一个时钟周期，约束多周期建立时间为2会使建立时间捕获沿与发起沿相隔2个时钟周期。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820133856602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 多周期保持时间约束指定了保持时间检查应该在建立时间捕获沿之前几个时钟周期的时钟沿处执行，无论建立时间发起沿在何处，如图8-18所示。默认的保持时间检查是在建立时间捕获沿之前一个周期的时钟沿处执行的。约束多周期保持时间为1会将保持时间检查放置于默认保持时间检查之前一个周期的时钟沿处，因此变为建立时间捕获沿之前两个周期的时钟沿处。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820133939754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="keyword">from</span> [get_pins UFF0/CK] -<span class="keyword">to</span> [get_pins UFF3/D]</span><br><span class="line"></span><br><span class="line"># Since no -hold <span class="keyword">option</span> <span class="built_in">is</span> specified, the <span class="keyword">default</span> <span class="keyword">option</span></span><br><span class="line"></span><br><span class="line"># -setup <span class="built_in">is</span> assumed. This implies that the setup</span><br><span class="line"></span><br><span class="line"># multiplier <span class="built_in">is</span> <span class="number">2</span> <span class="built_in">and</span> the hold multiplier <span class="built_in">is</span> <span class="number">0</span>.</span><br></pre></td></tr></table></figure>
<p>​ 这是与多周期约束相对应的建立时间路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820134500508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，路径报告中指定的路径组始终是捕获触发器的路径组，在本例中为 CLKP。</p>
<p>​ 接下来是保持时间检查的路径报告。由于多周期保持时间约束默认为0，因此将在建立时间捕获沿（20ns）之前一个时钟周期的10ns处进行保持时间检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820135027590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以上报告报出了保持时间违例，这可以通过将多周期保持时间约束指定为1来消除。接下来将在一个单独的示例中说明这一点。</p>
<p>​ 例子2：</p>
<p>​ 下面给出了跨两个不同时钟域指定的多周期的另一个示例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/CK]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF3/D]</span> -setup</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">1</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins UFF0/CK]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins UFF3/D]</span> -hold</span><br><span class="line"></span><br><span class="line"># The -setup and -hold options are explicitly specified.</span><br></pre></td></tr></table></figure>
<p>​ 以下是多周期建立时间约束为2时建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820140423413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820140515351.png" alt="img"></p>
<p>​ 以下是多周期保持时间约束为1时保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820140558833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，本节中建立和保持检查的示例报告针对相同的时序角（timing corner）。然而，在最坏情况下的慢角（worst-case slow corner）通常最难满足建立时间检查（具有最低的裕量），而在最佳情况下的快速角（ best-case fast corner）通常最难满足保持检查（具有最低的裕量）。</p>
<h2 id="伪路径false-paths">伪路径（False Paths）</h2>
<p>​ 当设计的功能运行时，某些时序路径可能不真实（或不可能）存在。在执行STA时可以将这些路径设置为伪路径（false path），这样就可以关闭这些路径，那么STA就不会对这些伪路径去进行分析了。</p>
<p>​ 伪路径可能是从一个时钟域到另一个时钟域、从触发器的时钟引脚到另一触发器的输入引脚、通过一个单元的引脚、通过多个单元的引脚或这些情况的组合 。当通过单元的引脚指定了伪路径后，通过该引脚的所有路径都将被忽略，无需进行时序分析。辨别出伪路径的好处在于减少了分析空间，从而使分析可以专注于真实存在的路径，这同样有助于减少分析时间。但是，过多使用<strong>-through</strong>选项去指定伪路径同样会降低分析的速度。</p>
<p>​ 可以使用<strong>set_false_path</strong>命令来约束伪路径，以下是一些例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set_false_path -<span class="keyword">from</span> [get_clocks SCAN_CLK] \</span><br><span class="line"></span><br><span class="line">    -to [get_clocks CORE_CLK]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Any path starting from the SCAN_CLK domain to the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CORE_CLK domain is a false path.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path -through [get_pins UMUX0/S]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Any path going through this pin is false.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path \</span><br><span class="line"></span><br><span class="line">    -through [get_pins SAD_CORE/RSTN]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The false path specifications can also be specified to,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># through, or from a module pin instance.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path -to [get_ports TEST_REG*]</span><br><span class="line"></span><br><span class="line"><span class="comment"># All paths that end in port named TEST_REG* are false paths.</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_false_path -through UINV/Z -through UAND0/Z</span><br><span class="line"></span><br><span class="line"><span class="comment"># Any path that goes through both of these pins</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># in this order is false.</span></span><br></pre></td></tr></table></figure>
<p>​ 下面给出了一些关于设置伪路径的建议。要在两个时钟域之间设置伪路径，请使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_false_path -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks clockA]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks clockB]</span></span><br></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_false_path -<span class="selector-tag">from</span> <span class="selector-attr">[get_pins &#123;regA_*&#125;/CP]</span> \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">to</span> <span class="selector-attr">[get_pins &#123;regB_*&#125;/D]</span></span><br></pre></td></tr></table></figure>
<p>​ 后者这种方式要慢得多。</p>
<p>​ 另一个建议是尽可能少使用<strong>-through</strong>选项，因为它增加了运行时不必要的复杂性。仅在绝对有必要且没有替代方法可以指定该伪路径的情况下，才可以使用<strong>-through</strong>选项。</p>
<p>​ 从优化的角度来看，还有一个建议是不要将一条多周期路径约束为伪路径。如果需要在已知或可预测的时刻对信号进行采样，则无论时间间隔多大，都应使用多周期路径约束，以使路径具有一定的约束条件并进行优化以满足多周期约束。如果把一条许多时钟周期后进行采样的路径指定为了伪路径，则对设计中其余逻辑路径的优化可能会使该路径变长，甚至超出所需的时间。</p>
<h2 id="半周期路径half-cycle-paths">半周期路径（Half-Cycle Paths）</h2>
<p>​ 如果设计中同时具有负边沿触发的触发器（有效时钟沿为下降沿）和正边沿触发的触发器（有效时钟沿为上升沿），则设计中可能存在半周期路径（half-cycle path）。半周期路径可能是从一个触发器的上升沿到另一个触发器的下降沿，或者反过来。图8-19给出了一个示例，其中数据的发起沿在触发器UFF5的时钟下降沿，而数据的捕获沿在触发器UFF3的时钟上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820141254211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820141327313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意起点（Startpoint）和终点（Endpoint）中的边沿说明。时钟CLKP的下降沿出现在6ns，上升沿出现在12ns。因此，数据需要在半个周期6ns内到达捕获触发器的输入引脚。</p>
<p>​ 虽然在建立时间检查时数据路径仅有半个时钟周期，但额外的半个周期可用于保持时间检查。以下是保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820141409658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间检查通常是在捕获沿之前一个周期的捕获沿上执行的。由于捕获沿是在12ns处，因此前一个捕获沿在0ns处，故将在0ns处检查保持时间。这为保持时间检查有效地增加了半个时钟周期的裕量，因此可以看见保持时间检查有较大的正裕量（slack）。</p>
<h2 id="移除时间检查removal-timing-check">移除时间检查（Removal Timing Check）</h2>
<p>​ <strong>移除时间检查（ removal timing check）</strong>可确保在有效时钟沿与释放异步控制信号之间有足够的时间。该检查可确保有效时钟沿不带来影响，因为异步控制信号将保持有效状态，直到有效时钟沿之后一段撤销时间为止。换句话说，异步控制信号会在有效时钟沿之后被释放（变为无效），因此该时钟沿不会产生任何影响，如图8-20所示。该检查基于的是触发器异步引脚上指定的撤销时间。以下是单元库中与撤销时间检查有关的描述片段：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pin</span>(CDN) &#123;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">    <span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">    related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    timing_type : removal_rising;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820142100731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与保持时间检查一样，该检查也是针对最小路径的，不过是在触发器的异步引脚上。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820142225533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820142331725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820142519229.png" alt="img"></p>
<p>​ 终点（Endpoint）表明这是移除时间检查，且在触发器UFF6的异步引脚CDN上。该触发器的移除时间在报告中显示为<strong>library removal time</strong>，值为0.19ns。</p>
<p>​ 所有异步时序检查均被分配给了<strong>async_default</strong>路径组。</p>
<h2 id="恢复时间检查recovery-timing-check">恢复时间检查（Recovery Timing Check）</h2>
<p>​ <strong>恢复时间检查（recovery timing check）</strong>可确保异步信号变为无效状态的时刻与下一个有效时钟沿之间的时间间隔大于一个最小值。换句话说，此检查可确保在异步信号变为无效状态之后，有足够的时间恢复，以便下一个有效时钟沿可以生效。例如，考虑从异步复位变为无效的时刻到触发器有效时钟沿之间的时间间隔。如果该时间间隔太短即有效时钟沿在复位释放后太早出现，则触发器可能进入未知的状态。恢复时间检查如图8-21所示。该检查基于的是触发器异步引脚上指定的恢复时间，单元库文件中与恢复时间有关的描述片段如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pin</span>(RSN) &#123;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">    <span class="built_in">timing</span>() &#123;</span><br><span class="line"></span><br><span class="line">    related_pin : <span class="string">&quot;CK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    timing_type : recovery_rising;</span><br><span class="line"></span><br><span class="line">    . . .</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021082014431722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与建立时间检查一样，该检查也是针对最大路径的，不过是在触发器的异步引脚上。</p>
<p>​ 以下是一份恢复时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820144815790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820144849652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 终点（Endpoint）表明这是恢复时间检查，并且触发器UFF6的恢复时间在报告中显示为<strong>library recovery time</strong>，值为0.09ns。恢复时间检查也属于<strong>async_default</strong>路径组。</p>
<h2 id="跨时钟域的时序timing-across-clock-domains">跨时钟域的时序（Timing across Clock Domains）</h2>
<h3 id="慢到快时钟域slow-to-fast-clock-domains">慢到快时钟域（Slow to Fast Clock Domains）</h3>
<p>​ 让我们来对一条从慢速时钟域到快速时钟域的路径来进行建立时间与保持时间检查，如图8-22所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820145105362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是以上示例的时钟定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]    </span><br></pre></td></tr></table></figure>
<p>​ 当发射触发器和捕获触发器的时钟频率不同时，STA通过首先确定一个共同的基周期来执行。下面给出了一个使用上述两个时钟进行STA时产生的消息示例。将较快的时钟展开，以获得一个普通周期。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Expanding clock <span class="string">&#x27;CLKP&#x27;</span> <span class="keyword">to</span> base <span class="keyword">period</span> <span class="keyword">of</span> <span class="number">20.00</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">old</span> <span class="keyword">period</span> was <span class="number">5.00</span>, added <span class="number">6</span> edges).</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820145940698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 图8-23中为建立时间检查。默认情况下，将使用最严格的建立时间边沿去检查，在本例中为5ns处的时钟沿。以下是此时建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150051566.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820150121371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，发起时钟沿为0ns，而捕获时钟沿为5ns。</p>
<p>​ 如前所述，保持时间检查与建立时间检查有关，并确保由当前时钟沿发起的数据不会干扰先前数据的捕获。这是保持时间检查的报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150152501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在上面的示例中，我们可以看到发起的数据在捕获时钟的第四个周期可用。让我们假设该设计的目的不是在CLKP的下一个有效沿上就捕获数据，而是在每第4个捕获沿上捕获数据。该假设给触发器之间的组合逻辑路径提供了4个CLKP周期的时间，即20ns。我们可以通过设置以下多周期路径约束来做到这一点：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">4</span> -setup \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKM]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKP]</span> -end</span><br></pre></td></tr></table></figure>
<p>​ <strong>-end</strong>选项指定了多周期4是用于终点（endpoint）或捕获时钟的。此多周期路径约束将建立时间和保持时间检查更改为了图8-24中所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150430480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是这种情况下建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150511369.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820150554384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 上图8-24中也说明了保持时间检查，请注意，保持时间检查是根据建立时间检查而决定的，默认为当前数据捕获沿之前的一个周期。以下是保持时间检查的路径报告。注意，保持时间捕获沿为15ns，比建立时间捕获沿（20ns）早一个周期（5ns）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820150853329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820150925407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在大多数设计中，这不是理想的时序检查，应将保持时间检查一直移回到数据发起沿所在位置。因此，我们可以约束多周期保持时间为3。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">3</span> -hold \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKM]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKP]</span> -end</span><br></pre></td></tr></table></figure>
<p>​ 3是指将保持时间检查沿向后移三个CLKP时钟周期，即0ns时刻处。与多周期建立时间约束的区别在于：在多周期建立时间约束中，建立时间捕获沿会从默认的建立时间捕获沿向前移动指定的周期数；而在多周期保持时间约束中，保持时间检查沿会从默认的保持时间检查沿向后移动指定的周期数。<strong>-end</strong>选项意味着我们想将终点（或捕获边沿）移回指定的周期数，即捕获时钟的周期数。代替<strong>-end</strong>的另一种选项<strong>-start</strong>指定了要移动的发起时钟周期数，<strong>-end</strong>选项指定了要移动的捕获时钟周期数。<strong>-end</strong>是多周期建立时间约束的默认值，<strong>-start</strong>是多周期保持时间约束的默认值。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820151345402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 使用多周期保持时间约束，可以将保持时间检查的时钟沿往回移，检查效果如图8-25所示。具有多周期保持时间约束的保持时间检查路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820151625970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820151705142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"> 总之，如果指定了N个周期的多周期建立时间，那么很可能还应指定N-1个周期的多周期保持时间。对于慢速到快速时钟域之间的路径，多周期路径约束的一个好经验是使用<strong>-end</strong>选项。使用此选项，可以根据快速时钟的时钟周期来调整建立时间和保持时间检查。</p>
<h3 id="快到慢时钟域fast-to-slow-clock-domains">快到慢时钟域（Fast to Slow Clock Domains）</h3>
<p>​ 在本小节中，我们考虑数据路径从快速时钟域到慢速时钟域的示例。使用以下时钟定义时，默认的建立时间和保持时间检查如图8-26所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820151850670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 总共可能有四种建立时间检查，请参阅图8-26中的Setup1，Setup2，Setup3和Setup4。其中，最严格的是Setup4检查。以下是此最严格检查的路径报告。请注意，数据发起时钟沿为15ns，捕获时钟沿为20ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820151931654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820152024246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与建立时间检查类似，总共也可能有四种保持时间检查。图8-26中所示为最严格的保持时间检查，该检查可确保0ns处的捕获沿不捕获0ns处正在发起的数据。以下是这种情况下保持时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820152747107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820152815105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通常，设计人员可以将从快时钟域到慢时钟域的数据路径指定为多周期路径。如果想要放宽建立时间检查，比如为数据路径提供两个快时钟周期，则此多周期路径约束如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> -setup \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKP]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKM]</span> -start</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">1</span> -hold \</span><br><span class="line"></span><br><span class="line">    -<span class="selector-tag">from</span> <span class="selector-attr">[get_clocks CLKP]</span> -<span class="selector-tag">to</span> <span class="selector-attr">[get_clocks CLKM]</span> -start</span><br><span class="line"></span><br><span class="line"># The -start option refers <span class="selector-tag">to</span> the launch clock and is</span><br><span class="line"></span><br><span class="line"># the default for <span class="selector-tag">a</span> multicycle hold.</span><br></pre></td></tr></table></figure>
<p>​ 在这种情况下，图8-27中为用于建立时间和保持时间检查的时钟沿。<strong>-start</strong>选项指定周期数的单位（在这种情况下为2）是发起时钟周期（在这种情况下为CLKP）。约束多周期建立时间为2会将发起沿移动到默认发起沿之前的一个时钟沿，即在10ns而不是默认的15ns处。多周期保持时间约束确保了在0ns处发起沿发起的数据，不会被0ns处的捕获沿捕获到。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820152951953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告。与预期一样，发起时钟沿为10ns，捕获时钟沿为20ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820153345132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820153446732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告。保持时间检查是在0ns处执行的，此时捕获时钟和发起时钟均为上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820153535212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820153612143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 与从慢速时钟域到快速时钟域的路径不同，在从快速时钟域到慢速时钟域的路径中，多周期路径约束的一个好经验是使用<strong>-start</strong>选项，然后再根据快速时钟调整建立时间和保持时间检查。</p>
<h2 id="例子">例子</h2>
<p>​ 在本节中，我们将介绍发起和捕获时钟的不同情况，并分别说明如何执行建立时间和保持时间检查。图8-28为所举例子的示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820153830904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>半周期路径 - 案例 1（Half-cycle Path - Case 1）</strong></p>
<p>​ 在此示例中，两个时钟具有相同的周期，但相位相反。以下是时钟定义，其波形如图8-29所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">10</span> <span class="number">20</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820154023190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查是从发起沿（0ns）到下一个捕获沿（10ns）的。半个时钟周期的裕量可用于保持时间检查，以验证在20ns处发起的数据是否在10ns处未被捕获沿所捕获。以下是建立时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082015415358.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820154225811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820154318780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820154417798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>半周期路径 - 案例2（Half-cycle Path - Case 2）</strong></p>
<p>​ 此示例与情况1类似，不过发起时钟和捕获时钟的相位相反。以下是时钟定义，其波形如图8-30所示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">5</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820155433765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查从5ns的发起时钟沿到10ns的下一个捕获时钟沿。保持时间检查从5ns的发起时钟沿到0ns的捕获时钟沿。以下是建立时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820155730210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以下是保持时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082015582393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>快到慢时钟域（Fast to Slow Clock Domain）</strong></p>
<p>​ 在此示例中，捕获时钟是发起时钟的二分频。以下是时钟定义。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p>​ 波形如图8-31所示。建立时间检查是从10ns的发起沿到20ns的捕获沿，保持时间检查是从0ns的发起沿到0ns的捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820160032372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820160521761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820160553683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告：</p>
<p><img src="https://img-blog.csdnimg.cn/2021082016063678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820160740172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>慢到快时钟域（Slow to Fast Clock Domain）</strong></p>
<p>​ 在此示例中，捕获时钟速度是发起时钟速度的2倍。图8-32中为建立时间和保持时间检查对应的时钟沿：从发起沿0ns到下一个捕获沿5ns进行建立时间检查，保持时间检查是在建立时间捕获沿前一个周期的捕获沿进行的，也就是说，发起沿和捕获沿都为0ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161515292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以下是建立时间检查的路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161610709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>以下是保持时间检查的路径报告</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161652557.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820161722349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="多倍时钟multiple-clocks">多倍时钟（Multiple Clocks）</h2>
<h3 id="整数倍数integer-multiples">整数倍数（Integer Multiples）</h3>
<p>​ 在设计中通常会定义多个时钟，这些时钟的频率是彼此的整数倍。在这种情况下，会通过计算所有相关时钟（related clocks）之间的公共基本周期来执行STA（如果两个时钟域之间具有数据路径，则两个时钟相关）。建立公共基本周期的目的是以便所有时钟都同步。</p>
<p>​ 以下是3个相关时钟的示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">20</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKQ</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br><span class="line"><span class="type">Expanding</span> clock &#x27;<span class="type">CLKP</span>&#x27; to base period of <span class="number">20.00</span> (old period was</span><br><span class="line"></span><br><span class="line"><span class="number">5.00</span>, added <span class="number">6</span> edges).</span><br><span class="line"></span><br><span class="line"><span class="type">Expanding</span> clock &#x27;<span class="type">CLKQ</span>&#x27; to base period of <span class="number">20.00</span> (old period was</span><br><span class="line"></span><br><span class="line"><span class="number">10.00</span>, added <span class="number">2</span> edges).</span><br></pre></td></tr></table></figure>
<p>​ 分析CLKP和CLKM时钟域之间的路径时，将使用20ns的公共基本周期，如图8-33所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820161919366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是建立时间检查的路径报告，用于从较快时钟CLKP到较慢时钟CLKM的路径。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820162136359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 相应保持时间检查的路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820162233407.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820162329394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="非整数倍数non-integer-multiples">非整数倍数（Non-Integer Multiples）</h3>
<p>​ 考虑当两个频率不是彼此整数倍的时钟域之间存在数据路径的的情况。例如，发起时钟是公共时钟的8分频，而捕获时钟是公共时钟的5分频，如图8-34所示。本节将介绍在这种情况下如何执行建立时间和保持时间检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820162658968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是时钟定义，其波形如图8-35所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">8</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; [get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKQ</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> \</span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>period <span class="number">5</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports <span class="type">CLKP</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210820162829823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时序分析会先计算相关时钟的公共周期，然后再将时钟扩展到该公共周期。请注意，仅针对相关时钟（即在它们之间具有时序路径的时钟）去计算公共周期。CLKQ和CLKP之间数据路径的公共周期仅扩展为10ns的公共周期，CLKM和CLKQ之间数据路径的公共周期为40ns，而CLKM和CLKP之间数据路径的公共周期也为40ns。</p>
<p>​ 让我们考虑一条从CLKM时钟域到CLKP时钟域的数据路径，这种情况下时序分析的公共基本周期为40ns。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Expanding clock <span class="string">&#x27;CLKM&#x27;</span> <span class="keyword">to</span> base <span class="keyword">period</span> <span class="keyword">of</span> <span class="number">40.00</span> (<span class="keyword">old</span> <span class="keyword">period</span> was</span><br><span class="line"></span><br><span class="line"><span class="number">8.00</span>, added <span class="number">8</span> edges).</span><br><span class="line"></span><br><span class="line">Expanding clock <span class="string">&#x27;CLKP&#x27;</span> <span class="keyword">to</span> base <span class="keyword">period</span> <span class="keyword">of</span> <span class="number">40.00</span> (<span class="keyword">old</span> <span class="keyword">period</span> was</span><br><span class="line"></span><br><span class="line"><span class="number">5.00</span>, added <span class="number">14</span> edges).</span><br></pre></td></tr></table></figure>
<p>​ 建立时间检查在时钟发起沿和捕获沿之间的最短时间内进行。在我们从CLKM到CLKP的示例路径中，这就是24ns处的时钟CLKM发起沿以及25ns处的时钟CLKP捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820163649538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820163925412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告，最严格的保持时间检查是从0ns处的CLKM发起沿到0ns处的CLKP捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820163958956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820164030643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 现在，我们对从CLKP时钟域到CLKM时钟域的路径的建立时间进行检查。在这种情况下，最严格的建立时间检查是从15ns处的时钟CLKP发起沿到16ns处的时钟CLKM捕获沿。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164157342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820164230477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是保持时间检查的路径报告，同样，最严格的还是0ns处的检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164321225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2021082016435437.png" alt="img"></p>
<h3 id="相移phase-shifted">相移（Phase Shifted）</h3>
<p>​ 在以下示例中，两个时钟有90°的相移（phase shift）：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">2.0</span> -waveform &#123;<span class="number">0</span> <span class="number">1.0</span>&#125; <span class="selector-attr">[get_ports CKM]</span></span><br><span class="line"></span><br><span class="line">create_clock -period <span class="number">2.0</span> -waveform &#123;<span class="number">0.5</span> <span class="number">1.5</span>&#125; <span class="selector-attr">[get_ports CKM90]</span></span><br></pre></td></tr></table></figure>
<p>​ 图8-36给出了使用这两个时钟的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164909372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查的路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820164957665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820165025759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 0.5ns处的CKM90第一个上升沿是捕获沿，保持时间检查是在建立时间捕获沿之前一个周期的时钟沿处。对于2ns的发起沿，建立时间捕获沿为2.5ns，因此保持时间检查沿就在0.5ns处的前一个捕获沿。保持时间检查的路径报告如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210820165204133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 在第10章中还会介绍其它时序检查，例如数据到数据（data to data）检查和时钟门控（clock gating）检查。</p>
<h1 id="接口分析interface-analysis">接口分析（Interface Analysis）</h1>
<blockquote>
<p>​ 本章描述了各种类型的输入和输出路径的时序分析程序，以及几种常用的接口。还描述了特殊接口(如SDRM)的时序分析和源同步接口(如DDR sdram)的时序分析。</p>
</blockquote>
<h2 id="io-接口io-interfaces">IO 接口(IO Interfaces)</h2>
<p>​ 本节给出的示例说明了如何定义DUA（设计的芯片）的输入和输出接口的约束。后面的部分提供了SRAM和DDR SDRAM接口的时序约束示例。</p>
<h3 id="输入接口input-interface">输入接口（Input Interface）</h3>
<p>​ 大致有两种指定的输入时序的替代方法:</p>
<ul>
<li>作为 AC 约束的DUA 输入端的波形。</li>
<li>指定外部逻辑到输入的路径延迟。</li>
</ul>
<p><em>数字设备的约束分为两部分：DC - 恒定值（静态）和 AC - 变化的波形（动态）。</em></p>
<p><strong>输入波形约束（Waveform Specification at Inputs）</strong></p>
<p>​ 考虑图 9-1 所示的输入交流约束。约束是输入CIN在时钟CLKP上升沿前4.3ns稳定，值保持稳定直到时钟上升沿后2ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820174357228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 首先考虑 4.3ns 约束。给定 8ns 的时钟周期（如图 9-1 所示），此要求映射到从虚拟触发器（驱动此输入的触发器）到输入 CIN 的延迟。从虚拟触发器时钟到 CIN 的延迟必须最多为 3.7ns (= 8.0 - 4.3)，最大延迟为 3.7ns。这可确保输入 CIN 处的数据在上升沿之前 4.3ns 到达。因此，AC 约束的这一部分可以等效地指定为 3.7ns 的最大输入延迟。</p>
<p>​ AC 约束还指出，输入 CIN 在时钟上升沿后稳定 2ns。这个规范也可以映射到虚拟触发器的延迟，即虚拟触发器到输入CIN的延迟必须至少为2.0ns。因此最小输入延迟指定为 2.0ns。</p>
<p>​ 这里的输入约束为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKP</span> <span class="operator">-</span>period <span class="number">8</span> [get_ports <span class="type">CLKP</span>]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span>min <span class="number">2.0</span> <span class="operator">-</span>clock <span class="type">CLKP</span> [get_ports <span class="type">CIN</span>]</span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span>max <span class="number">3.7</span> <span class="operator">-</span>clock <span class="type">CLKP</span> [get_ports <span class="type">CIN</span>]</span><br></pre></td></tr></table></figure>
<p>​ 以下是这些输入条件下设计的路径报告。首先是建立时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082017485994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 指定的最大输入延迟 (3.7ns) 被添加到数据路径。建立时间检查可确保 DUA 内的延迟小于 4.3ns，并且可以锁存正确的数据。接下来是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820175219324.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820175252174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 最小输入延迟被添加到保持检查中的数据路径。该检查确保，时钟边沿后 2ns 处的最早数据变化不会覆盖触发器处的先前数据。</p>
<p><strong>输入路径延迟约束（Path Delay Specification to Inputs）</strong></p>
<p>​ 已知连接到输入的外部逻辑的路径延迟时，指定输入约束是一项简单的任务。添加外部逻辑路径到输入的任何延迟，并使用 <strong>set_input_delay</strong> 命令指定路径延迟。</p>
<p>​ 图9-2示例输入的外部逻辑路径。添加Tck2q和Tc1延迟以获得外部延迟。知道Tck2q和Tc1后，直接获得输入延迟作为Tck2q Tc1。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082018013184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 外部最大和最小路径延迟转换为以下输入约束。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">create_clock -name RCLK -period <span class="number">10</span> [get_ports RCLK]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">max</span> <span class="number">6.2</span> -<span class="built_in">clock</span> RCLK [get_ports INIT]</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="built_in">min</span> <span class="number">3.0</span> -<span class="built_in">clock</span> RCLK [get_ports INIT]</span><br></pre></td></tr></table></figure>
<p>​ 它们的路径报告类似于第8.1节和第8.2节中的路径报告。</p>
<p>​ 注意，当计算设计内部触发器的数据引脚处的到达时间时，最大和最小输入延迟值被添加到数据路径延迟中，这取决于是执行最大路径检查（建立时间）还是最小路径检查（保持时间）。</p>
<h3 id="输出接口output-interface">输出接口（Output Interface）</h3>
<p>​ 与输入情况类似，指定输出时序要求大致有两种替代方法：</p>
<ul>
<li>作为AC约束的DUA输出端所需的波形。</li>
<li>指定外部逻辑的路径延迟。</li>
</ul>
<p><strong>输出波形约束（Output Waveform Specification）</strong></p>
<p>​ 考虑图9-3所示的输出AC约束，输出QOUT应该稳定在时钟CKP的上升沿之前的输出2ns。此外，输出应在时钟上升沿后1.5ns后才改变。这些约束通常从与QOUT接口的外部块的设置和保持要求中获得。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820185516273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 以下是在输出上表达此需求的约束。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name CLKP <span class="operator">-</span>period <span class="number">6</span> <span class="operator">-</span>waveform <span class="punctuation">&#123;</span><span class="number">0</span> <span class="number">3</span><span class="punctuation">&#125;</span> <span class="punctuation">[</span>get_ports CLKP<span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup delay of virtual flip-flop:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock CLKP <span class="operator">-</span><span class="built_in">max</span> <span class="number">2.0</span> <span class="punctuation">[</span>get_ports QOUT<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hold time for virtual flip-flop:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock CLKP <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">1.5</span> <span class="punctuation">[</span>get_ports QOUT<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 输出的外部路径延迟最大输出路径延迟指定为2.0ns。这将确保数据QOUT在时钟边缘之前的2ns窗口之前发生变化。最小输出路径延迟-1.5ns从虚拟触发器的角度指定了要求，也就是说，为了确保在输出端口 QOUT的1.5ns的保持时间需求。1.5ns的保持时间要求就是<strong>set_output_delay</strong>中指定的最小值-1.5。</p>
<p>这里是建立时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820190115573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 从下一个时钟沿减去最大输出延迟，以确定到达 DUA 输出所需的时间。</p>
<p>​ 接下来是保持时间检查路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082019023821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 从捕获时钟边沿中减去最小输出延迟（-1.5ns），以确定满足保持时间要求的 DUA 输出的最早到达时间。负最小输出延迟要求很常见。</p>
<p><strong>输出的外部路径延迟（ External Path Delays for Output）</strong></p>
<p>​ 在这种情况下，明确指定了外部逻辑的路径延迟。请参见图 9-4 中的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082019054179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 让我们首先检查建立时间检查。从Tc2_max和Tsetup获得最大输出延迟（set_output_delay max）建立时间。为了检查DUA内部触发器（如UFF0）和虚拟触发器之间输出路径的建立时间要求，将最大输出延迟指定为Tc2_max + Tsetup。</p>
<p>​ 接下来，让我们检查保持时间检查。最小输出延迟（set_output_delay min）设置由Tc2_min和Thold获得。由于捕获触发器的保持时间被添加到捕获时钟路径，最小输出延迟被指定为（Tc2_min-Thold）。</p>
<p>​ 输出上的约束转化为以下内容：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name SCLK <span class="operator">-</span>period <span class="number">5</span> <span class="punctuation">[</span>get_ports SCLK<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup of the external logic (Tc2_max = 2.5,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tsetup = 0.6):</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">3.1</span> <span class="operator">-</span>clock SCLK <span class="punctuation">[</span>get_ports RDY<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hold of the external logic (Tc2_min=1.6, Thold=0.15):</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="number">1.45</span> <span class="operator">-</span>clock SCLK <span class="punctuation">[</span>get_ports RDY<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 它们的路径报告类似于第8.1节和第8.2节中的路径报告。</p>
<h3 id="窗口内的输出变化output-change-within-window">窗口内的输出变化（Output Change within Window）</h3>
<p>​ <strong>set_output_delay</strong> 命令可用于指定输出信号相对于时钟的最大和最小到达时间。本节考虑指定约束的特殊情况，以验证当输出只能在相对于时钟边沿的时序窗口内更改时的场景。在验证源同步接口的时序时，此要求经常出现。</p>
<p>​ 在源同步接口中，时钟也作为输出与数据一起出现。在这种情况下，通常需要时钟和数据之间的时序关系。例如，可能只需要在时钟上升沿附近的特定窗口内更改输出数据。</p>
<p>​ 图 9-5 显示了对源同步接口的示例要求。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820191516481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 要求是 DATAQ 的每一位只能在时钟上升沿前 2ns 和时钟上升沿后最多 1ns 的指定窗口内发生变化。这与前几节讨论的输出延迟约束完全不同，后者要求数据引脚在时钟上升沿附近的指定时序窗口中保持稳定。</p>
<p>​ 我们在主时钟为 CLKM 的 CLK_STROBE 上创建一个生成时钟。这是为了帮助指定与此接口要求相对应的时序约束。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> <span class="operator">-</span>period <span class="number">6</span> [get_ports <span class="type">CLKM</span>&#125;</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">CLK_STROBE</span> <span class="operator">-</span>source <span class="type">CLKM</span> \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>divide_by <span class="number">1</span> [get_ports <span class="type">CLK_STROBE</span>]</span><br></pre></td></tr></table></figure>
<p>​ 使用具有多周期路径约束的建立和保持时间检查的组合来指定窗口要求。时序要求映射到必须在单个上升沿（启动和捕获的同一沿）发生的建立时间检查。因此，我们为建立时间指定了一个多周期为 0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">0</span> -setup -<span class="selector-tag">to</span> <span class="selector-attr">[get_ports DATAQ]</span></span><br></pre></td></tr></table></figure>
<p>​ 此外，保持时间检查必须发生在同一边上，因此我们需要为保持时间检查指定 -1（减一）的多周期。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_multicycle_path -<span class="number">1</span> -hold -<span class="selector-tag">to</span> <span class="selector-attr">[get_ports DATAQ]</span></span><br></pre></td></tr></table></figure>
<p>​ 现在指定关于时钟 CLK_STROBE 的输出时序约束。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">set_output_delay -<span class="built_in">max</span> <span class="number">-1.0</span> -<span class="built_in">clock</span> CLK_STROBE [get_ports DATAQ]</span><br><span class="line"></span><br><span class="line">set_output_delay -<span class="built_in">min</span> +<span class="number">2.0</span> -<span class="built_in">clock</span> CLK_STROBE [get_ports DATAQ]</span><br></pre></td></tr></table></figure>
<p>​ 请注意，输出延迟约束指定的最小值大于最大值。之所以存在这种异常，是因为在这种情况下，输出延迟约束与实际逻辑块不对应。与典型输出接口的情况不同，输出延迟约束对应于输出端的逻辑块，源同步接口中的 <strong>set_output_delay</strong> 约束只是一种机制，用于验证输出是否被限制在了时钟有效沿附近的指定窗口内才能切换。因此，我们有最小输出延迟约束大于最大输出延迟约束的异常。</p>
<p>​ 这是指定约束的建立时间时序检查路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193033323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820193108653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，发射边沿和捕获边沿是相同的时钟边沿，即时间 0。报告显示 DATAQ 在 0.61ns 处发生变化，而 CLK_STROBE 在 0.09ns 处发生变化。由于 DATAQ 可以在 CLK_STROBE 的 1ns 内发生变化，因此在考虑 0.3ns 的时钟不确定性后有 0.18ns 的裕量。</p>
<p>​ 这是检查时钟另一侧边界的保持路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193300190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820193337452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 通过最小路径分析，DATAQ 到达时间为0.48ns，而 CLK_STROBE 到达时间为 0.09ns。由于要求数据在 CLK_STROBE 之前最多可以更改 2ns 限制，因此在考虑 50ps 的时钟不确定性后，我们得到 2.35ns 的裕量。</p>
<p>​ 源同步接口的另一个示例如图 9-6 所示。在这种情况下，输出时钟是主时钟的 2 分频，并且是数据同步接口的一部分。 POUT 被限制在 QCLKOUT 之前不早于 2ns 且不晚于 QCLKOUT 之后的 1ns 切换。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193602967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是约束。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">create_clock -<span class="keyword">name</span> CLKM -period <span class="number">6</span> [get_ports CLKM&#125;</span><br><span class="line"></span><br><span class="line">create_generated_clock -<span class="keyword">name</span> QCLKOUT -source CLKM -divide_by <span class="number">2</span> [get_ports QCLKOUT]</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">0</span> -setup -<span class="keyword">to</span> [get_ports POUT]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_multicycle_path -<span class="number">1</span> -hold -<span class="keyword">to</span> [get_ports POUT]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">set_output_delay -max -<span class="number">1.0</span> -clock QCLKOUT [get_ports POUT]</span><br><span class="line"></span><br><span class="line">set_output_delay -min +<span class="number">2.0</span> -clock QCLKOUT [get_ports POUT]</span><br></pre></td></tr></table></figure>
<p>​ 下面是建立时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820193819667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820193910330.png" alt="img"></p>
<p>​ 请注意，多周期约束已将建立时间检查移回一个周期，以便在同一时钟沿执行检查。输出 POUT 在 0.61ns处 变化，而时钟 QCLKOUT 在 0.27ns处 变化。鉴于要求在 1ns 内改变，并考虑 0.30ns 的时钟不确定性，我们得到 0.36ns 的裕量。</p>
<p>​ 这是检查切换窗口上的其他约束的保持路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820194609756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820194811877.png" alt="img"></p>
<p>​ 路径报告显示，数据在 QCLKOUT 时钟边沿之前 2ns 的允许窗口内发生变化，并且存在 2.17ns 的裕量。</p>
<h2 id="sram-接口sram-interface">SRAM 接口（SRAM Interface）</h2>
<p>​ SRAM 接口中的所有数据传输仅在时钟的有效边沿发生。所有信号都由 SRAM 锁存或仅在有效时钟沿由 SRAM 启动。构成 SRAM 接口的信号包括命令、地址和控制输出总线 (CAC)、双向数据总线 (DQ) 和时钟。在写周期中，DUA 将数据写入 SRAM，数据和地址从 DUA 传输到 SRAM，并在有效时钟沿锁存在 SRAM 中。在读周期中，地址信号仍然从 DUA 到 SRAM，而从 SRAM 输出的数据信号到 DUA。因此地址和控制是单向的，从 DUA 到 SRAM，如图 9-7 所示。 <strong>DLL(delay-locked loop延迟锁定环 ）</strong>通常放置在时钟路径中。 DLL 允许延迟时钟（如有必要），以解决由于 PVT 和其他外部变化引起的跨接口的各种信号的延迟变化。通过考虑这些变化，对于往返 SRAM 的读周期和写周期的数据传输都有很好的时序余量。</p>
<p>​ 图 9-8 显示了典型 SRAM 接口的交流特性。请注意，图9-8中的数据输入和数据输出是指SRAM看到的方向。来自SRAM的Data out是DUA的输入，进入SRAM的Data in是DUA的输出。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082021031111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># First define primary clock at the output of UPLL0:</span></span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name PLL_CLK <span class="operator">-</span>period <span class="number">5</span> <span class="punctuation">[</span>get_pins UPLL0<span class="operator">/</span>CLKOUT<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Next define a generated clock at clock output pin of DUA:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name SRAM_CLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source <span class="punctuation">[</span>get_pins UPLL0<span class="operator">/</span>CLKOUT<span class="punctuation">]</span> <span class="operator">-</span>divide_by <span class="number">1</span> <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports SRAM_CLK<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constrain the address and control:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">1.5</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports ADDR<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.5</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports ADDR<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">. . .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Constrain the data going out of DUA:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">1.7</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.8</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constrain the data coming into the DUA:</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">3.2</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="built_in">min</span> <span class="number">1.7</span> <span class="operator">-</span>clock SRAM_CLK <span class="punctuation">[</span>get_ports DQ<span class="punctuation">[</span><span class="number">0</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 这是地址引脚的代表性建立时间路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820211339616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 建立时间检查验证地址信号是否在 SRAM_CLK 边沿之前 1.5ns处（存储器地址引脚的设置时间）到达存储器。</p>
<p>​ 这是同一引脚的保持时间时序路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820211705190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间检查验证地址信号是否在时钟边沿后 0.5ns 内保持稳定。</p>
<h2 id="ddr-sdram-接口ddr-sdram-interface">DDR SDRAM 接口（DDR SDRAM Interface）</h2>
<p>​ DDR SDRAM 接口可以看作是上一节描述的 SRAM 接口的扩展。就像SRAM接口一样，有两条主要的总线。图 9-9 说明了 DUA 和 SDRAM 之间的总线连接和总线方向。第一个总线由命令、地址和控制引脚（通常称为 CAC）组成，使用标准方案在内存时钟的一个时钟沿（或每个时钟周期一次）发送信息。两条双向总线由数据总线 DQ 和数据选通 DQS 组成。 DDR 接口的主要区别在于双向数据选通 DQS。为一组数据信号提供 DQS 选通。这允许数据信号（每字节一个或每半字节一个）与选通信号具有紧密匹配的时序；如果时钟对于整个数据总线是通用的，那么这种紧密匹配对于时钟信号可能是不可行的。双向选通信号 DQS 用于读取和写入操作。选通用于在其两个边沿（下降沿和上升沿或双倍数据速率）上捕获数据。在SDRAM的读模式下，DQ总线源同步于数据选通DQS（而不是存储器时钟），即DQ和DQS从SDRAM发出时是对齐的。在另一个方向，即 DUA 发送数据时，DQS 相移 90 度。请注意，数据 DQ 和选通 DQS 边沿均源自 DUA 内的存储器时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820212024441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如上所述，对于一组 DQ 信号（四位或八位）有一个数据选通 DQS。这样做是为了使 DQ 和 DQS 的所有位之间的偏斜平衡要求更容易。例如，一个字节一个DQS，一组9个信号（8个DQ和一个DQS）需要平衡，这比用时钟平衡72位数据总线要容易得多。</p>
<p>​ 上面的描述不是对 DDR SDRAM 接口的完整解释，尽管足以解释这种接口的时序要求。</p>
<p>​ 图 9-10 显示了典型 DDR SDRAM 接口的 CAC 总线（在 DUA 处）的交流特性。这些建立和保持要求映射到 CAC 总线的以下接口约束。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820212248862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DDRCLK is typically a generated clock of the PLL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clock internal to DUA:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name DDRCLK <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>source <span class="punctuation">[</span>get_pins UPLL0<span class="operator">/</span>CLKOUT<span class="punctuation">]</span><span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line">    <span class="operator">-</span>divide_by <span class="number">1</span> <span class="punctuation">[</span>get_ports DDRCLK<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Set output constraints for each bit of CAC:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.75</span> <span class="operator">-</span>clock DDRCLK <span class="punctuation">[</span>get_ports CAC<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.75</span> <span class="operator">-</span>clock DDRCLK <span class="punctuation">[</span>get_ports CAC<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 在某些情况下，地址总线可能会驱动比时钟大得多的负载，尤其是在与无缓冲存储器模块接口时。在这种情况下，地址信号比时钟信号具有更大的存储器延迟，这种延迟差异可能导致与图 9-10 中描述的不同的 AC 约束。</p>
<p>​ DQS 和 DQ 的对齐对于读和写周期是不同的。这将在以下小节中进一步探讨。</p>
<h3 id="读取周期read-cycle">读取周期（Read Cycle）</h3>
<p>​ 在读周期中，存储器输出的数据与 DQS 边沿对齐。波形如图 9-11 所示；图中的 DQ 和 DQS 代表存储器引脚上的信号。数据 (DQ) 由存储器在 DQS 的每个边沿发出，并且 DQ 转换与 DQS 的下降沿和上升沿边沿对齐。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820213331438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 由于 DQS 选通信号和 DQ 数据信号名义上彼此对齐，因此 DUA 内的存储器控制器通常使用 DLL（或任何替代方法来实现四分之一周期延迟）来延迟 DQS，从而对齐延迟的DQS 边缘与数据有效窗口的中心。</p>
<p>​ 即使 DQ 和 DQS 名义上在内存中对齐，但 DQ 和 DQS 选通信号可能不再在 DUA 内的内存控制器上对齐。这可能是由于 IO 缓冲器之间的延迟差异以及 PCB 互连走线的差异等因素造成的。</p>
<p>​ 图9-12中为基本的数据读取原理图。上升沿触发的触发器在DQS_DLL的上升沿捕获数据DQ，而下降沿触发的触发器在DQS_DLL的下降沿捕获数据DQ。虽然图中的DQ路径上没有DLL，但某些设计可能在数据路径上也会放置一个DLL。这样可以用来延迟信号（以解决由于PVT或互连走线长度或其它差异引起的变化），以便可以在数据有效窗口的中间准确地采样数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820213548856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 为了约束控制器上的读取接口，在 DQS 上定义了一个时钟，并在与时钟相关的数据上指定了输入延迟。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">5</span> -name DQS <span class="selector-attr">[get_ports DQS]</span></span><br></pre></td></tr></table></figure>
<p>​ 这假设内存读取接口以 200 MHz 运行（相当于 400 Mbps，因为数据在两个时钟边沿传输），并且对应于每 2.5ns 采样一次的 DQ 信号。由于数据是在两条边上捕获的，因此需要为每条边明确指定输入约束。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For rising clock edge:</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">0.4</span> <span class="operator">-</span><span class="built_in">max</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="number">0.4</span> <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is with respect to clock rising edge (default).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Similarly for falling edge:</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="number">0.35</span> <span class="operator">-</span><span class="built_in">max</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_input_delay <span class="operator">-</span><span class="number">0.35</span> <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The launch and capture are on the same edge:</span></span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">0</span> <span class="operator">-</span>setup <span class="operator">-</span>to UFF0<span class="operator">/</span>D</span><br><span class="line"></span><br><span class="line">set_multicycle_path <span class="number">0</span> <span class="operator">-</span>setup <span class="operator">-</span>to UFF5<span class="operator">/</span>D</span><br></pre></td></tr></table></figure>
<p>​ 输入延迟命令指定了DUA引脚上DQ和DQS沿之间的延迟差，即使这两个信号通常是从存储器中同时输出的，但由于不同存储器的规格，在时序上仍会存在偏差。因此，DUA内的控制器设计应考虑到两个信号之间可能存在偏斜（skew）。以下是两个触发器建立时间检查的路径报告。假设捕获触发器的建立时间要求为0.05ns、保持时间要求为0.03ns，且DLL延迟设置为1.25ns，即四分之一周期 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820214821164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820214852999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820214916862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215011788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2021082021504258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h3 id="写周期write-cycle">写周期（Write Cycle）</h3>
<p>​ 在写周期中，DQS 边沿与来自 DUA 内的存储器控制器的 DQ 信号有四分之一周期的偏移，因此 DQS 选通可用于捕获存储器中的数据。</p>
<p>​ 图9-13显示了存储器引脚上所需的波形，在存储器引脚处，DQS信号必须与DQ数据窗口的中心对齐。请注意，仍然是由于IO缓冲器延迟不匹配或者PCB互连走线的变化，仅在存储控制器（DUA内部）中对齐DQ和DQS还不足以使这些信号在SDRAM存储器引脚处真正的对齐。因此，DUA通常在写周期中使用额外的DLL去进行控制，以实现DQS和DQ信号之间所需的四分之一周期偏移（offset）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215207808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 约束此模式的输出取决于在控制器中生成时钟的方式。我们考虑两种情况。</p>
<p><strong>情况 1：内部 2x 时钟（Case 1: Internal 2x Clock）</strong></p>
<p>​ 如果有两倍于 DDR 时钟频率的内部时钟可用，则输出逻辑可以类似于图 9-14 中所示的逻辑。 DLL 提供了一种机制，可在必要时偏移 DQS 时钟，以便满足存储器引脚上的建立和保持要求。在某些情况下，可能不使用 DLL - 而是使用负沿触发器来获得 90 度偏移。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215347243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 对于图 9-14 所示的场景，输出可以被约束为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 166MHz (333Mbps) DDR; 2x clock is at 333MHz:</span></span><br><span class="line"></span><br><span class="line">create_clock -period 3 [get_ports CLK2X]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a 1x generated clock at the output of flip-flop:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name pre_DQS -<span class="built_in">source</span> CLK2X \</span><br><span class="line"></span><br><span class="line">-divide_by 2 [get_pins UFF1/Q]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the delayed version as DQS assuming 1.5ns DLL delay:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock -name DQS -<span class="built_in">source</span> UFF1/Q \</span><br><span class="line"></span><br><span class="line">-edges &#123;1 2 3&#125; -edge_shift &#123;1.5 1.5 1.5&#125; [get_ports DQS]</span><br></pre></td></tr></table></figure>
<p>​ DQ 输出引脚的时序必须相对于生成的时钟 DQS 进行约束。</p>
<p>​ 假设DDR SDRAM的DQ和DQS管脚之间的设置要求分别为DQ的上升沿和下降沿为0.25ns和0.4ns。同样，假设 DQ 引脚的上升沿和下降沿需要 0.15ns 和 0.2ns 的保持时间。 DQS 输出的 DLL 延迟已设置为四分之一周期，即 1.5ns。波形如图 9-15 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820215528622.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.25</span> <span class="operator">-</span>rise <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default above is rising clock.</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.4</span> <span class="operator">-</span>fall <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If setup requirements are different for falling edge of DQS,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># that can be specified by using the -clock_fall option.</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.15</span> <span class="operator">-</span>rise DQ</span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span>clock DQS <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.2</span> <span class="operator">-</span>fall DQ</span><br></pre></td></tr></table></figure>
<p>​ 这是通过输出 DQ 的建立时间报告。建立时间检查是从 0ns 时 CLK2X 的上升沿开始，在 1.5ns 时启动 DQ 到 DQS 的上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082021565414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，上述报告中的四分之一周期延迟出现在了时钟DQS上升沿的第一行中，而不是在DLL实例UDLL0的那行中。这是因为DLL延迟已被建模为了衍生时钟DQS定义的一部分，而不是DLL时序弧中的一部分。</p>
<p>​ 以下是通过输出DQ路径的保持时间检查报告。保持时间检查从3ns处发起DQ的时钟CLK2X上升沿到1.5ns处的DQS前一个上升沿。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082021572331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>情况 2：内部 1x 时钟（Case 2: Internal 1x Clock）</strong></p>
<p>​ 当只有内部 1x 时钟可用时，输出电路通常类似于图 9-16 中所示的电路。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820220343806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 有两个触发器用于生成 DQ 数据。第一个触发器NEGEDGE_REG由时钟CLK1X的负沿触发，第二个触发器POSEDGE_REG由时钟CLK1X的正沿触发。每个触发器锁存适当的边沿数据，然后使用 CLK1X 作为多路复用器选择多路复用输出该数据。当 CLK1X 为高电平时，触发器 NEGEDGE_REG 的输出被送到 DQ。当 CLK1X 为低电平时，触发器 POSEDGE_REG 的输出被送到 DQ。因此，数据在时钟 CLK1X 的两个边沿到达输出 DQ。请注意，每个触发器都有半个周期将数据传播到多路复用器的输入，以便输入数据在被 CLK1X 边沿选择之前在多路复用器处准备就绪。相关波形如图 9-17 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082022045226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create the 1x clock:</span></span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name CLK1X <span class="operator">-</span>period <span class="number">6</span> <span class="punctuation">[</span>get_ports CLK1X<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a generated clock at DQS. It is a divide-by-1 of</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CLK1X. Assume a quarter-cycle delay of 1.5ns on UDLL0:</span></span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name DQS <span class="operator">-</span>source CLK1X <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>edges <span class="punctuation">&#123;</span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span><span class="punctuation">&#125;</span> <span class="operator">-</span>edge_shift <span class="punctuation">&#123;</span><span class="number">1.5</span> <span class="number">1.5</span> <span class="number">1.5</span><span class="punctuation">&#125;</span> <span class="punctuation">[</span>get_ports DQS<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a setup check of 0.25 and 0.3 between DQ and DQS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pins on rising and falling edge of clock:</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.25</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">max</span> <span class="number">0.3</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.2</span> <span class="operator">-</span>clock DQS <span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">set_output_delay <span class="operator">-</span><span class="built_in">min</span> <span class="operator">-</span><span class="number">0.27</span> <span class="operator">-</span>clock DQS <span class="operator">-</span>clock_fall <span class="punctuation">\</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span>get_ports DQ<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​ 建立和保持检查验证从多路复用器到输出的时序。设置检查之一是从多路复用器输入处的 CLK1X 上升沿（启动 NEGEDGE_REG 数据）到 DQS 的上升沿。另一个设置检查是从多路复用器输入（启动 POSEDGE_REG 数据）处的 CLK1X 下降沿到 DQS 的下降沿。类似地，保持检查是从相同的 CLK1X 边沿（如设置检查）到 DQS 的前一个下降沿或上升沿。</p>
<p>​ 这是通过端口 DQ 的建立时间检查报告。检查在选择 NEGEDGE_REG 输出的 CLK1X 的上升沿和 DQS 的上升沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221033546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820221110528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820221144131.png" alt="img"></p>
<p>​ 这是通过端口 DQ 的另一个设置时序检查报告。此设置检查在选择 POSEDGE_REG 输出的 CLK1X 下降沿和 DQS 下降沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221236695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是通过端口 DQ 的保持时间检查报告。检查在 CLK1X 的上升沿和 DQS 的前一个下降沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221347904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 这是通过端口 DQ 的另一个保持时序检查报告。该检查在 CLK1X 的下降沿和 DQS 的前一个上升沿之间进行。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221446443.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210820221515820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 虽然上述接口时序分析忽略了任何负载对输出的影响，但可以指定额外的负载（使用 set_load）以获得更高的准确性。然而，STA 可以通过电路模拟来补充，以实现如下所述的稳健 DRAM 时序。</p>
<p>​ DDR 接口的 DQ 和 DQS 信号通常在读取和写入模式下使用 ODT（On-Die Termination），以减少由于 DRAM 和 DUA 的阻抗不匹配引起的任何反射。存在 ODT 终端时，用于 STA 的时序模型无法提供足够的精度。设计人员可以使用另一种机制，例如详细的电路级模拟来验证 DRAM 接口的信号完整性和时序。</p>
<h2 id="视频-dac-接口interface-to-a-video-dac">视频 DAC 接口（Interface to a Video DAC）</h2>
<p>​ 考虑图 9-18，它显示了一个典型的 DAC（Digital to Analog Converter）接口，其中高速时钟正在将数据传输到 DAC 的低速时钟接口。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820221750364.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 时钟 DAC_CLK 是时钟 XPLL_CLK 的 2 分频。 DAC 建立和保持检查与 DAC_CLK 的下降沿有关。</p>
<p>​ 在这种情况下，建立时间被视为单周期 (XPLL_CLK) 路径，即使从较快时钟域到较慢时钟域的接口可以在必要时指定为多周期路径。如图 9-18 所示，XPLL_CLK 的上升沿发射数据，DAC_CLK 的下降沿捕获数据。这是建立时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/2021082022194144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 请注意，接口是从较快的时钟到较慢的时钟，因此如有必要，可以将其设置为双周期路径。</p>
<p>​ 这是保持时间报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820222044800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 保持时间检查是在建立时间捕获沿之前一个周期完成的。在这种接口情况下，最关键的保持时间检查是在发起沿和捕获沿重合处执行的，这显示在保持时序报告中。</p>
<h1 id="稳健验证robust-verification">稳健验证（Robust Verification）</h1>
<blockquote>
<p>​ 本章描述了特殊的 STA 分析，例如时间借用（ time borrowing）、时钟门控（clock gating）和非顺序时序检查（non-sequential timing checks）。此外，还介绍了先进的 STA 概念，例如片上变化（on-chip variation）、统计时序（statistical timing analysis）以及功率与时序之间的权衡。</p>
</blockquote>
<h2 id="片上变化on-chip-variations">片上变化（On-Chip Variations）</h2>
<p>​ 通常，工艺和各环境参数在芯片的不同部分上可能不一致。由于工艺差异，芯片上不同部分的相同MOS晶体管可能没有相似的特性，这些差异是由于芯片内部的工艺差异引起的。请注意，多个制造批次中的工艺参数差异可能会覆盖慢工艺到快工艺（2.10节中所介绍）。在本节中，我们讨论的是对一个芯片上可能存在的工艺差异（称为<strong>局部工艺差异local process variations</strong>）的分析，该差异远小于多个制造批次之间的差异（称为<strong>全局工艺差异 global process variations</strong>）。</p>
<p>​ 除了工艺参数的变化，设计的不同部分也可能会遇到不同的电源电压和温度。因此，同一芯片的两个区域可能不处于相同的 PVT 条件。这些差异可能由许多因素引起，包括：</p>
<ul>
<li>会影响局部电源电压的沿芯片区域的IR压降变化</li>
<li>PMOS或NMOS器件的电压阈值变化</li>
<li>PMOS或NMOS器件的沟道长度变化</li>
<li>由于局部热点造成的温度变化</li>
<li>互连金属刻蚀或厚度变化会影响互连电阻或电容</li>
</ul>
<p>​ 上述 PVT 变化被称为片上变化 (<strong>On-Chip Variations，OCV</strong>)，这些变化会影响芯片不同部分的线延迟和单元延迟。如上所述，OCV 的建模并不是要对晶片与晶片之间可能的 PVT 变化的整个范围进行建模，而是要对单个管芯内局部可能的 PVT 变化进行建模。 OCV 效应通常在时钟路径上更明显，因为它们在芯片中行进的距离更长。考虑局部 PVT 变化的一种方法是在 STA 期间合并 OCV 分析。前几章中描述的静态时序分析是在特定<strong>时序角（timing corner）</strong>获得时序，而不是对沿芯片的变化进行建模。由于 OCV 对时钟和数据路径的影响可能不同，时序验证可以通过使发射和捕获路径的 PVT 条件略有不同来模拟 OCV 效应。 STA 可以通过<strong>降额（derate）</strong>特定路径的延迟来包含 OCV 效应，也就是说，通过使这些路径更快或更慢，然后使用这些变化来验证设计的行为。单元延迟或线延迟或两者都可以降额以模拟 OCV 的影响。</p>
<p>​ 我们现在检查 OCV 降额是如何进行建立时间检查的。考虑图 10-1 中所示的逻辑，其中 PVT 条件可以随芯片变化。当启动时钟路径和数据路径具有导致最大延迟的 OCV 条件，而捕获时钟路径具有导致最小延迟的 OCV 条件时，建立时间检查的最差条件发生。请注意，这里的最小和最大是由于裸片上的局部 PVT 变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210820223333186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>对于此示例，以下是建立时间检查，注意此处还不包括任何用于降额延迟的OCV设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LaunchClockPath <span class="operator">+</span> MaxDataPath <span class="operator">&lt;=</span> ClockPeriod <span class="operator">+</span> CaptureClockPath <span class="operator">-</span> Tsetup_UFF1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">This implies that the minimum clock <span class="keyword">period</span> <span class="operator">=</span> </span><br><span class="line"></span><br><span class="line">        LaunchClockPath <span class="operator">+</span> MaxDataPath <span class="operator">-</span> CaptureClockPath <span class="operator">+</span> Tsetup_UFF1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">From</span> the figure,</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LaunchClockPath <span class="operator">=</span> <span class="number">1.2</span> <span class="operator">+</span> <span class="number">0.8</span> <span class="operator">=</span> <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">MaxDataPath <span class="operator">=</span> <span class="number">5.2</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">CaptureClockPath <span class="operator">=</span> <span class="number">1.2</span> <span class="operator">+</span> <span class="number">0.86</span> <span class="operator">=</span> <span class="number">2.06</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Tsetup_UFF1 <span class="operator">=</span> <span class="number">0.35</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">This results <span class="keyword">in</span> a minimum clock <span class="keyword">period</span> <span class="keyword">of</span>:</span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span> <span class="operator">+</span> <span class="number">5.2</span> – <span class="number">2.06</span> <span class="operator">+</span> <span class="number">0.35</span> <span class="operator">=</span> <span class="number">5.49</span>ns</span><br></pre></td></tr></table></figure>
<p>​ 上述路径延迟对应于没有任何 OCV 降额的延迟值。可以使用 set_timing_derate 规范来降低单元和网络延迟。例如，命令：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<p>​ 上述命令将最小/最短/最早路径的延迟降低了20％，并将最大/最长/最迟路径的延迟增加了10％。长路径的延迟（例如，用于建立时间检查的数据路径和发起时钟路径或用于保持时间检查的捕获时钟路径）将乘以使用<strong>-late</strong>选项指定的降额值，而短路径的延迟（例如，用于建立时间检查的捕获时钟路径或用于保持时间检查的数据路径和发起时钟路径）将乘以使用<strong>-early</strong>选项指定的降额值。如果未指定降额系数，则假定值为1.0。</p>
<p>​ 降额系数将统一应用于所有网络延迟和单元延迟，如果某个应用场景中需要保证单元和网络的降额系数不同，则可以在<strong>set_timing_derate</strong>命令中使用<strong>-cell_delay</strong>和<strong>-net_delay</strong>选项。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Derate only the cell delays - early paths by -10%, and</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no derate on the late paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -cell_delay -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -cell_delay -late <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Derate only the net delays - no derate on the early paths</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># and derate the late paths by +20%:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -net_delay -early <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -net_delay -late <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>​ 可以使用<strong>-cell_check</strong>选项来对单元检查（例如建立时间和保持时间）的延迟进行降额。使用此选项时，使用<strong>set_output_delay</strong>指定的任何输出延迟也将被降额，因为此约束也是输出建立时间要求的一部分。但是，对于使用<strong>set_input_delay</strong>指定的输入延迟，是不会被降额的。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Derate the cell timing check values:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.8</span> -cell_check</span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.1</span> -cell_check</span><br><span class="line"></span><br><span class="line"><span class="comment"># Derate the early clock paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.95</span> -clock</span><br><span class="line"></span><br><span class="line"><span class="comment"># Derate the late data paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.05</span> -data</span><br></pre></td></tr></table></figure>
<p>​ <strong>-clock</strong>选项仅将降额应用于时钟路径。同样，<strong>-data</strong>选项仅将降额应用于数据路径。</p>
<p>​ 我们现在将以下降额应用于图 10-1 的示例。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.1</span> -cell_check</span><br><span class="line">使用这些降额值，我们得到以下建立时间检查的结果：</span><br><span class="line"></span><br><span class="line">LaunchClockPath = <span class="number">2.0</span> * <span class="number">1.2</span> = <span class="number">2.4</span></span><br><span class="line"></span><br><span class="line">MaxDataPath = <span class="number">5.2</span> * <span class="number">1.2</span> = <span class="number">6.24</span></span><br><span class="line"></span><br><span class="line">CaptureClockPath = <span class="number">2.06</span> * <span class="number">0.9</span> = <span class="number">1.854</span></span><br><span class="line"></span><br><span class="line">Tsetup_UFF1 = <span class="number">0.35</span> * <span class="number">1.1</span> = <span class="number">0.385</span></span><br><span class="line"></span><br><span class="line">最小时钟周期为</span><br><span class="line"></span><br><span class="line"><span class="number">2.4</span> + <span class="number">6.24</span> – <span class="number">1.854</span> + <span class="number">0.385</span> = <span class="number">7.171</span>ns</span><br></pre></td></tr></table></figure>
<p>​ 在上面的建立时间检查中，存在差异，因为时钟树的公共时钟路径（图 10-1）具有 1.2ns 的延迟，对于启动时钟和捕获时钟的降额不同。时钟树的这一部分对启动时钟和捕获时钟都是通用的，不应以不同的方式降额。对启动和捕获时钟应用不同的降额过于悲观，因为实际上时钟树的这一部分将真正处于一个 PVT 条件下，要么作为最大路径，要么作为最小路径（或介于两者之间），但永远不会同时处于同时。对时钟树公共部分应用不同降额因子引起的悲观情绪称为<strong>公共路径悲观情绪（Common Path Pessimism，CPP）</strong>，在分析过程中应将其去除。 CPPR 代表 <strong>Common Path Pessimism Removal</strong>，通常在路径报告中作为单独的项目列出。它也被标记为<strong>时钟重新收敛悲观消除</strong>（ <strong>Clock Reconvergence Pessimism Removal，CRPR）</strong>。</p>
<p>​ CPPR 是在时序分析中去除启动时钟路径和捕获时钟路径之间人为引起的悲观情绪。如果相同的时钟同时驱动捕获和启动触发器，那么时钟树可能会在分支之前共享一个公共部分。由于启动和捕获时钟路径的降额不同，CPP 本身就是沿时钟树的这个公共部分的延迟差异。时钟信号在公共点的最小和最大到达时间之间的差值是 CPP。<strong>公共点（ common point）</strong>定义为时钟树公共部分中最后一个单元的输出引脚。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">CPP</span> = <span class="title class_">LatestArrivalTime</span><span class="meta">@CommonPoint</span> – <span class="title class_">EarliestArrivalTime</span><span class="meta">@CommonPoint</span></span><br></pre></td></tr></table></figure>
<p>​ 上述分析中的“最晚时间”和“最早时间”是指在特定工艺角（Corner）下的OCV降额值，例如最坏情况下的慢速（Worst-Case-Slow）或最佳情况下的快速（Best-Case-Fast）。对于图10-1的示例：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">LatestArrivalTime<span class="keyword">@CommonPoint</span> = <span class="number">1.2</span> * <span class="number">1.2</span> = <span class="number">1.44</span></span><br><span class="line"></span><br><span class="line">EarliestArrivalTime<span class="keyword">@CommonPoint</span> = <span class="number">1.2</span> * <span class="number">0.9</span> = <span class="number">1.08</span></span><br><span class="line"></span><br><span class="line">This implies a CPP <span class="attribute">of</span>: <span class="number">1.44</span> - <span class="number">1.08</span> = <span class="number">0.36</span>ns</span><br><span class="line"></span><br><span class="line">With the CPP correction, this results in a</span><br><span class="line"></span><br><span class="line">minimum clock period <span class="attribute">of</span>: <span class="number">7.171</span> - <span class="number">0.36</span> = <span class="number">6.811</span>ns</span><br></pre></td></tr></table></figure>
<p>​ 应用OCV降额将本示例设计的最小时钟周期从5.49ns增加到6.811ns。这说明，由这些降额系数模拟的OCV变化可降低设计的最大运行频率。</p>
<p><strong>在最坏 PVT 条件下使用 OCV 进行分析（Analysis with OCV at Worst PVT Condition）</strong></p>
<p>​ 如果在最坏的 PVT 条件下执行建立时序检查，则不需要对后期路径进行降额，因为它们已经是最差的。但是，可以通过使用特定的降额来使这些路径更快，例如，将早期路径加速 10%，从而将降额应用于早期路径。在最坏情况下慢速corner的降额约束可能类似于：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don’t derate the late paths as they are already the slowest,</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># but derate the early paths to make these faster by 10%.</span></span><br></pre></td></tr></table></figure>
<p>​ 上述降额设置用于最坏情况慢速角的最大路径（或setup）检查；因此，后期路径 OCV 降额设置保持在 1.0，以免使其减速超过最坏情况的慢速转角。</p>
<p>​ 下面描述了在最坏情况下慢转角的setup时序检查示例。为以下捕获时钟路径指定了降额约束：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Derate the early clock paths:</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.8</span> -clock</span><br></pre></td></tr></table></figure>
<p>​ 以下是在最坏情况下的慢角执行的setup时序检查路径报告。延迟路径使用的降额报告为Max Data Paths Derating Factor 和 Max Clock Paths Derating Factor。</p>
<p>​ 用于早期路径的降额报告为Min Clock Paths Derating Factor（最小时钟路径降额因子）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828114206571.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，捕获时钟路径降额了 20%。请参阅时序报告中的单元 UCKBUF0。在发射路径中，它具有 56ps 的延迟，而在捕获路径中具有 45ps 的降额延迟。单元 UCKBUF0 在公共时钟路径上，即在捕获时钟路径和启动时钟路径上。由于公共时钟路径不能有不同的降额，因此该公共路径的时序差异 56ps - 45ps = 11ps 将单独校正。这在报告中表现为线路clock reconvergence pessimism。总之，如果要比较这条路径的报告，有和没有降额，人们会注意到只有捕获时钟路径的单元和网络延迟被降额了。</p>
<p><strong>OCV 用于保持检查（OCV for Hold Checks）</strong></p>
<p>​ 我们现在检查如何进行降额以进行保持时序检查。考虑图 10-2 所示的逻辑。如果沿芯片的 PVT 条件不同，当启动时钟路径和数据路径具有导致最小延迟的 OCV 条件时，即当我们有最早的启动时钟时，保持检查的最坏条件发生，并且捕获时钟路径具有导致最大延迟的 OCV 条件，即具有最新的捕获时钟。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828114915472.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对于此示例，在以下表达式中指定了保持时序检查 ：</p>
<p><embed src="https://latex.codecogs.com/gif.latex?LaunchClockPath%20+%20MinDataPath%20-CaptureClockPath%20-TholdUFF1%20%3E%3D%200"></p>
<p>​ 将图 10-2 中的延迟值应用于表达式，我们得到（不应用任何降额）：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?LaunchClockPath%20%3D%200.25%20+%200.6%20%3D%200.85"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?MinDataPath%20%3D%201.7"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?CaptureClockPath%20%3D%200.25%20+%200.75%20%3D%201.00"></p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?TholdUFF1%20%3D%201.25"></p>
<p>​ 这意味着条件是：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?0.85%20+%201.7%20-%201.00%20-%201.25%20%3D%200.3n%20%3E%3D0"></p>
<p>​ 这是真的，因此不存在保持违规。</p>
<p>​ 应用以下降额约束：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -<span class="keyword">late</span> <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -early <span class="number">0.95</span> -cell_check</span><br></pre></td></tr></table></figure>
<p>​ 可以得到</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">LaunchClockPath = 0.85 <span class="emphasis">* 0.9 = 0.765</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">MinDataPath = 1.7 *</span> 0.9 = 1.53</span><br><span class="line"></span><br><span class="line">CaptureClockPath = 1.00 <span class="emphasis">* 1.2 = 1.2</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Thold_UFF1 = 1.25 *</span> 0.95 = 1.1875</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Common clock path pessimism: 0.25 <span class="emphasis">* (1.2 - 0.9) = 0.075</span></span><br></pre></td></tr></table></figure>
<p>​ 通过对启动和捕获时钟路径的公共时钟树应用降额而产生的公共时钟路径悲观情绪也被移除以进行保持时序检查。然后保持检查条件变为：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?0.765%20+%201.53%20-1.2%20-%201.1875%20+%200.075%20%3D%20-0.0175ns"></p>
<p>​ 它小于 0，因此表明存在违反保持的情况，将 OCV 降额因子应用于早期和晚期路径。</p>
<p>​ 通常，保持时序检查在最佳情况下的快速 PVT corner执行。在这种情况下，不需要对早期路径进行降容，因为这些路径已经是最早的可能。但是，可以通过将延迟路径降低特定的降额因子来对延迟路径应用降额，例如，将延迟路径减慢 20%。这个corner的降额约束将类似于：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_timing_derate -early <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">set_timing_derate -late <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don’t derate the early paths as they are already the</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastest, but derate the late paths slower by 20%.</span></span><br></pre></td></tr></table></figure>
<p>​ 在图10-2例子中，</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">LatestArrivalTime<span class="variable">@CommonPoint</span> = <span class="number">0.25</span> * <span class="number">1.2</span> = <span class="number">0.30</span></span><br><span class="line"></span><br><span class="line">EarliestArrivalTime<span class="variable">@CommonPoint</span> = <span class="number">0.25</span> * <span class="number">1.0</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>​ 这意味着一个共同的路径悲观性：</p>
<p>​ <embed src="https://latex.codecogs.com/gif.latex?0.30%20-%200.25%20%3D%200.05ns"></p>
<p>​ 以下是使用此降额的示例设计的保持时序检查路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828120250589.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，后期路径的额定值降低了 20%，而早期的路径并未降低额定值。请参阅单元格 UCKBUF0。它在发射路径上的延迟为 56ps，而在捕获路径上的延迟为 67ps - 降额了 20%。 UCKBUF0是公共时钟树上的单元，因此该公共时钟树上因不同降额引入的悲观情绪为，67ps - 56ps = 11ps，在线clock reconvergence pessimism中单独考虑。</p>
<h2 id="时间借用time-borrowing">时间借用（Time Borrowing）</h2>
<p>​ 时间借用（ <strong>time borrowing</strong>）技术，也称为<strong>cycle stealing</strong>，发生在锁存器上。在锁存器中，时钟的一个边沿使锁存器透明，也就是说，它打开锁存器，使锁存器的输出与数据输入相同；这个时钟边缘称为开启边沿（ <strong>opening edge</strong>）。时钟的第二个边沿关闭锁存器，即数据输入上的任何更改在锁存器的输出端不再可用；此时钟边沿称为闭合边沿（ <strong>closing edge</strong>）。</p>
<p>​ 通常，数据应该在时钟的有效边沿之前在锁存输入端准备就绪。然而，由于锁存器在时钟有效时是透明的，因此数据到达的时间可能晚于有效时钟边沿，也就是说，它可以从下一个周期借用时间。如果借用了这样的时间，则可用于下一阶段(锁存到另一顺序单元)的时间减少。</p>
<p>​ 图10-3显示了使用主动上升沿借用时间的示例。如果数据DIN在10 ns的CLK上升沿上的锁存器打开之前的时间A准备就绪，则数据在锁存器打开时流向锁存器的输出。如果数据如DIN(延迟)所示在时间B到达，则借用时间Tb。然而，这减少了从锁存器到下一个触发器UFF2的可用时间-而不是整个时钟周期，只有时间Ta可用。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828121452541.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 锁存器时序的第一条规则是，如果数据在锁存器的开启边缘之前到达，则行为建模与触发器完全相同。起始边沿捕获数据，相同的时钟边沿启动数据作为下一条路径的起始点。</p>
<p>​ 第二个规则适用于数据信号到达时，而锁存器是透明的(在开口和闭合边缘之间)。锁存器的输出，而不是时钟引脚，被用作下一级的启动点。在锁存器结束的路径借用的时间量决定了下一阶段的启动时间。</p>
<p>​ 在锁存器的闭合沿之后到达的数据信号是时序冲突。图10-4显示了positive slack, zero slack, 和negative slack (即发生违规时)的数据到达时序区域。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828121743872.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828121905272.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-5(A)显示了具有通向下一级触发器的半周期路径的锁存器的使用。图10-5(B)描述了借用时间场景的波形。时钟周期为10 ns。数据由UFF0在时间0启动，但数据路径需要7 ns。锁闩ULAT1以5 ns的速度打开。因此，从路径ULAT1到UFF1借用2 ns。ULAT1到UFF1路径的可用时间仅为3 ns(5 ns-2 ns)。</p>
<p>​ 接下来，我们将为图10-5(A)中的锁存示例描述三组时序报告，以说明从下一阶段借用的不同时间量。</p>
<p><strong>没有借用时间的示例（Example with No Time Borrowed）</strong></p>
<p>​ 以下是从触发器UFF0到锁存器ULAT1的数据路径延迟小于5 ns时的setup路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828122232374.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828122341479.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828122505588.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 在这种情况下，不需要借用，因为数据在锁存器打开之前及时到达锁存器ULAT1。</p>
<p><strong>有借用时间的示例（Example with Time Borrowed）</strong></p>
<p>​ 下面的路径报告显示了从触发器UFF0到锁存器ULAT1的数据路径延迟大于5 ns的情况。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828123718576.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828123759594.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 在这种情况下，由于在锁存器透明的同时数据变为可用，因此从后续路径借用所需的1.81 ns的延迟，并且仍然满足定时。下面是后续路径的路径报告，显示前一路径已经借用了1.81 ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828124500967.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>有时序违规的示例（Example with Timing Violation）</strong></p>
<p>​ 在这种情况下，数据路径延迟要大得多，只有在锁存器关闭后数据才可用。这显然是timing violation</p>
<p><img src="https://img-blog.csdnimg.cn/20210828124940278.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828125407421.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828125449516.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="数据到数据检查data-to-data-checks">数据到数据检查（Data to Data Checks）</h2>
<p>​ setup和hold检查也可以在任意两个数据引脚之间应用，这两个引脚都不是时钟。一个管脚是约束管脚（ <strong>constrained pin</strong>），其作用类似于触发器的数据管脚，第二个管脚是相关管脚（<strong>related pin</strong>），其作用类似于触发器的时钟管脚。关于触发器的setup检查的一个重要区别在于，数据到数据setup检查在与启动边沿相同的边沿上执行(与触发器的正常setup检查不同，在触发器的正常setup检查中，捕获时钟边沿通常与启动时钟边沿相差一个周期)。因此，数据到数据setup检查也称为 <strong>zero-cycle checks</strong>或 <strong>same-cycle checks</strong>。</p>
<p>​ 使用 <strong>set_data_check</strong> 约束指定数据到数据检查。以下是 SDC 约束示例。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_data_check -<span class="selector-tag">from</span> SDA -<span class="selector-tag">to</span> SCTRL -setup <span class="number">2.1</span></span><br><span class="line"></span><br><span class="line">set_data_check -<span class="selector-tag">from</span> SDA -<span class="selector-tag">to</span> SCTRL -hold <span class="number">1.5</span></span><br></pre></td></tr></table></figure>
<p>​ 参见图 10-6。 SDA 是<strong>related pin</strong>，SCTRL 是 <strong>constrained pin</strong>。setup数据检查意味着 SCTRL 应在相关引脚 SDA 的边缘之前至少 2.1ns 到达。否则它是数据到数据setup检查违规。hold数据检查指定 SCTRL 应在 SDA 之后至少 1.5ns 到达。如果约束信号早于此约束到达，则它是数据到数据hold检查违规。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828130442153.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这种检查在 custom-designed block 中很有用，在这种情况下，可能需要提供一个信号相对于另一个信号的特定到达时间。一种常见的情况是数据信号被使能信号门控，当数据信号到达时，需要保证使能信号稳定。</p>
<p>​ 考虑图 10-7 中所示的 and 单元格。我们假设要求是确保 PNA 在 PREAD 上升沿之前 1.8ns 到达，并且在 PREAD 上升沿之后的 1.0ns 内不应改变。在本例中，PNA 是 <strong>constrained pin</strong>，PREAD 是<strong>related pin</strong>。所需的波形如图 10-7 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828130725350.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 可以使用数据到数据建立和保持检查来指定这样的要求。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_data_check -<span class="selector-tag">from</span> UAND0/A1 -<span class="selector-tag">to</span> UAND0/A2 -setup <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">set_data_check -<span class="selector-tag">from</span> UAND0/A1 -<span class="selector-tag">to</span> UAND0/A2 -hold <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>​ 这是setup报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828131153755.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ setup时间在报告中指定为data check setup time。失败的报告表明 PREAD 需要至少延迟 1.72ns，以确保 PENA 在 PREAD 之前 1.8ns 到达——这是我们的要求</p>
<p>​ 数据到数据setup检查的一个重要方面是，启动<strong>constrained pin</strong>和<strong>related pin</strong>的时钟边沿来自相同的时钟周期（也称为same-cycle checks）。因此，请注意报告中捕获沿 (UDFF0/CK) 的开始时间为 0ns，而不是像setup报告中通常看到的那样晚一个周期。</p>
<p>​ zero-cycle setup check导致保持时序检查与其他保持检查报告不同 - 保持检查不再在同一时钟沿上。下面是用于保持路径报告的 CLKPLL 的时钟约束。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKPLL</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKPLL</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210828132551788.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828132628336.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，用于启动<strong>related pin</strong>以进行保持检查的时钟沿比 <strong>constrained pin</strong>的启动沿早一个周期。这是因为根据定义，保持检查通常在建立捕获沿之前的一个周期执行。由于<strong>constrained pin</strong>和<strong>related pin</strong>的时钟沿对于数据到数据setup检查是相同的，因此保持检查在启动沿前一个周期完成。</p>
<p>​ 在某些情况下，设计人员可能需要在同一时钟周期内执行数据到数据保持检查。相同的周期保持要求意味着将用于<strong>related pin</strong>的时钟沿移回受<strong>constrained pin</strong>的时钟沿所在的位置。这可以通过指定 -1 的多周期来实现。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">set_multicycle_path -<span class="number">1</span> -hold -<span class="keyword">to</span> UAND0/A2</span><br></pre></td></tr></table></figure>
<p>​ 以下是具有此多周期约束的上述示例的保持时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828133043530.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210828133122590.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 现在，对constrained pin 和 the related pin使用相同的时钟沿执行保持检查。在同一周期中执行数据到数据保持检查的另一种方法是将其指定为反向引脚之间的数据到数据setup检查。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">set_data_check -<span class="selector-tag">from</span> UAND0/A2 -<span class="selector-tag">to</span> UAND0/A1 -setup <span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>​ 数据到数据检查在定义<strong>no-change data check</strong>时也很有用。这是通过在上升沿指定setup检查和在下降沿指定保持检查来完成的，以便有效定义不变窗口。如图 10-8 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210828133421644.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 以下是此方案的约束：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">set_data_check -rise_from D2 -<span class="keyword">to</span> D1 -setup <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line">set_data_check -fall_from D2 -<span class="keyword">to</span> D1 -hold <span class="number">0.8</span></span><br></pre></td></tr></table></figure>
<h2 id="非顺序检查non-sequential-checks">非顺序检查（Non-Sequential Checks）</h2>
<p>​ 单元或宏的（cell 和 macro）库文件可以将时序弧指定为非顺序检查（non-sequential check），例如两个数据引脚之间的时序弧。非顺序检查是两个引脚之间的检查，这两个引脚都不是时钟。一个引脚是constrained pin，其作用类似于数据，而第二个引脚是related pin，其作用类似于时钟。该检查指定在related pin上发生变化之前和之后，constrained pin上的数据必须保持稳定多长时间。</p>
<p>​ 请注意，此检查被指定为单元库约束的一部分，并且不需要显式数据到数据检查约束。以下是这样的时间弧如何出现在单元库中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">pin (WEN) &#123;</span><br><span class="line"></span><br><span class="line">    timing () &#123;</span><br><span class="line"></span><br><span class="line">    timing_type: non_seq_setup_rising;</span><br><span class="line"></span><br><span class="line">    intrinsic_rise: <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">    intrinsic_fall:<span class="number">1.15</span>;</span><br><span class="line"></span><br><span class="line">    related_pin: “D0”;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timing () &#123;</span><br><span class="line"></span><br><span class="line">    timing_type: non_seq_hold_rising;</span><br><span class="line"></span><br><span class="line">    intrinsic_rise: <span class="number">0.6</span>;</span><br><span class="line"></span><br><span class="line">    intrinsic_fall:<span class="number">0.65</span>;</span><br><span class="line"></span><br><span class="line">    related_pin: “D0”;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ setup_rising 是指相关管脚的上升沿。固有上升和下降值是指受限引脚的上升和下降设置时间。可以为hold_rising、setup_falling 和hold_falling 定义类似的时序弧。</p>
<p>​ 非顺序检查（non-sequential check）类似于第10.3节中描述的数据对数据检查，但是它们有两个主要区别。在非顺序检查中，建立和保持值从标准单元库中获得，其中建立和保持时序模型可以使用NLDM表格模型或其他高级时序模型来描述。在数据到数据检查中，只能为数据到数据建立或保持检查指定一个值。第二个区别是，非顺序检查只能应用于单元的pin，而数据对数据检查可以应用于设计中的任意两个pin。</p>
<p>​ <strong>非顺序建立检查（non-sequential setup check）</strong>指定相对于related pin，受约束信号必须多早到达。如图10-9所示。单元库包含建立时序弧D0-&gt;WEN，该弧被指定为非顺序弧。如果WEN信号出现在建立窗口内，则非顺序建立检查失败。</p>
<p>​ <strong>非顺序保持检查（non-sequential hold check）</strong>指定相对于related pin，受约束信号必须到达多晚。见图10-9。如果WEN在保持窗口内发生变化，则保持检查失败。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830101407282.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<h2 id="时钟门控检查clock-gating-checks">时钟门控检查（Clock Gating Checks）</h2>
<p>​ 当<strong>门控信号（gating signal）</strong>可以控制逻辑单元处的<strong>时钟信号（clock signal）</strong>的路径时，发生时钟门控检查。如图10-10示例。连接到时钟的逻辑单元的引脚称为<strong>时钟引脚（clock pin）</strong>，连接门控信号的引脚称为<strong>门控引脚（gating pin）</strong>。发生时钟门控的逻辑单元也称为<strong>门控单元（gating cell）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083012393322.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 时钟门控检查的一个条件是通过单元的时钟必须用作<strong>下游时钟（clock downstream）</strong>。下游时钟使用既可以作为触发器时钟，也可以扇出到输出端口，或者作为生成时钟，将门控单元的输出称为其主时钟。如果时钟不用作门控单元之后的时钟，则不会推断时钟门控检查。</p>
<p>​ 时钟门控检查的另一个条件适用于门控信号。检查的门控引脚上的信号不应是时钟，或者如果是时钟，则不应用作下游时钟（本节后面将包含作为门控信号的时钟示例）。</p>
<p>​ 在一般情况下，时钟信号和门控信号不需要连接到单个逻辑单元，例如and、或or，而是可以是任意逻辑块的输入。在这种情况下，要推断时钟门控检查，检查的时钟引脚和检查的门控引脚必须扇出到公共输出引脚。</p>
<p>​ 推断出两种类型的时钟门控检查：</p>
<ul>
<li>高电平有效时钟门控检查（Active-high clock gating check）：当门控单元具有and 或 nand功能时发生。</li>
<li>低电平有效时钟门控检查（ Active-low clock gating check）：当门控单元具有 or或 nor功能时发生。</li>
</ul>
<p>​ 高电平有效和低电平有效是指门控信号的逻辑状态，它激活门控单元输出端的时钟信号。如果门控单元是门控关系不明显的复杂功能，例如多路复用器或异或单元，则 STA 输出通常会提供警告，指出未推断出时钟门控检查。然而，这可以通过使用命令 set_clock_gating_check 明确指定门控单元的时钟门控关系来改变。在这种情况下， 如果set_clock_gating_check 约束与门控单元的功能不一致，STA 通常会提供警告。我们将在本节后面介绍此类命令的示例。</p>
<p>​ 如前所述，只有当时钟不用作下游时钟时，它才能成为门控信号。考虑图 10-11 中的示例。由于 CLKA 的生成时钟的定义，CLKB 不用作下游时钟 - CLKB 的路径被生成的时钟定义阻塞。因此，为and单元推断时钟 CLKA 的时钟门控检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830125722393.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>高电平有效时钟门控（Active-High Clock Gating）</strong></p>
<p>​ 我们现在检查高电平有效时钟门控检查的时序关系。这发生在一个and或一个 nand 单元上；使用and的示例如图 10-12 所示。门控单元的引脚 B 是时钟信号，门控单元的引脚 A 是门控信号。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830125923262.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 让我们假设时钟 CLKA 和 CLKB 具有相同的波形 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKA</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKA</span>]</span><br><span class="line"></span><br><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKB</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKB</span>]</span><br></pre></td></tr></table></figure>
<p>​ 因为它是一个and单元，门控信号 UAND0/A 上的高电平打开门控单元并允许时钟通过。时钟门控检查旨在验证门控引脚转换不会为扇出时钟创建有效边沿。对于正边沿触发逻辑，这意味着门控信号的上升沿发生在时钟的非活动周期（低电平时）。类似地，对于负沿触发逻辑，门控信号的下降沿应仅在时钟为低电平时出现。请注意，如果时钟同时驱动正边沿和负边沿触发的触发器，则门控信号（上升沿或下降沿）的任何转换都必须仅在时钟为低电平时发生。图 10-13 显示了需要延迟以通过时钟门控检查的活动边沿期间门控信号转换的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083013173523.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 高电平有效时钟门控建立检查要求门控信号在时钟变高之前发生变化。这是建立路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830131901143.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830131938470.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> 请注意，端点指示它是时钟门控检查。此外，该路径位于 Path Group中指定的clock_gating_default 路径组中。该检查验证门控信号在 10ns 时钟 CLKB 的下一个上升沿之前发生变化。</p>
<p>​ 高电平有效时钟门控保持检查要求门控信号仅在时钟下降沿之后发生变化。这是保持路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830132409531.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 保持门控检查失败，因为门控信号在 5ns 处的 CLKB 下降沿之前变化太快。如果在 UDFF0/Q 和 UAND0/A1 引脚之间添加 5ns 延迟，则建立和保持门控检查都将通过验证门控信号仅在指定window中发生变化。</p>
<p>​ 可以看出，保持时间要求相当大。这是因为门控信号的意义和被门控的触发器是相同的。这可以通过使用不同类型的启动触发器来解决，例如，一个负边沿触发的触发器来生成门控信号。这样的例子如下所示。</p>
<p>​ 在图 10-14 中，触发器 UFF0 由时钟 CLKA 的负沿控制。安全时钟门控意味着触发器 UFF0 的输出必须在门控时钟的非活动部分（5ns 到 10ns 之间）发生变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830173538597.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对应于图 10-14 中原理图的信号波形如图 10-15 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830174143777.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控建立报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830174323459.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830174358708.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830174433665.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控保持报告。请注意，新设计更容易满足保持时间检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830174519796.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 由于启动门控信号的时钟沿（负沿）与被门控的时钟（高电平有效）相反，建立和保持要求非常容易满足。这是门控时钟最常用的结构。</p>
<p><strong>低电平有效时钟门控（Active-Low Clock Gating）</strong></p>
<p>​ 图 10-16 显示了低电平有效时钟门控检查的示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830181603890.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">create_clock -name MCLK -period <span class="number">8</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_ports MCLK]</span></span><br><span class="line"></span><br><span class="line">create_clock -name SCLK -period <span class="number">8</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; \</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[get_ports SCLK]</span></span><br></pre></td></tr></table></figure>
<p>​ 低电平有效时钟门控检查验证门控信号的上升沿是否到达正沿触发逻辑的时钟的有效部分（当它为高电平时）。如前所述，关键是门控信号不应导致输出门控时钟的有效边沿。当门控信号为高电平时，时钟无法通过。因此，只有当时钟为高电平时，门控信号才应切换，如图 10-17 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830185148249.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是低电平有效时钟门控建立时序报告。此检查可确保门控信号在时钟边沿变为无效之前到达，在本例中为 4ns。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083018523843.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830185304979.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控保持时序报告。此检查确保门控信号仅在时钟信号的上升沿之后发生变化，在本例中为 0ns。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830190607857.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>带多路复用器的时钟门控（Clock Gating with a Multiplexer）</strong></p>
<p>​ 图10-18显示了使用多路复用器单元的时钟门控示例。多路复用器输入端的时钟门控检查确保多路复用器选择信号在正确的时间到达，以便在MCLK和TCLK之间干净地切换。对于本例，我们感兴趣的是在MCLK之间切换，并假设在选择信号切换时TCLK较低。这意味着多路复用器的选择信号应仅在MCLK低时切换。这类似于高电平有效时钟门控检查。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192230279.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图 10-19 显示了时序关系。多路复用器的选择信号必须在 MCLK 为低电平时到达。此外，假设选择更改时 TCLK 将为低。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192339475.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 由于门控单元是一个多路复用器，因此不会自动推断时钟门控检查，如 STA 期间报告的此消息所示。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083019243746.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 但是，可以通过提供 set_clock_gating_check 明确强制进行时钟门控检查。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_clock_gating_check -high [get_cells UMUX0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -high option indicates an active-high check.</span></span><br><span class="line"></span><br><span class="line">set_disable_clock_gating_check UMUX0/I1</span><br></pre></td></tr></table></figure>
<p>​ 禁用检查（disable check）关闭特定引脚上的时钟门控检查，因为我们不关心该引脚。多路复用器上的时钟门控检查已指定为高电平有效时钟门控检查。这是建立时序路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192632656.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830192706977.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 接下来是时钟门控保持时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830192800398.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830192831749.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>具有时钟反转的时钟门控（Clock Gating with Clock Inversion）</strong></p>
<p>​ 图10-20显示了另一个时钟门控示例，其中触发器的时钟反转，触发器的输出为门控信号。由于门控单元是and单元，因此只有当and单元的时钟信号较低时，门控信号才必须切换。这定义了建立和保持时钟门控检查。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083019310096.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是时钟门控建立时序报告 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830195034612.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830195110873.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830195144823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，建立检查会验证数据是否在时间 15ns 的 MCLK 边沿之前发生更改。这是时钟门控保持时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830195249157.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 保持检查验证数据（门控信号）是否在时间 10ns 的 MCLK 下降沿之前发生变化。</p>
<p>​ 如果门控单元是复杂单元并且建立和保持检查不明显，则可以使用 set_clock_gating_check 命令指定对时钟信号进行门控的门控信号的建立和保持检查。建立检查验证门控信号在时钟信号的有效边沿之前是否稳定。建立失败会导致门控单元输出出现故障。保持检查验证门控信号在时钟信号的非活动边沿是否稳定。以下是 set_clock_gating_check 约束的一些示例。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">set_clock_gating_check -setup <span class="number">2.4</span> -hold <span class="number">0.8</span> \</span><br><span class="line"></span><br><span class="line">[get_cells U0/UXOR1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies the setup and hold time for the clock</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gating check at the specified cell.</span></span><br><span class="line"></span><br><span class="line">set_clock_gating_check -high [get_cells UMUX5]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check is performed on high level of clock. Alternately, the</span></span><br><span class="line"></span><br><span class="line">-low option can be used <span class="keyword">for</span> an active-low clock gating check.</span><br></pre></td></tr></table></figure>
<h2 id="功耗管理power-management">功耗管理（Power Management）</h2>
<p>​ 管理功率是任何设计及其实现方式的一个重要方面。在设计实施期间，设计人员通常需要评估不同的方法，以在设计的速度、功耗和面积之间进行权衡。</p>
<p>​ 如第 3 章所述，设计逻辑部分的功耗由泄漏功率（leakage power）和有功功率（active power）组成。此外，模拟宏和 IO 缓冲器（尤其是那些具有有源端接的）可以消耗与活动无关且不泄漏的功率。在本节中，我们关注设计逻辑部分功耗的权衡。</p>
<p>​ 一般来说，管理由标准单元和内存宏组成的数字逻辑的功率贡献有两个考虑事项:</p>
<ul>
<li>最小化设计的总有功功率：设计人员将确保总功耗保持在可用功率限制范围内。设计的不同操作模式可能有不同的限制。此外，设计中使用的不同电源也可能有不同的限制。</li>
<li>将设计在待机模式下的功耗降至最低：对于电池供电的设备（例如手机）来说，这是一个重要的考虑因素，其目标是将待机模式下的功耗降至最低。待机模式下的功耗是泄漏功耗加上待机模式下活动逻辑的任何功耗。如上所述，可能有其他模式，例如睡眠模式，对功率有不同的限制。</li>
</ul>
<p>​ 本节介绍功率管理的各种方法。这些方法中的每一种都有其优点和缺点，本文将对其进行描述。</p>
<h3 id="时钟门控clock-gating">时钟门控（Clock Gating）</h3>
<p>​ 如第 3 章所述，触发器的时钟活动占总功耗的重要组成部分。即使触发器输出不切换，触发器也会由于时钟切换而耗散功率。考虑图 10-21(a) 中的示例，其中触发器仅在使能信号 EN 有效时才接收新数据，否则保持先前状态。在 EN 信号无效期间，触发器的时钟<strong>翻转（toggle）</strong>不会引起任何输出变化，尽管时钟活动仍会导致触发器内部的功率耗散。时钟门控的目的是，通过在触发器输入无效的clock cycles期间消除触发器的时钟活动来最小化这种贡献。通过时钟门控进行的逻辑重组在触发器引脚处引入了时钟门控。图 10-21 说明了时钟门控引起的转换示例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830210553168.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 因此，时钟门控确保触发器的时钟引脚仅在其数据输入端有新数据时才触发。</p>
<h3 id="电源门控power-gating">电源门控（Power Gating）</h3>
<p>​ 电源门控涉及关闭电源，以便可以关闭非活动块的电源。此过程如图 10-22 所示，其中添加了一个与电源串联的footer（或header）MOS 器件。配置控制信号 SLEEP ，使得在块的正常操作期间footer（或header）MOS 器件处于开启状态。由于电源门控 MOS 器件（footer or header）在正常操作期间处于开启状态，因此该模块已通电并在正常功能模式下运行。在模块的非活动（或睡眠）模式期间，门控 MOS 器件（footer or header）被关闭，从而消除了逻辑模块中的任何活动功耗。footer是在实际的地与模块的地网络之间的大型NMOS器件，可通过电源门控对其进行控制。header是实际电源和模块的电源网络之间的大型 PMOS 器件，通过电源门控进行控制。在睡眠模式期间，块中唯一耗散的功率是通过footer（或header）设备的泄漏功率。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830212647360.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ footer or header通常使用多个电源门控单元来实现，这些电源门控单元对应于多个并联的 MOS 器件。footer or header设备向电源引入了串联电阻。如果导通电阻值不小，通过门控 MOS 器件的 IR 压降会影响逻辑块中单元的时序。虽然关于门控器件尺寸的主要标准是确保导通电阻值较小，但由于电源门控 MOS 器件决定了非活动或睡眠模式下的泄漏功率，因此需要进行权衡。</p>
<p>​ 总之，应该有足够数量的电源门控单元并联，以确保在有源模式下串联电阻的 IR 降最小。然而，处于非活动或睡眠模式的门控单元的泄漏功率也是选择并联电源门控单元数量的一个标准。</p>
<h3 id="多电压阈值单元multi-vt-cells">多电压阈值单元（Multi Vt Cells）</h3>
<p>​ 如第3章（第3.8节）所述，多<strong>电压阈值（Vt）</strong>单元用于权衡速度和泄露功率。高Vt单元具有较少的泄露功率，尽管其速度比标准Vt单元慢，标准Vt单元速度更快，但具有较高的泄露功率。类似地，低Vt单元比标准Vt单元快，但泄露功率也相应地更高。</p>
<p>​ 在大多数设计中，目标是在达到所需操作速度的同时将总功率降至最低。尽管泄露功率可能是总功率的重要组成部分，但实现仅使用高Vt单元来减少泄露功率的设计可以增加总功率，即使泄露功率贡献可能会降低。这是因为最终的设计实现可能需要更多(或更高强度)的高Vt单元来实现所需的性能。与使用高Vt单元导致的泄漏功率的降低相比，等效gate数目的增加可以更多地增加有功功率。然而，在某些情况下，泄漏功率是总功率的主要组成部分；在这种情况下，采用高Vt单元的设计可能会导致总功率降低。需要适当地利用具有不同Vt的单元之间在其速度和泄露功率方面的上述权衡，因为它取决于设计及其开关活动曲线。下面说明了高性能块的两个场景，其中实现方法可以根据块是非常活跃的还是具有低切换活动而不同。</p>
<p><strong>具有高活性的高性能块（High Performance Block with High Activity）</strong></p>
<p>​ 这种情况是具有高开关活动的高性能块，并且功率由有功功率支配。对于此类块，仅关注降低泄漏功率会导致总功率增加，即使泄漏功率贡献可被最小化。在这种情况下，初始设计实现应使用标准 Vt（或低 Vt）单元以满足所需的性能。在达到所需的时序后，沿着具有正时序裕量的路径的单元可以更改为高 Vt 单元，从而在仍然满足时序要求的同时减少泄漏贡献。因此，在最终实现中，标准 Vt（或低 Vt）单元仅用于关键或难以实现的时序路径，而沿非关键时序路径的单元可以是高 Vt 单元。</p>
<p><strong>具有低活性的高性能块（High Performance Block with Low Activity）</strong></p>
<p>​ 这种情况是具有非常低开关活动的高性能模块，因此泄漏功率是总功率的重要组成部分。由于模块的活动性较低，因此有功功率不是设计总功率的主要组成部分。对于此类模块，初始实现尝试仅在组合逻辑和触发器中使用高 Vt 单元。一个例外是时钟树，它始终处于活动状态，因此使用标准 Vt（或低 Vt）单元构建。在仅使用高 Vt 单元进行初始实施后，可能存在一些无法实现所需时序的时序路径。然后将沿这些路径的单元替换为标准 Vt（或低 Vt）单元，以实现所需的时序性能。</p>
<h3 id="阱偏置well-bias">阱偏置（Well Bias）</h3>
<p>​ <strong>阱偏置（well bias）</strong>是指在分别用于 NMOS 和 PMOS 器件的 P-well 或 N-well 上添加一个小的电压偏置。图 2-1 所示 NMOS 器件的衬底（或 P 阱）连接通常接地。同样，图 2-1 所示 PMOS 器件的衬底（或 N 阱）连接通常连接到电源 (Vdd) 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210809140101587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc4ODU2MA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>​ 如果阱连接具有轻微的负偏压，可以显著降低泄漏功率。这意味着 NMOS 器件的 P 阱连接到一个小的负电压（例如 -0.5V）。同样，PMOS 器件的 Nwell 连接连接到高于电源的电压（例如 Vdd +0.5V）。通过添加阱偏置，单元的速度受到影响；然而，泄漏功率大大减少。单元库中的时序是通过将阱偏置考虑在内而生成的。</p>
<p>​ 使用阱偏置的缺点是P阱和N阱连接需要额外的供电电源（例如-0.5V和Vdd + 0.5V）。</p>
<h2 id="反标backannotation">反标（Backannotation）</h2>
<h3 id="spef">SPEF</h3>
<p>​ STA 如何知道设计的寄生参数是什么？通常，该信息是通过使用寄生提取工具提取的，并且该数据由 STA 工具以 SPEF 的形式读取。附录 C 中描述了 SPEF 的详细信息和格式。</p>
<p>​ 物理设计布局工具内的 STA 引擎的行为也类似，不同之处在于提取信息写入内部数据库。</p>
<h3 id="sdf">SDF</h3>
<p>​ 在某些情况下，单元和互连的延迟由另一个工具计算，并通过 SDF 为 STA 读取。使用 SDF 的优点是不再需要计算单元延迟和互连延迟——因为它们直接来自 SDF，因此 STA 可以专注于时序检查。但是，这种延迟注释的缺点是由于缺少寄生信息，STA 无法执行串扰计算。 SDF 是通常用于将延迟信息传递给模拟器的机制。</p>
<p>​ SDF 的详细信息和格式在附录 B 中描述。</p>
<h2 id="sign-off方法sign-off-methodology">sign off方法（Sign-off Methodology）</h2>
<p>​ STA 可以针对许多不同的场景运行。决定场景的三个主要变量是：</p>
<ul>
<li>寄生角（Parasitics corners）（RC 互连角和用于寄生提取的操作条件）</li>
<li>操作模式 （Operating mode）</li>
<li>PVT 角（PVT corner）</li>
</ul>
<p><strong>互连寄生角（Parasitic Interconnect Corners）</strong></p>
<p>​ 可以在许多corner提取寄生参数。这些主要取决于制造过程中金属宽度和金属蚀刻的变化。其中一些是：</p>
<ul>
<li>Typical：这是指互连电阻和电容的标称值。</li>
<li>Max C：这是指导致最大电容的互连角。互连电阻比 typical corner小。该角会导致短网路径的最大延迟，可用于最大路径分析。</li>
<li>Min C：这是指导致最小电容的互连角。互连电阻比 typical corner大。该角导致具有短网络的路径的最小延迟并可用于最小路径分析。</li>
<li>Max RC：这是指使互连RC 乘积最大化的互连角。这通常对应于减小走线宽度的较大蚀刻。这导致最大电阻但对应于小于Typical电容。总体而言，对于具有长互连的路径，该角具有最大延迟，可用于最大路径分析。</li>
<li>Min RC：这是指使互连RC 乘积最小的互连角。这通常对应于增加走线宽度的较小蚀刻。这导致最小的电阻，但对应于大于Typical电容。总体而言，对于具有长互连的路径，该角具有最小的路径延迟，可用于最小路径分析。</li>
</ul>
<p>​ 基于上述各个角的互连电阻和电容，具有较大电容的互连角会导致电阻较小，具有较小电容的互连角会导致电阻较大。因此，电阻在一定程度上补偿了各个互连角下的电容。这意味着对于所有类型网络的延迟，没有一个角会真正对应极限情况（最差情况或最佳情况）。使用Cworst / Cbest角下的路径延迟仅对于较短网络是极限情况，而RCworst / RCbest角仅对于较长网络是极限情况，而对于平均长度的网络，Typical互连角通常在路径延迟方面是极限的。因此，设计人员经常会在上述各个互连角下都去验证设计的时序。但是，即使在每个角处都进行了验证也可能无法涵盖所有可能的情况，因为不同的金属层实际上可以独立地处于不同互连角下，例如：METAL2在Max C角下而METAL1在Max RC角下。10.9节中介绍的统计（statistical）时序分析将提出一种静态时序分析的机制，其中不同的金属层可以处于不同的互连角下。</p>
<p><strong>操作模式（Operating Modes）</strong></p>
<ul>
<li>功能模式1（工作在高速时钟下）</li>
<li>功能模式2（工作在低速时钟下）</li>
<li>功能模式3（睡眠模式）</li>
<li>功能模式4（调试模式）</li>
<li>测试模式1（scan capture）</li>
<li>测试模式2（scan shift）</li>
<li>测试模式3（bist）</li>
<li>测试模式4（jtag）</li>
</ul>
<p><strong>PVT corner</strong></p>
<p>​ PVT corner指示在什么条件下进行STA分析。最常见的PVT corner是：</p>
<ul>
<li>WCS(慢工艺，低电源，高温)</li>
<li>BCF(快工艺，高电源，低温)</li>
<li>Typical(典型工艺，额定电源，额定温度)</li>
<li>WCL(冷慢工艺，低电源，低温)</li>
<li>或PVT domin中的任何其他点</li>
</ul>
<p>​ 任何情况下都可以执行STA分析。这里的场景指的是上述互连角、操作模式和PVT corner的组合。</p>
<p><strong>多模式多角分析（Multi-Mode Multi-Corner Analysis）</strong></p>
<p>​ <strong>多模式多角(Multi-mode multi-corner ，MMMC)</strong>分析是指同时对多个工作模式、PVT角和寄生互连角进行STA分析。例如，假设DUA有四种工作模式(Normal, Sleep, Scan shift, Jtag)，并在三个PVT角(WCS、BCF、WCL)和三个寄生互连角(Typical、Min C、Min RC)进行分析，如表10-23所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830222133808.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 总共有 36 种可能的场景，在这些场景中可以执行所有时序检查，例如建立、保持、转换和时钟门控检查。根据设计的规模，同时为所有 36 个场景运行 STA 在运行时间方面可能会令人望而却步。一个场景可能不需要，因为它可能包含在另一个场景中，或者一个场景可能不需要。例如，设计者可以确定场景 4、6、7 和 9 不相关，因此不需要。此外，可能没有必要在一个corner运行所有模式，例如场景 5 中可能不需要 Scan shift 或 Jtag 模式。 如果多模式多角功能是可用的，则可以在单个场景或多个场景中同时运行 STA可用的。</p>
<p>​ 运行多模式多角 STA 的优点是节省了运行时间和设置分析脚本的复杂性。 MMMC 场景中的额外节省是设计和寄生参数只需加载一次或两次，而不是为每个mode或corner单独加载多次。这样的工作也更适合在 LSF 场上运行它们。多模式多角在优化流程中具有更大的优势，其中优化在所有场景中完成，以便在一个场景中修复时序违规不会在另一个场景中引入时序违规。</p>
<p>​ 对于 IO 约束，-add_delay 选项可以与多个时钟源一起使用，以在一次运行中分析不同的模式，例如扫描或双模式，或对应于不同速度的 PHY（物理层接口 IP 块，例如 10G PHY）中的不同操作模式。通常，每种模式都在单独的运行中进行分析，但并非总是如此。</p>
<p>​ 发现具有大量时钟的设计需要数十次独立运行才能覆盖最大和最小corner的每个模式，并且包括串扰和噪声的影响，这并不罕见。</p>
<h2 id="统计静态时序分析statistical-static-timing-analysis">统计静态时序分析（Statistical Static Timing Analysis）</h2>
<p>​ 到目前为止描述的静态时序分析技术是确定性的，因为该分析基于设计中所有时序弧的固定延迟。根据操作条件以及工艺和互连模型计算每个电弧的延迟。虽然可能存在多个mode和多个corner，但是可以确定性地获得给定场景的时序路径延迟。</p>
<p>​ 实际上，执行STA时通常使用的工艺和工作条件的最差情况（WCS）或最佳情况（BCF）对应于极端的3σ角（这里的σ指的是统计建模的自变量的标准差）。时序库基于的是代工厂提供的带有工作条件的工艺角模型，这些条件对应于单元时序值的不同角。例如，使用快速工艺模型、最高电源和最低温度来表征最佳情况的快速时序库。</p>
<h3 id="工艺和互连变化process-and-interconnect-variations">工艺和互连变化（Process and Interconnect Variations）</h3>
<p><strong>全局工艺变化（Global Process Variations）</strong></p>
<p>​ 全局工艺变化（global process variations）（也称为芯片间器件变化inter-die device variations），指的是影响芯片(或晶片)上所有器件的工艺参数的变化。参见图10-24。这描述了芯片上的所有设备都受到这些工艺变化的类似影响-芯片上的每个设备都将变slow或变fast，或者介于两者之间的任何位置。因此，由全局工艺参数建模的变化旨在捕捉不同模具之间的变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830223058608.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-25显示了全局参数值(例如g_par1)的变化。例如，参数g_par1可以对应于标准（<em>这里的标准设备是指长度和宽度固定的设备。</em>）NMOS器件的IDSsat(器件饱和电流)。由于这是一个全局参数，因此芯片上所有单元实例中的所有NMOS器件将对应于相同的g_par1值。可以有如下选择：所有单元实例的g_par1的变化是完全相关的，或者芯片上g_par1的变化相互影响。注意，可能还存在其它全局参数（g_par2，...），其可能可以对PMOS器件饱和电流和其它相关变量建模。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830223509267.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 不同的全局参数(g_par1、g_par2、.。。。)。是不相关的。不同全局参数中的变化不会相互影响，这意味着g_par1和g_par2参数彼此独立变化；在芯片中，g_par1可能处于最大值，而g_par2可能处于最小值。</p>
<p>​ 在确定性（即非统计性）分析中，慢速工艺模型可能对应于芯片间变化的+ 3σ角的条件。类似地，快速工艺模型可能对应于芯片间变化的-3σ角的条件。</p>
<p><strong>局部工艺变化（Local Process Variations）</strong></p>
<p>​ 局部工艺变化(也称为<strong>芯片内器件变化intra-die device variations</strong>)指的是工艺参数中的变化，这些变化可能以不同方式影响给定芯片上的器件。参见图10-26。这意味着并排放置的芯片上的相同器件在同一芯片上可能具有不同的行为。由局部工艺变化建模的变化旨在捕捉模具内的随机工艺变化。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830231808425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-27显示了局部工艺参数的变化。芯片上的局部参数变化不会相互影响，并且它们从一个单元实例到另一个单元实例的变化是不相关的。这意味着对于同一芯片上的不同器件，局部参数可能具有不同的值。例如，芯片上的不同NAND2单元实例可能会看到不同的局部工艺参数值。这会导致同一NAND2单元的不同实例具有不同的延迟值，即使其他参数(例如输入转换和输出负载)是相同的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830232146765.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 图10-28显示了由全局和局部变化引起的NAND2信元延迟的变化。该图说明了全局参数变化比局部参数变化引起的时延变化更大。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830232319120.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 局部工艺变化是打算在使用 OCV 建模的分析中捕获的变化之一，如第 10.1 节所述。由于统计时序模型通常包括局部工艺变化，使用统计时序模型的 OCV 分析不应包括 OCV 设置中的局部工艺变化。</p>
<p><strong>互连变化（Interconnect Variations）</strong></p>
<p>​ 如第 10.8 节所述，有各种互连角代表影响互连电阻和电容值的每个金属层的参数变化。这些参数变化通常是金属和电介质的厚度，以及影响各种金属层中金属走线的宽度和间距的金属蚀刻。通常，影响金属的参数会影响该金属层中所有走线的寄生效应，但对其他金属层中走线的寄生效应影响很小或没有影响。</p>
<p>​ 第 10.8 节中描述的互连角对互连变化进行建模，以便所有金属层映射到相同的互连角。对互连走线变化进行统计建模时，每个金属层都可以独立地变化。</p>
<p>​ 统计方法对互连空间中所有可能的变化组合进行建模，从而对仅通过在指定的互连角处分析无法捕捉到的变化进行建模。例如，时钟树的启动路径可能在 METAL2 中，而时钟树的捕获路径在 METAL3 中。传统互连corner处的时序分析考虑了所有金属一起变化的各个corner，因此无法模拟 METAL2 位于导致最大延迟的corner而 METAL3 位于导致最小延迟的corner的情况。这种组合对应于设置路径的最坏情况，只能通过对互连变化进行统计建模来捕获。</p>
<h3 id="统计分析statistical-analysis">统计分析（Statistical Analysis）</h3>
<p><strong>什么是 SSTA？</strong></p>
<p>​ 如果对单元时序模型和互连寄生进行统计建模，则上述变化的建模是可行的。除了延迟之外，单元输入端的引脚电容值也被统计建模。这意味着时序模型是根据工艺参数（全局和局部）的平均值和标准偏差来描述的。互连电阻和电容是根据互连参数的平均值和标准偏差来描述的。延迟计算程序（在第 5 章中描述）获得每个时序弧（单元以及互连）的延迟，然后用关于各种参数的平均值和标准偏差表示。因此，每个延迟都由平均值和 N 个标准偏差表示（其中 N 是统计建模的独立过程和互连参数的数量）。</p>
<p>​ 由于通过各个时序弧的延迟是用统计形式表示的，因此统计静态时序分析SSTA（Statistical Static Timing Analysis）过程中会结合时序弧的延迟以获得路径延迟，该路径延迟同样会以统计形式表示（具有均值和标准差）。SSTA会根据独立的工艺和互连参数的标准差，来获得路径延迟的总体标准差。例如，考虑由两个时序弧组成的路径延迟，如图10-29所示。由于每个延迟分量都有其变化，因此根据变化是相关的还是不相关的，将对变化进行不同的组合。如果变化来自同一来源（例如，由相互影响的g_par1参数引起），则路径延迟的σ仅等于（σ1 + σ2）。但是，如果变化是不相关的（例如由于l_par1参数），那么路径延迟的σ等于<embed src="https://latex.codecogs.com/gif.latex?%5Csqrt%7B%5Csigma%201%5E%7B2%7D+%5Csigma%202%5E%7B2%7D%7D"> ，该值小于（σ1 + σ2）。当对局部（不相关的）工艺变化建模时，路径延迟σ较小的现象也称为各个延迟变化的<strong>统计抵消（statistical cancellation）</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830233527671.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对于实际设计，相关和不相关的变化都被建模，因此需要适当组合这两种类型的变化的贡献。</p>
<p>​ 发起和捕获时钟的时钟路径延迟也以相同的统计形式表示。基于数据和时钟路径延迟，可以将裕量（slack）作为具有标准值和标准差的统计量。</p>
<p>​ 假设使用正态分布，可以获得对应于（平均值mean +/- 3σ）的有效最小值和最大值。 （平均值mean -/ + 3σ）对应于图10-30中所示正态分布的0.135％和99.865％的分位数。0.135％的分位数意味着仅0.135％的结果分布小于此值（平均值mean-3σ）；同样，99.865％的分位数表示99.865％的结果小于此值，或仅0.135％（100％-99.865％）的结果大于此值（平均值mean+3σ）。有效的下限和上限在SSTA报告中称为<strong>分位数（quantile）</strong>，设计人员可以选择分析中使用的分位数，例如0.5％或99.5％，对应于（平均值mean -/ + 2.576σ）。</p>
<p><img src="https://img-blog.csdnimg.cn/2021083023382033.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 对于噪声和串扰分析（第 6 章），所使用的路径延迟和时序窗口是根据各种参数的平均值和标准偏差进行统计建模的。</p>
<p>​ 根据路径裕量分布，SSTA会报告每个路径裕量的平均值、标准差和分位数，从而可以根据所需的统计置信度（confidence）来判断时序是通过还是违例。</p>
<p><strong>统计时序库（Statistical Timing Libraries）</strong></p>
<p>​ 在 SSTA 方法中，标准单元库（以及设计中使用的其他宏的库）提供各种环境条件下的时序模型。例如，在最小 Vdd 和高温corner处的分析利用在此条件下表征的库，但对工艺参数进行统计建模。库包括标称参数值以及参数变化的时序模型。对于 N 个工艺参数，在 0.9V 和 125C 电源下表征的统计时序库可能包括以下内容：</p>
<ul>
<li>具有标准工艺参数的时序模型，<em>加上以下关于每个工艺参数的信息</em>。</li>
<li>参数i为（标准值+1σ）的时序模型，其他参数保持为标准值</li>
<li>参数i为（标准值-1σ）的时序模型，其他参数保持为标准值</li>
</ul>
<p>​ 对于具有两个独立工艺参数的简化示例场景，时序模型的特征在于标称参数值以及参数值的变化，如图 10-31 所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830234408681.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>统计互连变化（Statistical Interconnect Variations）</strong></p>
<p>​ 每个金属层有三个独立的参数：</p>
<ul>
<li>金属刻蚀（ Metal etch）：这可以控制金属宽度以及与相邻导体的间距。金属层中的大刻蚀减小了宽度（这增加了电阻）并增加了到相邻走线的间距（这减小了到相邻走线的耦合电容）。该参数表示为导体宽度的变化。</li>
<li>金属厚度（ Metal thickness）：较厚的金属意味着与下面各层的电容更大。该参数表示为导体厚度的变化。</li>
<li>IMD厚度（金属间介电层厚度，Inter Metal Dielectric thickness）：较大的IMD厚度会减少与下面各层的耦合。该参数表示为IMD厚度的变化。</li>
</ul>
<p><strong>SSTA 结果（SSTA Results）</strong></p>
<p>​ 统计分析中输出的结果将根据平均值和角的有效值来提供路径的裕量。以下是用于建立时间检查（最大路径分析）的SSTA报告示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210830234749790.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830234818841.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 上面的报告显示，尽管时序路径的均值满足要求，但0.135％的分位数却有0.43ns的时序违例，时序路径裕量的分位数为-0.43ns。时序路径裕量的平均值为+ 0.86ns，标准差为0.43ns，这意味着+/- 2σ的分布结果满足要求。由于95.5％的分布落在2σ的变化范围内，这意味着只有2.275％的路径会出现时序违例（其余的2.275％分布具有较大的正裕量）。因此，把分位数设置为2.275％后可以使得裕量为0或没有时序违例。到达时间和路径裕量分布如下图10-32所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210830234912288.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，以上报告是针对建立时间检查的，因此分位数那一列提供的是分位数上限（例如，路径延迟的+ 3σ值），保持时间检查时则会指定为分位数下限（例如-3σ值）。报告中的“sensitiv”列是指敏感度，即标准差与平均值的比值（表示为百分比）。就裕量而言，需要较小的灵敏度，这意味着即使平均值发生变化，以平均值通过的路径也会继续通过。“incr”列中指定了报告中该行的增量标准差。</p>
<p>​ 使用单元和互连走线的统计模型，统计时序方法可以分析各种角条件下的设计，并分析由于工艺和互连参数变化而导致的情况。例如，在最差VT（电压和温度）情况下进行统计分析将分析整个全局工艺和互连走线空间。在最佳VT（电压和温度）情况下的另一种统计分析也将分析整个工艺和互连走线空间。这些分析可以与在最差PVT情况或最佳PVT情况下进行的传统分析进行对比，传统分析仅探讨工艺和互连空间中的单个点。</p>
<h2 id="路径失败时序paths-failing-timing">路径失败时序？（Paths Failing Timing?）</h2>
<p>​ 在本节中，我们将提供一些示例，突出显示设计者在调试STA结果期间需要关注的关键方面。这些例子中有几个只包含STA报告的相关摘录 。</p>
<h3 id="未找到路径no-path-found">未找到路径（No Path Found）</h3>
<p>​ 如果用户尝试获取路径报告，而STA报告找不到路径，或者它提供了路径报告但slack时间是无限的，该怎么办？在这两种情况下，出现这种情况可能是因为：</p>
<ul>
<li>时序路径已断开</li>
<li>该路径不存在</li>
<li>这是一条false path</li>
</ul>
<p>​ 在上述每种情况下，都需要仔细调试约束以确定是什么约束导致路径被阻塞。一种强力选项是删除所有错误的路径设置和时序中断，然后查看该路径是否可以进行时序分析。(时序中断是从STA中移除时序弧，通过使用<strong>set_disable_timing</strong>现，如第7.10节所述。)</p>
<h3 id="时钟交叉域clock-crossing-domain">时钟交叉域（Clock Crossing Domain）</h3>
<p>​ 这是路径报告的头部。</p>
<p><img src="https://img-blog.csdnimg.cn/20210830235839772.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210830235908791.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 首先要注意的是，该路径从输入端口（ input port）开始，在触发器的clear pin结束，并且正在验证clear pin上的恢复检查（参见库恢复时间library recovery time）。接下来要注意的是，路径跨越两个不同的时钟域，SYS_IN_CLK，启动输入的时钟，和 PX9_CLK，触发器的时钟，正在检查其恢复时序。尽管从时序报告中看不出来，但从设计知识来看，可以检查两个时钟是否完全异步以及这两个时钟域之间的任何路径是否应该被视为错误。</p>
<p>​ lesson：验证启动时钟和捕获时钟以及两者之间的路径是否有效。</p>
<h3 id="反向生成时钟inverted-generated-clocks">反向生成时钟（Inverted Generated Clocks）</h3>
<p>​ 创建生成时钟时，需要谨慎使用 -invert 选项。如果使用 -invert 选项指定生成的时钟，则 STA 假定指定点的生成时钟属于指定类型。但是根据逻辑，设计中可能不会出现这样的波形。 STA 通常会提供错误或警告消息，指示生成的时钟无法实现，但它会继续分析并报告时序路径。</p>
<p>​ 考虑图 10-33。让我们在单元 UCKBUF0 的输出上定义一个带有 -invert 的生成时钟。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">CLKGEN</span> <span class="operator">-</span>divide_by <span class="number">1</span> <span class="operator">-</span>invert \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source [get_ports <span class="type">CLKM</span>] [get_pins <span class="type">UCKBUF0</span><span class="operator">/</span><span class="type">C</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210831000333661.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 这是基于上述约束的建立时间时序报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831000435921.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2021083100051170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 请注意，STA 假设单元 UCKBUF0 输出的波形是时钟 CLKM 的反相时钟。因此，上升沿为 5ns，捕获设置时钟沿为 15ns。除了时钟的上升沿在 5ns 而不是 0ns 的事实之外，从时序报告中看不出有什么问题。应该注意的是，由于错误位于启动和捕获时钟路径的公共部分，因此建立和保持时序检查确实正确执行。 STA产生的警告和错误需要仔细分析和理解。</p>
<p>​ 需要注意的重要一点是，无论是否可实现，STA 都会按照指定的方式创建生成的时钟。</p>
<p>​ 现在让我们尝试使用 -invert 选项将生成的时钟移动到单元 UCKBUF1 的输出，看看会发生什么。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">create_clock <span class="operator">-</span>name <span class="type">CLKM</span> <span class="operator">-</span>period <span class="number">10</span> <span class="operator">-</span>waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; \</span><br><span class="line"></span><br><span class="line">[get_ports <span class="type">CLKM</span>]</span><br><span class="line"></span><br><span class="line">create_generated_clock <span class="operator">-</span>name <span class="type">CLKGEN</span> <span class="operator">-</span>divide_by <span class="number">1</span> <span class="operator">-</span>invert \</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>source [get_ports <span class="type">CLKM</span>] [get_pins <span class="type">UCKBUF1</span><span class="operator">/</span><span class="type">C</span>]</span><br></pre></td></tr></table></figure>
<p>​ 这是setup报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831000724466.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831000758651.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 该路径看起来像半周期路径，但这是不正确的，因为在实际逻辑中时钟路径上没有反转。 STA 再次假设 UCKBUF1/C 引脚上的时钟是 create_generated_clock 命令中指定的时钟。因此上升沿发生在 5ns。捕获时钟边沿正在运行时钟 CLKM，其下一个上升沿发生在 10ns。下面的保持路径报告也包含与建立路径类似的差异。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831000911937.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831001005109.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 通常，STA 输出将包括错误或警告，指示生成的时钟不可实现。调试此类不正确路径的最佳方法是实际绘制捕获触发器和启动触发器处的时钟波形，并尝试了解所显示的边沿是否确实有效。</p>
<p>​ lesson：检查捕获和启动时钟的边沿，看看它们是否确实是它们应该的样子。</p>
<h3 id="缺少虚拟时钟延迟missing-virtual-clock-latency">缺少虚拟时钟延迟（Missing Virtual Clock Latency）</h3>
<p>​ 考虑以下路径报告。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831001250883.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831001324170.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 它是从输入引脚开始的路径。请注意，起始到达时间列为 0。这表明时钟 VCLKM 上没有指定延迟 - 该时钟用于定义输入引脚 RESET_L 上的输入到达时间；这很可能是一个虚拟时钟，这就是缺少到达时间的原因。</p>
<p>​ lesson：使用虚拟时钟时，请确保在 set_input_delay 和 set_output_delay 约束中指定或考虑了虚拟时钟的延迟。</p>
<h3 id="大-io-延迟large-io-delays">大 I/O 延迟（Large I/O Delays）</h3>
<p>​ 当输入或输出路径有时序违例时，首先要检查的是时钟延迟，该延迟用作指定输入到达时间或输出所需时间的参考。这同样适用于前面所讲的例子。</p>
<p>​ 要检查的第二件事是输入或输出延迟，即输入路径上的输入到达时间或输出路径上的输出所需时间。我们可能会发现这些数值对于目标频率是不现实的。输入到达时间通常是时序报告中数据路径的第一个值，而输出所需时间通常是时序报告中数据路径的最后一个值。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831001604440.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>​ 在输入失败路径的这个数据路径中，注意输入到达时间为 14ns。在这种特殊情况下，输入到达时间规范存在错误，因为它太大。</p>
<p>​ lesson：在检查输入或输出路径时，检查指定的外部延迟是否合理。</p>
<h3 id="错误的-io-缓冲区延迟incorrect-io-buffer-delay">错误的 I/O 缓冲区延迟（Incorrect I/O Buffer Delay）</h3>
<p>​ 当路径经过输入缓冲器或输出缓冲器时，约束不正确可能会导致输入或输出缓冲器延迟值较大。在如下所示的情况中，请注意18ns这个较大的输出缓冲器延迟值，这是由于输出引脚上指定的负载值较大导致的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210831001732524.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20210831001801107.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGQ5qGQ6Iqx,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"> lesson：注意由不正确的负载规范引起的缓冲区的大延迟。</p>
<h3 id="延迟值不正确incorrect-latency-numbers">延迟值不正确（Incorrect Latency Numbers）</h3>
<p>​ 当时序路径出现故障时，需要检查的一件事是启动时钟和捕获时钟的延迟是否合理，即确保这些时钟之间的偏差在可接受的范围内。时钟构建期间不正确的延迟规范或不正确的时钟平衡都可能导致启动和捕获时钟路径中的大偏差，从而导致时序违规。</p>
<p>​ lesson：检查时钟偏差是否在合理范围内。</p>
<h3 id="半周期路径half-cycle-path">半周期路径（Half-cycle Path）</h3>
<p>​ 如前面的示例所述，设计人员需要检查违例路径的时钟域。随之而来的是，设计人员可能需要检查发起和捕获触发器的时钟沿。在某些情况下，可能会发现一个半周期路径（上升沿至下降沿路径或下降沿至上升沿路径）并且可能无法满足半周期路径的时序要求，又或者这些半周期路径不是真实存在的 。</p>
<p>​ lesson：确保数据路径有足够的时间进行传播。</p>
<h3 id="大延迟和转换时间large-delays-and-transition-times">大延迟和转换时间（Large Delays and Transition Times）</h3>
<p>​ 一项关键项目是检查沿数据路径的延迟或转换时间的异常大的数值。其中一些可能是由于：</p>
<ul>
<li>高扇出网络（High-fanout nets）：未适当缓冲（buffered）的网络。</li>
<li>较长网络（ Long nets）：需要在中间插入缓冲器的网络。</li>
<li>低强度单元（Low strength cells）：由于在设计中标有“don't touch”，因此未被更换的单元。</li>
<li>存储器路径（Memory paths）：这些路径通常会由于存储器输入上的建立时间较长以及存储器输出上的输出延迟较大而导致时序违规。</li>
</ul>
<h3 id="缺少多周期保持missing-multicycle-hold">缺少多周期保持（Missing Multicycle Hold）</h3>
<p>​ 对于多周期 N 设置规范，通常会看到缺少相应的多周期 N-1 保持规范。因此，这会导致在工具修复保持违规时插入大量不必要的延迟单元。</p>
<p>​ lesson：在修复之前始终审核保留违规，以确保正在修复的保留违规是真实的。</p>
<h3 id="路径未优化path-not-optimized">路径未优化（Path Not Optimized）</h3>
<p>​ STA违例也可能出现在尚未优化的路径上，可以通过检查数据路径来确定这种情况。是否存在延迟较大的单元？可以手动改善数据路径的时序吗？也许数据路径需要进一步优化，工具可能正在其它违例路径上工作。</p>
<h3 id="路径仍然不满足时序path-still-not-meeting-timing">路径仍然不满足时序（Path Still Not Meeting Timing）</h3>
<p>​ 如果数据路径具有强驱动能力的单元，而该路径仍然时序违例，则需要检查布线延迟和线负载较高的引脚。这可能是下一个改进方法：也许可以将单元移动得更近一些，从而可以减少线负载和布线延迟。</p>
<h3 id="如果仍然无法满足时序怎么办what-if-timing-still-cannot-be-met">如果仍然无法满足时序怎么办（What if Timing Still Cannot be Met）*</h3>
<p>​ 可以利用有用偏斜（useful skew）来帮助时序收敛。有用偏斜是指故意使时钟树失衡的地方，尤其是时序违例路径的发起时钟和捕获时钟路径，从而使时序在该路径上收敛。通常，这意味着可以延迟捕获时钟，以使捕获触发器的时钟在数据准备就绪稍后到达。当然，这假定了后续数据路径（即下一级触发器到触发器的数据路径）上有足够的裕量。</p>
<p>​ 也可以尝试相反的操作，也就是说，可以使发起时钟路径更短，以便更早地发起来自发起触发器的数据，从而帮助满足建立时间要求。同样，只有在前一级触发器到触发器路径具有多余的裕量时，才能做到这一点。</p>
<p>​ 有用偏斜技术不仅可用于修复建立时间违例，还可用于修复保持时间违例。此技术的一个缺点是，如果设计具有多种操作模式，则有用偏斜可能会在另一种模式下引起问题。</p>
<h2 id="验证时序约束validating-timing-constraints">验证时序约束（Validating Timing Constraints）</h2>
<p>​ 随着芯片尺寸的增长，将越来越依赖静态时序分析所交付的时序。仅依赖STA的风险在于STA取决于时序约束的合理与否。因此，时序约束的验证成为重要的考虑因素。</p>
<h3 id="检查路径例外checking-path-exceptions">检查路径例外（Checking Path Exceptions）</h3>
<p>​ 有一些工具可以根据设计的结构（网表）检查伪路径和多周期路径的有效性，这些工具会检查指定的伪路径或多周期路径约束是否有效。此外，这些工具还可能可以根据设计的结构生成缺少的伪路径和多周期路径约束。但是，这些工具生成的某些路径例外（path exception）也可能是无效的。这是因为这些工具通常使用形式验证技术（formal verification techniques）通过逻辑结构来确定伪路径或多周期路径，而设计人员对设计的功能行为有更深入的了解。因此，在接受并在STA中使用它们之前，设计人员需要检查工具生成的路径例外。可能还存在其它基于设计语义行为的路径例外，如果工具无法提取此类路径例外，设计者必须手动定义这些路径例外。</p>
<p>​ 时序约束中最大的风险就是路径例外。因此，应在仔细分析设计后确定出伪路径和多周期路径。通常，相比于伪路径，最好使用多周期路径，这确保了该路径至少受到一定程度的约束。如果在已知或可预期的时间会对信号进行采样，则无论信号离时钟沿有多远，都应使用多周期路径，这样静态时序分析至少可以知道一些时序约束的信息。伪路径可能会导致时序优化工具完全忽略这些路径，而实际上，它们确实可能在经过大量时钟周期后才被采样。</p>
<h3 id="检查时钟域交叉checking-clock-domain-crossing">检查时钟域交叉（Checking Clock Domain Crossing）</h3>
<p>​ 可用工具来确保设计中所有的跨时钟域均有效，这些工具还可以自动生成必要的伪路径约束。这样的工具也可能可以识别出非法（illegal）的跨时钟域，即数据在没有任何时钟同步逻辑的情况下跨越了两个不同时钟域。在这种情况下，这些工具可以提供在需要时自动插入合适的时钟同步逻辑的功能。请注意，并非所有跨异步时钟域都需要时钟同步器，应该取决于数据性质以及是否需要在下一个周期或几个周期后捕获数据。</p>
<p>​ 使用STA检查跨异步时钟域的另一种方法是设置一个很大的时钟不确定度（uncertainty），该不确定度等于采样时钟的周期。这样可以确保至少存在一些时序违例行为，根据这些时序违例行为，可以确定适当的路径例外，或者将时钟同步逻辑添加到设计中。</p>
<h3 id="验证-io-和时钟约束validating-io-and-clock-constraints">验证 IO 和时钟约束（Validating IO and Clock Constraints）</h3>
<p>​ 验证IO和时钟约束仍然是一个挑战，设计人员会经常进行时序仿真以检查设计中所有时钟的有效性。可以进行系统级时序仿真来验证IO时序，以确保芯片可以与其外围设备通信且没有任何时序问题。</p>
<h1 id="附录asdc">附录A:SDC</h1>
<blockquote>
<p>本附录将介绍1.7版本的SDC格式，此格式主要用于指定设计的时序约束。它不包含任何特定工具的命令，例如链接（link）和编译（compile）。它是一个文本文件，可以手写或由程序创建，并由程序读取。某些SDC命令仅适用于实现（implementation）或综合（synthesis），但是本附录会列出所有SDC命令。</p>
</blockquote>
<p>SDC语法是基于TCL的格式，即所有命令都遵循TCL语法。一个SDC文件会在文件开头包含SDC版本号，其次是设计约束，注释（注释以字符＃开始，并在行尾处结束）在SDC文件中可以散布在设计约束中。设计约束中较长的命令行可以使用反斜杠（）字符分成多行。</p>
<h2 id="a.1-基本命令">A.1 基本命令</h2>
<p>以下是SDC中的基本命令：</p>
<p>● <strong>current_instance</strong> [instance_pathname]</p>
<p>上述命令设置了设计的当前实例，这允许其它命令从该实例中设置或获取属性（attribute）。如果未提供任何参数，则当前实例将成为顶层（top-level）。</p>
<p>例子：</p>
<p>● <strong>current_instance</strong> /core/U2/UPLL</p>
<p>● <strong>current_instance</strong> .. （向上一层）</p>
<p>● <strong>current_instance</strong> （设为顶层）</p>
<p>● <strong>expr</strong> arg1 arg2 ... argn</p>
<p>● <strong>list</strong> arg1 arg2 ... argn</p>
<p>● <strong>set</strong> variable_name value</p>
<p>● <strong>set_hierarchy_separator</strong> separator</p>
<p>上述命令指定了SDC文件中使用的默认层次结构分隔符。在允许的情况下，可以通过在各个SDC命令中使用<strong>-hsc</strong>选项来覆盖此设置。</p>
<p>例子：</p>
<p>● <strong>set_hierarchy_separator</strong> /</p>
<p>● <strong>set_hierarchy_separator</strong> .</p>
<p>● <strong>set_units</strong> [<strong>-capacitance</strong> cap_unit] [<strong>-resistance</strong> res_units] [<strong>-time</strong> time_unit] [<strong>-voltage</strong> voltage_unit] [<strong>-current</strong> current_unit] [<strong>-power</strong> power_unit]</p>
<p>上述命令指定了SDC文件中使用的单位。</p>
<p>例子：</p>
<p>● <strong>set_units</strong> <strong>-capacitance</strong> pf <strong>-time</strong> ps</p>
<h2 id="a.2-对象访问命令">A.2 对象访问命令</h2>
<p>以下命令指定了如何访问设计实例中的对象。</p>
<p><strong>all_clocks</strong>命令会返回一个所有时钟的集合：</p>
<p>● <strong>foreach_in_collection</strong> clkvar [<strong>all_clocks</strong>]</p>
<p>● <strong>set_clock_transition</strong> 0.150 [<strong>all_clocks</strong>]</p>
<p><strong>all_inputs</strong> [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-clock</strong> clock_name] 命令会返回一个设计中所有输入端口的集合：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> VCLK 0.6 <strong>-min</strong> [<strong>all_inputs</strong>]</p>
<p><strong>all_outputs</strong> [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-clock</strong> clock_name] 命令会返回一个设计中所有输出端口的集合：</p>
<p>● <strong>set_load</strong> 0.5 [<strong>all_outputs</strong>]</p>
<p><strong>all_registers</strong> [<strong>-no_hierarchy</strong>] [<strong>-clock</strong> clock_name] [<strong>-rise_clock</strong> clock_name] [<strong>-fall_clock</strong> clock_name] [<strong>-cells</strong>] [<strong>-data_pins</strong>] [<strong>-clock_pins</strong>] [<strong>-slave_clock_pins</strong>] [<strong>-async_pins</strong>] [<strong>-output_pins</strong>] [<strong>-level_sensitive</strong>] [<strong>-edge_triggered</strong>] [<strong>-master_slave</strong>] 命令会返回一个具有指定属性的寄存器的集合：</p>
<p>● <strong>all_registers</strong> <strong>-clock</strong> DAC_CLK</p>
<p>上述这个命令返回的集合中为所有由时钟DAC_CLK触发的寄存器。</p>
<p><strong>current_design</strong> [design name] 命令会返回当前设计的名称。如果使用参数指定，则将会设置当前设计为指定的名称：</p>
<p>● <strong>current_design</strong> FADD</p>
<p>● <strong>current_design</strong></p>
<p><strong>get_cells</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个设计中与指定模型（pattern）匹配的单元的集合，通配符可用于匹配多个单元：</p>
<p>● <strong>get_cells</strong> RegEdge*</p>
<p>● <strong>foreach_in_collection</strong> cvar [<strong>get_cells</strong> <strong>-hierarchical</strong> *]</p>
<p><strong>get_clocks</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个设计中与指定模型匹配的时钟的集合。当在<strong>-from</strong>或<strong>-to</strong>等上下文中使用时，它将返回一个由指定时钟驱动的所有触发器的集合：</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_clocks</strong> SYS_CLK]</p>
<p>● <strong>set_multicycle_path</strong> <strong>-to</strong> [<strong>get_clocks</strong> jtag*]</p>
<p><strong>get_lib_cells</strong> [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会创建一个当前正在加载的库中并且与指定模型匹配的库单元的集合：</p>
<p>● <strong>get_lib_cells</strong> cmos131v/AOI3*</p>
<p><strong>get_lib_pins</strong> [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个与指定模型匹配的库单元引脚的集合。</p>
<p><strong>get_libs</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个设计中当前加载的库的集合。</p>
<p><strong>get_nets</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个与指定模型匹配的网络的集合：</p>
<p>● <strong>get_nets</strong> <strong>-hierarchical</strong> *</p>
<p>● <strong>get_nets</strong> FIFO_patt*</p>
<p><strong>get_pins</strong> [<strong>-hierarchical</strong>] [<strong>-hsc</strong> separator] [<strong>-regexp</strong>] [<strong>-nocase</strong>] [<strong>-of_objects</strong> objects] patterns 命令会返回一个与指定模型匹配的引脚名称的集合：</p>
<p>● <strong>get_pins</strong> *</p>
<p>● <strong>get_pins</strong> U1/U2/U3/UAND/Z</p>
<p><strong>get_ports</strong> [<strong>-regexp</strong>] [<strong>-nocase</strong>] patterns 命令会返回一个与指定模型匹配的设计（输入和输出）端口名称的集合：</p>
<p>● <strong>foreach_in_collection</strong> port_name [<strong>get_ports</strong> clk*]</p>
<p>可以在不“获取”对象的情况下引用诸如端口（port）之类的对象吗？当设计中只有一个具有该名称的对象时，实际上没有任何区别。但是，当多个对象具有相同的名称时，使用<strong>get_ *</strong> 命令将变得更加重要，它可以避免在引用哪种类型对象方面所带来的任何可能的混淆。假设有一个名为BIST_N1的网络和一个名为BIST_N1的端口，考虑以下SDC命令：</p>
<p>● <strong>set_load</strong> 0.05 BIST_N1</p>
<p>问题是要引用哪个BIST_N1？网络还是端口？在大多数情况下，最好明确表明对象的类型，例如：</p>
<p>● <strong>set_load</strong> 0.05 [<strong>get_nets</strong> BIST_N1]</p>
<p>现在再假设有一个时钟MCLK和另一个也称为MCLK的端口，考虑以下SDC命令：</p>
<p>● <strong>set_propagated_clock</strong> MCLK</p>
<p>该对象是引用名为MCLK的端口还是引用称为MCLK的时钟？在此特定情况下，它指的是时钟，因为这是<strong>set_propagated_clock</strong>命令的优先级所选择的。但是，要明确一点，最好明确表明对象类型，如下所示：</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_clocks</strong> MCLK]</p>
<p>● <strong>set_propagated_clock</strong> [<strong>get_ports</strong> MCLK]</p>
<p>有了这种明确的条件申明，就不必依赖优先级规则了，并且SDC命令会非常清楚。</p>
<h2 id="a.3-时序约束">A.3 时序约束</h2>
<p>本节将介绍与时序约束有关的SDC命令。</p>
<p><strong>create_clock</strong> <strong>-period</strong> period_value [<strong>-name</strong> clock_name] [<strong>-waveform</strong> edge_list] [<strong>-add</strong>] [source_objects] 命令可用于定义时钟。如果未指定clock_name，则时钟名称将是第一个源对象的名称。<strong>-period</strong>选项指定时钟周期，<strong>-add</strong>选项用于在已经具有时钟定义的引脚上创建时钟。否则，如果不使用此选项，则此时钟定义将覆盖该节点上任何其它现有的时钟定义。<strong>-waveform</strong>选项指定时钟的上升沿和下降沿（占空比），默认值为（0，period / 2）。如果时钟定义的节点位于另一个时钟之后的路径上，则它将阻塞该点之前一个时钟。</p>
<p>例子：</p>
<p>● <strong>create_clock</strong> <strong>-period</strong> 20 <strong>-waveform</strong> {0 6} <strong>-name</strong> SYS_CLK [<strong>get_ports</strong> SYS_CLK]</p>
<p>● <strong>create_clock</strong> <strong>-name</strong> CPU_CLK <strong>-period</strong> 2.33 <strong>-add</strong> [<strong>get_ports</strong> CPU_CLK]</p>
<p><strong>create_generated_clock</strong> [<strong>-name</strong> clock_name] [<strong>-source</strong> master_pin] [<strong>-edges</strong> edge_list] [<strong>-divide_by</strong> factor] [<strong>-multiply_by</strong> factor] [<strong>-duty_cycle</strong> percent] [<strong>-invert</strong>] [<strong>-edge_shift</strong> shift_list] [<strong>-add</strong>] [<strong>-master_clock</strong> clock] [<strong>-combinational</strong>] [source_objects] 命令可用于定义内部的衍生时钟。如果未指定<strong>-name</strong>，则时钟名称为第一个源对象的名称。<strong>-source</strong>指定衍生时钟的源是设计中的引脚或端口。如果有多个时钟输入源节点，必须使用<strong>-master_clock</strong>选项指定将这些时钟中的哪一个用作衍生时钟的源。<strong>-divide_by</strong>选项用于指定时钟的分频系数，与<strong>-multiply_by</strong>类似。<strong>-duty_cycle</strong>可以用于指定时钟的占空比。如果时钟的相位已反转，则可以指定<strong>-invert</strong>选项。除了使用时钟倍频或分频，还可以使用<strong>-edges</strong>和<strong>-edge_shift</strong>选项指定衍生时钟。<strong>-edges</strong>选项指定一个由三个数字组成的列表，该列表指定用于第一个上升沿、下一个下降沿和下一个上升沿的主时钟边沿。例如，可以将时钟分频器指定为<strong>-divide_by</strong> 2或<strong>-edges</strong> {1 3 5}。<strong>-edge_shift</strong>选项可以与<strong>-edges</strong>选项一起使用，以指定三个边沿中每个边沿的偏移量。</p>
<p>例子：</p>
<p>● <strong>create_generated_clock</strong> <strong>-divide_by</strong> 2 <strong>-source</strong> [<strong>get_ports</strong> sys_clk] <strong>-name</strong> gen_sys_clk [<strong>get_pins</strong> UFF/Q]</p>
<p>● <strong>create_generated_clock</strong> <strong>-add</strong> <strong>-invert</strong> <strong>-edges</strong> {1 2 8} <strong>-source</strong> [<strong>get_ports</strong> mclk] <strong>-name</strong> gen_clk_div</p>
<p>● <strong>create_generated_clock</strong> <strong>-multiply_by</strong> 3 <strong>-source</strong> [<strong>get_ports</strong> ref_clk] <strong>-master_clock</strong> clk10MHz [<strong>get_pins</strong> UPLL/CLKOUT] <strong>-name</strong> gen_pll_clk</p>
<p><strong>group_path</strong> [<strong>-name</strong> group_name] [<strong>-default</strong>] [<strong>-weight</strong> weight_value] [<strong>-from</strong> from_list] [<strong>-rise_from</strong> from_list] [<strong>-fall_from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-rise_to</strong> to_list] [<strong>-fall_to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_through</strong> through_list] [<strong>-fall_through</strong> through_list] 命令可以为指定的路径组命名。</p>
<p><strong>set_clock_gating_check</strong> [<strong>-setup</strong> setup_value] [<strong>-hold</strong> hold_value] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-high</strong>] [<strong>-low</strong>] [object_list] 命令可以提供对任何对象指定时钟门控检查的功能。时钟门控检查仅在具有时钟信号的逻辑门处执行，默认情况下建立时间和保持时间值为0。</p>
<p>例子：</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-setup</strong> 0.15 <strong>-hold</strong> 0.05 [<strong>get_clocks</strong> ck20m]</p>
<p>● <strong>set_clock_gating_check</strong> <strong>-hold</strong> 0.3 [<strong>get_cells</strong> U0/clk_divider/UAND1]</p>
<p><strong>set_clock_groups</strong> [<strong>-name</strong> name] [<strong>-logically_exclusive</strong>] [<strong>-physically_exclusive</strong>] [<strong>-asynchronous</strong>] [<strong>-allow_paths</strong>] <strong>-group</strong> clock_list 命令指定了一组具有特定属性的时钟，并为该组分配了一个名称。</p>
<p><strong>set_clock_latency</strong> [<strong>-rayise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-source</strong>] [<strong>-late</strong>] [<strong>-early</strong>] [<strong>-clock</strong> clock_list] delay object_list 命令指定给定时钟的时钟延迟。有两种类型的延迟：网络延迟和源延迟。源延迟是时钟定义引脚与其源之间的时钟网络延迟，而网络延迟是时钟定义引脚与触发器时钟引脚之间的时钟网络延迟。</p>
<p>例子：</p>
<p>● <strong>set_clock_latency</strong> 1.86 [<strong>get_clocks</strong> clk250]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-late</strong> <strong>-rise</strong> 2.5 [<strong>get_clocks</strong> MCLK]</p>
<p>● <strong>set_clock_latency</strong> <strong>-source</strong> <strong>-late</strong> <strong>-fall</strong> 2.3 [<strong>get_clocks</strong> MCLK]</p>
<p><strong>set_clock_sense</strong> [<strong>-positive</strong>] [<strong>-negative</strong>] [<strong>-pulse</strong> pulse] [<strong>-stop_propagation</strong>] [<strong>-clock</strong> clock_list] pin_list 命令在引脚上设置时钟属性。</p>
<p><strong>set_clock_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] transition_clock_list 命令指定时钟定义点处的时钟过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_clock_transition</strong> <strong>-min</strong> 0.5 [<strong>get_clocks</strong> SERDES_CLK]</p>
<p>● <strong>set_clock_transition</strong> <strong>-max</strong> 1.5 [<strong>get_clocks</strong> SERDES_CLK]</p>
<p><strong>set_clock_uncertainty</strong> [<strong>-from</strong> from_clock] [<strong>-rise_from</strong> rise_from_clock] [<strong>-fall_from</strong> fall_from_clock] [<strong>-to</strong> to_clock] [<strong>-rise_to</strong> rise_to_clock] [<strong>-fall_to</strong> fall_to_clock] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-setup</strong>] [<strong>-hold</strong>] uncertainty [object_list] 命令指定了时钟或时钟到时钟传输的时钟不确定度。STA将从路径的数据需要到达时间中减去建立时间不确定度，并将保持时间不确定度增加到路径的数据需要到达时间中。</p>
<p>例子：</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-setup</strong> <strong>-rise</strong> <strong>-fall</strong> 0.2 [<strong>get_clocks</strong> CLK2]</p>
<p>● <strong>set_clock_uncertainty</strong> <strong>-from</strong> [<strong>get_clocks</strong> HSCLK] <strong>-to</strong> [<strong>get_clocks</strong> SYSCLK] <strong>-hold</strong> 0.35</p>
<p><strong>set_data_check</strong> [<strong>-from</strong> from_object] [<strong>-to</strong> to_object] [<strong>-rise_from</strong> from_object] [<strong>-fall_from</strong> from_object] [<strong>-rise_to</strong> to_object] [<strong>-fall_to</strong> to_object] [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-clock</strong> clock_object] value 命令在两个数据引脚之间执行指定的检查。</p>
<p>例子：</p>
<p>● <strong>set_data_check</strong> <strong>-from</strong> [<strong>get_pins</strong> UBLK/EN] <strong>-to</strong> [<strong>get_pins</strong> UBLK/D] <strong>-setup</strong> 0.2</p>
<p><strong>set_disable_timing</strong> [<strong>-from</strong> from_pin_name] [<strong>-to</strong> to_pin_name] cell_pin_list 命令中断了指定单元内的时序弧。</p>
<p>例子：</p>
<p>● <strong>set_disable_timing</strong> <strong>-from</strong> A <strong>-to</strong> ZN [<strong>get_cells</strong> U1]</p>
<p><strong>set_false_path</strong> [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] 命令指定了STA不需要考虑的路径例外。</p>
<p>● <strong>set_false_path</strong> <strong>-from</strong> [<strong>get_clocks</strong> jtag_clk] <strong>-to</strong> [<strong>get_clocks</strong> sys_clk]</p>
<p>● <strong>set_false_path</strong> <strong>-through</strong> U1/A <strong>-through</strong> U4/ZN</p>
<p><strong>set_ideal_latency</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] delay object_list 命令用于为特定对象设置理想的延迟。</p>
<p><strong>set_ideal_network</strong> [<strong>-no_propagate</strong>] object_list 命令将指定设计中理想网络的源节点。</p>
<p><strong>set_ideal_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] transition_time object_list 命令将指定理想网络的过渡时间。</p>
<p><strong>set_input_delay</strong> [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-max</strong>] [<strong>-min</strong>] [<strong>-add_delay</strong>] [<strong>-network_latency_included</strong>] [<strong>-source_latency_included</strong>] delay_value port_pin_list 命令将指定相对于指定时钟的输入端口数据到达时间，默认为时钟的上升沿。<strong>-add_delay</strong>选项允许向该引脚或端口添加多个约束，可以使用此<strong>-add_delay</strong>选项将时钟设置为不同的时钟。默认情况下，会将发起时钟的时钟源延迟添加到输入延迟值中，但是当指定了<strong>-source_latency_included</strong>选项时，由于假设已将源网络延迟添加到了输入延迟值中，因此不再添加源网络延迟。<strong>-max</strong>选项指定的延迟用于建立时间和恢复时间检查，而<strong>-min</strong>选项指定的延迟用于保持时间和撤销时间检查。如果仅指定<strong>-min</strong>或<strong>-max</strong>或两者均未指定，则两者将使用相同的值。</p>
<p>例子：</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> SYSCLK 1.1 [<strong>get_ports</strong> MDIO*]</p>
<p>● <strong>set_input_delay</strong> <strong>-clock</strong> virtual_mclk 2.5 [<strong>all_inputs</strong>]</p>
<p><strong>set_max_delay</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] delay_value 命令用于设置指定路径上的最大延迟。这个命令用于指定两个任意引脚之间的延迟，而不是从一个触发器到另一个触发器的延迟。</p>
<p>例子：</p>
<p>● <strong>set_max_delay</strong> <strong>-from</strong> [<strong>get_clocks</strong> FIFOCLK] <strong>-to</strong> [<strong>get_clocks</strong> MAINCLK] 3.5</p>
<p>● <strong>set_max_delay</strong> <strong>-from</strong> [<strong>all_inputs</strong>] <strong>-to</strong> [<strong>get_cells</strong> UCKDIV/UFF1/D] 2.66</p>
<p><strong>set_max_time_borrow</strong> delay_value object_list 命令可用于设置在分析锁存器路径时可以借用的最长时间。</p>
<p>例子：</p>
<p>● <strong>set_max_time_borrow</strong> 0.6 [<strong>get_pins</strong> CORE/CNT_LATCH/D]</p>
<p><strong>set_min_delay</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] delay_value 命令用于设置指定路径上的最小延迟，该延迟可以在任意两个引脚之间。</p>
<p>例子：</p>
<p>● <strong>set_min_delay</strong> <strong>-from</strong> U1/S <strong>-to</strong> U2/A 0.6</p>
<p>● <strong>set_min_delay</strong> <strong>-from</strong> [<strong>get_clocks</strong> PCLK] <strong>-to</strong> [<strong>get_pins</strong> UFF/*/S]</p>
<p><strong>set_multicycle_path</strong> [<strong>-setup</strong>] [<strong>-hold</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-start</strong>] [<strong>-end</strong>] [<strong>-from</strong> from_list] [<strong>-to</strong> to_list] [<strong>-through</strong> through_list] [<strong>-rise_from</strong> rise_from_list] [<strong>-rise_to</strong> rise_to_list] [<strong>-rise_through</strong> rise_through_list] [<strong>-fall_from</strong> fall_from_list] [<strong>-fall_to</strong> fall_to_list] [<strong>-fall_through</strong> fall_through_list] path_multiplier 命令将路径指定为多周期路径，可以使用多个<strong>-through</strong>选项。如果多周期路径仅用于建立时间检查，请使用<strong>-setup</strong>选项，而如果多周期路径用于保持时间检查，请使用<strong>-hold</strong>选项。如果<strong>-setup</strong>或<strong>-hold</strong>均未指定，则默认为<strong>-setup</strong>且默认的保持时间周期为0。<strong>-start</strong>选项指定了时钟周期数使用的是发起时钟的 ，而<strong>-end</strong>选项指定使用的是捕获时钟的，默认值为<strong>-start</strong>。<strong>-hold</strong>选项指定的时钟周期数表示需要偏离默认多周期保持时间值0的时钟沿数。</p>
<p>例子：</p>
<p>● <strong>set_multicycle_path</strong> <strong>-start</strong> <strong>-setup</strong> <strong>-from</strong> [<strong>get_clocks</strong> PCLK] <strong>-to</strong> [<strong>get_clocks</strong> MCLK] 4</p>
<p>● <strong>set_multicycle_path</strong> <strong>-hold</strong> <strong>-from</strong> UFF1/Q <strong>-to</strong> UCNTFF/D 2</p>
<p>● <strong>set_multicycle_path</strong> <strong>-setup</strong> <strong>-to</strong> [<strong>get_pins</strong> UEDGEFF*] 4</p>
<p><strong>set_output_delay</strong> [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] [<strong>-level_sensitive</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-max</strong>] [<strong>-min</strong>] [<strong>-add_delay</strong>] [<strong>-network_delay_included</strong>] [<strong>-source_latency_included</strong>] delay_value port_pin_list 命令可以指定相对于时钟的输出所需时间，默认是上升沿。默认情况下，时钟源延迟会添加到输出延迟值中，但是当指定<strong>-source_latency_included</strong>选项时，不会添加时钟延迟值，因为会假定它已包含在输出延迟值中。<strong>-add_delay</strong>选项可用于在一个引脚/端口上指定多个<strong>set_output_delay</strong>。</p>
<p><strong>set_propagated_clock</strong> object_list 命令指定时钟延迟需要计算，即不是理想的。</p>
<p>● <strong>set_propagated_clock</strong> [<strong>all_clocks</strong>]</p>
<h2 id="a.4-环境命令">A.4 环境命令</h2>
<p>本节介绍了用于设置待分析设计环境的命令。</p>
<p><strong>set_case_analysis</strong> value port_or_pin_list 命令用于指定被设置为常数的端口或引脚。</p>
<p>例子：</p>
<p>● <strong>set_case_analysis</strong> 0 [<strong>get_pins</strong> UDFT/MODE_SEL]</p>
<p>● <strong>set_case_analysis</strong> 1 [<strong>get_ports</strong> SCAN_ENABLE]</p>
<p><strong>set_drive</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] resistance port_list 命令用于指定输入端口的驱动强度，它指定端口的外部驱动电阻，值为0表示驱动强度是最高的。</p>
<p>例子：</p>
<p>● <strong>set_drive</strong> 0 {CLK RST}</p>
<p><strong>set_driving_cell</strong> [<strong>-lib_cell</strong> lib_cell_name] [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-library</strong> lib_name] [<strong>-pin</strong> pin_name] [<strong>-from_pin</strong> from_pin_name] [<strong>-multiply_by</strong> factor] [<strong>-dont_scale</strong>] [<strong>-no_design_rule</strong>] [<strong>-input_transition_rise</strong> rise_time] [<strong>-input_transition_fall</strong> fall_time] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] port_list 命令用于模拟驱动输入端口的单元的驱动电阻。</p>
<p>例子：</p>
<p>● <strong>set_driving_cell</strong> <strong>-lib_cell</strong> BUFX4 <strong>-pin</strong> ZN [<strong>all_inputs</strong>]</p>
<p><strong>set_fanout_load</strong> value port_list 命令在输出端口上设置指定的扇出负载。</p>
<p>例子：</p>
<p>● <strong>set_fanout_load</strong> 5 [<strong>all_outputs</strong>]</p>
<p><strong>set_input_transition</strong> [<strong>-rise</strong>] [<strong>-fall</strong>] [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-clock</strong> clock_name] [<strong>-clock_fall</strong>] transition port_list 命令指定了输入端口上的过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_input_transition</strong> 0.2 [<strong>get_ports</strong> SD_DIN*]</p>
<p>● <strong>set_input_transition</strong> <strong>-rise</strong> 0.5 [<strong>get_ports</strong> GPIO*]</p>
<p><strong>set_load</strong> [<strong>-min</strong>] [<strong>-max</strong>] [<strong>-subtract_pin_load</strong>] [<strong>-pin_load</strong>] [<strong>-wire_load</strong>] value objects 命令用于指定在设计中引脚或网络上的电容性负载的值。<strong>-subtract_pin_load</strong>选项表示从指定负载中减去引脚电容。</p>
<p>例子：</p>
<p>● <strong>set_load</strong> 50 [<strong>all_outputs</strong>]</p>
<p>● <strong>set_load</strong> 0.1 [<strong>get_pins</strong> UFF0/Q]</p>
<p>● <strong>set_load</strong> <strong>-subtract_pin_load</strong> 0.025 [<strong>get_nets</strong> UCNT0/NET5]</p>
<p><strong>set_logic_dc</strong> port_list 命令、<strong>set_logic_one</strong> port_list 命令以及<strong>set_logic_zero</strong> port_list 命令将指定的端口设置为不关心（don't care）、逻辑1或逻辑0。</p>
<p>例子：</p>
<p>● <strong>set_logic_dc</strong> SE</p>
<p>● <strong>set_logic_one</strong> TEST</p>
<p>● <strong>set_logic_zero</strong> [<strong>get_pins</strong> USB0/USYNC_FF1/Q]</p>
<p><strong>set_max_area</strong> area_value 命令指定了当前设计的最大面积限制。</p>
<p>例子：</p>
<p>● <strong>set_max_area</strong> 20000.0</p>
<p><strong>set_max_capacitance</strong> value object_list 命令指定了端口或设计中的最大电容。如果是设计，则指定了设计中所有引脚的最大电容。</p>
<p>● <strong>set_max_capacitance</strong> 0.2 [<strong>current_design</strong>]</p>
<p>● <strong>set_max_capacitance</strong> 1 [<strong>all_outputs</strong>]</p>
<p><strong>set_max_fanout</strong> value object_list 命令指定了端口或设计中的最大扇出值。如果是设计，则指定了设计中所有输出引脚的最大扇出值。</p>
<p>● <strong>set_max_fanout</strong> 16 [<strong>get_pins</strong> UDFT0/JTAG/ZN]</p>
<p>● <strong>set_max_fanout</strong> 50 [<strong>current_design</strong>]</p>
<p><strong>set_max_transition</strong> [<strong>-clock_path</strong>] [<strong>-data_path</strong>] [<strong>-rise</strong>] [<strong>-fall</strong>] value object_list 命令指定了端口或设计中的最大过渡时间。如果是设计，则指定了设计中所有引脚上的最大过渡时间。</p>
<p>例子：</p>
<p>● <strong>set_max_transition</strong> 0.2 UCLKDIV0/QN</p>
<p><strong>set_min_capacitance</strong> value object_list 命令指定了设计中端口或引脚上的最小电容值。</p>
<p>例子：</p>
<p>● <strong>set_min_capacitance</strong> 0.05 UPHY0/UCNTR/B1</p>
<p><strong>set_operating_conditions</strong> [<strong>-library</strong> lib_name] [<strong>-analysis_type</strong> type] [<strong>-max</strong> max_condition] [<strong>-min</strong> min_condition] [<strong>-max_library</strong> max_lib] [<strong>-min_library</strong> min_lib] [<strong>-object_list</strong> objects] [condition] 命令可以设置用于时序分析的工作条件。分析类型可以是single（单个情况），bc_wc（最佳情况/最差情况）或者on_chip_variation（片上变化）。可以使用<strong>operating_conditions</strong>命令在库中定义工作条件。</p>
<p>例子：</p>
<p>● <strong>set_operating_conditions</strong> <strong>-analysis_type</strong> bc_wc</p>
<p>● <strong>set_operating_conditions</strong> WCCOM</p>
<p>● <strong>set_operating_conditions</strong> <strong>-analysis_type</strong> on_chip_variation</p>
<p><strong>set_port_fanout_number</strong> value port_list 命令可用于设置端口的最大扇出数。</p>
<p>例子：</p>
<p>● <strong>set_port_fanout_number</strong> 10 [<strong>get_ports</strong> GPIO*]</p>
<p><strong>set_resistance</strong> [<strong>-min</strong>] [<strong>-max</strong>] value list_of_nets 命令可用于设置指定网络上的电阻。</p>
<p>例子：</p>
<p>● <strong>set_resistance</strong> 10 <strong>-min</strong> U0/U1/NETA</p>
<p>● <strong>set_resistance</strong> 50 <strong>-max</strong> U0/U1/NETA</p>
<p><strong>set_timing_derate</strong> [<strong>-cell_delay</strong>] [<strong>-cell_check</strong>] [<strong>-net_delay</strong>] [<strong>-data</strong>] [<strong>-clock</strong>] [<strong>-early</strong>] [<strong>-late</strong>] derate_value [object_list] 命令指定了降额系数。</p>
<p><strong>set_wire_load_min_block_size</strong> size 命令指定了将线负载模型设置为“enclosed”时使用的最小的块大小。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_min_block_size</strong> 5000</p>
<p><strong>set_wire_load_mode</strong> mode_name 命令定义了如何对分层设计（hierarchical design）中的网络使用线负载模型的机制。mode_name可以是top，enclosure或segmented。top模式规定在顶层定义的线负载模型将用于所有较低级别上。enclosure模式规定完全封闭在模块中的网络的线负载模型用于该网络。segmented模式规定模块中的网络段使用该模块的线负载模型。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_mode</strong> enclosed</p>
<p><strong>set_wire_load_model</strong> <strong>-name</strong> model_name [<strong>-library</strong> lib_name] [<strong>-min</strong>] [<strong>-max</strong>] [object_list] 命令定义了用于当前设计或指定网络的线负载模型。</p>
<p>例子：</p>
<p>● <strong>set_wire_load_model</strong> <strong>-name</strong> "eSiliconLightWLM"</p>
<p><strong>set_wire_load_selection_group</strong> [<strong>-library</strong> lib_name] [<strong>-min</strong>] [<strong>-max</strong>] group_name [object_list] 命令会在根据块的单元面积确定线负载模型时，为设计设置线负载选择组，该选择组通常在技术库中定义。</p>
<h2 id="a.5-多电压命令">A.5 多电压命令</h2>
<p>当设计中存在多电压岛（multi-voltage islands）时，以下命令适用。</p>
<p><strong>create_voltage_area</strong> <strong>-name</strong> name [<strong>-coordinate</strong> coordinate_list] [<strong>-guard_band_x</strong> float] [<strong>-guard_band_y</strong> float] cell_list</p>
<p><strong>set_level_shifter_strategy</strong> [<strong>-rule</strong> rule_type]</p>
<p><strong>set_level_shifter_threshold</strong> [<strong>-voltage</strong> float] [<strong>-percent</strong> float]</p>
<p><strong>set_max_dynamic_power</strong> power [unit] 命令指定了最大动态功率。</p>
<p>例子：</p>
<p>● <strong>set_max_dynamic_power</strong> 0 mw</p>
<p><strong>set_max_leakage_power</strong> power [unit] 命令指定了最大漏电功率。</p>
<p>例子：</p>
<p>● <strong>set_max_leakage_power</strong> 12 mw</p>
<h1 id="附录bsdf">附录B:SDF</h1>
<blockquote>
<p>本附录将介绍标准延迟标注格式，并说明了如何在仿真中执行反标。</p>
</blockquote>
<p>延迟格式描述了设计网表的单元延迟和互连走线延迟，无论设计是用两种主要硬件描述语言（VHDL或Verilog HDL）中的哪一种所描述的。</p>
<p>本章还会介绍仿真的反标（backannotation），STA的反标其实是一个简单直接的过程，其中DUA中的时序弧将由SDF所指定的延迟进行标注。</p>
<h2 id="b.1-什么是sdf">B.1 什么是SDF？</h2>
<p>SDF是指标准延迟格式（Standard Delay Format）。它是一个IEEE标准——IEEE Std1497，它是ASCII文本文件，它描述了时序信息和约束，其目的是用作各种工具之间的文本类型的时序信息交换媒介，它也可以用来描述需要它的工具的时序数据。由于它是IEEE标准，因此由一个工具生成的时序信息可以被支持该标准的许多其它工具所使用。SDF中的数据与工具和语言都无关，且包括了互连走线延迟、器件延迟以及时序检查的规范。</p>
<p>由于SDF是ASCII文件，因此它易于阅读，尽管对于实际设计而言，这些文件往往很大。但是，它是作为工具之间的交换媒介。经常在进行信息交换时，一个工具可能会在生成SDF文件时产生一个问题，而另一个读取SDF的工具可能无法正确读取SDF。读取SDF的工具可能会在读取SDF时产生一个错误或警告，或者它可能会错误地解释SDF中的值。在这种情况下，设计人员可能必须查看SDF文件，看看出了什么问题。本章介绍了SDF文件的基础知识，并提供了必要和足够的信息，以帮助理解和调试任何标注问题。</p>
<p>图B-1显示了如何使用SDF文件的典型流程。时序计算工具通常会生成时序信息存储在SDF文件中。然后，通过读取SDF的工具将该信息反标到设计中。请注意，完整的设计信息不会都存储到SDF文件中，而只会存储延迟值。例如，实例名称和实例的引脚名称将被存储到SDF文件中，因为它们对于指定实例相关或引脚相关的延迟是必需的。因此，必须为SDF生成工具和SDF读取工具提供相同的设计。</p>
<p><img src="https://pic3.zhimg.com/80/v2-ecd6657bd53a0b42922cf29e0791ce96_720w.jpg" alt="图B-1"></p>
<p>一个设计可以具有多个与之关联的SDF文件。可以为一个设计创建一个SDF文件，在分层设计中，也可以为分层中的每个块创建多个SDF文件。在标注期间，每个SDF都将应用于适当的分层实例中，如图B-2所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-e94cf2f197e57648d209e2e296787f33_720w.jpg" alt="图B-2"></p>
<p>SDF文件包含了用于反标和标注的时序数据。更具体地说，它包含：</p>
<p>● 单元延迟（Cell delays）</p>
<p>● 脉冲传播（Pulse propagation）</p>
<p>● 时序检查（Timing checks）</p>
<p>● 互连走线延迟（Interconnect delays）</p>
<p>● 时序环境（Timing environment）</p>
<p>引脚到引脚的延迟（pin-to-pin delay）和分布式延迟（distributed delay）都可以针对单元延迟进行建模。引脚到引脚的延迟使用<strong>IOPATH</strong>结构（construct）表示，这些结构定义了每个单元输入到输出的路径延迟。<strong>COND</strong>结构还可以用于额外指定有条件的引脚到引脚延迟。状态相关（state-dependent）的路径延迟也可以使用<strong>COND</strong>结构来指定，分布式延迟的建模是使用<strong>DEVICE</strong>结构指定的。</p>
<p>脉冲传播结构——<strong>PATHPULSE</strong>和<strong>PATHPULSEPERCENT</strong>可用于指定使用引脚到引脚延迟模型时允许传播到单元输出端口的毛刺大小。</p>
<p>可以在SDF中指定的时序检查包括：</p>
<p>● 建立时间：SETUP，SETUPHOLD</p>
<p>● 保持时间：HOLD，SETUPHOLD</p>
<p>● 恢复时间：RECOVERY，RECREM</p>
<p>● 撤销时间：REMOVAL，RECREM</p>
<p>● 最大偏斜：SKEW，BIDIRECTSKEW</p>
<p>● 最小脉冲宽度：WIDTH</p>
<p>● 最小周期：PERIOD</p>
<p>● 不变化：NOCHANGE</p>
<p>时序检查中的信号可能存在某些条件。在时序检查中允许使用负值，不支持负值的工具可以选择将其替换为零。</p>
<p>SDF描述中支持三种类型的互连走线建模。<strong>INTERCONNECT</strong>结构是最通用且最常用的，可用于指定点对点延迟（从源端到接收端），因此单个网络可以具有多个<strong>INTERCONNECT</strong>结构。<strong>PORT</strong>结构可用于指定负载端口处的网络延迟，假定网络只有一个源端驱动。<strong>NETDELAY</strong>结构可用于指定整个网络的延迟，而无需考虑其源端或接收端，因此是指定网络上延迟的最不具体的方法。</p>
<p>时序环境提供了设计在工作时所依据的信息，这些信息包括<strong>ARRIVAL</strong>，<strong>DEPARTURE</strong>，<strong>SLACK</strong>和<strong>WAVEFORM</strong>结构。这些结构主要用于标注，例如可用于综合。</p>
<h2 id="b.2-sdf格式">B.2 SDF格式</h2>
<p>SDF文件包含一个首部（header section），后跟一个或多个单元。每个单元代表设计中的一个区域或范围，它可以是库原语（primitive）或用户自定义的黑盒。</p>
<p><img src="https://pic1.zhimg.com/80/v2-32c338d91631d725594577be36353fe0_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-1b4881894fc3ec6ff1263e2e99283d98_720w.png"></p>
<p>首部包含一般信息，除了层次结构分隔符、时间刻度（timescale）和SDF版本号外，都不会影响SDF文件的语义。默认情况下，层次结构分隔符<strong>DIVIDER</strong>是点字符（“.”）。通过以下方法，可以将其替换为“/”字符：</p>
<p>● （<strong>DIVIDER</strong> /）</p>
<p>如果首部中没有时间刻度信息，则默认值为1ns。否则，可以使用以下命令明确指定时间刻度<strong>TIMESCALE</strong>：</p>
<p>● （<strong>TIMESCALE</strong> 10ps）</p>
<p>也就是说，将SDF文件中指定的所有延迟值乘以10ps。</p>
<p>SDF版本号<strong>SDFVERSION</strong>是必需的，SDF文件的使用者会根据它来确保文件符合指定的SDF版本。首部中可能存在的其它信息（属于常规信息类别）包括日期、程序名称、版本和工作条件。</p>
<p><img src="https://pic3.zhimg.com/80/v2-577b099dcdbd269c15847aca12e30a66_720w.jpg"></p>
<p>首部之后是一个或多个单元的描述，每个单元在设计中代表一个或多个实例（使用通配符），单元可以是库原语或分层块（hierarchical block）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fe6bfaad0613dedb373ad17b1277fe91_720w.jpg"></p>
<p>单元的顺序很重要，因为数据是从上到下进行处理的。后面的单元描述可以覆盖前面的单元描述所指定的时序信息（通常，两次定义同一单元实例的时序信息并不常见）。另外，可以将时序信息标注为绝对值或增量的形式。如果时序信息使用增量的形式，它将会把新值添加到现有值中。而如果时序信息是绝对值，它将覆盖任何先前指定的时序信息。</p>
<p>单元实例可以是分层实例名称。用于层次结构分隔的分隔符必须符合首部中指定的分隔符。单元实例名称可以选择为“ * ”字符，即通配符，这表示指定类型的所有单元实例。</p>
<p><img src="https://pic2.zhimg.com/80/v2-fc80b331cfbceb028f05ba6436b635a5_720w.jpg"></p>
<p>单元中可以描述四种类型的时序规范：</p>
<p>● <strong>DELAY</strong>：用于描述延迟</p>
<p>● <strong>TIMINGCHECK</strong>：用于描述时序检查</p>
<p>● <strong>TIMINGENV</strong>：用于描述时序环境</p>
<p>● <strong>LABEL</strong>：声明可用于描述延迟的时序模型变量。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-71e1306389fda36a3736c4355c3e6a5e_720w.jpg"></p>
<p><strong>DELAY</strong>时序规范有四种类型：</p>
<p>● <strong>ABSOLUTE</strong>：在反标期间替换单元实例的现有延迟值。</p>
<p>● <strong>INCREMETN</strong>：将新的延迟数据添加到单元实例的任何现有延迟值。</p>
<p>● <strong>PATHPULSE</strong>：指定设计输入和输出之间的脉冲传播极限。此极限值用于决定是将出现在输入上的脉冲传播到输出，还是将其标记为“ X ”，或者将其滤除。</p>
<p>● <strong>PATHPULSEPERCENT</strong>：除了值以百分比表示外，这与<strong>PATHPULSE</strong>完全相同。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-dd3ec3554236c12e4fa6fc701cd4b44c_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8bc0512afe629aec62d694de4a60fec5_720w.png"></p>
<p>RN和Q是单元的输入端口和输出端口。第一个值3是脉冲抑制极限（pulse rejection limit），称为r-limit，它定义了可以出现在输出上的最窄脉冲。窄于此的任何脉冲都会被拒绝通过，也就是说，它将不会出现在输出上。第二个值7（如果存在）是错误极限（error limit），也称为e-limit。任何小于e-limit的脉冲都会导致输出为“ X ”。e-limit必须大于r-limit，如图B-3所示。 当出现小于3（r-limit）的脉冲时，该脉冲不会传播到输出；当脉冲宽度在3（r-limit）和7（e-limit）之间时，输出为X ；当脉冲宽度大于7（e-limit）时，脉冲会传播到输出且没有任何滤除（unfiltered）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7a44bc7feaf5240b72fc659a73e49b0d_720w.jpg" alt="图B-3"></p>
<p>可以使用<strong>ABSOLUTE</strong>或<strong>INCREMENT</strong>描述八种延迟定义：</p>
<p>● <strong>IOPATH</strong>：输入到输出路径的延迟。</p>
<p>● <strong>RETAIN</strong>：保留时间定义，可以用于指定输出端口在其相关输入端口改变后应保留其先前值的时间。</p>
<p>● <strong>COND</strong>：条件路径延迟，可以用于指定状态相关的输入到输出路径延迟。</p>
<p>● <strong>CONDELSE</strong>：默认路径延迟，可以用于指定条件路径的默认值。</p>
<p>● <strong>PORT</strong>：端口延迟，可以用于指定互连走线延迟，该延迟被建模为输入端口的延迟。</p>
<p>● <strong>INTERCONNECT</strong>：互连走线延迟，可以用于指定从其源端到接收端的整个网络的传播延迟。</p>
<p>● <strong>NETDELAY</strong>：网络延迟，可以用于指定从一个网络的所有源端到所有接收端的传播延迟。</p>
<p>● <strong>DEVICE</strong>：器件延迟，主要用于描述分布式时序模型，可以用于指定通过单元到输出端口的所有路径的传播延迟。</p>
<p>以下是一些例子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-26486eadc451e8cf4b3ba11d9a90c44d_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-000889b7625a146ea8cd833cbdd586d0_720w.jpg"></p>
<p>输入A上的值发生更改后，Y将保留其先前值50ps（低电平为40ps）。50ps是保持高电平的值，40ps是保持低电平的值，101ps是传播上升沿延迟，90ps是传播下降沿延迟，如图B-4所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8f5362a1813e5826d56cf53189078208_720w.jpg" alt="图B-4"></p>
<p><img src="https://pic3.zhimg.com/80/v2-064e1ab89c1059a05fa4327a5c3601f2_720w.jpg"></p>
<h3 id="延迟">延迟</h3>
<p>到目前为止，我们已经看过了许多不同形式的延迟，其实延迟规范还有其它形式。通常，可以将延迟指定为一个、两个、三个、六个或十二个令牌（token）的集合，这些令牌可用于描述以下过渡的延迟：0-&gt; 1、1-&gt; 0、0-&gt; Z，Z-&gt; 1，1-&gt; Z，Z-&gt; 0，0-&gt; X，X-&gt; 1,1-&gt; X，X-&gt; 0，X-&gt; Z，Z-&gt; X。下表展示了如何使用少于十二个延迟令牌来表示十二种过渡情况。</p>
<p><img src="https://pic3.zhimg.com/80/v2-418bcbad04cfac55e68b987108dd126a_720w.jpg"></p>
<p>以下是这些延迟的一些示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2411c1a4d95992b3c3cb7ad538f77938_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0efbda04e3b93496dae44e52e7d662ea_720w.jpg"></p>
<p>每个延迟令牌可以依次写为一个、两个或三个值，如以下示例所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a25316d9a9dc68a981aed38dd574ed02_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-d7cdbec2a0e38c883521a18500fd5ece_720w.jpg"></p>
<p>一个SDF文件中的延迟值可以使用有符号的实数或以下形式的三元数组来编写：</p>
<p>● （ 8.0：3.6：9.8 ）</p>
<p>为了表示出设计在三个工艺工作条件下的最小、典型以及最大延迟，注释器通常会根据用户提供的选项来决定去选择哪个值。三元数组形式中的值是可选的，但是至少应有一个。例如，以下形式是规范的：</p>
<p>● （ ： ： 0.22）</p>
<p>● （ 1.001 ： ： 0.998 ）</p>
<p>未指定的值就不会去标注。</p>
<h3 id="时序检查">时序检查</h3>
<p>在以<strong>TIMINGCHECK</strong>关键字开头的部分中指定了时序检查的极限。在任何这些检查中，可以使用<strong>COND</strong>结构指定有条件的时序检查。在某些情况下，可以指定两个额外的条件检查<strong>SCOND</strong>和<strong>CCOND</strong>，它们与<strong>stamp event</strong>和<strong>check event</strong>关联。</p>
<p>以下是一组检查：</p>
<p>● <strong>SETUP</strong>：建立时间检查</p>
<p>● <strong>HOLD</strong>：保持时间检查</p>
<p>● <strong>SETUPHOLD</strong>：建立时间和保持时间检查</p>
<p>● <strong>RECOVERY</strong>：恢复时间检查</p>
<p>● <strong>REMOVAL</strong>：撤销时间检查</p>
<p>● <strong>RECREM</strong>：恢复时间和撤销时间检查</p>
<p>● <strong>SKEW</strong>：单向偏斜时序检查</p>
<p>● <strong>BIDIRECTSKEW</strong>：双向偏斜时序检查</p>
<p>● <strong>WIDTH</strong>：脉宽时序检查</p>
<p>● <strong>PERIOD</strong>：周期时序检查</p>
<p>● <strong>NOCHANGE</strong>：不变化时序检查</p>
<p>以下是一些例子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-5c5d7204f65836158e1103e50124ac1a_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-027858b082c45fdd460dbdd0967c8b01_720w.jpg"></p>
<h3 id="标签">标签</h3>
<p>标签可用于指定VHDL泛型（generics）或Verilog HDL参数的值。</p>
<p><img src="https://pic3.zhimg.com/80/v2-8cdfc771fcd6b908f0a9399b1cb84d12_720w.jpg"></p>
<h3 id="时序环境">时序环境</h3>
<p>有许多结构可用于描述设计的时序环境。但是，这些结构可用于标注，而不是用于反标，例如在逻辑综合工具中。这些未在本文中描述。</p>
<h2 id="b.2.1-例子">B.2.1 例子</h2>
<p>接下去，我们将为两个设计提供完整的SDF文件。</p>
<h3 id="全加器">全加器</h3>
<p>这是用于全加器（full-adder）电路的Verilog HDL网表（netlist）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0e7bc900139da441a2767d8fad090c30_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-caf8d96c333133e47484f32cf01fe8b8_720w.jpg"></p>
<p>以下是时序分析工具生成的完整SDF文件：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d23fbfd72155d7886d89e1b2f4e5476b_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-77685b34c4fbbe8ace061a710aed5df5_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e12b065955a4de070114fddadcfbce8c_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e6a30e472c3bdae01ffa43bd9910ccb7_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-01c6fc556821612d5dbfe35a9cf647cc_720w.jpg"></p>
<p><strong>INTERCONNECT</strong>中的所有延迟均为0，因为这是布局前的数据，因此建模的是理想互连走线模型。</p>
<h3 id="十进制计数器">十进制计数器</h3>
<p>这是十进制计数器的Verilog HDL模型：</p>
<p><img src="https://pic4.zhimg.com/80/v2-0748cd5cfa0dd22a9d106a3384bbe087_720w.jpg"></p>
<p>对应的完整SDF文件如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-b21c8a0a1b09a6245240c95006952694_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-4901921680558a65934ef446e58216cf_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-3b63a6d8348af47f5bbda97888ac5391_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-7138bb34c6a3100db8aab1f592a929a6_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-03e59a8edcf0e9bd228bb44e0a2fa6c7_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-d1e8d9de8ae1f68138500f12648c8969_720w.jpg"></p>
<h2 id="b.3-标注过程">B.3 标注过程</h2>
<p>在本节中，我们将介绍如何在HDL描述中进行SDF的标注（annotation）。SDF的标注可以通过多种工具执行，例如逻辑综合工具、仿真工具和静态时序分析工具。SDF标注器（annotator）是这些工具的组件，可用于读取SDF、解释并向设计中标注时序值。假定会使用与HDL模型一致的信息创建SDF文件，并且在反标期间使用相同的HDL模型。此外，SDF标注器还需要负责正确解释SDF中的时序值。</p>
<p>SDF标注器标注了反标时序的泛型和参数。如果在语法或映射（mapping）过程中不符合该标准，它将给出错误报告。如果一个SDF标注器不支持某些SDF结构，则不会产生任何错误，标注器将忽略这些错误。</p>
<p>如果SDF标注器未能修改反标时序的泛型，则在反标过程中不会修改泛型的值，即保持不变。</p>
<p>在仿真工具中，反标通常发生在规划（elaboration）阶段之后，紧接在负约束延迟计算之前。</p>
<h2 id="b.3.1-verilog-hdl">B.3.1 Verilog HDL</h2>
<p>在Verilog HDL中，标注的主要机制是指定块（specify block），指定块可以指定路径延迟和时序检查。实际延迟值和时序检查极限值是通过SDF文件指定的，映射是一种行业标准，在IEEE Std 1364中定义。</p>
<p>从SDF文件中获得并在Verilog HDL模块的指定块中标注的信息包括指定路径的延迟、参数值、时序检查约束极限值和互连走线延迟。向一个Verilog HDL模型进行标注时，将忽略SDF文件中的其它结构。SDF中的<strong>LABEL</strong>部分定义了参数值。通过将SDF结构与相应的Verilog HDL声明进行匹配，然后将现有的时序值替换为SDF文件中的时序值，即可完成反标。</p>
<p>下表显示了SDF延迟值如何映射到Verilog HDL延迟值：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9f1f317462c2611034a9a4b53741e0de_720w.jpg"></p>
<p>下表描述了SDF结构到Verilog HDL结构的映射：</p>
<p><img src="https://pic2.zhimg.com/80/v2-313db78cf9a45f6c105d3d1440348085_720w.jpg"></p>
<p>有关示例，请参见后面部分。</p>
<h2 id="b.3.2-vhdl">B.3.2 VHDL</h2>
<p>SDF到VHDL的标注是一个行业标准，它在VITAL ASIC建模规范的IEEE标准IEEE Std 1076.4中定义，该标准的其中一部分描述了SDF延迟到ASIC库的标注。在这里，我们仅介绍与SDF映射有关的VITAL标准的相关部分。</p>
<p>SDF可用于直接在符合VITAL的模型中修改反标时序泛型，只能使用SDF为符合VITAL的模型指定时序数据。有两种方法可以将时序数据传递到VHDL模型中：通过配置，或直接传递到仿真中去。SDF标注过程包括在仿真期间在符合VITAL的模型中映射SDF结构和相应的泛型。</p>
<p>在符合VITAL的模型中，存在着有关如何命名和声明泛型的规则，以确保可以在模型的时序泛型和相应的SDF时序信息之间建立映射。</p>
<p>时序泛型由泛型名称及其类型组成，名称指定时序信息的种类，类型指定时序值的种类。如果泛型名称不符合VITAL标准，则它不是时序泛型，也不会被标注。</p>
<p>下表显示了SDF延迟值如何映射到VHDL延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-866c35b13ece5c6ea2823a6dc2b7369a_720w.jpg"></p>
<p>在VHDL中，时序信息是通过泛型进行反标的。泛型名称遵循一定的规则，以便保持一致或从SDF结构中获取。利用每个时序泛型名称，可以指定条件边沿的可选后缀。边沿可以指定一个与时序信息相关联的边沿。</p>
<p>下表列出了各种时序泛型名称：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a44e7be49c593fa926151c78211ea37e_720w.jpg"></p>
<h2 id="b.4-映射示例">B.4 映射示例</h2>
<p>以下是将SDF结构映射到VHDL泛型（generic）和Verilog HDL声明（declaration）的示例。</p>
<h3 id="传播延迟">传播延迟</h3>
<p>● 从输入端口A到输出端口Y的传播延迟：上升时间为0.406，下降时间为0.339：</p>
<p><img src="https://pic3.zhimg.com/80/v2-ce8817f40cbe6944cae4e876a1141952_720w.jpg"></p>
<p>● 从输入端口OE到输出端口Y的传播延迟：上升时间为0.441，下降时间为0.409。最小、标准和最大延迟是相同的：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5ba1ce30b7681eeb36521d1b4fdb0149_720w.jpg"></p>
<p>● 从输入端口S0到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4520723ba1cbe4d6efeded2cc18fcc8b_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-941b803367be3f8b623e9441c672e74e_720w.jpg"></p>
<p>● 从输入端口A到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic1.zhimg.com/80/v2-5910a4199d9cf0ccbde48394fb8c4fe4_720w.jpg"></p>
<p>● 从输入端口CK到输出端口Q的传播延迟：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0088f98f6ea741e7591f39e6fae58c8_720w.jpg"></p>
<p>● 从输入端口A到输出端口Y的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0906839b82ae3746a30f2fbab837ae52_720w.jpg"></p>
<p>● 从输入端口CK到输出端口ECK的传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-958bf0a11aad37027a21df522b30032f_720w.jpg"></p>
<p>● 从输入端口CI到输出端口S的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-57e351f67f6ccce1466b610c8a1adf3e_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-16d981773c8041d428f2be9a89d1c7ff_720w.jpg"></p>
<p>● 从输入端口CS到输出端口S的条件传播延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e31479125e64ea6a9f64df5d464553d6_720w.jpg"></p>
<p>● 从输入端口A到输出端口ICO的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-54d7a6401167320d44fac2bee4b25213_720w.jpg"></p>
<p>● 从输入端口A到输出端口CO的条件传播延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-32182414760afe7846ba1e1ce8812077_720w.jpg"></p>
<p>● 从CK的上升沿到Q的延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-99e2051f91bb85807bf213162372cae9_720w.png"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0e460d79ac68db88328a50ec20a72ba7_720w.jpg"></p>
<h3 id="输入建立时间">输入建立时间</h3>
<p>● D的上升沿与CK的上升沿之间的建立时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-74df5beb66d1ae66e712eb57ce3c325b_720w.jpg"></p>
<p>● D的下降沿与CK的上升沿之间的建立时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-cfc7c24f1b23b829bc2380713acddef2_720w.jpg"></p>
<p>● 输入端口E的上升沿与参考CK的上升沿之间的建立时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-be5f8683b8362378df8607312a4ce0f0_720w.jpg"></p>
<p>● 输入端口E的下降沿和参考CK的上升沿之间的建立时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-35d38d491de9b443e26b8a28d8c36356_720w.jpg"></p>
<p>● SE和CK之间的条件建立时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-69ee9e630b83697eb0fd27cd4ed80e6b_720w.jpg"></p>
<h3 id="输入保持时间">输入保持时间</h3>
<p>● D的上升沿与CK的上升沿之间的保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-747b90fc0b8da319d271419f537bc6c5_720w.jpg"></p>
<p>● RN与SN之间的保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-e4046cfa14bff3712bcd1fc7d3080e0d_720w.jpg"></p>
<p>● 输入端口SI与参考端口CK之间的保持时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4e7ac1d79cc26faa847d30c9fe8cd02a_720w.jpg"></p>
<p>● E和CK上升沿之间的条件保持时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-a3437becbae9757ee567c0263df8c750_720w.jpg"></p>
<h3 id="输入建立和保持时间">输入建立和保持时间</h3>
<p>● 在D和CLK之间的建立时间与保持时间检查。这是一个有条件的检查，第一个延迟值是建立时间，第二个延迟值是保持时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-dd937a75ad7ee6c5db2dd4db88cc676d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-40c51c521d6435c7b62a5a430ca34902_720w.jpg"></p>
<h3 id="输入恢复时间">输入恢复时间</h3>
<p>● CLKA和CLKB之间的恢复时间：</p>
<p><img src="https://pic1.zhimg.com/80/v2-16f2fefab421960b02616ee979f19ec0_720w.jpg"></p>
<p>● CLKA上升沿与CLKB上升沿之间的条件恢复时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c83e876cd023698a3a33fa12f0d1773a_720w.jpg"></p>
<p>● SE与CK之间的恢复时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-efeb18f572104d6bfdef3af51d68903b_720w.jpg"></p>
<p>● RN与CK之间的恢复时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-5ca9075bc61d1632d53c41a5a8196221_720w.jpg"></p>
<h3 id="输入撤销时间">输入撤销时间</h3>
<p>● E的上升沿与CK的下降沿之间的撤销时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b3caa9abbff61864a418a14693fd9ac5_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-699caacc53dd183477ea55a704c1b9ae_720w.png"></p>
<p>● CK的上升沿和SN之间的条件撤销时间：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3126ac8ac932e519a5e4df7905f0ba5b_720w.jpg"></p>
<h3 id="周期">周期</h3>
<p>● 输入CLKB的周期：</p>
<p><img src="https://pic1.zhimg.com/80/v2-020a171b7bb267280a44a3b0fa6c2fcc_720w.jpg"></p>
<p>● 输入端口EN的周期：</p>
<p><img src="https://pic3.zhimg.com/80/v2-25504e21962dff3d9b6769b8847b75de_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-05a0d9f7bf016ed54f14e5b0b30341b4_720w.jpg"></p>
<p>● 输入端口TCK的周期：</p>
<p><img src="https://pic1.zhimg.com/80/v2-24f6b097b58e8bc2565b7216f4f15e50_720w.jpg"></p>
<h3 id="脉宽">脉宽</h3>
<p>● CK上高脉冲的脉冲宽度：</p>
<p><img src="https://pic1.zhimg.com/80/v2-870910d6bcedcc59f797c11e7b6ece90_720w.jpg"></p>
<p>● CK上低脉冲的脉冲宽度：</p>
<p><img src="https://pic1.zhimg.com/80/v2-929c85b83c12d25707c2ae3c04d96528_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9e4066425d9adc9cdd95bec6a11b9c74_720w.jpg"></p>
<p>● RN上高脉冲的脉冲宽度：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d9cfe0e3981d15668e6b11cf0e5a4d37_720w.jpg"></p>
<h3 id="输入偏斜时间">输入偏斜时间</h3>
<p>● CK与TCK之间的偏斜：</p>
<p><img src="https://pic3.zhimg.com/80/v2-8a49393d63450f5c7aa992c55e2ea7aa_720w.jpg"></p>
<p>● SE和CK下降沿之间的偏斜：</p>
<p><img src="https://pic2.zhimg.com/80/v2-53cda8ce114c00c5586cfda867410581_720w.png"></p>
<p><img src="https://pic3.zhimg.com/80/v2-16f953ab76a39bb1e7585312ebc8b9ca_720w.jpg"></p>
<h3 id="无变化的建立时间">无变化的建立时间</h3>
<p>SDF文件中的NOCHANGE结构将同时映射到VHDL中的tncsetup和tnchold泛型。</p>
<p>● D和CK下降沿之间无变化的建立时间：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35501310e16ec371aba334d7d748ec31_720w.jpg"></p>
<h3 id="无变化的保持时间">无变化的保持时间</h3>
<p>SDF文件中的NOCHANGE结构将同时映射到VHDL中的tncsetup和tnchold泛型。</p>
<p>● E和CLKA之间无变化的条件保持时间：</p>
<p><img src="https://pic3.zhimg.com/80/v2-17346e072ebd78d7d4c7ff1519bae456_720w.png"></p>
<p><img src="https://pic1.zhimg.com/80/v2-9251364fb786f794df968c1821e6dbf8_720w.jpg"></p>
<h3 id="端口延迟">端口延迟</h3>
<p>● 端口OE的延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-ca3ed5652ebb3b601eb1f6bcb62350b5_720w.jpg"></p>
<p>● 端口RN的延迟：</p>
<p><img src="https://pic4.zhimg.com/80/v2-d1def2fb828ac302521caf6a83c86fc3_720w.jpg"></p>
<h3 id="网络延迟">网络延迟</h3>
<p>● 连接到端口CKA的网络延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-bb573f4548409fcd60d58457b5fee1e6_720w.jpg"></p>
<h3 id="互连路径延迟">互连路径延迟</h3>
<p>● 从端口Y到端口D的互连路径延迟：</p>
<p><img src="https://pic2.zhimg.com/80/v2-92c911cbd368a44d8fdc8b5d70840a25_720w.jpg"></p>
<h3 id="器件延迟">器件延迟</h3>
<p>● 实例uP的输出SM的器件延迟：</p>
<p><img src="https://pic3.zhimg.com/80/v2-594d97d08b6dd15cd5a7fac8ae779262_720w.jpg"></p>
<h2 id="b.5-完整语法">B.5 完整语法</h2>
<p>以下是使用BNF格式显示的SDF的完整语法。终端（terminal）名称是大写的，关键字是粗体的，但是不区分大小写。起始的终端是delay_file：</p>
<p><img src="https://pic4.zhimg.com/80/v2-778ef72b2a25569041fc038d59b6b6c3_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-25318d1ed0e04a456481502b0b78d402_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-c4a97a21948d8413effe48b3f4b98fb2_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-3712a766a742f058308daeb4733f8d73_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-72f6af6a036ef6a4345a84ec5d8717db_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-de80ee340df3748c82680bcb38abc0ee_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-8fc1c5592b3caeb7953e1a2f72f909ba_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-c7df5901bd83557b3e0226bae3b859d3_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-ce2cf75964e4d40841dc4aa72646215d_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-958c19cddf02f96d902b58b7a92fcd29_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-39f72aafdf5ecdb580cbb2482e05dfc0_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f12d07ad8763294f144ca9291f67c13b_720w.jpg"></p>
<h1 id="附录cspef">附录C:SPEF</h1>
<blockquote>
<p>本附录将介绍标准寄生参数提取格式（SPEF），它是IEEE Std 1481标准的一部分。</p>
</blockquote>
<h2 id="c.1-基础">C.1 基础</h2>
<p>SPEF允许以ASCII交换格式描述设计的寄生信息（R，L和C）。用户可以读取和检查SPEF文件中的值，尽管用户永远不会手动创建此文件。它主要用于将寄生信息从一个工具传递到另一个工具。图C-1显示了SPEF可以由诸如布局布线工具或寄生参数提取工具之类的工具生成，然后交由时序分析工具用于电路仿真或执行串扰分析。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d66bfe17d0657c476a9db91bc10399d7_720w.jpg" alt="图C-1"></p>
<p>寄生参数可以在许多不同的层次上表示。SPEF支持分布式（distributed）网络模型、（reduced）简化网络模型和（lumped）集总电容模型。在分布式网络模型（D_NET）中，网络走线的每段都有其自己的R和C。在简化网络模型（R_NET）中，在网络的负载引脚上考虑一个简化的R和C，而在网络的驱动引脚上考虑一个π模型（C-R-C）。在集总电容模型中，仅为整个网络指定一个电容。图C-2显示了物理网络走线的一个示例，图C-3显示了分布式网络模型，图C-4显示了简化的网络模型，图C-5显示了集总电容模型。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0826235775bf5a106ea18e42a61d1b82_720w.jpg" alt="图C-2"></p>
<p><img src="https://pic2.zhimg.com/80/v2-072247589e9f878fade00feb0c1ffb61_720w.jpg" alt="图C-3"></p>
<p><img src="https://pic4.zhimg.com/80/v2-60166c6d849bcaa4f16f21e8ff44fd73_720w.jpg" alt="图C-4"></p>
<p><img src="https://pic3.zhimg.com/80/v2-ee7be67b2c83c0739da7df72acf5fa2a_720w.jpg" alt="图C-5"></p>
<p>互连寄生效应取决于工艺，SPEF支持最佳（best-case）、典型（typical）和最差（worst-case）三种情况。允许R、L和C值、端口压摆和负载使用此三种不同情况下的值。</p>
<p>通过提供一个包含网络名称和实例名称映射到索引的一个名称映射（name map），可以有效地减小SPEF文件的大小，更重要的是，所有较长名称仅出现在一个位置。</p>
<p>设计的SPEF文件可以拆分为多个文件，也可以分层。</p>
<h2 id="c.2-格式">C.2 格式</h2>
<p>SPEF文件的格式如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-e1eb8bc8e1d1dc3c659322158db3aa0b_720w.jpg"></p>
<p><strong>header_definition</strong>包含了基本信息，例如SPEF版本号、设计名称以及R，L和C的单位。<strong>name_map</strong>指定了网络名称和实例名称到索引的映射。<strong>power_definition</strong>声明了电源网络和地网络。<strong>external_definition</strong>定义了设计的端口。<strong>define_definition</strong>中指出了SPEF还在其它文件中进行了描述的那些实例。<strong>internal_definition</strong>包含的是文件的核心——设计的寄生参数。</p>
<p>图C-6显示了<strong>header_definition</strong>的示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-484aac79a1305cbe5e8b710781ecd170_720w.jpg" alt="图C-6"></p>
<p><strong>SPEF</strong> name 指定了SPEF的版本号；</p>
<p><strong>DESIGN</strong> name 指定了设计的名称；</p>
<p><strong>DATE</strong> string 指定了创建文件时的时间戳；</p>
<p><strong>VENDOR</strong> string 指定了用于创建SPEF的供应商工具；</p>
<p><strong>PROGRAM</strong> string 指定了用于生成SPEF的程序；</p>
<p><strong>VERSION</strong> string 指定了用于创建SPEF的程序的版本号；</p>
<p><strong>DESIGN_FLOW</strong> string string string . . . 指定了在什么阶段创建SPEF文件。它描述了有关SPEF文件的信息，这些信息无法通过读取文件来获得。</p>
<p>预定义的字符串值为：</p>
<p>● <strong>EXTERNAL_LOADS：</strong>外部载荷在SPEF文件中完全指定。</p>
<p>● <strong>EXTERNAL_SLEWS：</strong>外部压摆在SPEF文件中完全指定。</p>
<p>● <strong>FULL_CONNECTIVITY：</strong>SPEF中存在逻辑网表连接。</p>
<p>● <strong>MISSING_NETS：</strong>SPEF文件中可能缺少某些逻辑网络。</p>
<p>● <strong>NETLIST_TYPE_VERILOG：</strong>使用Verilog HDL类型命名约定。</p>
<p>● <strong>NETLIST_TYPE_VHDL87：</strong>使用VHDL87命名约定。</p>
<p>● <strong>NETLIST_TYPE_VHDL93：</strong>使用VHDL93网表命名约定。</p>
<p>● <strong>NETLIST_TYPE_EDIF：</strong>使用EDIF类型命名约定。</p>
<p>● <strong>ROUTING_CONFIDENCE：</strong>（正整数）所有网络的默认走线置信度，基本上是寄生精度的水平。</p>
<p>● <strong>ROUTING_CONFIDENCE_ENTRY：</strong>补充走线置信度值。</p>
<p>● <strong>NAME_SCOPE_LOCAL | FLAT：</strong>指定了SPEF文件中的路径是相对于文件还是相对于设计顶层。</p>
<p>● <strong>SLEW_THRESHOLDS：</strong>（low_input_threshold_percent，high_input_threshold_percent）指定了设计的默认输入转换阈值。</p>
<p>● <strong>PIN_CAP NONE | INPUT_OUTPUT | INPUT_ONLY：</strong>指定了作为总电容一部分的引脚电容类型，默认值为INPUT_OUTPUT。</p>
<p><strong>DIVIDER /</strong> 指定了层次结构分隔符。可以使用的其它字符是" . " , " : "和" / "。</p>
<p><strong>DELIMITER ：</strong>指定了实例与其引脚之间的分隔符。可以使用的其它可能字符是" . " , " / " , " : " 或者 "|"。</p>
<p><strong>BUS_DELIMITER [ ]</strong> 指定了用于标识总线位的前缀和后缀。可以用于前缀和后缀的其他可能字符是" { " , " ( " , " &lt; " , " : "，" ."和" } " , " ) ", " &gt; "。</p>
<p><strong>T_UNIT</strong> 正整数 <strong>NS | PS</strong> 指定了时间单位。</p>
<p><strong>C_UNIT</strong> 正整数 <strong>PF | FF</strong> 指定了电容单位。</p>
<p><strong>R_UNIT</strong> 正整数 <strong>OHM| KOHM</strong> 指定了电阻单位。</p>
<p><strong>L_UNIT</strong> 正整数 <strong>HENRY | MH | UH</strong> 指定了电感单位。</p>
<p>SPEF文件中的注释可以两种形式出现：</p>
<p><img src="https://pic2.zhimg.com/80/v2-cd8ab4c3d088f43622badae784fe8745_720w.jpg"></p>
<p>图C-7显示了一个名称映射的示例。 它的形式为：</p>
<p><img src="https://pic2.zhimg.com/80/v2-1d58b398fa18b250b4bf1720d0d9831d_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-830b7f416c518cc6939b4c2a2a344e0a_720w.jpg" alt="图C-7"></p>
<p>名称映射将指定名称到唯一整数值（它们的索引）的映射。名称映射有助于通过索引来对名称进行引用从而减小文件的大小，名称可以是网络名称或实例名称。考虑图C-7中的名称映射，以后可以使用它们的索引在SPEF文件中引用这些名称，例如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-aa1fd2b77bc88b929311c8607fde5a47_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-d7541e59caead48893974062b457c9b8_720w.png"></p>
<p>因此，名称映射会通过使用其唯一的整数表示来避免重复长名称及其路径。</p>
<p><strong>power definition</strong>部分定义了电源和接地网络：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9e013a5dc7f8b677915b38c98830968d_720w.png"></p>
<p>以下是一些例子：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e0bf96246e2c1639894272b3cacf6374_720w.png"></p>
<p><strong>external_definition</strong>包含了设计的逻辑和物理端口的定义。图C-8显示了逻辑端口的示例，逻辑端口可以以下形式描述：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4d9ee95769630326723c2f28d2e07d0c_720w.png"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c5b9b4c86664f72d1053abbf0ecd5c55_720w.jpg" alt="图C-8"></p>
<p>其中<strong>port_name</strong>可以是形式为*正整数的端口索引。方向为I表示输入，O表示输出，B表示双向。连接属性（conn_attribute）是可选的，可以是以下属性：</p>
<p>● *<strong>C</strong> number number：端口的坐标。</p>
<p>● *<strong>L</strong> par_value：端口的电容负载。</p>
<p>● *<strong>S</strong> par_value par_value：定义端口上的波形。</p>
<p>● *<strong>D</strong> cell_type：定义端口的驱动单元。</p>
<p>可以使用以下命令定义SPEF文件中的物理端口：</p>
<p><img src="https://pic3.zhimg.com/80/v2-46131891dca3b3ae809ea9cc5c461a1a_720w.jpg"></p>
<p><strong>define definition</strong>部分定义了当前SPEF文件中引用的实例，但其寄生参数在其它SPEF文件中进行了描述：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4a4ace48312c1977d659dd31a8be32fe_720w.png"></p>
<p>当实例是物理分区（而不是逻辑层次结构）时，将使用*<strong>PDEFINE</strong>。以下有些例子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fc8d4ae3a1ab2e5d586321cd2cfd774d_720w.png"></p>
<p>这意味着将存在另一个带有*<strong>DESIGN</strong>值ddrphy的SPEF文件，该文件将包含设计ddrphy的寄生参数，其可能具有物理和逻辑层次结构。跨越层次边界的任何网络都必须描述为分布式网络（D_NET）。</p>
<p><strong>internal definition</strong>部分包含了SPEF文件的核心，即设计中网络的寄生参数。基本上有两种形式：分布式网络D_NET和简化网络R_NET。图C-9中为一个分布式网络定义的示例：</p>
<p><img src="https://pic2.zhimg.com/80/v2-283e7c120b5c5437c4781a02a3835ead_720w.jpg" alt="图C-9"></p>
<p>第一行中的*5426是网络的索引号（网络名称请参见名称映射），0.899466是网络上的总电容值。电容值是网络上所有电容的总和，其中包括假定为接地的交叉耦合电容，还包括负载电容。它可能包含也可能不包含引脚电容，具体取决于<strong>DESIGN_FLOW</strong>定义中的<strong>PIN_CAP</strong>设置。</p>
<p><strong>connectivity section</strong>描述了网络的驱动和负载引脚：</p>
<p><img src="https://pic2.zhimg.com/80/v2-682dad147f6f48ad51d7e59d10b1f675_720w.png"></p>
<p><em>I表示内部引脚（ </em> P表示端口），<em>14212：D表示实例</em>14212的D引脚，14212是一个索引号（有关实际名称需参见名称映射）。“ I”表示网络上的负载（输入引脚），“ O”表示网络上的驱动（输出引脚）。<em>C和 </em>D如先前在<strong>connection attributes</strong>中所定义的那样，<em>C定义了引脚的坐标，</em>D定义了引脚的驱动单元。</p>
<p><strong>capacitance section</strong>描述了分布式网络的电容，电容单位在之前已用* C_UNIT指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-d2b4601149c0f392d43cba3646d01c3d_720w.jpg"></p>
<p>第一个数字是电容标识符。电容规范有两种形式： 第一种到第四种一种形式，第五种是另一种形式。第一种形式（第一至第四种）指定两个网络之间的交叉耦合电容，而第二种形式（id为5）指定接地电容。因此，在电容id1中，网络<em>5426和</em>5290之间的交叉耦合电容为0.217446；在电容id5中，接地电容为0.529736。请注意，第一个节点名称必须是所描述的D_NET的网络名称。网络索引后面的正整数（<em>5426：10278中的10278）指定内部节点或连接点。因此，电容id4表示在内部节点10278的网络</em>5426和内部节点9922的网络*5116之间存在耦合电容，该耦合电容的值为0.113918。</p>
<p><strong>resistance section</strong>描述了分布式网络的电阻，电阻单位在之前已用* R_UNIT指定。</p>
<p><img src="https://pic2.zhimg.com/80/v2-43c952ff95fe9602d9db81ec6a033e5d_720w.png"></p>
<p>第一个字段是电阻标识符。因此，该网络具有三个电阻部分。第一个在内部节点<em>5426：10278与</em>14212上的D引脚之间，电阻值为0.34。使用图C-10中所示的RC网络可以更好地理解电容和电阻部分。</p>
<p><img src="https://pic2.zhimg.com/80/v2-54692812f54dc062e6e3d425c15c9061_720w.jpg" alt="图C-10"></p>
<p>图C-11显示了分布式网络的另一个示例。该网络具有一个驱动和两个负载，网络上的总电容为2.69358。图C-12显示了与分布式网络相对应的RC网络。</p>
<p><img src="https://pic4.zhimg.com/80/v2-938002ad4792085b1bb900c3a4fab8ff_720w.jpg" alt="图C-11"></p>
<p><img src="https://pic4.zhimg.com/80/v2-5e55c1dad59c315a8f334a8073ac1e67_720w.jpg" alt="图C-12"></p>
<p>通常，内部定义（internal definition）可以包含以下规范：</p>
<p>● <strong>D_NET</strong>：逻辑网络的分布式RC网络形式。</p>
<p>● <strong>R_NET</strong>：逻辑网络的简化RC网络形式。</p>
<p>● <strong>D_PNET</strong>：物理网络的分布式形式。</p>
<p>● <strong>R_PNET</strong>：物理网络的简化形式。</p>
<p>语法如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-4fe6519e2a6a66d0ae1226635a95a8c8_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5cb28904839a93a2349824681e125ce4_720w.jpg"></p>
<p><strong>inductance section</strong>用于指定电感，其格式类似于电阻部分。 * V用于指定网络寄生参数的准确性。这些可以单独使用网络指定，也可以使用带有<strong>ROUTING_CONFIDENCE</strong>值的*** DESIGN_FLOW**语句进行全局指定，例如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-811c988ccd8701a6c6f2b9354a72beff_720w.png"></p>
<p>它指定了寄生参数是在最终单元布局和最终布线之后提取得到的，并且使用了3d提取。走线置信度的其它可能值为：</p>
<p>● 10：统计线负载模型</p>
<p>● 20：物理线负载模型</p>
<p>● 30：具有位置但没有单元布局的物理分区</p>
<p>● 40：使用基于斯坦纳树（steiner tree）的走线估计的单元位置</p>
<p>● 50：使用全局走线估计的单元位置</p>
<p>● 60：使用斯坦纳走线进行的最终单元布局</p>
<p>● 70：使用全局走线进行的最终单元布局</p>
<p>● 80：最终单元布局，最终走线，2d提取</p>
<p>● 90：最终单元布局，最终走线，2.5d提取</p>
<p>● 100：最终单元布局，最终走线，3d提取</p>
<p><strong>reduced net</strong>是从分布式网络形式简化而来的网络。网络上每个驱动都有一个驱动精简部分（driver reduction section）。驱动精简部分的形式为：</p>
<p><img src="https://pic1.zhimg.com/80/v2-aeb44e379a12069929a4d96c43c79b10_720w.jpg"></p>
<p><em>C2_R1_C1表示在网络的驱动引脚上使用π模型的寄生参数。 </em> RC结构中的rc_value是指Elmore延迟（R * C）。 图C-13显示了简化后的网络的SPEF示例，图C-14以图形方式显示了RC网络。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2890bf55cf5daca5bf05c97e259f22b4_720w.jpg" alt="图C-13"></p>
<p><img src="https://pic1.zhimg.com/80/v2-3947f51106a7373e73b6fc25466226ec_720w.jpg" alt="图C-14"></p>
<p>可使用<em><strong>D_NET</strong>或</em><strong>R_NET</strong>结构描述集总电容模型（lumped capacitance model），该结构仅具有总电容而没有其它信息。以下是集总电容声明的示例：</p>
<p><img src="https://pic4.zhimg.com/80/v2-ee64afd594898f8c63a77fbab14f1923_720w.jpg"></p>
<p>SPEF文件中的值可以采用三元数组的形式来表示工艺变化，例如：</p>
<p>● 0.243 ： 0.269 ： 0.300</p>
<p>最佳情况下值为0.243，典型情况下值为0.269，最差情况下值为0.300。</p>
<h2 id="c.3-完整语法">C.3 完整语法</h2>
<p>本节描述了SPEF文件的完整语法。</p>
<p>可以在字符前面加上反斜杠（）来对其进行转义。注释有两种形式：//开始注释直到行尾，而/ * . . . * /是多行注释。</p>
<p>在以下语法中，粗体字符如（，[是语法的一部分。所有结构均按字母顺序排列，起始符号为SPEF_file：</p>
<p><img src="https://pic3.zhimg.com/80/v2-07d727acd214247bedf57d671232a11e_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c8fb4e366e5154843f123975f1b02ffd_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-0456819806173f4d5cfe1f07e3c1b856_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-95fcf79c19ee60fdf418eb1489b36fe3_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-8e456c68bf7b3d4d80c8ec56a4a1d5e1_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-75d9df40768e4a338ec16bb3fb7e3770_720w.jpg"></p>
<p><img src="https://pic1.zhimg.com/80/v2-4f8ba11df9dce8065baac3a18032fa70_720w.jpg"></p>
<p><img src="https://pic3.zhimg.com/80/v2-947377e805d31cfbc32aadbab331ffbe_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a6c00e091dc1ae58f09bb13dd7128649_720w.jpg"></p>
<p><img src="https://pic2.zhimg.com/80/v2-389fd37ea782a79b658f16808aa55c05_720w.jpg"></p>
<p><img src="https://pic4.zhimg.com/80/v2-e0da9791e613e059a2c949f966382c2f_720w.png"></p>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog For Design</title>
    <url>/2025/05/22/SystemVerilog-For-Design/</url>
    <content><![CDATA[<h1 id="声明空间">声明空间</h1>
<p>在<em>verilog</em>中，<code>reg 、wire、task、function</code>等的定义都必须在<em>module</em>之内，这些声明都是局部的，因此只能在模块内部使用，无法跨模块使用。如果希望在多个模块中使用某个<code>function</code>，则需要在每一个模块内都重新定义。特别是使用<em>user-defined type</em>，需要在每一个模块内都重复进行<code>typedef</code>，非常的冗余，且容易出错。</p>
<p>为此<em>system verilog</em>拓展了声明空间。</p>
<h2 id="package">package</h2>
<h3 id="package的定义">package的定义</h3>
<p><em>package</em>是一个独立的声明空间，因此不能嵌入在<em>module</em>内部。</p>
<p><em>package</em>是通过两个关键字进行定义的——<code>package</code>与<code>endpackage</code>。<strong>可综合</strong>的<em>package</em>可以包含如下的内容：</p>
<ul>
<li><code>parameter</code>和<code>localparam</code>定义的常数（在<em>package</em>中，两个是一样的，都不能在外部被修改）。</li>
<li><code>const</code>定义的变量。</li>
<li><code>typedef</code>定义的自定义类型。</li>
<li><em>automatic</em> <code>task</code>和<em>automatic</em> <code>function</code>。</li>
<li><code>import</code>导入其他<em>package</em>。</li>
<li>操作符重载。</li>
</ul>
<p><em>package</em>还可以包含全局变量声明、静态任务定义和静态函数定义。然而，这些都是不可综合的。</p>
<p>一个<em>package</em>的实例如下:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> definitions;  </span><br><span class="line">    <span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MUL&#125; opcodes_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b;</span><br><span class="line">        opcodes_t opcode;</span><br><span class="line">    &#125; instruction_t;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">automatic</span> [<span class="number">31</span>:<span class="number">0</span>] multiplier (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a, b);</span><br><span class="line">        <span class="comment">// code for a custom 32-bit multiplier goes here</span></span><br><span class="line">        <span class="keyword">return</span> a * b; <span class="comment">// abstract multiplier (no error detection)</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>
<h3 id="package的引用">package的引用</h3>
<p><em>package</em>可以在<em>module</em>和<em>interface</em>中，通过如下四种方式进行引用。</p>
<ol type="1">
<li>直接使用名称空间决议运算符（<code>::</code>）</li>
<li>将<em>package</em>中特定的<em>item</em>通过<code>import</code>导入到<em>module</em>和<em>interface</em>中</li>
<li>使用通配符<code>*</code>将<em>package</em>中的<em>item</em>通过<code>import</code>导入到<em>module</em>和<em>interface</em>中</li>
<li>将<em>package</em>中的内容<code>import</code>到<code>$unit</code>声明空间</li>
</ol>
<p><strong>名称空间决议运算符</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU  (</span><br><span class="line">    <span class="keyword">input</span> definitions::instruction_t IW,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result </span><br><span class="line">);</span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (IW<span class="variable">.opcode</span>)</span><br><span class="line">        definitions::ADD : result = IW<span class="variable">.a</span> + IW<span class="variable">.b</span>;</span><br><span class="line">        definitions::SUB : result = IW<span class="variable">.a</span> - IW<span class="variable">.b</span>;</span><br><span class="line">        definitions::MUL : result = definitions::multiplier(IW<span class="variable">.a</span>, IW<span class="variable">.b</span>);</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>import特定item</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU  (</span><br><span class="line">    <span class="keyword">input</span> definitions::instruction_t IW,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result </span><br><span class="line">);</span><br><span class="line"><span class="keyword">import</span> definitions::ADD; </span><br><span class="line"><span class="keyword">import</span> definitions::SUB; </span><br><span class="line"><span class="keyword">import</span> definitions::MUL; </span><br><span class="line"><span class="keyword">import</span> definitions::multiplier;  </span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">case</span> (IW<span class="variable">.opcode</span>) </span><br><span class="line">        ADD : result = IW<span class="variable">.a</span> + IW<span class="variable">.b</span>; </span><br><span class="line">        SUB : result = IW<span class="variable">.a</span> - IW<span class="variable">.b</span>; </span><br><span class="line">        MUL : result = multiplier(IW<span class="variable">.a</span>, IW<span class="variable">.b</span>); </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">
Importing an enumerated type definition does not import the labels used within that definition.</p></div>
<p><strong>使用通配符导入</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU  (</span><br><span class="line">    <span class="keyword">input</span> definitions::instruction_t IW,  </span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result </span><br><span class="line">); </span><br><span class="line"><span class="keyword">import</span> definitions::*; <span class="comment">// wildcard import  </span></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">case</span> (IW<span class="variable">.opcode</span>) </span><br><span class="line">        ADD : result = IW<span class="variable">.a</span> + IW<span class="variable">.b</span>; </span><br><span class="line">        SUB : result = IW<span class="variable">.a</span> - IW<span class="variable">.b</span>; </span><br><span class="line">        MUL : result = multiplier(IW<span class="variable">.a</span>, IW<span class="variable">.b</span>); </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>导入到$unit</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import specific package items into $unit </span></span><br><span class="line"><span class="keyword">import</span> definitions::instruction_t;  </span><br><span class="line"><span class="keyword">module</span> ALU  (</span><br><span class="line">    <span class="keyword">input</span> instruction_t IW,  </span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者使用下面的通配符导入：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import specific package items into $unit </span></span><br><span class="line"><span class="keyword">import</span> definitions::*;  </span><br><span class="line"><span class="keyword">module</span> ALU  (</span><br><span class="line">    <span class="keyword">input</span> instruction_t IW,  </span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clock, </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] result </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="导入到unit注意事项">导入到$unit注意事项</h3>
<p><strong>文件导入顺序</strong></p>
<p>如果在<code>A</code>文件中使用<code>import</code>导入声明到<code>$unit</code>中，而<code>B</code>文件不使用<code>import</code>语句来导入。这时候，只有<code>B</code>文件在<code>A</code>之后导入，<code>B</code>中才能使用导入的声明，如果在<code>A</code>之间被导入，则为报错（或者使用隐式声明）。</p>
<p><strong>每个文件都import</strong><br>
虽然每个文件都是用<code>import</code>导入声明到<code>$unit</code>，可以解决上述的问题。但是，这几个文件同时编译时，会导致重复定义的错误。</p>
<p><strong>解决办法</strong><br>
与c当中的头文件类似，使用宏来防止被重复导入。</p>
<p>一个可行的示例如下：</p>
<p>创建一个名为<em>definitions.pkg</em>的文件，其内容如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifndef</span> DEFS_DONE </span><span class="comment">// if the already-compiled flag is not set... </span></span><br><span class="line">    <span class="meta">`<span class="keyword">define</span> DEFS_DONE </span><span class="comment">// set the flag </span></span><br><span class="line">    <span class="keyword">package</span> definitions;  </span><br><span class="line">        <span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.1&quot;</span>;  </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;ADD, SUB, MUL&#125; opcodes_t;  </span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;  </span><br><span class="line">            <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a, b; </span><br><span class="line">            opcodes_t opcode; </span><br><span class="line">        &#125; instruction_t;  </span><br><span class="line">        <span class="keyword">function</span> <span class="keyword">automatic</span> [<span class="number">31</span>:<span class="number">0</span>] multiplier (<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a, b); </span><br><span class="line">            <span class="comment">// code for a custom 32-bit multiplier goes here </span></span><br><span class="line">            <span class="keyword">return</span> a * b; <span class="comment">// abstract multiplier (no error detection) </span></span><br><span class="line">        <span class="keyword">endfunction</span> </span><br><span class="line">    <span class="keyword">endpackage</span>  </span><br><span class="line">    <span class="keyword">import</span> definitions::*; <span class="comment">// import package into $unit  </span></span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后将下面的语句放在每一个需要导入该package的文件开头</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">‘<span class="keyword">include</span> <span class="string">&quot;definitions.pkg&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="unit-compilation-unit">$unit compilation-unit</h2>
<p><em>SystemVerilog</em>语言在<em>Verilog</em>中增加了一个称为<em>compilation-unit</em>(编译单元)的概念——一个编译单元是同时编译的所有源文件。<em>compilation-unit</em>为软件工具提供了一种对整体设计的子块进行单独编译的手段。一个子块可能包含单个模块，也可能包含多个模块。模块可能包含在单个文件中，也可能包含在多个文件中。</p>
<p><em>SystemVerilog</em>语言扩展了<em>Verilog</em>的声明空间，允许声明在<code>package</code>、<code>module</code>、<code>interface</code>和<code>program block</code>边界之外进行。这些外部声明处于一个<em>compilation-unit</em>范围内，对于同时编译的所有模块都是可见的。</p>
<p><strong>compilation-unit示例</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************* External declarations *******************/</span> </span><br><span class="line"><span class="keyword">parameter</span> VERSION = <span class="string">&quot;1.2a&quot;</span>; <span class="comment">// external constant  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> resetN = <span class="number">1</span>; <span class="comment">// external variable (active low)  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="comment">// external user-defined type </span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] address; </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data; </span><br><span class="line">    <span class="keyword">reg</span> [ <span class="number">7</span>:<span class="number">0</span>] opcode; </span><br><span class="line">&#125; instruction_word_t;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> log2 (<span class="keyword">input</span> <span class="keyword">int</span> n); <span class="comment">// external function </span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;=<span class="number">1</span>) <span class="keyword">return</span>(<span class="number">1</span>); </span><br><span class="line">    log2 = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) <span class="keyword">begin</span> </span><br><span class="line">        n = n/<span class="number">2</span>; </span><br><span class="line">        log2++; </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">return</span>(log2); </span><br><span class="line"><span class="keyword">endfunction</span>  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/********************* module definition *********************/</span> </span><br><span class="line"><span class="comment">// external declaration is used to define port types </span></span><br><span class="line"><span class="keyword">module</span> register (</span><br><span class="line">    <span class="keyword">output</span> instruction_word_t q, </span><br><span class="line">    <span class="keyword">input</span> instruction_word_t d,</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clock </span><br><span class="line">);  </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN) </span><br><span class="line"><span class="keyword">if</span> (!resetN) </span><br><span class="line">    q &lt;= <span class="number">0</span>; <span class="comment">// use external reset </span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    q &lt;= d; </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">
External compilation-unit scope declarations are not global</p></div>
<div class="markdown-alert markdown-alert-tip" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto">
A declaration in the compilation-unit scope is not the same as a global declaration. A true global declaration, such as a global variable or function, would be shared by all modules that make up a design, regardless of whether or not source files are compiled separately or at the same time.</p></div>
<h1 id="数据类型">数据类型</h1>
]]></content>
      <categories>
        <category>IC</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS握手流程</title>
    <url>/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="tls握手过程">TLS握手过程</h1>
<p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。</p>
<p>所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p>HTTPS 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640.webp" alt="HTTPS"></p>
<p>TLS 协议是如何解决 HTTP 的风险的呢？</p>
<ul>
<li><strong>信息加密</strong>：HTTP 交互信息是被加密的，第三方就无法被窃取。</li>
<li><strong>校验机制</strong>：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网。</li>
</ul>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128862076-3.webp" alt="TLS握手过程"></p>
<p>上图简要概述来 TLS 的握手过程，其中每一个「框」都是一个记录（record），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>
<p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p>
<p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p>
<p>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</p>
<p>接下来，我们就以最简单的 RSA 密钥交换算法，来看看它的 TLS 握手过程。</p>
<h1 id="rsa握手过程">RSA握手过程</h1>
<p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>
<p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>
<p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历来四次握手：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128871865-6.webp"></p>
<p>对应 Wireshark 的抓包，我也画了一幅图，你可以从下图很清晰地看到该过程：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128875542-9.webp"></p>
<p>那么，接下来针对每一个 TLS 握手做进一步的介绍。</p>
<h2 id="tls第一次握手">TLS第一次握手</h2>
<p>客户端首先会发一个「Client Hello」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128881561-12.webp"></p>
<p>消息里面有客户端使用的<strong>TLS 版本号</strong>、支持的<strong>密码套件列表</strong>，以及生成的<strong>随机数（Client Random）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>
<h2 id="tls第二次握手">TLS第二次握手</h2>
<p>当服务端收到客户端的「<strong>Client Hello</strong>」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（Server Random）</strong>。</p>
<p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了<strong>随机数（Server Random）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128887386-15.webp"></p>
<p>可以看到，服务端选择的密码套件是<code>Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256</code>。</p>
<p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「<strong>密钥交换算法</strong> + <strong>签名算法</strong> + <strong>对称加密算法</strong> + <strong>摘要算法</strong>」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p>
<ul>
<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>
<li>摘要算法 SHA256 用于消息认证和产生随机数；</li>
</ul>
<p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。</p>
<p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「主密钥」和「会话密钥」的条件，所谓的主密钥，就是使用DH或者RSA等密钥交换算法得到的密钥(由<strong>预备主密钥</strong>、<strong>ClientHello random</strong> 和 <strong>ServerHello random</strong> 通过 <strong>PRF</strong> 函数生成的)，而会话密钥就是数据传输时，所使用的对称加密密钥（由<strong>主密钥</strong>、<strong>SecurityParameters.server_random</strong> 和 <strong>SecurityParameters.client_random</strong> 通过 <strong>PRF</strong> 函数来生成）。</p>
<p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128894819-18.webp"></p>
<p>随后，服务端发了「Server Hello Done」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128898442-21.webp"></p>
<h3 id="客户端验证证书">客户端验证证书</h3>
<p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p>
<h4 id="数字证书和ca机构">数字证书和CA机构</h4>
<p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p>
<ul>
<li>公钥；</li>
<li>持有者信息；</li>
<li>证书认证机构（CA）的信息；</li>
<li>CA 对这份文件的数字签名及使用的算法；</li>
<li>证书有效期；</li>
<li>还有一些其他额外信息；</li>
</ul>
<p>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</p>
<p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？</p>
<p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （Certificate Authority，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>
<p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p>
<h4 id="数字证书签发和验证流程">数字证书签发和验证流程</h4>
<p>如下图图所示，为数字证书签发和验证流程：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128904315-24.webp"></p>
<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
<h4 id="证书链">证书链</h4>
<p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128908654-27.webp"></p>
<p>对于这种三级层级关系的证书的验证过程如下：</p>
<ul>
<li>客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 <code>GlobalSign Organization Validation CA - SHA256 - G2</code>，然后向 CA 请求该中间证书。</li>
<li>请求到证书后发现 <code>GlobalSign Organization Validation CA - SHA256 - G2</code> 证书是由 <code>GlobalSign Root CA</code> 签发的，由于 <code>GlobalSign Root CA</code> 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 <code>GlobalSign Organization Validation CA - SHA256 - G2</code> 证书，如果发现验证通过，就认为该中间证书是可信的。</li>
<li><code>GlobalSign Organization Validation CA - SHA256 - G2</code> 证书被信任后，可以使用 <code>GlobalSign Organization Validation CA - SHA256 - G2</code> 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。</li>
</ul>
<p>在这四个步骤中，最开始客户端只信任根证书 <code>GlobalSign Root CA</code> 证书的，然后 <code>GlobalSign Root CA</code> 证书信任 <code>GlobalSign Organization Validation CA - SHA256 - G2</code> 证书，而 <code>GlobalSign Organization Validation CA - SHA256 - G2</code> 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。</p>
<p>总括来说，由于用户信任 <code>GlobalSign</code> ，所以由 <code>GlobalSign</code> 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 <code>GlobalSign</code> 都可被信任。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128912706-30.webp"></p>
<p>操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128916464-33.webp"></p>
<p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128920814-36.webp"></p>
<p>最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？</p>
<p>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>
<h2 id="tls第三次握手">TLS第三次握手</h2>
<p>客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的<strong>随机数 (pre-master)</strong>，用服务器的 RSA 公钥加密该随机数，通过「<strong>Change Cipher Key Exchange</strong>」消息传给服务端。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128925137-39.webp"></p>
<p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。</p>
<p>至此，客户端和服务端双方都共享了三个随机数，分别是 <strong>Client Random</strong>、<strong>Server Random</strong>、<strong>pre-master</strong>。</p>
<p>于是，双方根据已经得到的三个随机数，生成<strong>主密钥（Master Secret）</strong>，它是对称密钥，用于生成<strong>会话密钥</strong>对后续的 HTTP 请求/响应的数据加解密。</p>
<div class="admonition admonition-missing">
<p class="admonition-title">Missing</p>
<p>具体如何依据该随机数来生成回话密钥，改内容还有待补充。参考<a href="https://halfrost.com/https-key-cipher/#toc-0">TLS密钥计算</a>和<a href="https://zhuanlan.zhihu.com/p/405387352">QUIC协议</a></p>
</div>
<p>生成完会话密钥后，然后客户端发一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128929945-42.webp"></p>
<p>然后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用<strong>会话密钥</strong>（<strong>master secret</strong>）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128933630-45.webp"></p>
<p>可以发现，「<strong>Change Cipher Spec</strong>」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>
<h2 id="tls第四次握手">TLS第四次握手</h2>
<p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p>
<h1 id="rsa算法的缺陷">RSA算法的缺陷</h1>
<p><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>
<p>为了解决这一问题，于是就有了 DH 密钥协商算法，这里简单介绍它的工作流程。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/640-1726128939300-48.webp"></p>
<p>客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。</p>
<p>DH 密钥交换过程中，私钥每次都是随机生成的，因此实现了前向保密。</p>
<h1 id="离散对数">离散对数</h1>
<p>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是离散对数。离散对数是「离散 + 对数」的两个数学概念的组合，所以我们先来复习一遍对数。要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">指数运算</th>
<th style="text-align: center;">对数运算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">32的对数</td>
<td style="text-align: center;"><span class="math inline">\(32 = 2^5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5 = log_2^{32}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">64的对数</td>
<td style="text-align: center;"><span class="math inline">\(64 = 2^6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6 = log_2^{64}\)</span></td>
</tr>
</tbody>
</table>
<p>而离散对数其实本质上与常规的对数运算一样，都是求解<span class="math inline">\(a^x = b\)</span>当中的解<span class="math inline">\(x\)</span>，他们的核心不同点在于，两个运算所处的数学结构不同（即群不同）。传统的对数运算主要定义在实数域或者复数域等连续域当中，而离散对数通常定义在有限的离散群当中（模运算群，椭圆曲线群），这就导致了离散对数的计算复杂度非常高（尤其在大素数模数或椭圆曲线群中）。</p>
<div class="admonition admonition-note">
<p class="admonition-title">离散对数的一个实例
</p>
<p>离散对数最简单的设置之一是组<span class="math inline">\((\mathbb{Z}_p)^x\)</span>。这是以素数 <span class="math inline">\(p\)</span> 为模的一个乘法组。它的元素是以 <span class="math inline">\(p\)</span> 为模的同余类，并且两个元素的组乘积可以在元素的普通整数乘法运算之后再模 <span class="math inline">\(p\)</span> 得到。</p>
<p>上述组中，一个数的 <span class="math inline">\(k\)</span> 次幂可以通过将其 <span class="math inline">\(k\)</span> 次幂作为整数求出之后，再除以 <span class="math inline">\(p\)</span> 求出余数的方式来计算。当涉及的数字很大时，在计算过程中多次减小模 <span class="math inline">\(p\)</span> 会更加具有效率。不管使用哪种特定算法，都会调用该操作：模幂运算。例如，研究<span class="math inline">\((\mathbb{Z}_{17})^x\)</span>。为了计算该组中的<span class="math inline">\(3^4\)</span> ，计算得到<span class="math inline">\(3^4 = 81\)</span>，然后用<span class="math inline">\(81\)</span>除以<span class="math inline">\(17\)</span>，得到大小为<span class="math inline">\(13\)</span>的余数。因此在组<span class="math inline">\((\mathbb{Z}_{17})^x\)</span>中<span class="math inline">\(3^4 = 13\)</span>。</p>
<p>离散对数就是逆运算。例如，研究关于 <span class="math inline">\(k\)</span> 的方程<span class="math inline">\(3^k ≡ 13 (mod\ 17)\)</span>。在上面的例子中，一个解是 <span class="math inline">\(k = 4\)</span>，但是这不是唯一的解。由于<span class="math inline">\(3^{16} ≡1(mod\ 17)\)</span>-遵循费马小定理-因此，如果 <span class="math inline">\(n\)</span> 是一个整数，那么就有<span class="math inline">\(3^{4+16n} ≡ 3^4 × (3^{16})^n ≡ 13 × 1^n ≡ 13 (mod\ 17)\)</span>。因此，这个方程有无穷多个<span class="math inline">\(4 + 16n\)</span>形式的解。此外，因为<span class="math inline">\(16\)</span>是满足<span class="math inline">\(3^m ≡ 1 (mod\ 17)\)</span>的最小正整数 <span class="math inline">\(m\)</span> ，所以这些是方程仅有的解。等价地，所有可能解的集合可以由一个约束条件来表示，该约束条件为 <span class="math inline">\(k ≡ 4 (mod\ 16)\)</span>。</p>
</div>
<h1 id="dh算法">DH算法</h1>
<p>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(G\)</span> 来代称。</p>
<p>然后小红和小明各自生成一个随机整数作为私钥，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 <span class="math inline">\(a\)</span> 代称，小明的私钥用 <span class="math inline">\(b\)</span> 代称。</p>
<p>现在小红和小明双方都有了 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(G\)</span> 以及各自的私钥，于是就可以计算出公钥：</p>
<ul>
<li>小红的公钥记作 <span class="math inline">\(A\)</span>，<span class="math inline">\(A = G ^ a ( mod\ P )\)</span>；</li>
<li>小明的公钥记作 <span class="math inline">\(B\)</span>，<span class="math inline">\(B = G ^ b ( mod\ P )\)</span>；</li>
</ul>
<p><span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 也是公开的，因为根据离散对数的原理，从真数（<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>）反向计算对数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。</p>
<p>双方交换各自 DH 公钥后，小红手上共有 <span class="math inline">\(5\)</span> 个数：<span class="math inline">\(P\)</span>、<span class="math inline">\(G\)</span>、<span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>，小明手上也同样共有 5 个数：<span class="math inline">\(P\)</span>、<span class="math inline">\(G\)</span>、<span class="math inline">\(b\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(A\)</span>。然后小红执行运算：<span class="math inline">\(B ^ a ( mod\ P )\)</span>，其结果为 <span class="math inline">\(K\)</span>，因为离散对数的幂运算有交换律，所以小明执行运算：<span class="math inline">\(A ^ b ( mod\ P )\)</span>，得到的结果也是 <span class="math inline">\(K\)</span>。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/rwm38y35kk.webp" alt="DH算法流程"></p>
<p>这个 <span class="math inline">\(K\)</span> 就是小红和小明之间用的对称加密密钥，可以作为会话密钥使用（但是通常不这么做）。</p>
<p>可以看到，整个密钥协商过程中，小红和小明公开了 <span class="math inline">\(4\)</span> 个信息：<span class="math inline">\(P\)</span>、<span class="math inline">\(G\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>，其中 <span class="math inline">\(P\)</span>、<span class="math inline">\(G\)</span> 是算法的参数，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 是公钥，而 <span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span> 是双方各自保管的私钥，黑客无法获取这 <span class="math inline">\(2\)</span> 个私钥，因此黑客只能从公开的 <span class="math inline">\(P\)</span>、<span class="math inline">\(G\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span> 入手，计算出离散对数（私钥）。</p>
<p>前面也多次强调， 根据离散对数的原理，如果 <span class="math inline">\(P\)</span> 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 <span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span> 的，破解不出私钥，也就无法计算出主密钥，因此 DH 密钥交换是安全的。</p>
<h1 id="dhe算法">DHE算法</h1>
<p>根据私钥生成的方式，DH 算法分为两种实现：</p>
<ul>
<li>static DH 算法，这个是已经被废弃了。</li>
<li>DHE 算法，现在常用的。</li>
</ul>
<p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。</p>
<p>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出主密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法不具备前向安全性。</p>
<p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「<strong>前向安全</strong>」。</p>
<h1 id="ecdhe算法">ECDHE算法</h1>
<p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。</p>
<p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p>
<p>小红和小明使用 ECDHE 密钥交换算法的过程：</p>
<ul>
<li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 <span class="math inline">\(G\)</span>，这两个参数都是公开的；</li>
<li>双方各自随机生成一个随机数作为私钥<span class="math inline">\(d\)</span>，并与基点 <span class="math inline">\(G\)</span>相乘得到公钥<span class="math inline">\(Q\)</span>（<span class="math inline">\(Q = dG\)</span>），此时小红的公私钥为 <span class="math inline">\(Q_1\)</span> 和 <span class="math inline">\(d_1\)</span>，小明的公私钥为 <span class="math inline">\(Q_2\)</span> 和 <span class="math inline">\(d_2\)</span>；</li>
<li>双方交换各自的公钥，最后小红计算点<span class="math inline">\(（x_1，y_1） = d_1Q_2\)</span>，小明计算点<span class="math inline">\(（x_2，y_2） = d_2Q_1\)</span>，由于椭圆曲线上是可以满足乘法交换和结合律，所以 <span class="math inline">\(d_1Q_2 = d_1d_2G = d_2d_1G = d_2Q_1\)</span> ，因此双方的 <span class="math inline">\(x\)</span> 坐标是一样的，所以它是共享密钥，也就是预主密钥。</li>
</ul>
<p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p>
<h1 id="ecdhe握手过程">ECDHE握手过程</h1>
<p>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。 我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/pzdzgr0mln.webp"></p>
<p>细心的小伙伴应该发现了，<strong>使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据</strong>，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p>
<p>所以，<strong>ECDHE 相比 RSA 握手过程省去了一个消息往返的时间</strong>，这个有点「抢跑」的意思，它被称为是「<em>TLS False Start</em>」，跟「<em>TCP Fast Open</em>」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p>
<p>其详细的通信流程图如下：<br>
<img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/3602849187.webp"></p>
<h2 id="tls第一次握手-1">TLS第一次握手</h2>
<p>客户端首先会发一个「<strong>Client Hello</strong>」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（Client Random）</strong>。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/s66ayc0rat.webp"></p>
<h2 id="tls第二次握手-1">TLS第二次握手</h2>
<p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「<strong>Server Hello</strong>」消息，消息面有服务器确认的 TLS 版本号，也给出了一个<strong>随机数（Server Random）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/t0heop0ra2.webp"></p>
<p>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。</p>
<p>「<strong>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</strong>」</p>
<ul>
<li>密钥协商算法使用 ECDHE；</li>
<li>签名算法使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；</li>
<li>摘要算法使用 SHA384；</li>
</ul>
<p>接着，服务端为了证明自己的身份，发送「<strong>Certificate</strong>」消息，会把证书也发给客户端。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/8z6ijqontn.webp"></p>
<p>这一步就和 RSA 握手过程有很大到区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「<strong>Server Key Exchange</strong>」消息。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/dnkq19f2kp.webp"></p>
<p>这个过程服务器做了三件事：</p>
<ul>
<li>选择了名为 <strong>named_curve</strong> 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 <span class="math inline">\(G\)</span> 也定好了，这些都会公开给客户端；</li>
<li>生成随机数作为服务端椭圆曲线的私钥，保留到本地；</li>
<li>根据基点 <span class="math inline">\(G\)</span> 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。</li>
</ul>
<p>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。</p>
<p>随后，就是「<strong>Server Hello Done</strong>」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/e9gsbztuu3.webp"></p>
<p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<strong>Client Random</strong>、<strong>Server Random</strong> 、<strong>使用的椭圆曲线</strong>、<strong>椭圆曲线基点 G</strong>、<strong>服务端椭圆曲线的公钥</strong>，这几个信息很重要，是后续生成主密钥和会话密钥的材料。</p>
<h2 id="tls第三次握手-1">TLS第三次握手</h2>
<p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书到过程，会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。</p>
<p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「<strong>Client Key Exchange</strong>」消息发给服务端。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/pi6fj19jla.webp"></p>
<p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 <span class="math inline">\(G\)</span>。于是，双方都就计算出点<span class="math inline">\(（x，y）\)</span>，其中 <span class="math inline">\(x\)</span> 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 <span class="math inline">\(x\)</span> 可以作为会话密钥，但实际应用中，<span class="math inline">\(x\)</span> 还不是最终的会话密钥。</p>
<p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？<strong>最终的主密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的</strong>。之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，安全性更高。然后再利用<strong>主密钥</strong>，使用<strong>PRF</strong>算法得到会话密钥</p>
<p>算好会话密钥后，客户端会发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端后续改用对称算法加密通信。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/dubg1j6fdg.webp"></p>
<p>接着，客户端会发「<strong>Encrypted Handshake Message</strong>」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p>
<p><img src="/2024/09/12/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/tipgyu0eqd.webp"></p>
<h2 id="tls第四次握手-1">TLS第四次握手</h2>
<p>最后，服务端也会有一个同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p>
<h1 id="总结">总结</h1>
<p>RSA 和 ECDHE 握手过程的区别：</p>
<ul>
<li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；</li>
<li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（RTT）；</li>
<li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「<strong>Server Key Exchange</strong>」消息，而 RSA 握手过程没有该消息（握手流程上的区别主要在这里）；</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>The Art of Command Line</title>
    <url>/2024/05/10/The-Art-of-Command-Line/</url>
    <content><![CDATA[<h1 id="命令行的艺术">命令行的艺术</h1>
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#基础">基础</a></li>
<li><a href="#日常使用">日常使用</a></li>
<li><a href="#文件及数据处理">文件及数据处理</a></li>
<li><a href="#系统调试">系统调试</a></li>
<li><a href="#单行脚本">单行脚本</a></li>
<li><a href="#冷门但有用">冷门但有用</a></li>
<li><a href="#仅限-os-x-系统">仅限 OS X 系统</a></li>
<li><a href="#仅限-windows-系统">仅限 Windows 系统</a></li>
<li><a href="#更多资源">更多资源</a></li>
<li><a href="#免责声明">免责声明</a></li>
</ul>
<p>熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p>
<p>这篇文章是<a href="AUTHORS.md">许多作者和译者</a>共同的成果。这里的部分内容<a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">首次</a><a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">出现</a>于 <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>，但已经迁移到了 GitHub，并由众多高手做出了许多改进。如果你在本文中发现了错误或者存在可以改善的地方，请<a href="/CONTRIBUTING.md"><strong>贡献你的一份力量</strong></a>。</p>
<h2 id="前言">前言</h2>
<p>涵盖范围：</p>
<ul>
<li>这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到<em>覆盖面广</em>（涉及所有重要的内容），<em>具体</em>（给出具体的最常用的例子），以及<em>简洁</em>（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。</li>
<li>本文主要为 Linux 所写，但在<a href="#仅限-os-x-系统">仅限 OS X 系统</a>章节和<a href="#仅限-windows-系统">仅限 Windows 系统</a>章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。</li>
<li>本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。</li>
<li>除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code>，<code>pacman</code>，<br>
<code>pip</code> 或 <code>brew</code>（以及其它合适的包管理器）来安装依赖的程序。</li>
<li>遇到问题的话，请尝试使用 <a href="http://explainshell.com/">Explainshell</a> 去获取相关命令、参数、管道等内容的解释。</li>
</ul>
<h2 id="基础">基础</h2>
<ul>
<li><p>学习 Bash 的基础知识。具体地，在命令行中输入 <code>man bash</code> 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你<em>只</em>学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。</p></li>
<li><p>熟悉至少一个基于文本的编辑器。通常而言 Vim （<code>vi</code>） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。</p></li>
<li><p>学会如何使用 <code>man</code> 命令去阅读文档。学会使用 <code>apropos</code> 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 <code>help</code> 和 <code>help -d</code> 命令获取帮助信息。你可以用 <code>type 命令</code> 来判断这个命令到底是可执行文件、shell 内置命令还是别名。</p></li>
<li><p>学会使用 <code>&gt;</code> 和 <code>&lt;</code> 来重定向输出和输入，学会使用 <code>|</code> 来重定向管道。明白 <code>&gt;</code> 会覆盖了输出文件而 <code>&gt;&gt;</code> 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。</p></li>
<li><p>学会使用通配符 <code>*</code> （或许再算上 <code>?</code> 和 <code>[</code>...<code>]</code>） 和引用以及引用中 <code>'</code> 和 <code>"</code> 的区别（后文中有一些具体的例子）。</p></li>
<li><p>熟悉 Bash 中的任务管理工具：<code>&amp;</code>，<strong>ctrl-z</strong>，<strong>ctrl-c</strong>，<code>jobs</code>，<code>fg</code>，<code>bg</code>，<code>kill</code> 等。</p></li>
<li><p>学会使用 <code>ssh</code> 进行远程命令行登录，最好知道如何使用 <code>ssh-agent</code>，<code>ssh-add</code> 等命令来实现基础的无密码认证登录。</p></li>
<li><p>学会基本的文件管理工具：<code>ls</code> 和 <code>ls -l</code> （了解 <code>ls -l</code> 中每一列代表的意义），<code>less</code>，<code>head</code>，<code>tail</code> 和 <code>tail -f</code> （甚至 <code>less +F</code>），<code>ln</code> 和 <code>ln -s</code> （了解硬链接与软链接的区别），<code>chown</code>，<code>chmod</code>，<code>du</code> （硬盘使用情况概述：<code>du -hs *</code>）。 关于文件系统的管理，学习 <code>df</code>，<code>mount</code>，<code>fdisk</code>，<code>mkfs</code>，<code>lsblk</code>。知道 inode 是什么（与 <code>ls -i</code> 和 <code>df -i</code> 等命令相关）。</p></li>
<li><p>学习基本的网络管理工具：<code>ip</code> 或 <code>ifconfig</code>，<code>dig</code>。</p></li>
<li><p>学习并使用一种版本控制管理系统，例如 <code>git</code>。</p></li>
<li><p>熟悉正则表达式，学会使用 <code>grep</code>／<code>egrep</code>，它们的参数中 <code>-i</code>，<code>-o</code>，<code>-v</code>，<code>-A</code>，<code>-B</code> 和 <code>-C</code> 这些是很常用并值得认真学习的。</p></li>
<li><p>学会使用 <code>apt-get</code>，<code>yum</code>，<code>dnf</code> 或 <code>pacman</code> （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 <code>pip</code> 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 <code>pip</code> 来安装会很方便）。</p></li>
</ul>
<h2 id="日常使用">日常使用</h2>
<ul>
<li><p>在 Bash 中，可以通过按 <strong>Tab</strong> 键实现自动补全参数，使用 <strong>ctrl-r</strong> 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 <strong>ctrl-r</strong> 会向后查找匹配项，按下 <strong>Enter</strong> 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。</p></li>
<li><p>在 Bash 中，可以按下 <strong>ctrl-w</strong> 删除你键入的最后一个单词，<strong>ctrl-u</strong> 可以删除行内光标所在位置之前的内容，<strong>alt-b</strong> 和 <strong>alt-f</strong> 可以以单词为单位移动光标，<strong>ctrl-a</strong> 可以将光标移至行首，<strong>ctrl-e</strong> 可以将光标移至行尾，<strong>ctrl-k</strong> 可以删除光标至行尾的所有内容，<strong>ctrl-l</strong> 可以清屏。键入 <code>man readline</code> 可以查看 Bash 中的默认快捷键。内容有很多，例如 <strong>alt-.</strong> 循环地移向前一个参数，而 <strong>alt-</strong>* 可以展开通配符。</p></li>
<li><p>你喜欢的话，可以执行 <code>set -o vi</code> 来使用 vi 风格的快捷键，而执行 <code>set -o emacs</code> 可以把它改回来。</p></li>
<li><p>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 <strong>escape-v</strong>。</p></li>
<li><p>键入 <code>history</code> 查看命令行历史记录，再用 <code>!n</code>（<code>n</code> 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 <code>!$</code>， 它用于指代上次键入的参数，而 <code>!!</code> 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 <strong>ctrl-r</strong> 和 <strong>alt-.</strong> 来实现。</p></li>
<li><p><code>cd</code> 命令可以切换工作路径，输入 <code>cd ~</code> 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 <code>~</code>（例如 <code>~/.bashrc</code>）。在 <code>sh</code> 脚本里则用环境变量 <code>$HOME</code> 指代 home 目录的路径。</p></li>
<li><p>回到前一个工作路径：<code>cd -</code>。</p></li>
<li><p>如果你输入命令的时候中途改了主意，按下 <strong>alt-#</strong> 在行首添加 <code>#</code> 把它当做注释再按下回车执行（或者依次按下 <strong>ctrl-a</strong>， <strong>#</strong>， <strong>enter</strong>）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。</p></li>
<li><p>使用 <code>xargs</code> （ 或 <code>parallel</code>）。他们非常给力。注意到你可以控制每行参数个数（<code>-L</code>）和最大并行数（<code>-P</code>）。如果你不确定它们是否会按你想的那样工作，先使用 <code>xargs echo</code> 查看一下。此外，使用 <code>-I&#123;&#125;</code> 会很方便。例如：</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&#x27;*.py&#x27;</span> | xargs grep some_function</span><br><span class="line"><span class="built_in">cat</span> hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>pstree -p</code> 以一种优雅的方式展示进程树。</p></li>
<li><p>使用 <code>pgrep</code> 和 <code>pkill</code> 根据名字查找进程或发送信号（<code>-f</code> 参数通常有用）。</p></li>
<li><p>了解你可以发往进程的信号的种类。比如，使用 <code>kill -STOP [pid]</code> 停止一个进程。使用 <code>man 7 signal</code> 查看详细列表。</p></li>
<li><p>使用 <code>nohup</code> 或 <code>disown</code> 使一个后台进程持续运行。</p></li>
<li><p>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 <code>-u</code> 则检查 UDP 端口）或者 <code>lsof -iTCP -sTCP:LISTEN -P -n</code> (这也可以在 OS X 上运行)。</p></li>
<li><p><code>lsof</code> 来查看开启的套接字和文件。</p></li>
<li><p>使用 <code>uptime</code> 或 <code>w</code> 来查看系统已经运行多长时间。</p></li>
<li><p>使用 <code>alias</code> 来创建常用命令的快捷形式。例如：<code>alias ll='ls -latr'</code> 创建了一个新的命令别名 <code>ll</code>。</p></li>
<li><p>可以把别名、shell 选项和常用函数保存在 <code>~/.bashrc</code>，具体看下这篇<a href="http://superuser.com/a/183980/7106">文章</a>。这样做的话你就可以在所有 shell 会话中使用你的设定。</p></li>
<li><p>把环境变量的设定以及登陆时要执行的命令保存在 <code>~/.bash_profile</code>。而对于从图形界面启动的 shell 和 <code>cron</code> 启动的 shell，则需要单独配置文件。</p></li>
<li><p>要想在几台电脑中同步你的配置文件（例如 <code>.bashrc</code> 和 <code>.bash_profile</code>），可以借助 Git。</p></li>
<li><p>当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 <code>"$FOO"</code>。尽量使用 <code>-0</code> 或 <code>-print0</code> 选项以便用 NULL 来分隔文件名，例如 <code>locate -0 pattern | xargs -0 ls -al</code> 或 <code>find / -print0 -type d | xargs -0 ls -al</code>。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 <code>IFS=$'\n'</code> 把内部字段分隔符设为换行符。</p></li>
<li><p>在 Bash 脚本中，使用 <code>set -x</code> 去调试输出（或者使用它的变体 <code>set -v</code>，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 <code>set -e</code> 令脚本在发生错误时退出而不是继续运行；使用 <code>set -u</code> 来检查是否使用了未赋值的变量；试试 <code>set -o pipefail</code>，它可以监测管道中的错误。当牵扯到很多脚本时，使用 <code>trap</code> 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息：</p></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27;error: Script failed: see failed command above&#x27;&quot;</span> ERR</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Bash 脚本中，子 shell（使用括号 <code>(...)</code>）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># do something in current dir</span></span><br><span class="line">(<span class="built_in">cd</span> /some/other/dir &amp;&amp; other-command)</span><br><span class="line"><span class="comment"># continue in original dir</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 Bash 中，变量有许多的扩展方式。<code>$&#123;name:?error message&#125;</code> 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 <code>input_file=$&#123;1:?usage: $0 input_file&#125;</code>。在变量为空时使用默认值：<code>$&#123;name:-default&#125;</code>。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 <code>output_file=$&#123;2:-logfile&#125;</code>，如果省略了 <code>$2</code>，它的值就为空，于是 <code>output_file</code> 就会被设为 <code>logfile</code>。数学表达式：<code>i=$(( (i + 1) % 5 ))</code>。序列：<code>&#123;1..10&#125;</code>。截断字符串：<code>$&#123;var%suffix&#125;</code> 和 <code>$&#123;var#prefix&#125;</code>。例如，假设 <code>var=foo.pdf</code>，那么 <code>echo $&#123;var%.pdf&#125;.txt</code> 将输出 <code>foo.txt</code>。</p></li>
<li><p>使用括号扩展（<code>&#123;</code>...<code>&#125;</code>）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 <code>mv foo.&#123;txt,pdf&#125; some-dir</code>（同时移动两个文件），<code>cp somefile&#123;,.bak&#125;</code>（会被扩展成 <code>cp somefile somefile.bak</code>）或者 <code>mkdir -p test-&#123;a,b,c&#125;/subtest-&#123;1,2,3&#125;</code>（会被扩展成所有可能的组合，并创建一个目录树）。</p></li>
<li><p>通过使用 <code>&lt;(some command)</code> 可以将输出视为文件。例如，对比本地文件 <code>/etc/hosts</code> 和一个远程文件：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">diff /etc/hosts &lt;(ssh somehost <span class="built_in">cat</span> /etc/hosts)</span><br></pre></td></tr></table></figure>
<ul>
<li>编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="comment"># 在这里写代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>了解 Bash 中的“here documents”，例如 <code>cat &lt;&lt;EOF ...</code>。</p></li>
<li><p>在 Bash 中，同时重定向标准输出和标准错误：<code>some-command &gt;logfile 2&gt;&amp;1</code> 或者 <code>some-command &amp;&gt;logfile</code>。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 <code>&lt;/dev/null</code> 是一个好习惯。</p></li>
<li><p>使用 <code>man ascii</code> 查看具有十六进制和十进制值的ASCII表。<code>man unicode</code>，<code>man utf-8</code>，以及 <code>man latin1</code> 有助于你去了解通用的编码信息。</p></li>
<li><p>使用 <code>screen</code> 或 <a href="https://tmux.github.io/"><code>tmux</code></a> 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 <code>byobu</code> 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 <a href="https://github.com/bogner/dtach"><code>dtach</code></a>。</p></li>
<li><p>ssh 中，了解如何使用 <code>-L</code> 或 <code>-D</code>（偶尔需要用 <code>-R</code>）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。</p></li>
<li><p>对 ssh 设置做一些小优化可能是很有用的，例如这个 <code>~/.ssh/config</code> 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCPKeepAlive=yes</span><br><span class="line">ServerAliveInterval=15</span><br><span class="line">ServerAliveCountMax=6</span><br><span class="line">Compression=yes</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath /tmp/%r@%h:%p</span><br><span class="line">ControlPersist yes</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 <code>StrictHostKeyChecking=no</code>，<code>ForwardAgent=yes</code>。</p></li>
<li><p>考虑使用 <a href="https://mosh.org/"><code>mosh</code></a> 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。</p></li>
<li><p>获取八进制形式的文件访问权限（修改系统设置时通常需要，但 <code>ls</code> 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> -c <span class="string">&#x27;%A %a %n&#x27;</span> /etc/timezone</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 <a href="https://github.com/mooz/percol"><code>percol</code></a> 或者 <a href="https://github.com/junegunn/fzf"><code>fzf</code></a> 可以交互式地从另一个命令输出中选取值。</p></li>
<li><p>使用 <code>fpp</code>（<a href="https://github.com/facebook/PathPicker">PathPicker</a>）可以与基于另一个命令(例如 <code>git</code>）输出的文件交互。</p></li>
<li><p>将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：<br>
<code>python -m SimpleHTTPServer 7777</code> （使用端口 7777 和 Python 2）或<code>python -m http.server 7777</code> （使用端口 7777 和 Python 3）。</p></li>
<li><p>以其他用户的身份执行命令，使用 <code>sudo</code>。默认以 root 用户的身份执行；使用 <code>-u</code> 来指定其他用户。使用 <code>-i</code> 来以该用户登录（需要输入_你自己的_密码）。</p></li>
<li><p>将 shell 切换为其他用户，使用 <code>su username</code> 或者 <code>su - username</code>。加入 <code>-</code> 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。</p></li>
<li><p>了解命令行的 <a href="https://wiki.debian.org/CommonErrorMessages/ArgumentListTooLong">128K 限制</a>。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 <code>find</code> 或 <code>xargs</code> 通常可以解决。）</p></li>
<li><p>当你需要一个基本的计算器时，可以使用 <code>python</code> 解释器（当然你要用 python 的时候也是这样）。例如：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 2+3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="文件及数据处理">文件及数据处理</h2>
<ul>
<li><p>在当前目录下通过文件名查找一个文件，使用类似于这样的命令：<code>find . -iname '*something*'</code>。在所有路径下通过文件名查找文件，使用 <code>locate something</code> （但注意到 <code>updatedb</code> 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。</p></li>
<li><p>使用 <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a> 在源代码或数据文件里检索（<code>grep -r</code> 同样可以做到，但相比之下 <code>ag</code> 更加先进）。</p></li>
<li><p>将 HTML 转为文本：<code>lynx -dump -stdin</code>。</p></li>
<li><p>Markdown，HTML，以及所有文档格式之间的转换，试试 <a href="http://pandoc.org/"><code>pandoc</code></a>。</p></li>
<li><p>当你要处理棘手的 XML 时候，<code>xmlstarlet</code> 算是上古时代流传下来的神器。</p></li>
<li><p>使用 <a href="http://stedolan.github.io/jq/"><code>jq</code></a> 处理 JSON。</p></li>
<li><p>使用 <a href="https://github.com/0k/shyaml"><code>shyaml</code></a> 处理 YAML。</p></li>
<li><p>要处理 Excel 或 CSV 文件的话，<a href="https://github.com/onyxfish/csvkit">csvkit</a> 提供了 <code>in2csv</code>，<code>csvcut</code>，<code>csvjoin</code>，<code>csvgrep</code> 等方便易用的工具。</p></li>
<li><p>当你要处理 Amazon S3 相关的工作的时候，<a href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> 是一个很方便的工具而 <a href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> 的效率更高。Amazon 官方提供的 <a href="https://github.com/aws/aws-cli"><code>aws</code></a> 以及 <a href="https://github.com/donnemartin/saws"><code>saws</code></a> 是其他 AWS 相关工作的基础，值得学习。</p></li>
<li><p>了解如何使用 <code>sort</code> 和 <code>uniq</code>，包括 uniq 的 <code>-u</code> 参数和 <code>-d</code> 参数，具体内容在后文单行脚本节中。另外可以了解一下 <code>comm</code>。</p></li>
<li><p>了解如何使用 <code>cut</code>，<code>paste</code> 和 <code>join</code> 来更改文件。很多人都会使用 <code>cut</code>，但遗忘了 <code>join</code>。</p></li>
<li><p>了解如何运用 <code>wc</code> 去计算新行数（<code>-l</code>），字符数（<code>-m</code>），单词数（<code>-w</code>）以及字节数（<code>-c</code>）。</p></li>
<li><p>了解如何使用 <code>tee</code> 将标准输入复制到文件甚至标准输出，例如 <code>ls -al | tee file.txt</code>。</p></li>
<li><p>要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 <a href="https://www.gnu.org/software/datamash/"><code>datamash</code></a>。</p></li>
<li><p>注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 <code>LANG</code> 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降<em>许多倍</em>。某些情况下（例如集合运算）你可以放心的使用 <code>export LC_ALL=C</code> 来忽略掉国际化并按照字节来判断顺序。</p></li>
<li><p>你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 <code>TZ=Pacific/Fiji date</code> 可以获取斐济的时间。</p></li>
<li><p>了解如何使用 <code>awk</code> 和 <code>sed</code> 来进行简单的数据处理。 参阅 <a href="#one-liners">One-liners</a> 获取示例。</p></li>
<li><p>替换一个或多个文件中出现的字符串：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">perl -pi.bak -e <span class="string">&#x27;s/old-string/new-string/g&#x27;</span> my-files-*.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <a href="https://github.com/jlevy/repren"><code>repren</code></a> 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 <code>rename</code> 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件、目录和内容全部重命名 foo -&gt; bar:</span></span><br><span class="line">repren --full --preserve-case --from foo --to bar .</span><br><span class="line"><span class="comment"># 还原所有备份文件 whatever.bak -&gt; whatever:</span></span><br><span class="line">repren --renames --from <span class="string">&#x27;(.*)\.bak&#x27;</span> --to <span class="string">&#x27;\1&#x27;</span> *.bak</span><br><span class="line"><span class="comment"># 用 rename 实现上述功能（若可用）:</span></span><br><span class="line">rename <span class="string">&#x27;s/\.bak$//&#x27;</span> *.bak</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 man 页面的描述，<code>rsync</code> 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 <code>rsync</code> 代替 <code>scp</code> 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的<a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html">最快方法</a>之一：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; <span class="built_in">rmdir</span> some-dir</span><br></pre></td></tr></table></figure>
<ul>
<li><p>若要在复制文件时获取当前进度，可使用 <code>pv</code>，<a href="https://github.com/dmerejkowsky/pycp"><code>pycp</code></a>，<a href="https://github.com/Xfennec/progress"><code>progress</code></a>，<code>rsync --progress</code>。若所执行的复制为block块拷贝，可以使用 <code>dd status=progress</code>。</p></li>
<li><p>使用 <code>shuf</code> 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。</p></li>
<li><p>了解 <code>sort</code> 的参数。显示数字时，使用 <code>-n</code> 或者 <code>-h</code> 来显示更易读的数（例如 <code>du -h</code> 的输出）。明白排序时关键字的工作原理（<code>-t</code> 和 <code>-k</code>）。例如，注意到你需要 <code>-k1，1</code> 来仅按第一个域来排序，而 <code>-k1</code> 意味着按整行排序。稳定排序（<code>sort -s</code>）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 <code>sort -k1，1 | sort -s -k2，2</code>。</p></li>
<li><p>如果你想在 Bash 命令行中写 tab 制表符，按下 <strong>ctrl-v</strong> <strong>[Tab]</strong> 或键入 <code>$'\t'</code> （后者可能更好，因为你可以复制粘贴它）。</p></li>
<li><p>标准的源代码对比及合并工具是 <code>diff</code> 和 <code>patch</code>。使用 <code>diffstat</code> 查看变更总览数据。注意到 <code>diff -r</code> 对整个文件夹有效。使用 <code>diff -r tree1 tree2 | diffstat</code> 查看变更的统计数据。<code>vimdiff</code> 用于比对并编辑文件。</p></li>
<li><p>对于二进制文件，使用 <code>hd</code>，<code>hexdump</code> 或者 <code>xxd</code> 使其以十六进制显示，使用 <code>bvi</code>，<code>hexedit</code> 或者 <code>biew</code> 来进行二进制编辑。</p></li>
<li><p>同样对于二进制文件，<code>strings</code>（包括 <code>grep</code> 等工具）可以帮助在二进制文件中查找特定比特。</p></li>
<li><p>制作二进制差分文件（Delta 压缩），使用 <code>xdelta3</code>。</p></li>
<li><p>使用 <code>iconv</code> 更改文本编码。需要更高级的功能，可以使用 <code>uconv</code>，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uconv -f utf-8 -t utf-8 -x <span class="string">&#x27;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#x27;</span> &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><p>拆分文件可以使用 <code>split</code>（按大小拆分）和 <code>csplit</code>（按模式拆分）。</p></li>
<li><p>操作日期和时间表达式，可以用 <a href="http://www.fresse.org/dateutils/"><code>dateutils</code></a> 中的 <code>dateadd</code>、<code>datediff</code>、<code>strptime</code> 等工具。</p></li>
<li><p>使用 <code>zless</code>、<code>zmore</code>、<code>zcat</code> 和 <code>zgrep</code> 对压缩过的文件进行操作。</p></li>
<li><p>文件属性可以通过 <code>chattr</code> 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：<code>sudo chattr +i /critical/directory/or/file</code></p></li>
<li><p>使用 <code>getfacl</code> 和 <code>setfacl</code> 以保存和恢复文件权限。例如：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getfacl -R /some/path &gt; permissions.txt</span><br><span class="line">setfacl --restore=permissions.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>为了高效地创建空文件，请使用 <code>truncate</code>（创建<a href="https://zh.wikipedia.org/wiki/稀疏文件">稀疏文件</a>），<code>fallocate</code>（用于 ext4，xfs，btrf 和 ocfs2 文件系统），<code>xfs_mkfile</code>（适用于几乎所有的文件系统，包含在 xfsprogs 包中），<code>mkfile</code>（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。</li>
</ul>
<h2 id="系统调试">系统调试</h2>
<ul>
<li><p><code>curl</code> 和 <code>curl -I</code> 可以被轻松地应用于 web 调试中，它们的好兄弟 <code>wget</code> 也是如此，或者也可以试试更潮的 <a href="https://github.com/jkbrzt/httpie"><code>httpie</code></a>。</p></li>
<li><p>获取 CPU 和硬盘的使用状态，通常使用使用 <code>top</code>（<code>htop</code> 更佳），<code>iostat</code> 和 <code>iotop</code>。而 <code>iostat -mxz 15</code> 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。</p></li>
<li><p>使用 <code>netstat</code> 和 <code>ss</code> 查看网络连接的细节。</p></li>
<li><p><code>dstat</code> 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 <a href="https://github.com/nicolargo/glances"><code>glances</code></a>，它会在一个终端窗口中向你提供一些系统级的数据。</p></li>
<li><p>若要了解内存状态，运行并理解 <code>free</code> 和 <code>vmstat</code> 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。</p></li>
<li><p>Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 <code>kill -3 &lt;pid&gt;</code> 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 <code>jps</code>，<code>jstat</code>，<code>jstack</code>，<code>jmap</code> 很有用。<a href="https://github.com/aragozin/jvm-tools">SJK tools</a> 更高级。</p></li>
<li><p>使用 <a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a> 去跟踪路由，用于确定网络问题。</p></li>
<li><p>用 <a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a> 来查看磁盘使用情况，它比寻常的命令，如 <code>du -sh *</code>，更节省时间。</p></li>
<li><p>查找正在使用带宽的套接字连接或进程，使用 <a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>。</p></li>
<li><p><code>ab</code> 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 <code>siege</code>。</p></li>
<li><p><a href="https://wireshark.org/"><code>wireshark</code></a>，<a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a> 和 <a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a> 可用于复杂的网络调试。</p></li>
<li><p>了解 <code>strace</code> 和 <code>ltrace</code>。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（<code>-c</code>）和附加到一个运行的进程参数 （<code>-p</code>）。</p></li>
<li><p>了解使用 <code>ldd</code> 来检查共享库。但是<a href="http://www.catonmat.net/blog/ldd-arbitrary-code-execution/">永远不要在不信任的文件上运行</a>。</p></li>
<li><p>了解如何运用 <code>gdb</code> 连接到一个运行着的进程并获取它的堆栈轨迹。</p></li>
<li><p>学会使用 <code>/proc</code>。它在调试正在出现的问题的时候有时会效果惊人。比如：<code>/proc/cpuinfo</code>，<code>/proc/meminfo</code>，<code>/proc/cmdline</code>，<code>/proc/xxx/cwd</code>，<code>/proc/xxx/exe</code>，<code>/proc/xxx/fd/</code>，<code>/proc/xxx/smaps</code>（这里的 <code>xxx</code> 表示进程的 id 或 pid）。</p></li>
<li><p>当调试一些之前出现的问题的时候，<a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a> 非常有用。它展示了 cpu、内存以及网络等的历史数据。</p></li>
<li><p>关于更深层次的系统分析以及性能分析，看看 <code>stap</code>（<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>），<a href="https://en.wikipedia.org/wiki/Perf_(Linux)"><code>perf</code></a>，以及<a href="https://github.com/draios/sysdig"><code>sysdig</code></a>。</p></li>
<li><p>查看你当前使用的系统，使用 <code>uname</code>，<code>uname -a</code>（Unix／kernel 信息）或者 <code>lsb_release -a</code>（Linux 发行版信息）。</p></li>
<li><p>无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 <code>dmesg</code>。</p></li>
<li><p>如果你删除了一个文件，但通过 <code>du</code> 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：<br>
<code>lsof | grep deleted | grep "filename-of-my-big-file"</code></p></li>
</ul>
<h2 id="单行脚本">单行脚本</h2>
<p>一些命令组合的例子：</p>
<ul>
<li>当你需要对文本文件做集合交、并、差运算时，<code>sort</code> 和 <code>uniq</code> 会是你的好帮手。具体例子请参照代码后面的，此处假设 <code>a</code> 与 <code>b</code> 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 <code>/tmp</code> 在一个小的根分区上时你可能需要 <code>-T</code> 参数，但是实际上 <code>sort</code> 并不被内存大小约束），参阅前文中关于 <code>LC_ALL</code> 和 <code>sort</code> 的 <code>-u</code> 参数的部分。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> a b | <span class="built_in">uniq</span> &gt; c   <span class="comment"># c 是 a 并 b</span></span><br><span class="line"><span class="built_in">sort</span> a b | <span class="built_in">uniq</span> -d &gt; c   <span class="comment"># c 是 a 交 b</span></span><br><span class="line"><span class="built_in">sort</span> a b b | <span class="built_in">uniq</span> -u &gt; c   <span class="comment"># c 是 a - b</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 <code>grep . *</code>（每行都会附上文件名）或者 <code>head -100 *</code>（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 <code>/sys</code>、<code>/proc</code>、<code>/etc</code>）时特别好用。</p></li>
<li><p>计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123; x += $3 &#125; END &#123; print x &#125;&#x27;</span> myfile</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你想在文件树上查看大小/日期，这可能看起来像递归版的 <code>ls -l</code> 但比 <code>ls -lR</code> 更易于理解：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<ul>
<li>假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 <code>acct_id</code> 参数在 URI 中。如果你想计算出每个 <code>acct_id</code> 值有多少次请求，使用如下代码：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">egrep -o <span class="string">&#x27;acct_id=[0-9]+&#x27;</span> access.log | <span class="built_in">cut</span> -d= -f2 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn</span><br></pre></td></tr></table></figure>
<ul>
<li><p>要持续监测文件改动，可以使用 <code>watch</code>，例如检查某个文件夹中文件的改变，可以用 <code>watch -d -n 2 'ls -rtlh | tail'</code>；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 <code>watch -d -n 2 ifconfig</code>。</p></li>
<li><p>运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）：</p></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">taocl</span></span>() &#123;</span><br><span class="line">  curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md|</span><br><span class="line">    pandoc -f markdown -t html |</span><br><span class="line">    iconv -f <span class="string">&#x27;utf-8&#x27;</span> -t <span class="string">&#x27;unicode&#x27;</span> |</span><br><span class="line">    xmlstarlet fo --html --dropdtd |</span><br><span class="line">    xmlstarlet sel -t -v <span class="string">&quot;(html/body/ul/li[count(p)&gt;0])[<span class="variable">$RANDOM</span> mod last()+1]&quot;</span> |</span><br><span class="line">    xmlstarlet unesc | <span class="built_in">fmt</span> -80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冷门但有用">冷门但有用</h2>
<ul>
<li><p><code>expr</code>：计算表达式或正则匹配</p></li>
<li><p><code>m4</code>：简单的宏处理器</p></li>
<li><p><code>yes</code>：多次打印字符串</p></li>
<li><p><code>cal</code>：漂亮的日历</p></li>
<li><p><code>env</code>：执行一个命令（脚本文件中很有用）</p></li>
<li><p><code>printenv</code>：打印环境变量（调试时或在写脚本文件时很有用）</p></li>
<li><p><code>look</code>：查找以特定字符串开头的单词或行</p></li>
<li><p><code>cut</code>，<code>paste</code> 和 <code>join</code>：数据修改</p></li>
<li><p><code>fmt</code>：格式化文本段落</p></li>
<li><p><code>pr</code>：将文本格式化成页／列形式</p></li>
<li><p><code>fold</code>：包裹文本中的几行</p></li>
<li><p><code>column</code>：将文本格式化成多个对齐、定宽的列或表格</p></li>
<li><p><code>expand</code> 和 <code>unexpand</code>：制表符与空格之间转换</p></li>
<li><p><code>nl</code>：添加行号</p></li>
<li><p><code>seq</code>：打印数字</p></li>
<li><p><code>bc</code>：计算器</p></li>
<li><p><code>factor</code>：分解因数</p></li>
<li><p><a href="https://gnupg.org/"><code>gpg</code></a>：加密并签名文件</p></li>
<li><p><code>toe</code>：terminfo 入口列表</p></li>
<li><p><code>nc</code>：网络调试及数据传输</p></li>
<li><p><code>socat</code>：套接字代理，与 <code>netcat</code> 类似</p></li>
<li><p><a href="https://github.com/mattthias/slurm"><code>slurm</code></a>：网络流量可视化</p></li>
<li><p><code>dd</code>：文件或设备间传输数据</p></li>
<li><p><code>file</code>：确定文件类型</p></li>
<li><p><code>tree</code>：以树的形式显示路径和文件，类似于递归的 <code>ls</code></p></li>
<li><p><code>stat</code>：文件信息</p></li>
<li><p><code>time</code>：执行命令，并计算执行时间</p></li>
<li><p><code>timeout</code>：在指定时长范围内执行命令，并在规定时间结束后停止进程</p></li>
<li><p><code>lockfile</code>：使文件只能通过 <code>rm -f</code> 移除</p></li>
<li><p><code>logrotate</code>： 切换、压缩以及发送日志文件</p></li>
<li><p><code>watch</code>：重复运行同一个命令，展示结果并／或高亮有更改的部分</p></li>
<li><p><a href="https://github.com/joh/when-changed"><code>when-changed</code></a>：当检测到文件更改时执行指定命令。参阅 <code>inotifywait</code> 和 <code>entr</code>。</p></li>
<li><p><code>tac</code>：反向输出文件</p></li>
<li><p><code>shuf</code>：文件中随机选取几行</p></li>
<li><p><code>comm</code>：一行一行的比较排序过的文件</p></li>
<li><p><code>strings</code>：从二进制文件中抽取文本</p></li>
<li><p><code>tr</code>：转换字母</p></li>
<li><p><code>iconv</code> 或 <code>uconv</code>：文本编码转换</p></li>
<li><p><code>split</code> 和 <code>csplit</code>：分割文件</p></li>
<li><p><code>sponge</code>：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 <code>grep -v something some-file | sponge some-file</code></p></li>
<li><p><code>units</code>：将一种计量单位转换为另一种等效的计量单位（参阅 <code>/usr/share/units/definitions.units</code>）</p></li>
<li><p><code>apg</code>：随机生成密码</p></li>
<li><p><code>xz</code>：高比例的文件压缩</p></li>
<li><p><code>ldd</code>：动态库信息</p></li>
<li><p><code>nm</code>：提取 obj 文件中的符号</p></li>
<li><p><code>ab</code> 或 <a href="https://github.com/wg/wrk"><code>wrk</code></a>：web 服务器性能分析</p></li>
<li><p><code>strace</code>：调试系统调用</p></li>
<li><p><a href="http://www.bitwizard.nl/mtr/"><code>mtr</code></a>：更好的网络调试跟踪工具</p></li>
<li><p><code>cssh</code>：可视化的并发 shell</p></li>
<li><p><code>rsync</code>：通过 ssh 或本地文件系统同步文件和文件夹</p></li>
<li><p><a href="https://wireshark.org/"><code>wireshark</code></a> 和 <a href="https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html"><code>tshark</code></a>：抓包和网络调试工具</p></li>
<li><p><a href="http://ngrep.sourceforge.net/"><code>ngrep</code></a>：网络层的 grep</p></li>
<li><p><code>host</code> 和 <code>dig</code>：DNS 查找</p></li>
<li><p><code>lsof</code>：列出当前系统打开文件的工具以及查看端口信息</p></li>
<li><p><code>dstat</code>：系统状态查看</p></li>
<li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>：高层次的多子系统总览</p></li>
<li><p><code>iostat</code>：硬盘使用状态</p></li>
<li><p><code>mpstat</code>： CPU 使用状态</p></li>
<li><p><code>vmstat</code>： 内存使用状态</p></li>
<li><p><code>htop</code>：top 的加强版</p></li>
<li><p><code>last</code>：登入记录</p></li>
<li><p><code>w</code>：查看处于登录状态的用户</p></li>
<li><p><code>id</code>：用户/组 ID 信息</p></li>
<li><p><a href="http://sebastien.godard.pagesperso-orange.fr/"><code>sar</code></a>：系统历史数据</p></li>
<li><p><a href="http://www.ex-parrot.com/~pdw/iftop/"><code>iftop</code></a> 或 <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a>：套接字及进程的网络利用情况</p></li>
<li><p><code>ss</code>：套接字数据</p></li>
<li><p><code>dmesg</code>：引导及系统错误信息</p></li>
<li><p><code>sysctl</code>： 在内核运行时动态地查看和修改内核的运行参数</p></li>
<li><p><code>hdparm</code>：SATA/ATA 磁盘更改及性能分析</p></li>
<li><p><code>lsblk</code>：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息</p></li>
<li><p><code>lshw</code>，<code>lscpu</code>，<code>lspci</code>，<code>lsusb</code> 和 <code>dmidecode</code>：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等</p></li>
<li><p><code>lsmod</code> 和 <code>modinfo</code>：列出内核模块，并显示其细节</p></li>
<li><p><code>fortune</code>，<code>ddate</code> 和 <code>sl</code>：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用”</p></li>
</ul>
<h2 id="仅限-os-x-系统">仅限 OS X 系统</h2>
<p>以下是<em>仅限于</em> OS X 系统的技巧。</p>
<ul>
<li><p>用 <code>brew</code> （Homebrew）或者 <code>port</code> （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。</p></li>
<li><p>用 <code>pbcopy</code> 复制任何命令的输出到桌面应用，用 <code>pbpaste</code> 粘贴输入。</p></li>
<li><p>若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 <strong>alt-b</strong>、<strong>alt-f</strong> 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。</p></li>
<li><p>用 <code>open</code> 或者 <code>open -a /Applications/Whatever.app</code> 使用桌面应用打开文件。</p></li>
<li><p>Spotlight：用 <code>mdfind</code> 搜索文件，用 <code>mdls</code> 列出元数据（例如照片的 EXIF 信息）。</p></li>
<li><p>注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 <code>ps</code>，<code>ls</code>，<code>tail</code>，<code>awk</code>，<code>sed</code>）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 "BSD General Commands Manual" 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 <code>gawk</code> 和 <code>gsed</code> 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 <code>perl</code> ）或者经过仔细的测试。</p></li>
<li><p>用 <code>sw_vers</code> 获取 OS X 的版本信息。</p></li>
</ul>
<h2 id="仅限-windows-系统">仅限 Windows 系统</h2>
<p>以下是<em>仅限于</em> Windows 系统的技巧。</p>
<h3 id="在-windows-下获取-unix-工具">在 Windows 下获取 Unix 工具</h3>
<ul>
<li><p>可以安装 <a href="https://cygwin.com/">Cygwin</a> 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。</p></li>
<li><p>在 Windows 10 上，你可以使用 <a href="https://msdn.microsoft.com/commandline/wsl/about">Bash on Ubuntu on Windows</a>，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。</p></li>
<li><p>如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 <a href="http://www.mingw.org/">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys">MSYS</a> 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。</p></li>
<li><p>另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 <a href="https://github.com/dthree/cash">Cash</a>。注意在此环境下只有很少的 Unix 命令和命令行可用。</p></li>
</ul>
<h3 id="实用-windows-命令行工具">实用 Windows 命令行工具</h3>
<ul>
<li><p>可以使用 <code>wmic</code> 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。</p></li>
<li><p>Windows 实用的原生命令行网络工具包括 <code>ping</code>，<code>ipconfig</code>，<code>tracert</code>，和 <code>netstat</code>。</p></li>
<li><p>可以使用 <code>Rundll32</code> 命令来实现<a href="http://www.thewindowsclub.com/rundll32-shortcut-commands-windows">许多有用的 Windows 任务</a> 。</p></li>
</ul>
<h3 id="cygwin-技巧">Cygwin 技巧</h3>
<ul>
<li><p>通过 Cygwin 的包管理器来安装额外的 Unix 程序。</p></li>
<li><p>使用 <code>mintty</code> 作为你的命令行窗口。</p></li>
<li><p>要访问 Windows 剪贴板，可以通过 <code>/dev/clipboard</code>。</p></li>
<li><p>运行 <code>cygstart</code> 以通过默认程序打开一个文件。</p></li>
<li><p>要访问 Windows 注册表，可以使用 <code>regtool</code>。</p></li>
<li><p>注意 Windows 驱动器路径 <code>C:\</code> 在 Cygwin 中用 <code>/cygdrive/c</code> 代表，而 Cygwin 的 <code>/</code> 代表 Windows 中的 <code>C:\cygwin</code>。要转换 Cygwin 和 Windows 风格的路径可以用 <code>cygpath</code>。这在需要调用 Windows 程序的脚本里很有用。</p></li>
<li><p>学会使用 <code>wmic</code>，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。</p></li>
<li><p>要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 <a href="https://github.com/dthree/cash">Cash</a>。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。</p></li>
<li><p>要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 <a href="http://www.mingw.org/">MinGW</a> 以及它的 <a href="http://www.mingw.org/wiki/msys">MSYS</a> 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。</p></li>
</ul>
<h2 id="更多资源">更多资源</h2>
<ul>
<li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a>：一份精心组织的命令行工具及资源的列表。</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line">awesome-osx-command-line</a>：一份针对 OS X 命令行的更深入的指南。</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Strict mode</a>：为了编写更好的脚本文件。</li>
<li><a href="https://github.com/koalaman/shellcheck">shellcheck</a>：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html">Filenames and Pathnames in Shell</a>：有关如何在 shell 脚本里正确处理文件名的细枝末节。</li>
<li><a href="http://datascienceatthecommandline.com/#tools">Data Science at the Command Line</a>：用于数据科学的一些命令和工具，摘自同名书籍。</li>
</ul>
<h2 id="免责声明">免责声明</h2>
<p>除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 <em>有能力</em> 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;)</p>
<h2 id="授权条款">授权条款</h2>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License"></a></p>
<p>本文使用授权协议 <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>。</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>VTR Architecture Reference XML</title>
    <url>/2022/05/21/VTR-Architecture-Reference-XML/</url>
    <content><![CDATA[<h1 id="架构描述">架构描述</h1>
<h2 id="顶级标签arichitecture">顶级标签(&lt;arichitecture&gt;)</h2>
<p>首先整体架构使用标签<span class="p red">< architectures ></span>，该标签包含如下标签：</p>
<ul>
<li><span class="p red">< models ></span></li>
<li><span class="p red">< tiles ></span></li>
<li><span class="p red">< layout ></span></li>
<li><span class="p red">< device ></span></li>
<li><span class="p red">< switchlist ></span></li>
<li><span class="p red">< segmentlist ></span></li>
<li><span class="p red">< directlist ></span></li>
<li><span class="p red">< complexblocklist ></span></li>
</ul>
<h2 id="识别blif模型models">识别BLIF模型(&lt;models&gt;)</h2>
<p><code>&lt;models&gt;</code>标签包含<code>&lt;model name="string" never_prune="string"&gt;</code> <code>&lt;model&gt;</code>标签。其中每个标签都描述了 FPGA 架构接受的 BLIF <code>.subckt</code>模型名称。模型名称必须与对应的 BLIF 模型名称匹配。</p>
<p>never_prune 标志是可选的，可以是：</p>
<ul>
<li>false（默认）:裁剪掉没有输出的模块</li>
<li>true:不裁剪没有输出的模块</li>
</ul>
<div class="note info flat"><p>默认情况下接受标准 blif 结构 ( <code>.names</code>, <code>.latch</code>, <code>.input</code>, <code>.output</code>)，因此这些模型不应在 <models> 标记中描述。</models></p>
</div>
<p>每一个model标签必须包含两个标签<code>&lt;input_ports&gt;</code> 和 <code>&lt;output_ports&gt;</code>.其中每一个又都包含<code>&lt;port&gt;</code>标签。<code>&lt;port name="string" is_clock="&#123;0 | 1&#125; clock="string" combinational_sink_ports="string1 string2 ..."/&gt;</code>，其属性如下：</p>
<ul>
<li><strong>name</strong>-端口名字</li>
<li><strong>is_clock</strong>(可选标签)-标识端口是否为时钟，默认值为0</li>
</ul>
<div class="note success flat"><p><a href="https://docs.verilogtorouting.org/en/latest/tutorials/arch/timing_modeling/#arch-model-timing-tutorial">Primitive Timing Modeling Tutorial</a>将<code>is_clock</code>用于对时钟控制模块进行建模，例如时钟发生器、时钟缓冲器/门和时钟多路复用器。</p>
</div>
<ul>
<li><strong>clock</strong>-指定一个端口是序列的(sequential)，并由指定的时钟控制（某个is_closk=1的port标签），默认值：端口被对待为组合(combinational)</li>
<li><strong>combinational_sink_ports</strong>-以空格分隔的输出端口列表，这些输出端口组合连接到当前输入端口。默认值：为组合连接（如果未指定）</li>
</ul>
<figure class="highlight xml"><figcaption><span>参考示例</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">models</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">model</span> <span class="attr">name</span>=<span class="string">&quot;single_port_ram&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input_ports</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;we&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">combinational_sink_ports</span>=<span class="string">&quot;out&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;data&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">combinational_sink_ports</span>=<span class="string">&quot;out&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">is_clock</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">input_ports</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output_ports</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;out&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">output_ports</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">model</span> <span class="attr">name</span>=<span class="string">&quot;adder&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input_ports</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">combinational_sink_ports</span>=<span class="string">&quot;cout sumout&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">combinational_sink_ports</span>=<span class="string">&quot;cout sumout&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;cin&quot;</span> <span class="attr">combinational_sink_ports</span>=<span class="string">&quot;cout sumout&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">input_ports</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output_ports</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;cout&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">&quot;sumout&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">output_ports</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">models</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于上述的<code>single_port_ram</code>，端口<code>we</code> <code>addr</code> <code>data</code>和<code>out</code>都是序列的，因为都指定了clock。 <code>addr</code> 和 <code>data</code> 被标识为组合连接到<code>out</code>，这对应到内部的时序路径（<code>addr</code> 和 <code>data</code>输入寄存器与<code>out</code>输出寄存器之间）</p>
<h2 id="全局fpga信息">全局FPGA信息</h2>
<p><code>&lt;tiles&gt;content&lt;/tiles&gt;</code>：此标签内包含一组<code>&lt;pb_type&gt;</code>标签，用于指定功能块的类型以及属性。</p>
<p><code>&lt;layout&gt;content&lt;/layout&gt;</code>：此标签用于指定设备的<a href="#1">网格布局</a>。</p>
<p><code>&lt;device&gt;content&lt;/device&gt;</code>：此标签用于指定设备信息。</p>
<p><code>&lt;switchlist&gt;content&lt;/switchlist&gt;</code>：此标签包含一组<code>&lt;switch&gt;</code>，用于指定开关的类型以及属性。</p>
<p><code>&lt;segmentlist&gt;content&lt;/segmentlist&gt;</code>：此标签包含一组<code>&lt;segment&gt;</code>，用于指定线段的类型以及属性</p>
<p><code>&lt;complexblocklist&gt;content&lt;/complexblocklist&gt;</code>:此标签内包含一组<code>&lt;pb_type&gt;</code>标签，用于指定功能块的类型以及属性。</p>
<h2 id="fpga网格布局-layout"><span id="1">FPGA网格布局(&lt; layout &gt;)</span></h2>
<p>本标签内的有效标签为：</p>
<ul>
<li><code>&lt;auto_layout aspect_radio="float"&gt;</code>（最多存在一个这个标签），用于定义可自动缩放到所需大小的可缩放设备网格布局。
<ul>
<li><code>aspect_radio</code>（可选）-设备网络的横纵比（width/height），默认为1.0</li>
</ul></li>
<li><code>&lt;fixed_layout name="string" width="int" height="int"&gt;</code>，用于定义具有固定尺寸的设备网格布局（可指定多个）。
<ul>
<li><code>name</code>-标识网格布局的唯一名称</li>
<li><code>width</code>-设备网格宽度</li>
<li><code>height</code>-设备网格高度</li>
</ul></li>
</ul>
<p>其中每个<code>&lt;auto_layout&gt;</code>或<code>&lt;fixed_layout&gt;</code>标签应包含一组网格位置标签。每个网格位置规范都有一个相关的数字<em>优先级</em>。优先级较高的位置规范会覆盖优先级较低的位置规范。可以使用特殊的块类型指定空网格位置<code>EMPTY</code>。</p>
<div class="note info flat"><p>1.如果一个网格块与另一个具有较高优先级的块部分重叠，则整个较低优先级的块将从网格中删除。</p>
<p>2.除非另有说明，否则所有网格位置都默认为<code>EMPTY</code>。</p>
</div>
<div class="timeline undefined"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>网格位置标签</p>
</div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; fill type="string" priority="int"/ &gt;</p>
</div></div><div class="timeline-item-content"><p>必须标签属性如下：</p>
<ul>
<li><strong>type</strong>-指定顶级复杂块的类型（pb_type）的名称</li>
<li><strong>priority</strong>-此布局规范的优先及。具有较高优先级的标签会覆盖具有较低优先级的标签。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Fill the device with CLB blocks --&gt;</span>                                         </span><br><span class="line"><span class="tag">&lt;<span class="name">fill</span> <span class="attr">type</span>=<span class="string">&quot;CLB&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;1&quot;</span>/&gt;</span>                           </span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/fill_fpga_grid.svg" alt="fill.svg"></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; perimeter type="string" priority="int"/ &gt;</p>
</div></div><div class="timeline-item-content"><p>将设备的周长（即边缘）设置为指定的块类型。必须标签属性如下：</p>
<ul>
<li><strong>type</strong></li>
<li><strong>priority</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create io blocks around the device perimeter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">perimeter</span> <span class="attr">type</span>=<span class="string">&quot;io&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/perimeter_fpga_grid.svg" alt="perimeter.svg"></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; corners type="string" priority="int"/ &gt;</p>
</div></div><div class="timeline-item-content"><p>将设备的角设置为指定的块类型。必须标签属性如下：</p>
<ul>
<li><strong>type</strong></li>
<li><strong>priority</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create PLL blocks at all corners --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">corners</span> <span class="attr">type</span>=<span class="string">&quot;PLL&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/corners_fpga_grid.svg" alt="coener.svg"></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; single type="string" priority="int" x="expr" y="expr"/ &gt;</p>
</div></div><div class="timeline-item-content"><p>在单个网格位置指定块类型的单个实例。其标签必须属性如下：</p>
<ul>
<li><strong>type</strong></li>
<li><strong>priority</strong></li>
<li><strong>x</strong>-块类型实例的水平位置</li>
<li><strong>y</strong>-块类型实例的垂直位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Create a single instance of a PCIE block (width 3, height 5)</span><br><span class="line">     at location (1,1)--&gt;</span><br><span class="line">&lt;single type=&quot;PCIE&quot; x=&quot;1&quot; y=&quot;1&quot; priority=&quot;20&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/single_fpga_grid.svg" alt="single_PCIE.svg"></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; col type="string" priority="int" startx="expr" repeatx="expr " starty= "expr" incry="expr"/ &gt;</p>
</div></div><div class="timeline-item-content"><p>在 处创建指定块类型的列<code>startx</code>。如果<code>repeatx</code>指定了该列将在任何地方重复<span class="math inline">\(x=startx+k*repeatx\)</span>，满足任何正整数<span class="math inline">\(k\)</span>。如果指定标签来调整高度 &gt; 1 的块的起始位置，<code>starty</code>则通常使用非零值。<code>&lt;perimeter&gt;</code>。其必选参数如下：</p>
<ul>
<li><strong>type</strong></li>
<li><strong>priority</strong></li>
<li><strong>startx</strong>-指定列的水平起始位置的表达式。</li>
</ul>
<p>其可选参数如下：</p>
<ul>
<li><strong>repeatx</strong>-指定列的水平重复因子的表达式。</li>
<li><strong>starty</strong>-指定列的垂直起始偏移量的表达式。(默认0)</li>
<li><strong>incry</strong>-一个表达式，指定区域内块实例化之间的垂直增量。（默认h）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create a column of RAMs starting at column 2, and</span></span><br><span class="line"><span class="comment">     repeating every 3 columns --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">col</span> <span class="attr">type</span>=<span class="string">&quot;RAM&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;2&quot;</span> <span class="attr">repeatx</span>=<span class="string">&quot;3&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/col_fpga_grid.svg" alt="col_RAM.svg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create IO&#x27;s around the device perimeter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">perimeter</span> <span class="attr">type</span>=<span class="string">&quot;io&quot;</span> <span class="attr">priority</span>=<span class="string">10</span>&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Create a column of RAMs starting at column 2, and</span></span><br><span class="line"><span class="comment">     repeating every 3 columns. Note that a vertical offset</span></span><br><span class="line"><span class="comment">     of 1 is needed to avoid overlapping the IOs--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">col</span> <span class="attr">type</span>=<span class="string">&quot;RAM&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;2&quot;</span> <span class="attr">repeatx</span>=<span class="string">&quot;3&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;1&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/col_perim_fpga_grid.svg" alt="col_RAM and perimeter_io.svg"></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; row type="string" priority="int" starty=" expr" repeaty="expr" startx="expr"/ &gt;</p>
</div></div><div class="timeline-item-content"><p>在 处创建指定块类型的行<code>starty</code>。如果<code>repeaty</code>指定了该列将在任何地方重复<span class="math inline">\(y=starty+k*repeaty\)</span>，满足任何正整数<span class="math inline">\(k\)</span>。如果指定标签来调整宽度 &gt; 1 的块的起始位置，<code>startx</code>则通常使用非零值。<code>&lt;perimeter&gt;</code>。其必选参数如下：</p>
<ul>
<li><strong>type</strong></li>
<li><strong>priority</strong></li>
<li><strong>starty</strong>-指定行的垂直起始位置的表达式。</li>
</ul>
<p>其可选参数如下：</p>
<ul>
<li><strong>repeaty</strong>-指定行的垂直重复因子的表达式。</li>
<li><strong>startx</strong>-指定行的水平起始偏移量的表达式。(默认0)</li>
<li><strong>incry</strong>-一个表达式，指定区域内块实例化之间的水平增量。（默认w）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create a row of DSPs (width 1, height 3) at</span></span><br><span class="line"><span class="comment">     row 1 and repeating every 7th row --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">row</span> <span class="attr">type</span>=<span class="string">&quot;DSP&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;1&quot;</span> <span class="attr">repeaty</span>=<span class="string">&quot;7&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/row_fpga_grid.svg" alt="row_DSP.svg"></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>&lt; region type="string" priority="int" startx="expr" endx="expr repeatx="expr" incrx=" expr" starty="expr " endy ="expr" repeaty="expr" incry="expr "/ &gt;</p>
</div></div><div class="timeline-item-content"><p>用指定的块类型填充由 ( <code>startx</code>, <code>starty</code>) 和 ( <code>endx</code>, <code>endy</code>) 定义的矩形区域。如果<code>repeatx</code>指定了区域将在任何地方重复<span class="math inline">\(x=startx+k_1*repeatx\)</span>，对于任何正整数都满足<span class="math inline">\(k_1\)</span>。如果<code>repeaty</code>指定了区域将在任何地方重复<span class="math inline">\(y=starty+k_2*repeaty\)</span>，对于任何正整数都满足<span class="math inline">\(k_2\)</span>。其必选参数如下：</p>
<ul>
<li><strong>type</strong></li>
<li><strong>priority</strong></li>
</ul>
<p>其可选参数如下：</p>
<ul>
<li><strong>startx</strong>-指定区域（包括）水平起始位置的表达式。(默认0)</li>
<li><strong>endx</strong>-指定区域（包括）水平结束位置的表达式（默认W-1）。</li>
<li><strong>repeatx</strong>-指定列的水平重复因子的表达式。</li>
<li><strong>incrx</strong>-一个表达式，指定区域内块实例化之间的水平增量。（默认w）</li>
<li><strong>starty</strong>-指定区域（包括）垂直起始位置的表达式。(默认0)</li>
<li><strong>endy</strong>-指定区域（包括）垂直结束位置的表达式。（默认H-1）</li>
<li><strong>repeaty</strong>-<strong>repeaty</strong> – 指定列的垂直重复因子的表达式。</li>
<li><strong>incry</strong>-一个表达式，指定区域内块实例化之间的垂直增量。(默认h)</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Fill RAMs withing the rectangular region bounded by (1,1) and (5,4) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">region</span> <span class="attr">type</span>=<span class="string">&quot;RAM&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">endx</span>=<span class="string">&quot;5&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;1&quot;</span> <span class="attr">endy</span>=<span class="string">&quot;4&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/region_single_fpga_grid.svg" alt="_RAM.svg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create RAMs every 2nd column withing the rectangular region bounded</span></span><br><span class="line"><span class="comment">     by (1,1) and (5,4) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">region</span> <span class="attr">type</span>=<span class="string">&quot;RAM&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">endx</span>=<span class="string">&quot;5&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;1&quot;</span> <span class="attr">endy</span>=<span class="string">&quot;4&quot;</span> <span class="attr">incrx</span>=<span class="string">&quot;2&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/region_incr_fpga_grid.svg" alt="region_RAM增量.svg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Fill RAMs within a rectangular 2x4 region and repeat every 3 horizontal</span></span><br><span class="line"><span class="comment">     and 5 vertical units --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">region</span> <span class="attr">type</span>=<span class="string">&quot;RAM&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;1&quot;</span> <span class="attr">endx</span>=<span class="string">&quot;2&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;1&quot;</span> <span class="attr">endy</span>=<span class="string">&quot;4&quot;</span> <span class="attr">repeatx</span>=<span class="string">&quot;3&quot;</span> <span class="attr">repeaty</span>=<span class="string">&quot;5&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/region_repeat_fpga_grid.svg" alt="region_RAM重复.svg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Create a 3x3 mesh of NoC routers (width 2, height 2) whose relative positions</span></span><br><span class="line"><span class="comment">     will scale with the device dimensions --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">region</span> <span class="attr">type</span>=<span class="string">&quot;NoC&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;W/4 - w/2&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;W/4 - w/2&quot;</span> <span class="attr">incrx</span>=<span class="string">&quot;W/4&quot;</span> <span class="attr">incry</span>=<span class="string">&quot;W/4&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/region_incr_mesh_fpga_grid.svg" alt="region_NoC网络.svg"></p>
</div></div></div>
<h3 id="整体的网络布局示例">整体的网络布局示例</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Specifies an auto-scaling square FPGA floorplan --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auto_layout</span> <span class="attr">aspect_ratio</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Create I/Os around the device perimeter --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">perimeter</span> <span class="attr">type</span>=<span class="string">&quot;io&quot;</span> <span class="attr">priority</span>=<span class="string">10</span>&quot;/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Nothing in the corners --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">type</span>=<span class="string">&quot;EMPTY&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Create a column of RAMs starting at column 2, and</span></span><br><span class="line"><span class="comment">             repeating every 3 columns. Note that a vertical offset (starty)</span></span><br><span class="line"><span class="comment">             of 1 is needed to avoid overlapping the IOs--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">type</span>=<span class="string">&quot;RAM&quot;</span> <span class="attr">startx</span>=<span class="string">&quot;2&quot;</span> <span class="attr">repeatx</span>=<span class="string">&quot;3&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;1&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Create a single PCIE block along the bottom, overriding</span></span><br><span class="line"><span class="comment">             I/O and RAM slots --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">single</span> <span class="attr">type</span>=<span class="string">&quot;PCIE&quot;</span> <span class="attr">x</span>=<span class="string">&quot;3&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Create an additional row of I/Os just above the PCIE,</span></span><br><span class="line"><span class="comment">             which will not override RAMs --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">row</span> <span class="attr">type</span>=<span class="string">&quot;io&quot;</span> <span class="attr">starty</span>=<span class="string">&quot;5&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Fill remaining with CLBs --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fill</span> <span class="attr">type</span>=<span class="string">&quot;CLB&quot;</span> <span class="attr">priority</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">auto_layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/fpga_grid_example.svg" alt="FPGA网络布局示例.svg"></p>
<h2 id="fpga器件信息">FPGA器件信息</h2>
<p>该信息包含在<code>&lt;device&gt;</code>标签当中，其中包含的子标签为：</p>
<ul>
<li><p><code>&lt;sizing R_minW_nmos="float" R_minW_pmos="float"/&gt;</code>（必须要，用于指定面积模型需要的参数）</p>
<ul>
<li><strong>R_minW_nmos</strong>-最小宽度 nmos 晶体管的电阻。此数据仅由 VPR 中内置的面积模型使用。</li>
<li><strong>R_minW_pmos</strong>-最小宽度 pmos 晶体管的电阻。此数据仅由 VPR 中内置的面积模型使用。</li>
</ul></li>
<li><p><code>&lt;connection_block input_switch_name="string"/&gt;</code>（必须要）</p>
<ul>
<li><p><strong>input_switch_name</strong>-用于指定在<code>&lt;switchlist&gt;</code>中定义的<code>&lt;switch&gt;</code>的名字，用来连接布线导线和模块的输入引脚（即，输入连接块）。</p>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/ipin_diagram.png" alt="输入连接块"></p></li>
</ul></li>
<li><p><code>&lt;area grid_logic_tile_area="float"/&gt;</code>(必须要)</p></li>
</ul>
<p>​ 指定一个逻辑tile的默认面积（在<a href="https://docs.verilogtorouting.org/en/latest/glossary/#term-MWTA">MWTAs</a>（Minimum Width Transitor Area）下），不包含布线。用于对所有功能块占用的面积进行面积估计。</p>
<div class="tip info"><p>这个属性会被覆盖，当指定<pb_type>s with the area属性</pb_type></p>
</div>
<ul>
<li><p><code>&lt;switch_block type="&#123;wilton | subset | universal | custom&#125;" fs="int"/&gt;</code>（必须要）</p>
<ul>
<li><strong>type</strong>-指定开关块的类型</li>
<li>开关块<span class="math inline">\(F_s\)</span>的类型</li>
</ul>
<p>此参数控制用于连接（群集间）路由网段的交换机模式。可以使用单个关键字分别指定三个相当简单的模式，也可以指定更复杂的自定义模式。</p>
<div class="tip error"><p>没搞明白为什么双向开关的<span class="math inline">\(F_s\)</span>都是3，而单向开关的<span class="math inline">\(F_s\)</span>可以是3的整数倍。以及对于穿过开关块的导线是如何处理的</p>
</div>
<p>指定<code>custom</code>允许在<code>&lt;switchblocklist&gt;</code>XML 节点下描述自定义开关块，其格式在<a href="https://docs.verilogtorouting.org/en/latest/arch/reference/#custom-switch-blocks">Custom Switch Blocks</a>中描述。如果开关块指定为<code>custom</code>，则<code>fs</code>不必指定该字段，如果存在则将被忽略。</p></li>
<li><p><code>&lt;chan_width_distr&gt;content&lt;/chan_width_distr&gt;</code></p>
<p>此标签内的内容仅在 VPR 处于全局路由模式时使用。该标签的内容在<a href="https://docs.verilogtorouting.org/en/latest/arch/reference/#global-routing-info">Global Routing Information</a>中描述。</p></li>
<li><p><code>&lt;default_fc in_type="&#123;frac|abs&#125;" in_val="&#123;int|float&#125;" out_type="&#123;frac|abs&#125;" out_val="&#123;int|float&#125;"/&gt;</code></p></li>
</ul>
<p>​ 这定义了默认的 Fc 规范，如果它没有在<code>&lt;fc&gt;</code>顶级复杂块内的标签中指定。这些属性与<fc> 标记属性的含义相同。</fc></p>
<h2 id="开关switch">开关（switch）</h2>
<p>标签<code>&lt;switchlist&gt;</code>中的标签，指定用于将电线和引脚连接在一起的开关。</p>
<p><code>&lt;switch type="&#123;mux|tristate|pass_gate|short|buffer&#125;" name="string" R="float" Cin="float" Cout="float" Cinternal="float" Tdel="float" buf_size=" &#123;auto|float&#125;" mux_trans_size="float", power_buf_size="int"/&gt;</code></p>
<div class="tabs" id="tabname"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tabname-1">必须属性</button></li><li class="tab"><button type="button" data-href="#tabname-2">可选属性</button></li><li class="tab"><button type="button" data-href="#tabname-3">子标签</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tabname-1"><ul>
<li><p><strong>type</strong>-开关的类型</p>
<ul>
<li><strong>mux</strong>:An isolating, configurable multiplexer</li>
<li><strong>tristate</strong>:An isolating, configurable tristate-able buffer</li>
<li><strong>pass_gate</strong>:A <em>non-isolating</em>, configurable pass gate</li>
<li><strong>short</strong>: A <em>non-isolating</em>, <em>non-configurable</em> electrical short (e.g. between two segments).</li>
<li><strong>buffer</strong>: An isolating, <em>non-configurable</em> non-tristate-able buffer (e.g. in-line along a segment).</li>
</ul>
<p><span class="p red">isolating</span>:包含一个缓冲器，有助于减少RC延迟。</p></li>
<li><p><strong>name</strong>-开关的唯一标识</p></li>
<li><p><strong>R</strong>-开关的电阻</p></li>
<li><p><strong>Cin</strong>-开关的输入电容</p></li>
<li><p><strong>Cout</strong>-开关的输出电容</p></li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-2"><ul>
<li><strong>Cinternal</strong>-内部电容（当开关类型为mux或者tristate时，需要指定该参数，因为这两种开关类型都是多个器件级联而成的，由内部电容）</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Pass Transistor</span><br><span class="line">          |</span><br><span class="line">        -----</span><br><span class="line">        -----      Buffer</span><br><span class="line">       |     |       |\</span><br><span class="line"> ------       -------| \--------</span><br><span class="line">   |             |   | /    |</span><br><span class="line"> =====         ===== |/   =====</span><br><span class="line"> =====         =====      =====</span><br><span class="line">   |             |          |</span><br><span class="line"> Input C    Internal C    Output C</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Tdel</strong>-通过开关的固有延迟。如果该开关由零电阻源驱动，并驱动零电容负载，则其延迟将为：<span class="math inline">\(T_{del}+R\cdot C_{out}\)</span></li>
<li><strong>buf_size</strong>-以最小宽度晶体管面积 (MWTA) 为单位指定缓冲区大小。(默认值 <code>auto</code>)，若设置为<code>auto</code>则根据R的值自动调整大小。</li>
<li><strong>mux_trans_size</strong>-指定<code>mux</code>类型开关中使用的两级复用器中的每个晶体管的大小（以最小宽度晶体管为单位）</li>
<li><strong>power_buf_size</strong>-用于功耗评估，标识buffer相对于最小尺寸反相器的驱动强度</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tabname-3"><p><code>&lt;Tdel num_inputs="int" delay="float"/&gt;</code></p>
<p>无需指定单个 Tdel 值，而是可以为开关扇入的不同值指定 Tdel 值列表。延迟基于两个最接近的扇入对任何未指定的扇入进行线性外推/插值。</p>
<ul>
<li><strong>num_inputs</strong>-开关的输入数量</li>
<li><strong>delay</strong>-当开关拓扑具有指定数量的开关输入时的固有开关延迟</li>
</ul>
<figure class="highlight xml"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">switch</span> <span class="attr">type</span>=<span class="string">&quot;mux&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my_mux&quot;</span> <span class="attr">R</span>=<span class="string">&quot;522&quot;</span> <span class="attr">Cin</span>=<span class="string">&quot;3.1e-15&quot;</span> <span class="attr">Cout</span>=<span class="string">&quot;3e-15&quot;</span> <span class="attr">Cinternal</span>=<span class="string">&quot;5e-15&quot;</span> <span class="attr">mux_trans_size</span>=<span class="string">&quot;1.7&quot;</span> <span class="attr">buf_size</span>=<span class="string">&quot;23&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Tdel</span> <span class="attr">num_inputs</span>=<span class="string">&quot;12&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;8.00e-11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Tdel</span> <span class="attr">num_inputs</span>=<span class="string">&quot;15&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;8.4e-11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Tdel</span> <span class="attr">num_inputs</span>=<span class="string">&quot;20&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;9.4e-11&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">switch</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="全局布线信息">全局布线信息</h3>
<p>如果要进行全局布线，可以将不同方向和FPGA不同部分的通道设置为不同的相对宽度。这是在<code>&lt;chan_width_distr&gt;</code>标签内的内容中指定的。</p>
<div class="tip info"><p>如果要执行详细的路由，只能使用均匀分布</p>
</div>
<div class="tip error"><p>暂时不知道干嘛的，先放着，之后再看</p>
</div>
<h2 id="物理tiles">物理Tiles</h2>
<p>在<code>&lt;tiles&gt;</code>内，描述了FPGA中可用的物理tiles，每一个使用一个<code>&lt;tile&gt;</code>标签指定。</p>
<p><code>&lt;tile name="string" capacity="int" width="int" height="int" area="float"/&gt;</code>:</p>
<ul>
<li><strong>name</strong>-tile的唯一标识符</li>
</ul>
<p>以下为可选参数：</p>
<ul>
<li><p><strong>capacity</strong>-？？？没看到相关文档介绍</p></li>
<li><p><strong>width</strong>-tile在网格中所占的宽度（多少个网格宽度，默认1）</p></li>
<li><p><strong>height</strong>-tile在网格中所占的高度（多少个网格高度，默认1）</p></li>
<li><p><strong>area</strong>-逻辑面积（in MWTA）(默认值来源于<code>&lt;area&gt;</code>)</p></li>
</ul>
<p>以下为可用的子标签：</p>
<div class="tabs" id="subtags"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#subtags-1">subtags 1</button></li><li class="tab"><button type="button" data-href="#subtags-2">subtags 2</button></li><li class="tab"><button type="button" data-href="#subtags-3">subtags 3</button></li><li class="tab"><button type="button" data-href="#subtags-4">subtags 4</button></li><li class="tab"><button type="button" data-href="#subtags-5">subtags 5</button></li><li class="tab"><button type="button" data-href="#subtags-6">subtags 6</button></li><li class="tab"><button type="button" data-href="#subtags-7">subtags 7</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="subtags-1"><p><code>&lt;clock name="string" num_pins="int" equivalent="{none|full}"/&gt;</code>:用于描述时钟端口</p>
<p><code>&lt;sub_tile name="string" capacity="{int}"&gt;</code>（每个tile至少指定一个subtile）</p>
<ul>
<li><strong>name</strong>-唯一标识符</li>
<li><strong>capacity</strong>-这种类型的块在每个网格上的实例化数量（默认值1）</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="subtags-2"><p><code>&lt;input name="string" num_pins="int" equivalent="{none|full}" is_non_clock_global="{true|false}"/&gt;</code>:用于定义输入端口，多个输入端口使用多个此标签。</p>
<ul>
<li><strong>name</strong>-输入端口名称</li>
<li><strong>num_pins</strong>-输入端口宽度</li>
<li><strong>equivalent(optional)</strong>-引脚是否具有逻辑灯效性
<ul>
<li><code>none</code>:没有输入引脚具有逻辑等效性。（如adder）</li>
<li><code>full</code>:所有的输入引脚都具有逻辑等效性。(如lut)</li>
</ul></li>
<li><strong>is_non_clock_global</strong>-是否为全局时钟信号</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="subtags-3"><p><code>&lt;output name="string" num_pins="int" equivalent="{none|full|instance}"/&gt;</code>::用于定义输出端口，多个输出端口使用多个此标签。</p>
<ul>
<li><strong>name</strong>-输出端口名称</li>
<li><strong>num_pins</strong>-输出端口的引脚数量</li>
<li><strong>equivalent(optional)</strong>-引脚是否具有逻辑灯效性
<ul>
<li><code>none</code></li>
<li><code>full</code></li>
<li><code>instance</code>:可以交换块内的子实例（例如 LUT/BLE）的模型，以实现有限形式的输出引脚逻辑等效。</li>
</ul></li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="subtags-4"><p><code>&lt;clock name="string" num_pins="int" equivalent="{none|full}"/&gt;</code>是否为时钟端口</p>
<p><code>&lt;equivalent_sites&gt;</code></p>
<p>其子标签如下：</p>
<ul>
<li><code>&lt;site pb_type="string" pin_mapping="string"/&gt;</code>
<ul>
<li><strong>pb_type</strong>-对应pb_type的名字</li>
<li><strong>pin_mapping</strong>-指定在物理tile与逻辑pb_type类型之间需要引脚映射(默认direct)
<ul>
<li><code>direct</code>:不需要指定pin映射，因为tile pin定义等于对应的pb_type</li>
<li><code>custom</code>:引脚映射是用户定义的</li>
</ul></li>
<li><code>&lt;direct from="string" to="string"&gt;</code>（描述物理tile与pb_type之间的端口映射）
<ul>
<li><code>form</code>:对应于物理tile的引脚</li>
<li><code>to</code>：对应与逻辑块的引脚</li>
</ul></li>
</ul></li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="subtags-5"><p><code>&lt;fc in_type="{frac|abs}" in_val="{int|float}" out_type="{frac|abs}" out_val="{int|float}"&gt;</code></p>
<p><code>&lt;fc_override fc_type="{frac|abs}" fc_val="{int|float}", port_name="{string}" segment_name="{string}"&gt;</code>用于覆盖某个端口的<span class="math inline">\(F_c\)</span></p>
<ul>
<li><strong>fc_type</strong></li>
<li><strong>fc_val</strong></li>
<li><strong>port_name(可选)</strong>-此覆盖适用的端口的名称。如果未指定，则此覆盖适用于所有端口。</li>
<li><strong>segment_name（可选）</strong>-此覆盖适用的段的名称（在<code>&lt;segmentlist&gt;</code>下定义）。如果未指定，则此覆盖适用于所有段。</li>
</ul>
<div class="note info flat">
<p>两个可选参数至少指定一个</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="subtags-6"><p><code>&lt;pinlocations pattern="{spread|perimeter|custom}"&gt;</code>（没有此标签则默认为spread）</p>
<ul>
<li><strong>pattern</strong>
<ul>
<li><code>spread</code>:表示引脚将均匀分布在复杂块的所有侧面。</li>
<li><code>perimeter</code>:表示引脚将均匀分布在复杂块的周边侧</li>
<li><code>soread_inputs_perimeter_outputs</code>:表示输入引脚将分布在复杂模块的所有侧面，但输出引脚仅分布在模块的周边。</li>
<li><code>custom</code>:允许架构师使用标签<code>&lt;loc&gt;</code>具体指定引脚的放置位置。
<ul>
<li><code>&lt;loc side="{left|right|bottom|top}" xoffset ="int" yoffset="int"&gt;name_of_complex_logic_block.port_name[int:int] ... &lt;/loc&gt;</code>
<ul>
<li><strong>side</strong>-位于grid的哪一个边</li>
<li><strong>xoffset(可选，0)</strong>-指定从块原点（左下角）的水平偏移（以网格为单位）。偏移值必须小于块的宽度。</li>
<li><strong>yoffset(可选，0)</strong>-指定距块原点（左下角）的垂直偏移量（以网格为单位）。偏移值必须小于块的高度。</li>
</ul></li>
</ul></li>
</ul></li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="subtags-7"><p><code>&lt;switchblock_locations pattern="{external_full_internal_straight|all|external|internal|none|custom}" internal_switch="string"&gt;</code>:描述与复杂块相关的全局路由交换块的创建位置。（如果未指定，则假定未默认模式）</p>
<ul>
<li><p><strong>pattern(默认值为第一个)</strong></p>
<ul>
<li><code>external_full_internal_straight</code>:在复杂块外部创建<em>完整</em>的开关块，在复杂块内创建<em>直接的开关块</em></li>
<li><code>all</code>:在路由通道交叉的地方创建开关块</li>
<li><code>external</code>:在路由通道在复杂块<em>之外的任何地方创建开关块</em></li>
<li><code>internal</code>:在复杂块<em>内</em>路由通道交叉的任何地方创建开关块</li>
<li><code>none</code>:表示没有为复杂块创建切换块</li>
<li><code>custom</code>:允许架构师使用<code>&lt;sb_loc&gt;</code>标签指定自定义开关块位置和类型</li>
</ul>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/sb_locations.svg" alt="宽度为2，高度为3的复杂快的开关位置模式"></p></li>
<li><p><strong>internal_switch</strong>:来自<code>&lt;switchlist&gt;</code>，应用于内部开关块的开关名称(<strong>Default:</strong> The default switch for the wire <code>&lt;segment&gt;</code>)</p></li>
</ul>
<figure class="highlight xml"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">switchlist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">switch</span> <span class="attr">type</span>=<span class="string">&quot;short&quot;</span> <span class="attr">name</span>=<span class="string">&quot;electrical_short&quot;</span> <span class="attr">R</span>=<span class="string">&quot;0&quot;</span> <span class="attr">Cin</span>=<span class="string">&quot;0&quot;</span> <span class="attr">Tdel</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">switchlist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">switchblock_locations</span> <span class="attr">pattern</span>=<span class="string">&quot;external_full_internal_straight&quot;</span> <span class="attr">internal_switch</span>=<span class="string">&quot;electrical_short&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>子标签：</strong></p>
<p><code>&lt;sb_loc type="{full|straight|turns|none}" xoffset="int" yoffset="int", switch_override="string"&gt;</code>:当选择<code>custom</code>属性时，指定开关块的位置</p>
<ul>
<li><p><strong>type(默认full)</strong>-指定开关块的类型</p>
<ul>
<li><code>full</code>:表示将创建一个完整的开关块</li>
<li><code>straight</code>:表示将创建一个只有直通连接的开关块</li>
<li><code>turns</code>:表示将创建一个只有转向连接的开关块</li>
<li><code>none</code>:表示不会创建 switchblock</li>
</ul>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/sb_types.svg" alt="开关块类型"></p></li>
<li><p><strong>xoffset(可选，0)</strong>-指定从块原点（左下角）的水平偏移（以网格为单位）。偏移值必须小于块的宽度。</p></li>
<li><p><strong>yoffset(可选，0)</strong>-指定距块原点（左下角）的垂直偏移量（以网格为单位）。偏移值必须小于块的高度。</p></li>
<li><p><strong>switch_override</strong>-创建开关块所使用的开关名字（from <code>&lt;switchlist&gt;</code>）（<strong>Default:</strong> The default switch for the wire <code>&lt;segment&gt;</code>）</p></li>
</ul>
<div class="note info flat">
<p>The switchblock associated with a grid tile is located to the top-right of the grid tile</p>
</div>
<p>如果我们假设一个宽度=2、高度=3 的块，我们可以使用自定义模式来指定等效于“电气短路内部直连”示例的架构：</p>
<figure class="highlight xml"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">switchblock_locations</span> <span class="attr">pattern</span>=<span class="string">&quot;custom&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Internal: using straight electrical shorts --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sb_loc</span> <span class="attr">type</span>=<span class="string">&quot;straight&quot;</span> <span class="attr">xoffset</span>=<span class="string">&quot;0&quot;</span> <span class="attr">yoffset</span>=<span class="string">&quot;0&quot;</span> <span class="attr">switch_override</span>=<span class="string">&quot;electrical_short&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sb_loc</span> <span class="attr">type</span>=<span class="string">&quot;straight&quot;</span> <span class="attr">xoffset</span>=<span class="string">&quot;0&quot;</span> <span class="attr">yoffset</span>=<span class="string">&quot;1&quot;</span> <span class="attr">switch_override</span>=<span class="string">&quot;electrical_short&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- External: using default switches --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sb_loc</span> <span class="attr">type</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xoffset</span>=<span class="string">&quot;0&quot;</span> <span class="attr">yoffset</span>=<span class="string">&quot;2&quot;</span>&gt;</span> <span class="comment">&lt;!-- Top edge --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sb_loc</span> <span class="attr">type</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xoffset</span>=<span class="string">&quot;1&quot;</span> <span class="attr">yoffset</span>=<span class="string">&quot;0&quot;</span>&gt;</span> <span class="comment">&lt;!-- Right edge --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sb_loc</span> <span class="attr">type</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xoffset</span>=<span class="string">&quot;1&quot;</span> <span class="attr">yoffset</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="comment">&lt;!-- Right edge --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sb_loc</span> <span class="attr">type</span>=<span class="string">&quot;full&quot;</span> <span class="attr">xoffset</span>=<span class="string">&quot;1&quot;</span> <span class="attr">yoffset</span>=<span class="string">&quot;2&quot;</span>&gt;</span> <span class="comment">&lt;!-- Top Right --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">switchblock_locations</span>/&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="复杂块">复杂块</h2>
<p><code>&lt;complexblocklist&gt;</code>中的内容描述了 FPGA 中的复杂模块。<code>&lt;complexblocklist&gt;</code>内每种类型的复杂块都使用标签内的顶级标签<code>&lt;pb_type&gt;</code>指定。</p>
<h3 id="pb_type">PB_Type</h3>
<p><code>&lt;pb_type name="string" num_pb="int" blif_model="string"/&gt;</code>:用于指定最顶层的复杂块，或者复杂块内部的部件（sub_blocks），使用哪些属性，取决于该标签在层次结构中的位置。</p>
<ul>
<li><strong>顶层(Top Level)</strong>：<code>&lt;complexblocklist&gt;</code>的子标签</li>
<li><strong>中间（Intermediate）</strong>：一个<code>&lt;pb_type&gt;</code>的子标签</li>
<li><strong>基元（Primitive/Leaf）</strong>：不包含<code>&lt;pb_type&gt;</code>子标签</li>
</ul>
<figure class="highlight xml"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">complexblocklist</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;CLB&quot;</span>/&gt;</span> <span class="comment">&lt;!-- Top level --&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;ble&quot;</span>/&gt;</span> <span class="comment">&lt;!-- Intermediate --&gt;</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;lut&quot;</span>/&gt;</span> <span class="comment">&lt;!-- Primitive --&gt;</span></span><br><span class="line">                ...</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;ff&quot;</span>/&gt;</span> <span class="comment">&lt;!-- Primitive --&gt;</span></span><br><span class="line">                ...</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">complexblocklist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="tabs" id="属性"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#属性-1">General</button></li><li class="tab"><button type="button" data-href="#属性-2">top、intermediate、primitive</button></li><li class="tab"><button type="button" data-href="#属性-3">primitive only</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="属性-1"><p><strong>name</strong>-pb_type的名字，相对于其父节点、同级节点以及子节点都应该是唯一的</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="属性-2"><p><strong>num_pb</strong>-当前pb_type在此层次结构中实例化的数量（默认1）</p>
<figure class="highlight xml"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--CLB包含10个BLE--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;CLB&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;ble&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">       ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="属性-3"><p><strong>blif_model</strong>-指定此pb_type所实现的网表基元</p>
<ul>
<li><code>.input</code>:A BLIF netlist input</li>
<li><code>.output</code>:A BLIF netlist output</li>
<li><code>.names</code>:A BLIF .names (LUT) primitive</li>
<li><code>.latch</code>:A BLIF .latch (DFF) primitive</li>
<li><code>.subckt &lt;custom_type&gt;</code>:A user defined black-box primitive.</li>
</ul>
<p><strong>class</strong>-指定这个原语是一个特殊的类型，应该被特殊对待。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;my_adder&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.subckt adder&quot;</span>/&gt;</span></span><br><span class="line">   ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note info flat">
<p>pb_type基元的输入、输出以及时钟端口必须与<code>&lt;models&gt;</code>中指定的对应</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p><strong>适用于所有&lt; pb_type &gt;标签的子标签</strong>：(与物理tile的描述很相似)</p>
<p><code>&lt;input name="string" num_pins="int" equivalent="&#123;none|full&#125;" is_non_clock_global="&#123;true|false&#125;"/&gt;</code>:定义输出端口，多个输入端口使用多个标签。</p>
<p><code>&lt;output name="string" num_pins="int" equivalent="&#123;none|full|instance&#125;"/&gt;</code></p>
<p><code>&lt;clock name="string" num_pins="int" equivalent="&#123;none|full&#125;"/&gt;</code></p>
<p><code>&lt;mode name="string" disable_packing="bool"&gt;</code>:为pb_type指定一个操作模式，每一个子model标签标识一个不同的操作模式，每一个<model>标签可能包含其他的<code>&lt;pb_type&gt;</code>和<code>&lt;interconnexct&gt;</code>标签。</model></p>
<ul>
<li><strong>name</strong>-唯一标识符</li>
<li><strong>disable_packing</strong>-用于指定该模式是否diable，或者不用于VPR打包器，一般用于调式用</li>
</ul>
<div class="note info no-icon flat"><p>在同一个<code>&lt;pb_type&gt;</code>父标签中的models是互斥的。</p>
<p>如果<code>&lt;pb_type&gt;</code>只包含一个操作模式，则可以省略<code>&lt;model&gt;</code></p>
</div>
<figure class="highlight xml"><figcaption><span>example</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--A fracturable 6-input LUT--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定lut可以使用为一个6-LUT或者两个5-LUT（但是不能同时）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;lut&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;lut6&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Can be used as a single 6-LUT--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;lut6&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">mode</span> <span class="attr">name</span>=<span class="string">&quot;lut5x2&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Or as two 5-LUTs--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;lut5&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="interconnect">interconnect</h3>
<p><code>&lt;model&gt;</code>标签的子标签<code>&lt;interconnect&gt;</code>包含以下子标签：</p>
<p><code>&lt;complete name="string" input="string" output="string"&gt;</code>:描述一个全连接crossbar——任何输入都可以连接到任何输出。</p>
<ul>
<li><strong>name</strong>-互联标识符</li>
<li><strong>inout</strong>-输入到互联的引脚</li>
<li><strong>output</strong>-输出到互联的引脚</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;complete input=&quot;Top.in&quot; output=&quot;Child.in&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/complete_example.png" alt="complete interconnect"></p>
<p><code>&lt;direct name="string" input="string" output="string"/&gt;</code>：在输入和输出之间描述一个一对一映射。</p>
<ul>
<li><strong>name</strong>-互联标识符</li>
<li><strong>input</strong>-输入引脚</li>
<li><strong>output</strong>-输出引脚</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">direct</span> <span class="attr">input</span>=<span class="string">&quot;Top.in[2:1]&quot;</span> <span class="attr">output</span>=<span class="string">&quot;Child[1].in&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/direct_example.png" alt="direct interconnect"></p>
<p><code>&lt;mux name="string" input="string" output="string"/&gt;</code>：描述一个基于总线的多路选择器。</p>
<ul>
<li><strong>name</strong></li>
<li><strong>input</strong></li>
<li><strong>output</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mux</span> <span class="attr">input</span>=<span class="string">&quot;Top.A Top.B&quot;</span> <span class="attr">output</span>=<span class="string">&quot;Child.in&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/mux_example.png" alt="mux interconnect"></p>
<p>上述三个标签都有一个可选的子标签<code>&lt;pack_pattern name="string" in_port="string" out_port="string"/&gt;</code>，使得CAD在打包的时候能将用到该两个元件的时候，能够打包到一起。</p>
<ul>
<li><strong>name</strong>-标识符</li>
<li><strong>in_port</strong>-输入引脚</li>
<li><strong>out_port</strong>-输出引脚</li>
</ul>
<p>下面的例子就可以让CAD在打包的时候，如果遇到一个LUT后面连接一个触发器，则会将其打包在一个BLE当中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pack_pattern</span> <span class="attr">name</span>=<span class="string">&quot;ble&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;lut.out&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;ff.D&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/pack_pattern_example.png" alt="pack_pattern"></p>
<h3 id="classes">Classes</h3>
<p>calss是基元<code>&lt;pb_type&gt;</code>的可选属性，使得指定那些常见的基元更加方便，内置的class可选值为：</p>
<div class="tabs" id="tab1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab1-1">calss="lut"</button></li><li class="tab"><button type="button" data-href="#tab1-2">class="flipflop"</button></li><li class="tab"><button type="button" data-href="#tab1-3">class="memory"</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab1-1"><p>用于描述一个K-LUT（所有哦输入引脚都逻辑等效），当这个类型被使用时，输入段楼必须有属性<code>port_class="lut_in"</code>，并且输出端口必须有属性<code>port_class_"lut_out"</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab1-2"><p>描述一个触发器。其输入端口必须要有属性<code>port_class="D"</code>，输出端口必须要有属性<code>port_class="Q"</code>，时钟端口必须要有属性<code>port_class="clock"</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab1-3"><p>描述一个存储器，存储器是很特殊的，因为一个存储器可以包含多个更小的逻辑存储器，只要满足以下条件：</p>
<ol type="1">
<li>地址、时钟以及控制输入是相同的</li>
<li>当不同的的网表存储器合并成一个物理存储器时，存在足够的物理数据管脚来满足网表存储器的需求。</li>
</ol>
<p>不同类型的存储器所需要的属性不一样。</p>
<p><strong>单端口存储器：</strong></p>
<ul>
<li><strong>input 端口</strong>
<ul>
<li><code>port_class="address"</code></li>
<li><code>port_class="data_in"</code></li>
<li><code>port_class="write_en"</code></li>
</ul></li>
<li><strong>output 端口</strong>
<ul>
<li><code>port_class="data_out"</code></li>
</ul></li>
<li><strong>clock 端口</strong>
<ul>
<li><code>port_class="clock"</code></li>
</ul></li>
</ul>
<p><strong>双端口存储器：</strong></p>
<ul>
<li><strong>input 端口</strong>
<ul>
<li><code>port_class="address1"</code></li>
<li><code>port_class="data_in1"</code></li>
<li><code>port_class="write_en1"</code></li>
<li><code>port_class="address2"</code></li>
<li><code>port_class="write_en2"</code></li>
</ul></li>
<li><strong>output 端口</strong>
<ul>
<li><code>port_class="data_out1"</code></li>
<li><code>port_class="data_out2"</code></li>
</ul></li>
<li><strong>clock 端口</strong>
<ul>
<li><code>port_class="clock"</code></li>
</ul></li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h3 id="timing">Timing</h3>
<p>时序是通过包在<code>pb_type</code>、<code>complete</code>、<code>direct</code>、<code>mux</code>中的标签来指定的。</p>
<p><code>&lt;delay_constant max="float" min="float" in_port="string" out_port="string"/&gt;</code>：用于指定从输入端口到输出端口的最大以及最小延迟。</p>
<div class="note danger flat"><p>不太明白，如果自定义单元的输入端口与输出端口之间很复杂（可以选择是否有寄存器），那么延迟该如何定义？</p>
</div>
<p><strong>可选参数如下：</strong>（两者至少包含一个）</p>
<ul>
<li><strong>max</strong>-最大延迟值</li>
<li><strong>min</strong>-最小延迟值</li>
</ul>
<p><strong>必须参数如下：</strong></p>
<ul>
<li><strong>in_port</strong>-输入端口名字</li>
<li><strong>out_port</strong>-输出端口名字</li>
</ul>
<p>如果<code>in_port</code>与<code>out_port</code>之间是组合逻辑，则该标签指定的是输入与输出之间的组合逻辑延迟。如果<code>in_port</code>与<code>out_port</code>之间是时序逻辑，则该标签指定的是输入寄存器和输出寄存器之间的组合逻辑延迟。</p>
<p><code>&lt;delay_matrix type="&#123;max | min&#125;" in_port="string" out_port="string"&gt; matrix &lt;/delay&gt;</code>：用于描述输入端口与输出端口之间所有引脚的之间的延迟，矩阵的行数与输入数量一致，矩阵的列数与输出的个数一致。</p>
<figure class="highlight xml"><figcaption><span>4-bit input and 3-bits out</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delay_matrix</span> <span class="attr">type</span>=<span class="string">&quot;max&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;out&quot;</span>&gt;</span></span><br><span class="line">    1.2e-10 1.4e-10 3.2e-10</span><br><span class="line">    4.6e-10 1.9e-10 2.2e-10</span><br><span class="line">    4.5e-10 6.7e-10 3.5e-10</span><br><span class="line">    7.1e-10 2.9e-10 8.7e-10</span><br><span class="line"><span class="tag">&lt;/<span class="name">delay</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;T_setup value="float" port="string" clock="string"/&gt;</code>：指定端口寄存器的建立时间约束。（仅仅只用于 primitive <code>pb_type</code> tags）</p>
<p><code>&lt;T_hold value="float" port="string" clock="string"/&gt;</code>：指定端口寄存器的保持时间约束。（仅仅只用于 primitive <code>pb_type</code> tags）</p>
<p><code>&lt;T_clock_to_Q max="float" min="float" port="string" clock="string"/&gt;</code>：指定端口寄存器的保持时间约束。（仅仅只用于 primitive <code>pb_type</code> tags）</p>
<h4 id="对时序基元的内部时序路径进行建模">对时序基元的内部时序路径进行建模</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pb_type</span> <span class="attr">name</span>=<span class="string">&quot;seq_foo&quot;</span> <span class="attr">blif_model</span>=<span class="string">&quot;.subckt seq_foo&quot;</span> <span class="attr">num_pb</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;in&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">&quot;out&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clock</span> <span class="attr">name</span>=<span class="string">&quot;clk&quot;</span> <span class="attr">num_pins</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- external --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">T_setup</span> <span class="attr">value</span>=<span class="string">&quot;80e-12&quot;</span> <span class="attr">port</span>=<span class="string">&quot;seq_foo.in&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">T_clock_to_Q</span> <span class="attr">max</span>=<span class="string">&quot;20e-12&quot;</span> <span class="attr">port</span>=<span class="string">&quot;seq_foo.out&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- internal --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">T_clock_to_Q</span> <span class="attr">max</span>=<span class="string">&quot;10e-12&quot;</span> <span class="attr">port</span>=<span class="string">&quot;seq_foo.in&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delay_constant</span> <span class="attr">max</span>=<span class="string">&quot;0.9e-9&quot;</span> <span class="attr">in_port</span>=<span class="string">&quot;seq_foo.in&quot;</span> <span class="attr">out_port</span>=<span class="string">&quot;seq_foo.out&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">T_setup</span> <span class="attr">value</span>=<span class="string">&quot;90e-12&quot;</span> <span class="attr">port</span>=<span class="string">&quot;seq_foo.out&quot;</span> <span class="attr">clock</span>=<span class="string">&quot;clk&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pb_type</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了模拟内部关键路径延迟，我们指定输入寄存器的内部时钟到 Q 延迟 (10ps)、内部组合延迟 (0.9ns) 和输出寄存器的建立时间 (90ps)。这些延迟的总和对应于 1ns 的关键路径延迟。</p>
<h3 id="power">Power</h3>
<p><code>&lt;power method="string"&gt;contents&lt;/power&gt;</code></p>
<p><strong>method</strong>-用于指明功耗评估的方式(default:<code>auto-size</code>)</p>
<ul>
<li><code>specify-size</code></li>
<li><code>auto-size</code></li>
<li><code>pin-toggle</code></li>
<li><code>C-internal</code></li>
<li><code>absolute</code></li>
<li><code>ignore</code></li>
<li><code>sum-of-children</code></li>
</ul>
<p><strong>contents</strong>则可以包含以下标签：</p>
<p><code>&lt;dynamic_power power_per_instance="float" C_internal="float"/&gt;</code></p>
<p><code>&lt;static_power power_per_instance="float"/&gt;</code></p>
<p><code>&lt;port name="string" energy_per_toggle="float" scaled_by_static_prob="string" scaled_by_static_prob_n="string"/&gt;</code></p>
<h2 id="wire-segments">Wire Segments</h2>
<p>根节点为<code>&lt;segmentlist&gt;</code>，其内容为一组<code>&lt;segment&gt;标签组成</code>。</p>
<p><code>&lt;segment axis="&#123;x|y&#125;" name="unique_name" length="int" type="&#123;bidir|unidir&#125;" freq="float" Rmetal="float" Cmetal="float"&gt;content&lt;/segment&gt;</code></p>
<p><strong>可选标签：</strong></p>
<ul>
<li><strong>axis</strong>-指定线段是只用于x通道还是只用于通道，如果未指定，则x、y通道都可以使用。</li>
</ul>
<p><strong>需要的标签：</strong></p>
<ul>
<li><strong>name</strong>-独一无二的线段类型的名字</li>
<li><strong>length</strong>-要么是标识线段长度（穿过多少个逻辑块），或者为关键字<code>longline</code>(跨过整个FPGA阵列)</li>
<li><strong>freq</strong>-此类线段在通道中所占的权重（该值除以所有线段该值的和）。</li>
<li><strong>Rmetal</strong>-每单位长度（以逻辑块为单位）的电阻（欧姆）</li>
<li><strong>Cmetal</strong>-每单位长度（以逻辑块为单位）的电容（法拉）</li>
<li><strong>directionality</strong>-线段的方向性。表明一个线段是否有多个驱动点（双向），或者线段的一端有一个驱动器（单向）（所有线段必须有相同的方向性值）</li>
<li><strong>content</strong>-包含开关名称、连接块填充以及开关块填充</li>
</ul>
<p><img src="https://docs.verilogtorouting.org/en/latest/_images/sb_pattern.png" alt="线段填充示例"></p>
<p><strong>content中的可用标签：</strong></p>
<p><code>&lt;sb type="pattern"&gt;int list&lt;/sb&gt;</code></p>
<p><code>&lt;cb type="pattren"&gt;int list&lt;/cb&gt;</code></p>
<p>上述两个标签用于指定开关块以及连接块的填充性质，不能用于<code>longline segments</code>，因为该类型的线段被指定为全部填充。</p>
<h2 id="自定义开关块">自定义开关块</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">switchblocklist</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">switchblock</span> <span class="attr">name</span>=<span class="string">&quot;my_switchblock&quot;</span> <span class="attr">type</span>=<span class="string">&quot;unidir&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">switchblock_location</span> <span class="attr">type</span>=<span class="string">&quot;EVERYWHERE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">switchfuncs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;lr&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;lt&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W-t&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;lb&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W+t-1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;rt&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W+t-1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;br&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W-t-2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;bt&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;rl&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;tl&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W-t&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;bl&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W+t-1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;tr&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W+t-1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;rb&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;W-t-2&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">func</span> <span class="attr">type</span>=<span class="string">&quot;tb&quot;</span> <span class="attr">formula</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">switchfuncs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wireconn</span> <span class="attr">from_type</span>=<span class="string">&quot;l4&quot;</span> <span class="attr">to_type</span>=<span class="string">&quot;l4&quot;</span> <span class="attr">from_switchpoint</span>=<span class="string">&quot;0,1,2,3&quot;</span> <span class="attr">to_switchpoint</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wireconn</span> <span class="attr">from_type</span>=<span class="string">&quot;l8_global&quot;</span> <span class="attr">to_type</span>=<span class="string">&quot;l8_global&quot;</span> <span class="attr">from_switchpoint</span>=<span class="string">&quot;0,4&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">to_switchpoint</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wireconn</span> <span class="attr">from_type</span>=<span class="string">&quot;l8_global&quot;</span> <span class="attr">to_type</span>=<span class="string">&quot;l4&quot;</span> <span class="attr">from_switchpoint</span>=<span class="string">&quot;0,4&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">to_switchpoint</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">switchblock</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">switchblock</span> <span class="attr">name</span>=<span class="string">&quot;another_switch_block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;unidir&quot;</span>&gt;</span></span><br><span class="line">    ... another switch block description ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">switchblock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">switchblocklist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="switchblock-namestring-typestring">&lt;switchblock name="string" type="string"&gt;</h3>
<p><code>&lt;switchblock&gt;</code> 是描述不同线段类型之间连接的顶层XML文件，有以下属性:</p>
<ul>
<li><strong>name</strong> – A unique alphanumeric string</li>
<li><strong>type</strong> – <code>unidir</code> or <code>bidir</code>.</li>
</ul>
<h3 id="switchblock_location-typestring">&lt;switchblock_location type="string"/&gt;</h3>
<ul>
<li><p>Required Attributes</p>
<p><strong>type</strong> –Can be one of the following strings:</p>
<ul>
<li><code>EVERYWHERE</code> – at each switch block of the FPGA</li>
<li><code>PERIMETER</code> – at each perimeter switch block (x-directed and/or y-directed channel segments may terminate here)</li>
<li><code>CORNER</code> – only at the corner switch blocks (both x and y-directed channels terminate here)</li>
<li><code>FRINGE</code> – same as PERIMETER but excludes corners</li>
<li><code>CORE</code> – everywhere but the perimeter</li>
</ul></li>
</ul>
<p>在 FPGA 上设置此开关块所描述的连接将被实例化的位置。</p>
]]></content>
      <categories>
        <category>CAD</category>
      </categories>
      <tags>
        <tag>VTR</tag>
      </tags>
  </entry>
  <entry>
    <title>VTR FLOW BEGIN</title>
    <url>/2022/05/10/VTR/</url>
    <content><![CDATA[<h1 id="手动运行vtr流程">手动运行VTR流程</h1>
<p>首先创建工程目录，位置任选，然后需要使用三个工具集来实现整个流程：</p>
<ul>
<li><strong>Odin II</strong>运行<span class="p red">综合</span>过程，将行为级描述转换为电路网表（.blif），该电路网表由基本逻辑门、除法器以及加法器等单元组成。</li>
<li><strong>ABC</strong>运行<span class="p red">逻辑优化</span>过程，用于简化逻辑电路，然后运行<span class="p red">工艺映射</span>过程，将由基本逻辑门实现的电路转换为由LUT所实现的电路。</li>
<li><strong>VPR</strong>运行<span class="p red">打包</span>、<span class="p red">布局</span>以及<span class="p red">布线</span>过程，将用户电路通过目标FPGA架构实现。</li>
</ul>
<h2 id="使用odin-ii进行综合">使用ODIN II进行综合</h2>
<figure class="highlight verilog"><figcaption><span>blink.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//A simple cricuit which blinks an LED on and off periodically</span></span><br><span class="line"><span class="keyword">module</span> blink(</span><br><span class="line">    <span class="keyword">input</span> clk,      <span class="comment">//Input clock</span></span><br><span class="line">    <span class="keyword">input</span> i_reset,  <span class="comment">//Input active-high reset</span></span><br><span class="line">    <span class="keyword">output</span> o_led);  <span class="comment">//Output to LED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sequential logic</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//A reset-able counter which increments each clock cycle</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">4</span>:<span class="number">0</span>] r_counter;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (i_reset) <span class="keyword">begin</span> <span class="comment">//When reset is high, clear counter</span></span><br><span class="line">            r_counter &lt;= <span class="number">5&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> <span class="comment">//Otherwise increment counter each clock (note that it will overflow back to zero)</span></span><br><span class="line">            r_counter &lt;= r_counter + <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Combinational logic </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//Drives o_led high if count is below a threshold</span></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (r_counter &lt; <span class="number">5&#x27;d16</span>) <span class="keyword">begin</span></span><br><span class="line">            o_led &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            o_led &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>首先，我们将在我们的 Verilog 文件上运行 ODIN II 以将其合成为电路网表，并提供以下选项：</p>
<ul>
<li><code>-a $VTR_ROOT/vtr_flow/arch/timing/EArch.xml</code>它指定了我们所针对的 FPGA 架构，</li>
<li><code>-V $VTR_ROOT/doc/src/quickstart/blink.v</code>它指定了我们要合成的verilog文件，以及</li>
<li><code>-o blink.odin.blif</code>它指定生成的<code>.blif</code>电路网表的名称。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VTR_ROOT/ODIN_II/odin_II \</span></span><br><span class="line"><span class="language-bash">    -a <span class="variable">$VTR_ROOT</span>/vtr_flow/arch/timing/EArch.xml \</span></span><br><span class="line"><span class="language-bash">    -V <span class="variable">$VTR_ROOT</span>/doc/src/quickstart/blink.v \</span></span><br><span class="line"><span class="language-bash">    -o blink.odin.blif</span></span><br></pre></td></tr></table></figure>
<p>然后可以观看所生成的网表文件，其内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#r_counter implements</span></span><br><span class="line">.latch blink^nMUX~<span class="number">0</span>^MUX_2~<span class="number">23</span> blink^r_counter~0_FF re blink^clk <span class="number">3</span></span><br><span class="line">.latch blink^nMUX~<span class="number">0</span>^MUX_2~<span class="number">27</span> blink^r_counter~4_FF re blink^clk <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># + operator implements</span></span><br><span class="line">.subckt adder a[<span class="number">0</span>]=blink^r_counter~0_FF b[<span class="number">0</span>]=vcc cin[<span class="number">0</span>]=blink^ADD~<span class="number">2</span>-<span class="number">0</span>[<span class="number">0</span>]\</span><br><span class="line"> cout[<span class="number">0</span>]=blink^ADD~<span class="number">2</span>-<span class="number">1</span>[<span class="number">0</span>] sumout[<span class="number">0</span>]=blink^ADD~<span class="number">2</span>-<span class="number">1</span>[<span class="number">1</span>]</span><br><span class="line">.subckt adder a[<span class="number">0</span>]=blink^r_counter~1_FF b[<span class="number">0</span>]=gnd cin[<span class="number">0</span>]=blink^ADD~<span class="number">2</span>-<span class="number">1</span>[<span class="number">0</span>]\</span><br><span class="line"> cout[<span class="number">0</span>]=blink^ADD~<span class="number">2</span>-<span class="number">2</span>[<span class="number">0</span>] sumout[<span class="number">0</span>]=blink^ADD~<span class="number">2</span>-<span class="number">2</span>[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># &lt; operator implements</span></span><br><span class="line"> .names blink^LT~<span class="number">4</span>^GT~<span class="number">10</span> blink^LT~<span class="number">4</span>^GT~<span class="number">12</span> blink^LT~<span class="number">4</span>^GT~<span class="number">14</span> blink^LT~<span class="number">4</span>^GT~<span class="number">16</span> blink^LT~<span class="number">4</span>^GT~<span class="number">18</span> blink^LT~<span class="number">4</span>^lOR~<span class="number">9</span></span><br><span class="line"><span class="number">1</span>---- <span class="number">1</span></span><br><span class="line">-<span class="number">1</span>--- <span class="number">1</span></span><br><span class="line">--<span class="number">1</span>-- <span class="number">1</span></span><br><span class="line">---<span class="number">1</span>- <span class="number">1</span></span><br><span class="line">----<span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div class="note success flat"><h3 id="see-also">See also</h3>
<p>For more information on the BLIF file format see <a href="https://docs.verilogtorouting.org/en/latest/vpr/file_formats/#blif-format">BLIF Netlist (.blif)</a>.</p>
</div>
<h2 id="使用abc进行优化以及技术映射">使用ABC进行优化以及技术映射</h2>
<p>ABC提供以下选项：</p>
<ul>
<li><code>-c &lt;script&gt;</code>，其中<code>&lt;script&gt;</code>是一组命令，用于高速ABC如何处理我们的电路，一个示例如下所示。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VTR_ROOT/abc/abc \</span></span><br><span class="line"><span class="language-bash">    -c <span class="string">&#x27;read blink.odin.blif; if -K 6; write_hie blink.odin.blif blink.abc_no_clock.blif&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">read</span> blink.odin.blif;                               <span class="comment">#Read the circuit synthesized by ODIN</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> -K 6;                                            <span class="comment">#Technology map to 6 input LUTs (6-LUTs)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">write_hie blink.odin.blif blink.abc_no_clock.blif   <span class="comment">#Write new circuit to blink.abc_no_clock.blif</span></span></span><br></pre></td></tr></table></figure>
<div class="note info flat"><h3 id="note">Note</h3>
<p>Usually you should use a more complicated script (such as that used by <a href="https://docs.verilogtorouting.org/en/latest/vtr/run_vtr_flow/#run-vtr-flow">run_vtr_flow</a>) to ensure ABC optitmizes your circuit well.</p>
</div>
<p>如果我们现在检查生成的 BLIF 文件 ( <code>blink.abc_no_clock.blif</code>)，我们会看到 ABC 能够显着简化和优化电路的逻辑（与<code>blink.odin.blif</code>相比）：</p>
<figure class="highlight scheme"><figcaption><span>blink.abc_no_clock.blif</span></figcaption><table><tr><td class="code"><pre><span class="line"># Benchmark <span class="string">&quot;blink&quot;</span> written by ABC on Tue May <span class="number">19</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">50</span> <span class="number">2020</span></span><br><span class="line">.model blink</span><br><span class="line">.inputs blink^clk blink^i_reset</span><br><span class="line">.outputs blink^o_led</span><br><span class="line"></span><br><span class="line">.latch        n<span class="number">19</span> blink^r_counter~<span class="number">0</span>_FF  <span class="number">2</span></span><br><span class="line">.latch        n<span class="number">24</span> blink^r_counter~<span class="number">4</span>_FF  <span class="number">2</span></span><br><span class="line">.latch        n<span class="number">29</span> blink^r_counter~<span class="number">3</span>_FF  <span class="number">2</span></span><br><span class="line">.latch        n<span class="number">34</span> blink^r_counter~<span class="number">2</span>_FF  <span class="number">2</span></span><br><span class="line">.latch        n<span class="number">39</span> blink^r_counter~<span class="number">1</span>_FF  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.subckt adder a[<span class="name">0</span>]=blink^r_counter~<span class="number">0</span>_FF b[<span class="name">0</span>]=vcc cin[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-0</span>[<span class="name">0</span>] cout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-1</span>[<span class="name">0</span>] sumout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-1</span>[<span class="name">1</span>]</span><br><span class="line">.subckt adder a[<span class="name">0</span>]=blink^r_counter~<span class="number">1</span>_FF b[<span class="name">0</span>]=gnd cin[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-1</span>[<span class="name">0</span>] cout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-2</span>[<span class="name">0</span>] sumout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-2</span>[<span class="name">1</span>]</span><br><span class="line">.subckt adder a[<span class="name">0</span>]=blink^r_counter~<span class="number">2</span>_FF b[<span class="name">0</span>]=gnd cin[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-2</span>[<span class="name">0</span>] cout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-3</span>[<span class="name">0</span>] sumout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-3</span>[<span class="name">1</span>]</span><br><span class="line">.subckt adder a[<span class="name">0</span>]=blink^r_counter~<span class="number">3</span>_FF b[<span class="name">0</span>]=gnd cin[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-3</span>[<span class="name">0</span>] cout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-4</span>[<span class="name">0</span>] sumout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-4</span>[<span class="name">1</span>]</span><br><span class="line">.subckt adder a[<span class="name">0</span>]=blink^r_counter~<span class="number">4</span>_FF b[<span class="name">0</span>]=gnd cin[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-4</span>[<span class="name">0</span>] cout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-5</span>[<span class="name">0</span>] sumout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-5</span>[<span class="name">1</span>]</span><br><span class="line">.subckt adder a[<span class="name">0</span>]=gnd b[<span class="name">0</span>]=gnd cin[<span class="name">0</span>]=unconn cout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-0</span>[<span class="name">0</span>] sumout[<span class="name">0</span>]=blink^ADD~<span class="number">2</span><span class="number">-0</span>~dummy_output~<span class="number">0</span>~<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.names blink^i_reset blink^ADD~<span class="number">2</span><span class="number">-1</span>[<span class="name">1</span>] n<span class="number">19</span></span><br><span class="line"><span class="number">01</span> <span class="number">1</span></span><br><span class="line">.names blink^i_reset blink^ADD~<span class="number">2</span><span class="number">-5</span>[<span class="name">1</span>] n<span class="number">24</span></span><br><span class="line"><span class="number">01</span> <span class="number">1</span></span><br><span class="line">.names blink^i_reset blink^ADD~<span class="number">2</span><span class="number">-4</span>[<span class="name">1</span>] n<span class="number">29</span></span><br><span class="line"><span class="number">01</span> <span class="number">1</span></span><br><span class="line">.names blink^i_reset blink^ADD~<span class="number">2</span><span class="number">-3</span>[<span class="name">1</span>] n<span class="number">34</span></span><br><span class="line"><span class="number">01</span> <span class="number">1</span></span><br><span class="line">.names blink^i_reset blink^ADD~<span class="number">2</span><span class="number">-2</span>[<span class="name">1</span>] n<span class="number">39</span></span><br><span class="line"><span class="number">01</span> <span class="number">1</span></span><br><span class="line">.names vcc</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">.names gnd</span><br><span class="line"> <span class="number">0</span></span><br><span class="line">.names unconn</span><br><span class="line"> <span class="number">0</span></span><br><span class="line">.names blink^r_counter~<span class="number">4</span>_FF blink^o_led</span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line">.end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.model adder</span><br><span class="line">.inputs a[<span class="name">0</span>] b[<span class="name">0</span>] cin[<span class="name">0</span>]</span><br><span class="line">.outputs cout[<span class="name">0</span>] sumout[<span class="name">0</span>]</span><br><span class="line">.blackbox</span><br><span class="line">.end</span><br></pre></td></tr></table></figure>
<p>ABC保留了<code>.latch</code>和<code>.sunckt adder</code>基元，但是确实极大的简化了其他逻辑（<code>.names</code>）。但是经过ABC处理之后的BLIF文件存在一个问题：锁存器（上升沿FF）没有指定任何时钟或者边沿敏感，但是这是VPR所需要的信息。</p>
<h3 id="重新插入时钟">重新插入时钟</h3>
<p>可以通过运行一个脚本来恢复时钟信息，该脚本将从原始 ODIN BLIF 文件中传输该信息（将其写入新文件<code>blink.pre-vpr.blif</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">VTR_ROOT/vtr_flow/scripts/restore_multiclock_latch.pl \</span></span><br><span class="line"><span class="language-bash">    blink.odin.blif \</span></span><br><span class="line"><span class="language-bash">    blink.abc_no_clock.blif \</span></span><br><span class="line"><span class="language-bash">    blink.pre-vpr.blif</span></span><br></pre></td></tr></table></figure>
<p>然后再检查<code>blink.pre-vpr.blif</code>，可以看到时钟 ( <code>blink^clk</code>) 已恢复到触发器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">grep <span class="string">&#x27;latch&#x27;</span> blink.pre-vpr.blif</span></span><br><span class="line"></span><br><span class="line">.latch n19 blink^r_counter~0_FF re blink^clk 3</span><br><span class="line">.latch n24 blink^r_counter~4_FF re blink^clk 3</span><br><span class="line">.latch n29 blink^r_counter~3_FF re blink^clk 3</span><br><span class="line">.latch n34 blink^r_counter~2_FF re blink^clk 3</span><br><span class="line">.latch n39 blink^r_counter~1_FF re blink^clk 3</span><br></pre></td></tr></table></figure>
<h2 id="使用vpr实现电路">使用VPR实现电路</h2>
<p>现在我们已经有了优化和技术映射的网<code>blink.pre-vpr.blif</code>表（但是，由于我们的 BLIF 文件与我们明确指定的设计名称不匹配。</p>
<p><code>blink</code>作为电路名称，和输入电路文件<a href="https://docs.verilogtorouting.org/en/latest/vpr/command_line_usage/#cmdoption-vpr-circuit_file"><code>--circuit_file</code></a>。以确保生成的<code>.net</code>,<code>.place</code>和<code>.route</code>文件将具有正确的名称。因此执行的命令以及执行的结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$VTR_ROOT</span>/vpr/vpr \</span></span><br><span class="line"><span class="language-bash">    <span class="variable">$VTR_ROOT</span>/vtr_flow/arch/timing/EArch.xml \</span></span><br><span class="line"><span class="language-bash">    blink --circuit_file blink.pre-vpr.blif \</span></span><br><span class="line"><span class="language-bash">    --route_chan_width 100</span></span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">ls</span> *.net *.place *.route</span></span><br><span class="line">blink.net  blink.place  blink.route</span><br></pre></td></tr></table></figure>
<p>然后可以通过添加 <code>--analysis --disp on</code> 来查看布局：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$VTR_ROOT</span>/vpr/vpr \</span></span><br><span class="line"><span class="language-bash">    <span class="variable">$VTR_ROOT</span>/vtr_flow/arch/timing/EArch.xml \</span></span><br><span class="line"><span class="language-bash">    blink --circuit_file blink.pre-vpr.blif \</span></span><br><span class="line"><span class="language-bash">    --route_chan_width 100 \</span></span><br><span class="line"><span class="language-bash">    --analysis --disp on</span></span><br></pre></td></tr></table></figure>
<div class="note info flat"><h3 id="note">Note</h3>
<p>如果不使用<code>--analysis</code>，那么VPR将重新布局布线。并且如果开启了<code>--disp on</code>，那么就可以看到VPR运行时如何修改布局布线。默认情况下，会再关键阶段停止以使得用户可以观察和探索布局。用户需要按GUI上的<code>Proceed</code>按钮以使得VPR继续运行。</p>
</div>
<h1 id="自动运行vtr流程">自动运行VTR流程</h1>
<p>手动运行流程的每个阶段非常耗时（并且可能容易出错）。为方便起见，VTR 提供了一个脚本 ( <a href="https://docs.verilogtorouting.org/en/latest/vtr/run_vtr_flow/#run-vtr-flow">run_vtr_flow</a> ) 来自动执行此过程。</p>
<p>首先，确保已激活在本教程开始时创建的 Python 虚拟环境(我为efpga环境)，然后运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建工作目录</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/vtr_work/quickstart/blink_run_flow</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cd</span> ~/vtr_work/quickstart/blink_run_flow</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">脚本名称  HDL文件  目标FPGA架构文件  指定运行目录为当前文件夹  FPGA架构的路由宽度为100</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$VTR_ROOT</span>/vtr_flow/scripts/run_vtr_flow.py \</span></span><br><span class="line"><span class="language-bash">    <span class="variable">$VTR_ROOT</span>/doc/src/quickstart/blink.v \</span></span><br><span class="line"><span class="language-bash">    <span class="variable">$VTR_ROOT</span>/vtr_flow/arch/timing/EArch.xml \</span></span><br><span class="line"><span class="language-bash">    -temp_dir . \</span></span><br><span class="line"><span class="language-bash">    --route_chan_width 100</span></span><br></pre></td></tr></table></figure>
<p>接下来便可以查看运行的日志文件（script_name.out），其中感兴趣的主要日志文件包括 ODIN 日志文件 ( <code>odin.out</code>)、ABC 生成的日志文件 (例如<code>abc0.out</code>) 和 VPR 日志文件 ( <code>vpr.out</code>)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">ls</span> *.out</span></span><br><span class="line"></span><br><span class="line">0_blackboxing_latch.out  odin.out        report_clocks.abc.out  vanilla_restore_clocks.out</span><br><span class="line">abc0.out                 report_clk.out  restore_latch0.out     vpr.out</span><br></pre></td></tr></table></figure>
<div class="note info flat"><h2 id="note">Note</h2>
<p>如果电路具有多个时钟域，则 ABC 可能会被多次调用，从而产生多个日志文件 ( <code>abc0.out</code>, <code>abc1.out</code>, ...)</p>
</div>
<p>除此之外，还可以看到生成的BLIF文件，其中感兴趣的主要文件是<code>blink.odin.blif</code>（ODIN 产生的网表），<code>blink.abc.blif</code>（时钟恢复后 ABC 产生的最终网表），<code>blink.pre-vpr.blif</code>VPR 使用的网表（通常与 相同<code>blink.abc.blif</code>）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">ls</span> *.blif</span></span><br><span class="line"></span><br><span class="line">0_blink.abc.blif   0_blink.raw.abc.blif  blink.odin.blif</span><br><span class="line">0_blink.odin.blif  blink.abc.blif        blink.pre-vpr.blif</span><br></pre></td></tr></table></figure>
<p>和之前一样，也可以看到VPR生成的实现文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">ls</span> *.net *.place *.route</span></span><br><span class="line"></span><br><span class="line">blink.net  blink.place  blink.route</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可视化方式</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$VTR_ROOT</span>/vpr/vpr \</span></span><br><span class="line"><span class="language-bash">    <span class="variable">$VTR_ROOT</span>/vtr_flow/arch/timing/EArch.xml \</span></span><br><span class="line"><span class="language-bash">    blink --circuit_file blink.pre-vpr.blif \</span></span><br><span class="line"><span class="language-bash">    --route_chan_width 100 \</span></span><br><span class="line"><span class="language-bash">    --analysis --disp on</span></span><br></pre></td></tr></table></figure>
<div class="poem-wrap"><div class="poem-reel"></div><div class="poem"><div class="poem-title">水调歌头</div><div class="poem-author">苏轼</div><div class="poem-main"><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>
明月几时有？把酒问青天。<br>
不知天上宫阙，今夕是何年？<br>
我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>
起舞弄清影，何似在人间？</p>
<p>转朱阁，低绮户，照无眠。<br>
不应有恨，何事长向别时圆？<br>
人有悲欢离合，月有阴晴圆缺，此事古难全。<br>
但愿人长久，千里共婵娟。</p>
</div></div></div>
]]></content>
      <categories>
        <category>CAD</category>
      </categories>
      <tags>
        <tag>VTR</tag>
      </tags>
  </entry>
  <entry>
    <title>WaveDrom教程</title>
    <url>/2024/07/29/WaveDrom/</url>
    <content><![CDATA[<p><a href="https://github.com/wavedrom/wavedrom">WaveDrom</a> 可以根据特定指令生成时序 / 波形图（SVG/PNG），并且也可以在浏览器中运行。同时也提供了<a href="https://wavedrom.com/editor.html">在线编辑器</a>和<a href="https://wavedrom.com/tutorial.html">教程</a>、<a href="https://wavedrom.com/tutorial2.html">教程 2</a>。</p>
<h1 id="信号signal">信号（signal)</h1>
<h2 id="名称name和波形wave">名称（name）和波形（wave）</h2>
<p>绘制信号时，需要向 WaveDrom 传递键为 <code>signal</code>，值为 <code>WaveLanes</code> 的数组，<code>WaveLane</code> 一般至少需要包含两个属性：名称（<code>name</code>）和波形（<code>wave</code>），例如（<a href="https://wavedrom.com/editor.html?%7B%20%22signal%22%20%3A%20%5B%7B%20%22name%22%3A%20%22clk%22%2C%20%22wave%22%3A%20%22P...........%22%20%7D%5D%20%7D%0A">在官方在线编辑器中打开</a>）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;signal&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clk&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;wave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P...........&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ "signal" : [{ "name": "clk", "wave": "P..........." }] }</script>
<p>波形的名称将显示在波形左侧，波形由一个字符串指定，每个字符都代表了一个周期的波形，每个字符代表的意义如下：</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 40%">
<col style="width: 42%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">样例</th>
<th style="text-align: center;">渲染结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>.</code></td>
<td style="text-align: center;">与上一周期状态相同</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "p..." &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom"> { signal : [{ name: ".", wave: "p..." }]}</script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>p</code></td>
<td style="text-align: center;">在周期开始时为上升沿的时钟信号</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "p", wave: "p.pp" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom"> { signal : [{ name: "p", wave: "p.pp" }]}</script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>P</code></td>
<td style="text-align: center;">在周期开始时为上升沿的时钟信号，上升沿有箭头</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "P", wave: "P.PP" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "P", wave: "P.PP" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>n</code></td>
<td style="text-align: center;">在周期开始时为下降沿的时钟信号</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "n", wave: "n.nn" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "n", wave: "n.nn" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>N</code></td>
<td style="text-align: center;">在周期开始时为下降沿的时钟信号，下降沿有箭头</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "N", wave: "N.NN" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "N", wave: "N.NN" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;">低电平，有过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "0", wave: "0.01" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "0", wave: "0.01" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>l</code></td>
<td style="text-align: center;">低电平，无过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "l", wave: "l.lh" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "l", wave: "l.lh" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;">高电平，有过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "1", wave: "1.10" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "1", wave: "1.10" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>h</code></td>
<td style="text-align: center;">高电平，无过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "h", wave: "h.hl" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "h", wave: "h.hl" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>z</code></td>
<td style="text-align: center;">高阻态</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "z", wave: "z.zz" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "z", wave: "z.zz" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>d</code></td>
<td style="text-align: center;">下拉（弱 0）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "d", wave: "d.dd" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "d", wave: "d.dd" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>u</code></td>
<td style="text-align: center;">上拉（弱 1）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "u", wave: "u.uu" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "u", wave: "u.uu" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>x</code></td>
<td style="text-align: center;">未定义</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "x", wave: "x.xx" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "x", wave: "x.xx" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>2</code>/<code>=</code></td>
<td style="text-align: center;">值（颜色为 2）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "2", wave: "2.22" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "2", wave: "2.22" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>3</code></td>
<td style="text-align: center;">值（颜色为 3）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "3", wave: "3.33" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom"> { signal : [{ name: "3", wave: "3.33" }]}</script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>4</code>/<code>5</code>/<code>6</code></td>
<td style="text-align: center;">值（颜色为 4/5/6）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "4/5/6", wave: "4.56" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "4/5/6", wave: "4.56" }]} </script></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>7</code>/<code>8</code>/<code>9</code></td>
<td style="text-align: center;">值（颜色为 7/8/9）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "7/8/9", wave: "7.89" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "7/8/9", wave: "7.89" }]} </script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>\|</code></td>
<td style="text-align: center;">延长前一个周期并绘制间隙</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "\|", wave: "xx\|x" &#125;]&#125;</code></td>
<td style="text-align: center;"><script type="WaveDrom">{ signal : [{ name: "|", wave: "xx|x" }]} </script></td>
</tr>
</tbody>
</table>
<p>这两个属性也可以没有，都没有时将显示一个空行。</p>
<h2 id="值名称data">值名称（data）</h2>
<p>通过<code>WaveLane</code>的<code>data</code>数组按波形中值出现的顺序指定值的名称：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;signal&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bus&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;wave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x.==.=x&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;head&quot;</span><span class="punctuation">,</span> <span class="string">&quot;body&quot;</span><span class="punctuation">,</span> <span class="string">&quot;tail&quot;</span><span class="punctuation">,</span> <span class="string">&quot;data&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ "signal" : [{ "name": "bus",  "wave": "x.==.=x", "data": ["head", "body", "tail", "data"] }]}</script>
<h2 id="分组">分组</h2>
<p>通过数组的第一项的值控制分组：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">[</span>&#x27;Slave&#x27;<span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;ctrl&#x27;<span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;ack&#x27;<span class="punctuation">,</span>   wave<span class="punctuation">:</span> &#x27;x01x0<span class="number">.1</span>x&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>  name<span class="punctuation">:</span> &#x27;rdata&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;x....<span class="number">.4</span>x&#x27;<span class="punctuation">,</span> data<span class="punctuation">:</span> &#x27;Q2&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ signal: [
  ['Slave',
    ['ctrl',
      {name: 'ack',   wave: 'x01x0.1x'},
    ],
    {  name: 'rdata', wave: 'x.....4x', data: 'Q2'},
  ]
]}</script>
<h2 id="周期period和相位phase">周期（period）和相位（phase）</h2>
<p>通过<code>WaveLane</code>的<code>period</code>和<code>phase</code>项控制周期和相位：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;CK&quot;</span><span class="punctuation">,</span>   wave<span class="punctuation">:</span> <span class="string">&quot;P.......&quot;</span><span class="punctuation">,</span>                                              period<span class="punctuation">:</span> <span class="number">2</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;CMD&quot;</span><span class="punctuation">,</span>  wave<span class="punctuation">:</span> <span class="string">&quot;x.3x=x4x=x=x=x=x&quot;</span><span class="punctuation">,</span> data<span class="punctuation">:</span> <span class="string">&quot;RAS NOP CAS NOP NOP NOP NOP&quot;</span><span class="punctuation">,</span> phase<span class="punctuation">:</span> <span class="number">0.5</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;DQ&quot;</span><span class="punctuation">,</span>   wave<span class="punctuation">:</span> <span class="string">&quot;z.........5555z.&quot;</span><span class="punctuation">,</span> data<span class="punctuation">:</span> <span class="string">&quot;D0 D1 D2 D3&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ signal: [
  { name: "CK",   wave: "P.......",                                              period: 2  },
  { name: "CMD",  wave: "x.3x=x4x=x=x=x=x", data: "RAS NOP CAS NOP NOP NOP NOP", phase: 0.5 },
  { name: "DQ",   wave: "z.........5555z.", data: "D0 D1 D2 D3" }
]}</script>
<h2 id="节点node">节点（node）</h2>
<p><code>node</code>可以指定节点并在边沿处显示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;A&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">01.</span>......<span class="number">.0</span>....&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;.a...c....j&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ signal: [
  { name: 'A', wave: '01........0....',  node: '.a...c....j' },
  ],
}</script>
<h2 id="连线edge">连线（edge）</h2>
<p>通过指定连线（edge）连接两个节点，连线有两种类型，一种是圆滑的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> ~    -~</span><br><span class="line">&lt;~&gt;  &lt;-~&gt;</span><br><span class="line"> ~&gt;   -~&gt;  ~-&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;A&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">01.</span>......<span class="number">.0</span>....&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;.a........j&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;B&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.1</span>......<span class="number">.0</span><span class="number">.1</span>..&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;..b.......i&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;C&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.</span><span class="number">.1</span>...<span class="number">.0</span>..<span class="number">.1</span>..&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;...c....h..&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;D&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.</span>.<span class="number">.1</span>.<span class="number">.0</span>....<span class="number">.1</span>.&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;....d..g...&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;E&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.</span>..<span class="number">.10</span>......<span class="number">.1</span>&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;.....ef....&#x27; <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  edge<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    &#x27;a~b t1&#x27;<span class="punctuation">,</span> &#x27;c-~a t2&#x27;<span class="punctuation">,</span> &#x27;c-~&gt;d time <span class="number">3</span>&#x27;<span class="punctuation">,</span> &#x27;d~-e&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;e~&gt;f&#x27;<span class="punctuation">,</span> &#x27;f-&gt;g&#x27;<span class="punctuation">,</span> &#x27;g-~&gt;h&#x27;<span class="punctuation">,</span> &#x27;h~&gt;i some text&#x27;<span class="punctuation">,</span> &#x27;h~-&gt;j&#x27;</span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ signal: [
  { name: 'A', wave: '01........0....',  node: '.a........j' },
  { name: 'B', wave: '0.1.......0.1..',  node: '..b.......i' },
  { name: 'C', wave: '0..1....0...1..',  node: '...c....h..' },
  { name: 'D', wave: '0...1..0.....1.',  node: '....d..g...' },
  { name: 'E', wave: '0....10.......1',  node: '.....ef....' }
  ],
  edge: [
    'a~b t1', 'c-~a t2', 'c-~>d time 3', 'd~-e',
    'e~>f', 'f->g', 'g-~>h', 'h~>i some text', 'h~->j'
  ]
}</script>
<p>另一种是直线：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"> -   -|   -|-</span><br><span class="line">&lt;-&gt; &lt;-|&gt; &lt;-|-&gt;</span><br><span class="line"> -&gt;  -|&gt;  -|-&gt;  |-&gt;</span><br><span class="line"> +</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;A&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">01.</span><span class="number">.0</span>..&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;.a..e..&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;B&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.1</span>.<span class="number">.0</span>.&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;..b..d.&#x27;<span class="punctuation">,</span> phase<span class="punctuation">:</span><span class="number">0.5</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;C&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.</span><span class="number">.1</span>.<span class="number">.0</span>&#x27;<span class="punctuation">,</span>  node<span class="punctuation">:</span> &#x27;...c..f&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span>                              node<span class="punctuation">:</span> &#x27;...g..h&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span>                              node<span class="punctuation">:</span> &#x27;...I..J&#x27;<span class="punctuation">,</span>  phase<span class="punctuation">:</span><span class="number">0.5</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> &#x27;D&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.</span><span class="number">.1</span>.<span class="number">.0</span>&#x27;<span class="punctuation">,</span>  phase<span class="punctuation">:</span><span class="number">0.5</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  edge<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    &#x27;b-|a t1&#x27;<span class="punctuation">,</span> &#x27;a-|c t2&#x27;<span class="punctuation">,</span> &#x27;b-|-c t3&#x27;<span class="punctuation">,</span> &#x27;c-|-&gt;e t4&#x27;<span class="punctuation">,</span> &#x27;e-|&gt;f more text&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;e|-&gt;d t6&#x27;<span class="punctuation">,</span> &#x27;c-g&#x27;<span class="punctuation">,</span> &#x27;f-h&#x27;<span class="punctuation">,</span> &#x27;g&lt;-&gt;h <span class="number">3</span> ms&#x27;<span class="punctuation">,</span> &#x27;I+J <span class="number">5</span> ms&#x27;</span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ signal: [
  { name: 'A', wave: '01..0..',  node: '.a..e..' },
  { name: 'B', wave: '0.1..0.',  node: '..b..d.', phase:0.5 },
  { name: 'C', wave: '0..1..0',  node: '...c..f' },
  {                              node: '...g..h' },
  {                              node: '...I..J',  phase:0.5 },
  { name: 'D', wave: '0..1..0',  phase:0.5 }
  ],
  edge: [
    'b-|a t1', 'a-|c t2', 'b-|-c t3', 'c-|->e t4', 'e-|>f more text',
    'e|->d t6', 'c-g', 'f-h', 'g<->h 3 ms', 'I+J 5 ms'
  ]
}</script>
<h1 id="寄存器reg">寄存器（reg）</h1>
<h2 id="名称name和比特数bit">名称（name）和比特数（bit）</h2>
<p>名称（<code>name</code>）和比特数（<code>bit</code>）是寄存器最基本的两个属性，名称将显示在寄存器框内且可以为空，比特数代表此与区域的长度。列表的顺序是从高位到低位，一个寄存器默认在一行中显示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3},
    {               bits: 7}
]}</script>
<h2 id="类型type">类型（type）</h2>
<p>类型（<code>type</code>）指定寄存器的颜色：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> name<span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    { bits: 1, name:""},
    { bits: 1, type: 0},
    { bits: 1, type: 1},
    { bits: 1, type: 2},
    { bits: 1, type: 3},
    { bits: 1, type: 4},
    { bits: 1, type: 5},
    { bits: 1, type: 6},
    { bits: 1, type: 7},
    { bits: 1, type: 8},
    { bits: 1, type: 9},
]}</script>
<h2 id="属性attr">属性（attr）</h2>
<p>属性（<code>attr</code>）指定寄存器下方文字或二进制数字并按列表顺序依次显示，当属性为文字时直接显示，为数字时将展开为二进制，若数字的二进制超过最大范围则截取有效部分：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span>  name<span class="punctuation">:</span> &#x27;opcode&#x27;<span class="punctuation">,</span>    attr<span class="punctuation">:</span> &#x27;OP&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>  name<span class="punctuation">:</span> &#x27;rd&#x27;<span class="punctuation">,</span>        attr<span class="punctuation">:</span> &#x27;dest&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  name<span class="punctuation">:</span> &#x27;func3&#x27;<span class="punctuation">,</span>     attr<span class="punctuation">:</span> &#x27;T0 T1 T2 T3 T4 T5 T6 T7 T8 T9&#x27;.split(&#x27; &#x27;)<span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>  name<span class="punctuation">:</span> &#x27;rs1&#x27;<span class="punctuation">,</span>       attr<span class="punctuation">:</span> &#x27;src1&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>  name<span class="punctuation">:</span> &#x27;rs2&#x27;<span class="punctuation">,</span>       attr<span class="punctuation">:</span> &#x27;src2&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span>  name<span class="punctuation">:</span> &#x27;funct7&#x27;<span class="punctuation">,</span> attr<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">16</span><span class="punctuation">,</span> <span class="number">32</span><span class="punctuation">,</span> <span class="number">64</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg: [
    {bits: 7,  name: 'opcode',    attr: 'OP'},
    {bits: 5,  name: 'rd',        attr: 'dest'},
    {bits: 3,  name: 'func3',     attr: 'T0 T1 T2 T3 T4 T5 T6 T7 T8 T9'.split(' '), type: 4},
    {bits: 5,  name: 'rs1',       attr: 'src1'},
    {bits: 5,  name: 'rs2',       attr: 'src2'},
    {bits: 7,  name: 'funct7', attr: [0, 1, 2, 3, 4, 5, 8, 16, 32, 64]}
]}</script>
<h2 id="旋转rotate">旋转（rotate）</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;label <span class="number">-90</span>&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> rotate<span class="punctuation">:</span> <span class="number">-90</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;label <span class="number">-45</span>&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> rotate<span class="punctuation">:</span> <span class="number">-45</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;label <span class="number">45</span>&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> rotate<span class="punctuation">:</span> <span class="number">45</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;label <span class="number">90</span>&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> rotate<span class="punctuation">:</span> <span class="number">90</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;label <span class="number">0</span>&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> rotate<span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>vspace<span class="punctuation">:</span><span class="number">100</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'label -90', bits: 1, rotate: -90},
    {name: 'label -45', bits: 1, rotate: -45},
    {name: 'label 45', bits: 1, rotate: 45},
    {name: 'label 90', bits: 1, rotate: 90},
    {name: 'label 0', bits: 1, rotate: 0},
],config:{vspace:100}}</script>
<h2 id="宽度hspace高度vspace">宽度（hspace）、高度（vspace）</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> attr<span class="punctuation">:</span> &#x27;RO&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> attr<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;RW&#x27;<span class="punctuation">,</span> &#x27;FOO&#x27;<span class="punctuation">]</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>hspace<span class="punctuation">:</span> <span class="number">800</span><span class="punctuation">,</span> vspace<span class="punctuation">:</span> <span class="number">150</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8, attr: 'RO'},
    {               bits: 7},
    {name: 'BRK',   bits: 5, attr: ['RW', 'FOO'], type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{hspace: 800, vspace: 150}}</script>
<h2 id="多行lanes">多行（lanes）</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>lanes<span class="punctuation">:</span><span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{lanes:2}}</script>
<h2 id="行号label">行号（label）</h2>
<p>指定寄存器左侧（<code>left</code>）或者右侧（<code>right</code>）的行号，参数为起始值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>lanes<span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span> label<span class="punctuation">:</span> <span class="punctuation">&#123;</span>right<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{lanes:2, label: {right: 2}}}</script>
<h2 id="位数bit">位数（bit）</h2>
<p>当位数大于已有的寄存器长度时，剩余长度用空白填充。当位数小于已有的寄存器长度时，多余的寄存器将不会显示。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>bits<span class="punctuation">:</span> <span class="number">48</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{bits: 48}}</script>
<h2 id="水平顺序vflip-垂直顺序hflip">水平顺序（vflip）/ 垂直顺序（hflip）</h2>
<p>默认顺序为水平方向上高位在低位在后，垂直方向上为高位在上低位在下，通过水平顺序（<code>vflip</code>）/ 垂直顺序（<code>hflip</code>）可以改变该顺序。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>vflip<span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{vflip: true}}</script>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>lanes<span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span> hflip<span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{lanes:2, hflip: true}}</script>
<h2 id="紧凑compact">紧凑（compact）</h2>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>lanes<span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span> compact<span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{lanes:2, compact: true}}</script>
<h2 id="字号fontsize-间隙margin">字号（fontsize）/ 间隙（margin）</h2>
<p>通过<code>fontsize</code>指定字号</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>fontsize<span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{fontsize: 20}}</script>
<p>通过<code>margin</code>指定与边缘的距离，包括上（<code>top</code>）下（<code>bottom</code>）左（<code>left</code>）右（<code>right</code>）四个方向。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>reg<span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;IPO&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;BRK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;CPK&#x27;<span class="punctuation">,</span>   bits<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>name<span class="punctuation">:</span> &#x27;Clear&#x27;<span class="punctuation">,</span> bits<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> type<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span>               bits<span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span>config<span class="punctuation">:</span><span class="punctuation">&#123;</span>margin<span class="punctuation">:</span> <span class="punctuation">&#123;</span>left<span class="punctuation">:</span> <span class="number">60</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{reg:[
    {name: 'IPO',   bits: 8},
    {               bits: 7},
    {name: 'BRK',   bits: 5, type: 4},
    {name: 'CPK',   bits: 2},
    {name: 'Clear', bits: 3, type: 5},
    {               bits: 7}
],config:{margin: {left: 60}}}</script>
<h1 id="配置config">配置（config）</h1>
<h2 id="水平缩放hscale">水平缩放（hscale）</h2>
<p>通过指定配置（<code>config</code>）的水平缩放（<code>hscale</code>）值来控制水平缩放，该值必须为大于零的整数（也就是说只能放大），若要缩小周期，需要配置皮肤。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;clk&quot;</span><span class="punctuation">,</span>     wave<span class="punctuation">:</span> <span class="string">&quot;p....&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  config<span class="punctuation">:</span> <span class="punctuation">&#123;</span> hscale<span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{ signal: [
  { name: "clk",     wave: "p...." },],
  config: { hscale: 2 }
}</script>
<h2 id="皮肤skin">皮肤（skin）</h2>
<p>通过指定配置（config）的皮肤（skin）添加不同的配色或是周期大小，可选的皮肤自已在<a href="https://github.com/wavedrom/wavedrom/tree/trunk/unpacked/skins">这里</a>查看，例如使用 narrow 可以减小周期长度，dark 为深色皮肤。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;clk&quot;</span><span class="punctuation">,</span>     wave<span class="punctuation">:</span> <span class="string">&quot;p....&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  config<span class="punctuation">:</span> <span class="punctuation">&#123;</span> skin<span class="punctuation">:</span> &#x27;narrow&#x27; <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>（<a href="https://wavedrom.com/editor.html?%7B%20signal%3A%20%5B%0A%20%20%7B%20name%3A%20%22clk%22%2C%20%20%20%20%20wave%3A%20%22p....%22%20%7D%2C%5D%2C%0A%20%20config%3A%20%7B%20skin%3A%20%27narrow%27%20%7D%0A%7D">在官方在线编辑器中打开</a>)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> name<span class="punctuation">:</span> <span class="string">&quot;clk&quot;</span><span class="punctuation">,</span>     wave<span class="punctuation">:</span> <span class="string">&quot;p....&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  config<span class="punctuation">:</span> <span class="punctuation">&#123;</span> skin<span class="punctuation">:</span> &#x27;dark&#x27; <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>（<a href="https://wavedrom.com/editor.html?%7B%20signal%3A%20%5B%0A%20%20%7B%20name%3A%20%22clk%22%2C%20%20%20%20%20wave%3A%20%22p....%22%20%7D%2C%5D%2C%0A%20%20config%3A%20%7B%20skin%3A%20%27dark%27%20%7D%0A%7D">在官方在线编辑器中打开</a>）</p>
<h2 id="项眉head-项脚foot适用于波形图">项眉（head）/ 项脚（foot）（适用于波形图）</h2>
<p>配置（<code>config</code>）的项眉（<code>head</code>）/ 项脚（<code>foot</code>）可以配置位于波形图上方和下方的文字（<code>text</code>）和坐标（<code>tick</code> 对齐周期起始位置，<code>tock</code> 在周期中居中，其值为起始值，<code>every</code> 指定显示周期）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span>name<span class="punctuation">:</span>&#x27;clk&#x27;<span class="punctuation">,</span>         wave<span class="punctuation">:</span> &#x27;p....&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span>name<span class="punctuation">:</span>&#x27;Data&#x27;<span class="punctuation">,</span>        wave<span class="punctuation">:</span> &#x27;x345x&#x27;<span class="punctuation">,</span> data<span class="punctuation">:</span> &#x27;a b c&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span>name<span class="punctuation">:</span>&#x27;Request&#x27;<span class="punctuation">,</span>     wave<span class="punctuation">:</span> &#x27;<span class="number">01.</span><span class="number">.0</span>&#x27; <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"> head<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">   text<span class="punctuation">:</span>&#x27;WaveDrom example&#x27;<span class="punctuation">,</span></span><br><span class="line">   tick<span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">   every<span class="punctuation">:</span><span class="number">2</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> foot<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">   text<span class="punctuation">:</span>&#x27;Figure <span class="number">100</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">   tock<span class="punctuation">:</span><span class="number">9</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{signal: [
  {name:'clk',         wave: 'p....' },
  {name:'Data',        wave: 'x345x', data: 'a b c' },
  {name:'Request',     wave: '01..0' }
],
 head:{
   text:'WaveDrom example',
   tick:0,
   every:2
 },
 foot:{
   text:'Figure 100',
   tock:9
 },
}</script>
<p>通过控制文本的<code>tspan</code>属性来指定文本的样式，有预定义的类：<code>h1</code>、<code>h2</code>、<code>h3</code>、<code>h4</code>、<code>h5</code>、<code>h6</code>（控制字体大小），<code>muted</code>、<code>warning</code>、<code>error</code>、<code>info</code>、<code>success</code>控制文本样式（颜色、斜体、粗细），其他<code>tspan</code>属性也可以直接使用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>signal<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span>name<span class="punctuation">:</span>&#x27;clk&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;p.....PPPPp....&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span>name<span class="punctuation">:</span>&#x27;dat&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;x...<span class="number">.2345</span>x.....&#x27;<span class="punctuation">,</span> data<span class="punctuation">:</span> &#x27;a b c d&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span>name<span class="punctuation">:</span>&#x27;req&#x27;<span class="punctuation">,</span> wave<span class="punctuation">:</span> &#x27;<span class="number">0.</span>..<span class="number">.1</span>..<span class="number">.0</span>.....&#x27; <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">head<span class="punctuation">:</span> <span class="punctuation">&#123;</span>text<span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>class<span class="punctuation">:</span>&#x27;error h1&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;error &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>class<span class="punctuation">:</span>&#x27;warning h2&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;warning &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>class<span class="punctuation">:</span>&#x27;info h3&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;info &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>class<span class="punctuation">:</span>&#x27;success h4&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;success &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>class<span class="punctuation">:</span>&#x27;muted h5&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;muted &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>class<span class="punctuation">:</span>&#x27;h6&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;h6 &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;default &#x27;<span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>fill<span class="punctuation">:</span>&#x27;pink&#x27;<span class="punctuation">,</span> &#x27;font-weight&#x27;<span class="punctuation">:</span>&#x27;bold&#x27;<span class="punctuation">,</span> &#x27;font-style&#x27;<span class="punctuation">:</span>&#x27;italic&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;pink-bold-italic&#x27;<span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">foot<span class="punctuation">:</span> <span class="punctuation">&#123;</span>text<span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> &#x27;E=mc&#x27;<span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>dy<span class="punctuation">:</span>&#x27;<span class="number">-5</span>&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;<span class="number">2</span>&#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>dy<span class="punctuation">:</span> &#x27;<span class="number">5</span>&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;. &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>&#x27;font-size&#x27;<span class="punctuation">:</span>&#x27;<span class="number">25</span>&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;B &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>&#x27;text-decoration&#x27;<span class="punctuation">:</span>&#x27;overline&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span>&#x27;over &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>&#x27;text-decoration&#x27;<span class="punctuation">:</span>&#x27;underline&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span>&#x27;under &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>&#x27;baseline-shift&#x27;<span class="punctuation">:</span>&#x27;sub&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;sub &#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">[</span>&#x27;tspan&#x27;<span class="punctuation">,</span> <span class="punctuation">&#123;</span>&#x27;baseline-shift&#x27;<span class="punctuation">:</span>&#x27;super&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span> &#x27;super &#x27;<span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span>tock<span class="punctuation">:</span><span class="number">-5</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<script type="WaveDrom">{signal: [
  {name:'clk', wave: 'p.....PPPPp....' },
  {name:'dat', wave: 'x....2345x.....', data: 'a b c d' },
  {name:'req', wave: '0....1...0.....' }
],
head: {text:
  ['tspan',
    ['tspan', {class:'error h1'}, 'error '],
    ['tspan', {class:'warning h2'}, 'warning '],
    ['tspan', {class:'info h3'}, 'info '],
    ['tspan', {class:'success h4'}, 'success '],
    ['tspan', {class:'muted h5'}, 'muted '],
    ['tspan', {class:'h6'}, 'h6 '],
    'default ',
    ['tspan', {fill:'pink', 'font-weight':'bold', 'font-style':'italic'}, 'pink-bold-italic']
  ]
},
foot: {text:
  ['tspan', 'E=mc',
    ['tspan', {dy:'-5'}, '2'],
    ['tspan', {dy: '5'}, '. '],
    ['tspan', {'font-size':'25'}, 'B '],
    ['tspan', {'text-decoration':'overline'},'over '],
    ['tspan', {'text-decoration':'underline'},'under '],
    ['tspan', {'baseline-shift':'sub'}, 'sub '],
    ['tspan', {'baseline-shift':'super'}, 'super ']
  ],tock:-5
}
}</script>
<p>转载 <a href="https://hadongzhu.com/archives/755">link</a></p>
]]></content>
      <categories>
        <category>Plot</category>
        <category>WaveDrom</category>
      </categories>
      <tags>
        <tag>WaveDrom</tag>
      </tags>
  </entry>
  <entry>
    <title>c plus plus summary</title>
    <url>/2022/11/28/c-plus-plus-summary/</url>
    <content><![CDATA[<h1 id="c基础入门">C++基础入门</h1>
<h2 id="c初识">C++初识</h2>
<h3 id="第一个c程序">第一个C++程序</h3>
<p>编写一个C++程序总共分为4个步骤</p>
<ul>
<li>创建项目</li>
<li>创建文件</li>
<li>编写代码</li>
<li>运行程序</li>
</ul>
<h4 id="创建项目">创建项目</h4>
<p>​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541383178746.webp"></p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541384366413.webp"></p>
<h4 id="创建文件">创建文件</h4>
<p>右键源文件，选择添加-&gt;新建项</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541383817248.webp"></p>
<p>给C++文件起个名称，然后点击添加即可。</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541384140042.webp"></p>
<h4 id="编写代码">编写代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行程序">运行程序</h4>
<p><img src="/2022/11/28/c-plus-plus-summary/1541384818688.webp"></p>
<h3 id="注释">注释</h3>
<p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p>
<p><strong>两种格式</strong></p>
<ol type="1">
<li><strong>单行注释</strong>：<code>// 描述信息</code>
<ul>
<li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li>
</ul></li>
<li><strong>多行注释</strong>： <code>/* 描述信息 */</code>
<ul>
<li>通常放在一段代码的上方，==对该段代码做整体说明==</li>
</ul></li>
</ol>
<blockquote>
<p>提示：编译器在编译代码时，会忽略注释的内容</p>
</blockquote>
<h3 id="变量">变量</h3>
<p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p>
<p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//变量的定义</span></span><br><span class="line">	<span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p>
</blockquote>
<h3 id="常量">常量</h3>
<p><strong>作用</strong>：用于记录程序中不可更改的数据</p>
<p>C++定义常量两种方式</p>
<ol type="1">
<li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code>
<ul>
<li>==通常在文件上方定义==，表示一个常量</li>
</ul></li>
<li><strong>const</strong>修饰的变量 <code>const 数据类型 常量名 = 常量值</code>
<ul>
<li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li>
</ul></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、const修饰变量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键字">关键字</h3>
<p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p>
<ul>
<li><strong>在定义变量或者常量时候，不要用关键字</strong></li>
</ul>
<p>C++关键字如下：</p>
<table>
<thead>
<tr class="header">
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr class="even">
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr class="odd">
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr class="even">
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr class="odd">
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr class="even">
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr class="odd">
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr class="even">
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr class="odd">
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr class="even">
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr class="odd">
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr class="even">
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</code></p>
<h3 id="标识符命名规则">标识符命名规则</h3>
<p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p>
<ul>
<li>标识符不能是关键字</li>
<li>标识符只能由字母、数字、下划线组成</li>
<li>第一个字符必须为字母或下划线</li>
<li>标识符中字母区分大小写</li>
</ul>
<blockquote>
<p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p>
</blockquote>
<h2 id="数据类型">数据类型</h2>
<p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p>
<h3 id="整型">整型</h3>
<p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p>
<p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p>
<table>
<thead>
<tr class="header">
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>short(短整型)</td>
<td>2字节</td>
<td>(-2^15 ~ 2^15-1)</td>
</tr>
<tr class="even">
<td>int(整型)</td>
<td>4字节</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr class="odd">
<td>long(长整形)</td>
<td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td>
<td>(-2^31 ~ 2^31-1)</td>
</tr>
<tr class="even">
<td>long long(长长整形)</td>
<td>8字节</td>
<td>(-2^63 ~ 2^63-1)</td>
</tr>
</tbody>
</table>
<h3 id="sizeof关键字">sizeof关键字</h3>
<p><strong>作用：</strong>利用sizeof关键字可以==统计数据类型所占内存大小==</p>
<p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= long long==</p>
</blockquote>
<h3 id="实型浮点型">实型（浮点型）</h3>
<p><strong>作用</strong>：用于==表示小数==</p>
<p>浮点型变量分为两种：</p>
<ol type="1">
<li>单精度float</li>
<li>双精度double</li>
</ol>
<p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p>
<table>
<thead>
<tr class="header">
<th><strong>数据类型</strong></th>
<th><strong>占用空间</strong></th>
<th><strong>有效数字范围</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>float</td>
<td>4字节</td>
<td>7位有效数字</td>
</tr>
<tr class="even">
<td>double</td>
<td>8字节</td>
<td>15～16位有效数字</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//科学计数法</span></span><br><span class="line">	<span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符型">字符型</h3>
<p><strong>作用：</strong>字符型变量用于显示单个字符</p>
<p><strong>语法：</strong><code>char ch = 'a';</code></p>
<blockquote>
<p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p>
</blockquote>
<blockquote>
<p>注意2：单引号内只能有一个字符，不可以是字符串</p>
</blockquote>
<ul>
<li>C和C++中字符型变量只占用==1个字节==。</li>
<li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line">	<span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">	ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASCII码表格：</p>
<table>
<thead>
<tr class="header">
<th><strong>ASCII</strong>值</th>
<th><strong>控制字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
<th><strong>ASCII</strong>值</th>
<th><strong>字符</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr class="even">
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr class="odd">
<td>2</td>
<td>STX</td>
<td>34</td>
<td>"</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr class="even">
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr class="odd">
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr class="even">
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr class="odd">
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr class="even">
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr class="odd">
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr class="even">
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr class="odd">
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr class="even">
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr class="odd">
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr class="even">
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr class="odd">
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr class="even">
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr class="odd">
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr class="even">
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr class="odd">
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr class="even">
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr class="odd">
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr class="even">
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr class="odd">
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr class="even">
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr class="odd">
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr class="even">
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr class="odd">
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr class="even">
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr class="odd">
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr class="even">
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr class="odd">
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr class="even">
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
<p>ASCII 码大致由以下<strong>两部分组</strong>成：</p>
<ul>
<li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li>
<li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li>
</ul>
<h3 id="转义字符">转义字符</h3>
<p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p>
<p>现阶段我们常用的转义字符有：<code>\n  \\  \t</code></p>
<table>
<thead>
<tr class="header">
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>\a</code></td>
<td>警报</td>
<td>007</td>
</tr>
<tr class="even">
<td><code>\b</code></td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr class="odd">
<td><code>\f</code></td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr class="even">
<td><code>\n</code></td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr class="odd">
<td><code>\r</code></td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr class="even">
<td><code>\t</code></td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr class="odd">
<td><code>\v</code></td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr class="even">
<td><code>\\</code></td>
<td>代表一个反斜线字符<code>"\"</code></td>
<td>092</td>
</tr>
<tr class="odd">
<td><code>\'</code></td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr class="even">
<td><code>\"</code></td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr class="odd">
<td><code>\?</code></td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr class="even">
<td><code>\0</code></td>
<td>数字0</td>
<td>000</td>
</tr>
<tr class="odd">
<td><code>\ddd</code></td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr class="even">
<td><code>\xhh</code></td>
<td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串型">字符串型</h3>
<p><strong>作用</strong>：用于表示一串字符</p>
<p><strong>两种风格</strong></p>
<ol type="1">
<li><p><strong>C风格字符串</strong>： <code>char 变量名[] = "字符串值"</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C风格的字符串要用双引号括起来</p>
</blockquote>
<ol type="1">
<li><p><strong>C++风格字符串</strong>： <code>string  变量名 = "字符串值"</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==</p>
</blockquote>
<h3 id="布尔类型-bool">布尔类型 bool</h3>
<p><strong>作用：</strong>布尔数据类型代表真或假的值</p>
<p>bool类型只有两个值：</p>
<ul>
<li>true --- 真（本质是1）</li>
<li>false --- 假（本质是0）</li>
</ul>
<p><strong>bool类型占==1个字节==大小</strong></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据的输入">数据的输入</h3>
<p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型输入</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//浮点型输入</span></span><br><span class="line">	<span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; d;</span><br><span class="line">	cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符型输入</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串型输入</span></span><br><span class="line">	string str;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//布尔类型输入</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; flag;</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符">运算符</h2>
<p><strong>作用：</strong>用于执行代码的运算</p>
<p>本章我们主要讲解以下几类运算符：</p>
<table>
<thead>
<tr class="header">
<th><strong>运算符类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算术运算符</td>
<td>用于处理四则运算</td>
</tr>
<tr class="even">
<td>赋值运算符</td>
<td>用于将表达式的值赋给变量</td>
</tr>
<tr class="odd">
<td>比较运算符</td>
<td>用于表达式的比较，并返回一个真值或假值</td>
</tr>
<tr class="even">
<td>逻辑运算符</td>
<td>用于根据表达式的值返回真值或假值</td>
</tr>
</tbody>
</table>
<h3 id="算术运算符">算术运算符</h3>
<p><strong>作用</strong>：用于处理四则运算</p>
<p>算术运算符包括以下符号：</p>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>正号</td>
<td>+3</td>
<td>3</td>
</tr>
<tr class="even">
<td>-</td>
<td>负号</td>
<td>-3</td>
<td>-3</td>
</tr>
<tr class="odd">
<td>+</td>
<td>加</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr class="even">
<td>-</td>
<td>减</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr class="odd">
<td>*</td>
<td>乘</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr class="even">
<td>/</td>
<td>除</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr class="odd">
<td>%</td>
<td>取模(取余)</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr class="even">
<td>++</td>
<td>前置递增</td>
<td>a=2; b=++a;</td>
<td>a=3; b=3;</td>
</tr>
<tr class="odd">
<td>++</td>
<td>后置递增</td>
<td>a=2; b=a++;</td>
<td>a=3; b=2;</td>
</tr>
<tr class="even">
<td>--</td>
<td>前置递减</td>
<td>a=2; b=--a;</td>
<td>a=1; b=1;</td>
</tr>
<tr class="odd">
<td>--</td>
<td>后置递减</td>
<td>a=2; b=a--;</td>
<td>a=1; b=2;</td>
</tr>
</tbody>
</table>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数可以相除</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">	cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在除法运算中，除数不能为0</p>
</blockquote>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//两个小数不可以取模</span></span><br><span class="line">	<span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：只有整型变量可以进行取模运算</p>
</blockquote>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置递增</span></span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	++b;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//区别</span></span><br><span class="line">	<span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line">	<span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line">	<span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p>
</blockquote>
<h3 id="赋值运算符">赋值运算符</h3>
<p><strong>作用：</strong>用于将表达式的值赋给变量</p>
<p>赋值运算符包括以下几个符号：</p>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=</td>
<td>赋值</td>
<td>a=2; b=3;</td>
<td>a=2; b=3;</td>
</tr>
<tr class="even">
<td>+=</td>
<td>加等于</td>
<td>a=0; a+=2;</td>
<td>a=2;</td>
</tr>
<tr class="odd">
<td>-=</td>
<td>减等于</td>
<td>a=5; a-=3;</td>
<td>a=2;</td>
</tr>
<tr class="even">
<td>*=</td>
<td>乘等于</td>
<td>a=2; a*=2;</td>
<td>a=4;</td>
</tr>
<tr class="odd">
<td>/=</td>
<td>除等于</td>
<td>a=4; a/=2;</td>
<td>a=2;</td>
</tr>
<tr class="even">
<td>%=</td>
<td>模等于</td>
<td>a=3; a%2;</td>
<td>a=1;</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// =</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// +=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// /=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// %=</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较运算符">比较运算符</h3>
<p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p>
<p>比较运算符有以下符号：</p>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>==</td>
<td>相等于</td>
<td>4 == 3</td>
<td>0</td>
</tr>
<tr class="even">
<td>!=</td>
<td>不等于</td>
<td>4 != 3</td>
<td>1</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td>小于</td>
<td>4 &lt; 3</td>
<td>0</td>
</tr>
<tr class="even">
<td>&gt;</td>
<td>大于</td>
<td>4 &gt; 3</td>
<td>1</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>小于等于</td>
<td>4 &lt;= 3</td>
<td>0</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>大于等于</td>
<td>4 &gt;= 1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。==</p>
</blockquote>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p>
<p>逻辑运算符有以下符号：</p>
<table>
<thead>
<tr class="header">
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真； 如果a为真，则!a为假。</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td>与</td>
<td>a &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr class="odd">
<td>||</td>
<td>或</td>
<td>a || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
<p><strong>示例1：</strong>逻辑非</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 真变假，假变真</p>
</blockquote>
<p><strong>示例2：</strong>逻辑与</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p>
</blockquote>
<p><strong>示例3：</strong>逻辑或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">0</span>;</span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑==或==运算符总结： ==同假为假，其余为真==</p>
</blockquote>
<h2 id="程序流程结构">程序流程结构</h2>
<p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p>
<ul>
<li>顺序结构：程序按顺序执行，不发生跳转</li>
<li>选择结构：依据条件是否满足，有选择的执行相应功能</li>
<li>循环结构：依据条件是否满足，循环多次执行某段代码</li>
</ul>
<h3 id="选择结构">选择结构</h3>
<h4 id="if语句">if语句</h4>
<p><strong>作用：</strong>执行满足条件的语句</p>
<p>if语句的三种形式</p>
<ul>
<li><p>单行格式if语句</p></li>
<li><p>多行格式if语句</p></li>
<li><p>多条件的if语句</p></li>
</ul>
<ol type="1">
<li><p>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002.webp"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择结构-单行if语句</span></span><br><span class="line">	<span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//if语句</span></span><br><span class="line">	<span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>注意：if条件表达式后不要加分号</p>
</blockquote>
<ol start="2" type="1">
<li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li>
</ol>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1541662519170.webp"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li>
</ol>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1541662566808.webp"></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p>
<p>案例需求：</p>
<ul>
<li>提示用户输入一个高考考试分数，根据分数做如下判断</li>
<li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li>
<li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例：</strong> 三只小猪称体重</p>
<p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<img src="/2022/11/28/c-plus-plus-summary/三只小猪.webp"></p>
<h4 id="三目运算符">三目运算符</h4>
<p><strong>作用：</strong> 通过三目运算符实现简单的判断</p>
<p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p>
<p><strong>解释：</strong></p>
<p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p>
<p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = a &gt; b ? a : b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p>
</blockquote>
<h4 id="switch语句">switch语句</h4>
<p><strong>作用：</strong>执行多条件分支语句</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//请给电影评分 </span></span><br><span class="line">	<span class="comment">//10 ~ 9   经典   </span></span><br><span class="line">	<span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line">	<span class="comment">// 6 ~ 5   一般</span></span><br><span class="line">	<span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (score)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意1：switch语句中表达式类型只能是整型或者字符型</p>
</blockquote>
<blockquote>
<p>注意2：case里如果没有break，那么程序会一直向下执行</p>
</blockquote>
<blockquote>
<p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p>
</blockquote>
<h3 id="循环结构">循环结构</h3>
<h4 id="while循环语句">while循环语句</h4>
<p><strong>作用：</strong>满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code>while(循环条件)&#123; 循环语句 &#125;</code></p>
<p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1541668640382.webp"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p>
</blockquote>
<p><strong>while循环练习案例：</strong>==猜数字==</p>
<p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p>
<p><img src="/2022/11/28/c-plus-plus-summary/猜数字.webp"></p>
<h4 id="do...while循环语句">do...while循环语句</h4>
<p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p>
<p><strong>注意：</strong>与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1541671163478.webp"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件</p>
</blockquote>
<p><strong>练习案例：水仙花数</strong></p>
<p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p>
<p>例如：1^3 + 5^3+ 3^3 = 153</p>
<p>请利用do...while语句，求出所有3位数中的水仙花数</p>
<h4 id="for循环语句">for循环语句</h4>
<p><strong>作用：</strong> 满足循环条件，执行循环语句</p>
<p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541673704101.webp"></p>
<blockquote>
<p>注意：for循环中的表达式，要用分号进行分隔</p>
</blockquote>
<blockquote>
<p>总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p>
</blockquote>
<p><strong>练习案例：敲桌子</strong></p>
<p>案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p>
<p><img src="/2022/11/28/c-plus-plus-summary/timg.gif"></p>
<h4 id="嵌套循环">嵌套循环</h4>
<p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p>
<p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541676003486.webp"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例：</strong>乘法口诀表</p>
<p>案例描述：利用嵌套循环，实现九九乘法表</p>
<p><img src="/2022/11/28/c-plus-plus-summary/0006018857256120_b.webp"></p>
<h3 id="跳转语句">跳转语句</h3>
<h4 id="break语句">break语句</h4>
<p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p>
<p>break使用的时机：</p>
<ul>
<li>出现在switch条件语句中，作用是终止case并跳出switch</li>
<li>出现在循环语句中，作用是跳出当前的循环语句</li>
<li>出现在嵌套循环中，跳出最近的内层循环语句</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (num)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//2、在循环语句中用break</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="continue语句">continue语句</h4>
<p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：continue并没有使整个循环终止，而break会跳出循环</p>
</blockquote>
<h4 id="goto语句">goto语句</h4>
<p><strong>作用：</strong>可以无条件跳转语句</p>
<p><strong>语法：</strong> <code>goto 标记;</code></p>
<p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	FLAG:</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p>
</blockquote>
<h2 id="数组">数组</h2>
<h3 id="概述">概述</h3>
<p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p>
<p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p>
<p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541748375356.webp"></p>
<h3 id="一维数组">一维数组</h3>
<h4 id="一维数组定义方式">一维数组定义方式</h4>
<p>一维数组定义的三种方式：</p>
<ol type="1">
<li><code>数据类型  数组名[ 数组长度 ];</code></li>
<li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li>
<li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式1</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line">	<span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标赋值</span></span><br><span class="line">	score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">	score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用下标输出</span></span><br><span class="line">	cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种定义方式</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line">	<span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//逐个输出</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line">	<span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p>
</blockquote>
<blockquote>
<p>总结2：数组中下标是从0开始索引</p>
</blockquote>
<h4 id="一维数组数组名">一维数组数组名</h4>
<p>一维数组名称的<strong>用途</strong>：</p>
<ol type="1">
<li>可以统计整个数组在内存中的长度</li>
<li>可以获取数组在内存中的首地址</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组名用途</span></span><br><span class="line">	<span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：数组名是常量，不可以赋值</p>
</blockquote>
<blockquote>
<p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p>
</blockquote>
<p><strong>练习案例1</strong>：五只小猪称体重</p>
<p><strong>案例描述：</strong></p>
<p>在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};</p>
<p>找出并打印最重的小猪体重。</p>
<p><strong>练习案例2：</strong>数组元素逆置</p>
<p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p>
<p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p>
<h4 id="冒泡排序">冒泡排序</h4>
<p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p>
<ol type="1">
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li>
<li>重复以上的步骤，每次比较次数-1，直到不需要比较</li>
</ol>
<p><img src="/2022/11/28/c-plus-plus-summary/1541905327273.webp"></p>
<p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组">二维数组</h3>
<p>二维数组就是在一维数组上，多加一个维度。</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1541905559138.webp"></p>
<h4 id="二维数组定义方式">二维数组定义方式</h4>
<p>二维数组定义的四种方式：</p>
<ol type="1">
<li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li>
<li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
<li><code>数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li>
</ol>
<blockquote>
<p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式1  </span></span><br><span class="line">	<span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">	arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式2 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式3</span></span><br><span class="line">	<span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//方式4 </span></span><br><span class="line">	<span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line">	<span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p>
</blockquote>
<h4 id="二维数组数组名">二维数组数组名</h4>
<ul>
<li>查看二维数组所占内存空间</li>
<li>获取二维数组首地址</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二维数组数组名</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：二维数组名就是这个数组的首地址</p>
</blockquote>
<blockquote>
<p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p>
</blockquote>
<h4 id="二维数组应用案例"><strong>5.3.3 二维数组应用案例</strong></h4>
<p><strong>考试成绩统计：</strong></p>
<p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p>
<table>
<thead>
<tr class="header">
<th></th>
<th>语文</th>
<th>数学</th>
<th>英语</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>张三</td>
<td>100</td>
<td>100</td>
<td>100</td>
</tr>
<tr class="even">
<td>李四</td>
<td>90</td>
<td>50</td>
<td>100</td>
</tr>
<tr class="odd">
<td>王五</td>
<td>60</td>
<td>70</td>
<td>80</td>
</tr>
</tbody>
</table>
<p><strong>参考答案：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">		&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += scores[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<h3 id="概述-1">概述</h3>
<p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p>
<p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p>
<h3 id="函数的定义">函数的定义</h3>
<p>函数的定义一般主要有5个步骤：</p>
<p>1、返回值类型</p>
<p>2、函数名</p>
<p>3、参数表列</p>
<p>4、函数体语句</p>
<p>5、return 表达式</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li>
<li>函数名：给函数起个名称</li>
<li>参数列表：使用该函数时，传入的数据</li>
<li>函数体语句：花括号内的代码，函数内需要执行的语句</li>
<li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li>
</ul>
<p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的调用">函数的调用</h3>
<p><strong>功能：</strong>使用定义好的函数</p>
<p><strong>语法：</strong><code>函数名（参数）</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = num1 + num2;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//调用add函数</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p>
</blockquote>
<h3 id="值传递">值传递</h3>
<ul>
<li>所谓值传递，就是函数调用时实参将数值传入给形参</li>
<li>值传递时，==如果形参发生，并不会影响实参==</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 值传递时，形参是修饰不了实参的</p>
</blockquote>
<h3 id="函数的常见样式"><strong>6.5 函数的常见样式</strong></h3>
<p>常见的函数样式有4种</p>
<ol type="1">
<li>无参无返</li>
<li>有参无返</li>
<li>无参有返</li>
<li>有参有返</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的声明">函数的声明</h3>
<p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<ul>
<li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的分文件编写">函数的分文件编写</h3>
<p><strong>作用：</strong>让代码结构更加清晰</p>
<p>函数分文件编写一般有4个步骤</p>
<ol type="1">
<li>创建后缀名为.h的头文件<br>
</li>
<li>创建后缀名为.cpp的源文件</li>
<li>在头文件中写函数的声明</li>
<li>在源文件中写函数的定义</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指针">指针</h2>
<h3 id="指针的基本概念">指针的基本概念</h3>
<p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p></li>
<li><p>可以利用指针变量保存地址</p></li>
</ul>
<h3 id="指针变量的定义和使用">指针变量的定义和使用</h3>
<p>指针变量定义语法： <code>数据类型 * 变量名；</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、指针的定义</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量赋值</span></span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">	cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、指针的使用</span></span><br><span class="line">	<span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针变量和普通变量的区别</p>
<ul>
<li>普通变量存放的是数据,指针变量存放的是地址</li>
<li>指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用</li>
</ul>
<blockquote>
<p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p>
</blockquote>
<blockquote>
<p>总结2：利用指针可以记录地址</p>
</blockquote>
<blockquote>
<p>总结3：对指针变量解引用，可以操作指针指向的内存</p>
</blockquote>
<h3 id="指针所占内存空间">指针所占内存空间</h3>
<p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p;</span><br><span class="line">	p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：所有指针类型在32位操作系统下是4个字节</p>
</blockquote>
<h3 id="空指针和野指针">空指针和野指针</h3>
<p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p>
<p><strong>用途：</strong>初始化指针变量</p>
<p><strong>注意：</strong>空指针指向的内存是不可以访问的</p>
<p><strong>示例1：空指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">	<span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问空指针报错 </span></span><br><span class="line">	<span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>野指针</strong>：指针变量指向非法的内存空间</p>
<p><strong>示例2：野指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line">	<span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问野指针报错 </span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p>
</blockquote>
<h3 id="const修饰指针">const修饰指针</h3>
<p>const修饰指针有三种情况</p>
<ol type="1">
<li>const修饰指针 --- 常量指针</li>
<li>const修饰常量 --- 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h3 id="指针和数组">指针和数组</h3>
<p><strong>作用：</strong>利用指针访问数组中元素</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//利用指针遍历数组</span></span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针和函数">指针和函数</h3>
<p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b; </span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p>
</blockquote>
<h3 id="指针数组函数">指针、数组、函数</h3>
<p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p>
<p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p>
</blockquote>
<h2 id="结构体">结构体</h2>
<h3 id="结构体基本概念">结构体基本概念</h3>
<p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p>
<h3 id="结构体定义和使用">结构体定义和使用</h3>
<p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li>struct 结构体名 变量名</li>
<li>struct 结构体名 变量名 = { 成员1值 ， 成员2值...}</li>
<li>定义结构体时顺便创建变量</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式1</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">	stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	stu1.age = <span class="number">18</span>;</span><br><span class="line">	stu1.score = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//结构体变量创建方式2</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">	stu3.age = <span class="number">18</span>;</span><br><span class="line">	stu3.score = <span class="number">80</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：定义结构体时的关键字是struct，不可省略</p>
</blockquote>
<blockquote>
<p>总结2：创建结构体变量时，关键字struct可以省略</p>
</blockquote>
<blockquote>
<p>总结3：结构体变量利用操作符 ''.'' 访问成员</p>
</blockquote>
<h3 id="结构体数组">结构体数组</h3>
<p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p>
<p><strong>语法：</strong><code>struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">		&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体指针">结构体指针</h3>
<p><strong>作用：</strong>通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line">	</span><br><span class="line">	p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p>
</blockquote>
<h3 id="结构体嵌套结构体">结构体嵌套结构体</h3>
<p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p>
<p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">	string name;  <span class="comment">//教师姓名</span></span><br><span class="line">	<span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">	t1.id = <span class="number">10000</span>;</span><br><span class="line">	t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">	t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	t1.stu.age = <span class="number">18</span>;</span><br><span class="line">	t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p>
<h3 id="结构体做函数参数">结构体做函数参数</h3>
<p><strong>作用：</strong>将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li>值传递</li>
<li>地址传递</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu.age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">printStudent</span>(stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p>
</blockquote>
<h3 id="结构体中-const使用场景">结构体中 const使用场景</h3>
<p><strong>作用：</strong>用const来防止误操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//成员列表</span></span><br><span class="line">	string name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体案例">结构体案例</h3>
<h4 id="案例1">案例1</h4>
<p><strong>案例描述：</strong></p>
<p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p>
<p>最终打印出老师数据以及老师所带的学生数据。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">	string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tArray[i].name = tName + nameSeed[i];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">			tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">	Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="案例2">案例2</h4>
<p><strong>案例描述：</strong></p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<p>五名英雄信息如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">			&#123;</span><br><span class="line">				hero temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">	&#123;</span><br><span class="line">		&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c核心编程">C++核心编程</h1>
<p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="内存分区模型">内存分区模型</h2>
<p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="程序运行前">程序运行前</h3>
<p>​ 在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>​ <strong>代码区：</strong></p>
<p>​ 存放 CPU 执行的机器指令</p>
<p>​ 代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​ 代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>​ <strong>全局区：</strong></p>
<p>​ 全局变量和静态变量存放在此.</p>
<p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​ ==该区域的数据在程序结束后由操作系统释放==.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1545017602518.webp"></p>
<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量 和 字符串常量</li>
</ul>
<h3 id="程序运行后">程序运行后</h3>
<p>​ <strong>栈区：</strong></p>
<p>​ 由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ <strong>堆区：</strong></p>
<p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​ 在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="new操作符">new操作符</h3>
<p>​ C++中利用==new==操作符在堆区开辟数据</p>
<p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>
<p>​ 语法：<code>new 数据类型</code></p>
<p>​ 利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="引用">引用</h2>
<h3 id="引用的基本使用">引用的基本使用</h3>
<p><strong>作用： </strong>给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用注意事项">引用注意事项</h3>
<ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用做函数参数">引用做函数参数</h3>
<p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="引用做函数返回值">引用做函数返回值</h3>
<p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<h3 id="引用的本质">引用的本质</h3>
<p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="常量引用">常量引用</h3>
<p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数提高">函数提高</h2>
<h3 id="函数默认参数">函数默认参数</h3>
<p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code>返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数占位参数">函数占位参数</h3>
<p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载">函数重载</h3>
<h4 id="函数重载概述">函数重载概述</h4>
<p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong> 函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数重载注意事项">函数重载注意事项</h4>
<ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类和对象"><strong>4</strong> 类和对象</h2>
<p>C++面向对象的三大特性为：==封装、继承、多态==</p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​ 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...</p>
<p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...</p>
<p>​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>
<h3 id="封装">封装</h3>
<h4 id="封装的意义">封装的意义</h4>
<p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​ 在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol type="1">
<li>public 公共权限<br>
</li>
<li>protected 保护权限</li>
<li>private 私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="struct和class区别">struct和class区别</h4>
<p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员属性设置为私有">成员属性设置为私有</h4>
<p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习案例1：设计立方体类</strong></p>
<p>设计立方体类(Cube)</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等。</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1545533548532.webp"></p>
<p><strong>练习案例2：点和圆的关系</strong></p>
<p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1545533829184.webp"></p>
<h3 id="对象的初始化和清理">对象的初始化和清理</h3>
<ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="构造函数和析构函数">构造函数和析构函数</h4>
<p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol type="1">
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol type="1">
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号 ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的分类及调用">构造函数的分类及调用</h4>
<p>两种分类方式：</p>
<p>​ 按参数分为： 有参构造和无参构造</p>
<p>​ 按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​ 括号法</p>
<p>​ 显示法</p>
<p>​ 隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝构造函数调用时机">拷贝构造函数调用时机</h4>
<p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数调用规则">构造函数调用规则</h4>
<p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li>
<li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h4>
<p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="初始化列表">初始化列表</h4>
<p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类对象作为类成员">类对象作为类成员</h4>
<p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态成员">静态成员</h4>
<p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul></li>
<li>静态成员函数
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul></li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c对象模型和this指针">C++对象模型和this指针</h3>
<h4 id="成员变量和成员函数分开存储">成员变量和成员函数分开存储</h4>
<p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="this指针概念">this指针概念</h4>
<p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//返回对象本身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空指针访问成员函数">空指针访问成员函数</h4>
<p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const修饰成员函数">const修饰成员函数</h4>
<p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元">友元</h3>
<p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为 ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="全局函数做友元">全局函数做友元</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类做友元">类做友元</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员函数做友元">成员函数做友元</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载">运算符重载</h3>
<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="加号运算符重载">加号运算符重载</h4>
<p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数方式</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="左移运算符重载">左移运算符重载</h4>
<p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="递增运算符重载">递增运算符重载</h4>
<p>作用： 通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">		m_Num = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置++</span></span><br><span class="line">	MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="comment">//先++</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="comment">//再返回</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后置++</span></span><br><span class="line">	MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">//先返回</span></span><br><span class="line">		MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">		m_Num++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">	out &lt;&lt; myint.m_Num;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyInteger myInt;</span><br><span class="line">	cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="赋值运算符重载">赋值运算符重载</h4>
<p>c++编译器至少给一个类添加4个函数</p>
<ol type="1">
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>赋值运算符 operator=, 对属性进行值拷贝</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载赋值运算符 </span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">		<span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">		m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回自身</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Age;</span><br><span class="line">			m_Age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄的指针</span></span><br><span class="line">	<span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int a = 10;</span></span><br><span class="line">	<span class="comment">//int b = 20;</span></span><br><span class="line">	<span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//c = b = a;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关系运算符重载">关系运算符重载</h4>
<p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int a = 0;</span></span><br><span class="line">	<span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a != b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数调用运算符重载">函数调用运算符重载</h4>
<ul>
<li>函数调用运算符 () 也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">	MyPrint myFunc;</span><br><span class="line">	<span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd add;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//匿名对象调用  </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<p><strong>继承是面向对象三大特性之一</strong></p>
<p>有些类与类之间存在特殊的关系，例如下图中：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1544861202252.webp"></p>
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="继承的基本语法">继承的基本语法</h4>
<p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B;</p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="继承方式">继承方式</h4>
<p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-166964376975239.webp"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="继承中的对象模型">继承中的对象模型</h4>
<p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用工具查看：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1545881904150.webp"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名</p>
<p>效果如下图：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1545882158050.webp"></p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="继承中构造和析构顺序">继承中构造和析构顺序</h4>
<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="继承同名成员处理方式">继承同名成员处理方式</h4>
<p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol type="1">
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="继承同名静态成员处理方式">继承同名静态成员处理方式</h4>
<p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员 直接访问即可</li>
<li>访问父类同名成员 需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="多继承语法">多继承语法</h4>
<p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="菱形继承">菱形继承</h4>
<p><strong>菱形继承概念：</strong></p>
<p>​ 两个派生类继承同一个基类</p>
<p>​ 又有某个类同时继承者两个派生类</p>
<p>​ 这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002.webp"></p>
<p><strong>菱形继承问题：</strong></p>
<ol type="1">
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li>
<li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h3 id="多态">多态</h3>
<h4 id="多态的基本概念">多态的基本概念</h4>
<p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p>
<h4 id="多态案例一-计算器类">多态案例一-计算器类</h4>
<p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="纯虚函数和抽象类">纯虚函数和抽象类</h4>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;</span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态案例二-制作饮品">多态案例二-制作饮品</h4>
<p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1545985945198.webp"></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚析构和纯虚析构">虚析构和纯虚析构</h4>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code>virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p>
<p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p>
<h4 id="多态案例三-电脑组装">多态案例三-电脑组装</h4>
<p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第二台电脑组装</span></span><br><span class="line">	Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//第三台电脑组装</span></span><br><span class="line">	Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">	computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件操作">文件操作</h2>
<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>
<p>文件类型分为两种：</p>
<ol type="1">
<li><strong>文本文件</strong> - 文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三大类:</p>
<ol type="1">
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="文本文件">文本文件</h3>
<h4 id="写文件">写文件</h4>
<p>写文件步骤如下：</p>
<ol type="1">
<li><p>包含头文件</p>
<p>#include &lt;fstream&gt;</p></li>
<li><p>创建流对象</p>
<p>ofstream ofs;</p></li>
<li><p>打开文件</p>
<p>ofs.open("文件路径",打开方式);</p></li>
<li><p>写数据</p>
<p>ofs &lt;&lt; "写入的数据";</p></li>
<li><p>关闭文件</p>
<p>ofs.close();</p></li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr class="header">
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr class="even">
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr class="odd">
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr class="even">
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr class="odd">
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr class="even">
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="读文件">读文件</h4>
<p>读文件与写文件步骤相似，但是读取方式相对于比较多</p>
<p>读文件步骤如下：</p>
<ol type="1">
<li><p>包含头文件</p>
<p>#include &lt;fstream&gt;</p></li>
<li><p>创建流对象</p>
<p>ifstream ifs;</p></li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open("文件路径",打开方式);</p></li>
<li><p>读数据</p>
<p>四种方式读取</p></li>
<li><p>关闭文件</p>
<p>ifs.close();</p></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种</span></span><br><span class="line">	<span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line">	<span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种</span></span><br><span class="line">	<span class="comment">//string buf;</span></span><br><span class="line">	<span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h3 id="二进制文件">二进制文件</h3>
<p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ==ios::binary==</p>
<h4 id="写文件-1">写文件</h4>
<p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、创建输出流对象</span></span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3、打开文件</span></span><br><span class="line">	<span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、写文件</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、关闭文件</span></span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h4 id="读文件-1">读文件</h4>
<p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文件输入流对象 可以通过read函数，以二进制方式读数据</li>
</ul>
<h1 id="c提高编程">C++提高编程</h1>
<ul>
<li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="模板">模板</h2>
<h3 id="模板的概念">模板的概念</h3>
<p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1547105026929.webp"></p>
<p>PPT模板：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1547103297864.webp"></p>
<p><img src="/2022/11/28/c-plus-plus-summary/1547103359158.webp"></p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="函数模板">函数模板</h3>
<ul>
<li><p>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</p></li>
<li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p></li>
</ul>
<h4 id="函数模板语法">函数模板语法</h4>
<p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>template --- 声明创建模板</p>
<p>typename --- 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T --- 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用模板实现交换</span></span><br><span class="line">	<span class="comment">//1、自动类型推导</span></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、显示指定类型</span></span><br><span class="line">	<span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="函数模板注意事项">函数模板注意事项</h4>
<p>注意事项：</p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p></li>
<li><p>模板必须要确定出T的数据类型，才可以使用</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">	<span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">	<span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="函数模板案例">函数模板案例</h4>
<p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				max = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试char数组</span></span><br><span class="line">	<span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//测试int数组</span></span><br><span class="line">	<span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">	<span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="普通函数与函数模板的区别">普通函数与函数模板的区别</h4>
<p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="普通函数与函数模板的调用规则">普通函数与函数模板的调用规则</h4>
<p>调用规则如下：</p>
<ol type="1">
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">	<span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">	myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">	<span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="模板的局限性">模板的局限性</h4>
<p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   	<span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">	<span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="类模板">类模板</h3>
<h4 id="类模板语法">类模板语法</h4>
<p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>template --- 声明创建模板</p>
<p>typename --- 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T --- 通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">	P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="类模板与函数模板区别">类模板与函数模板区别</h4>
<p>类模板与函数模板区别主要有两点：</p>
<ol type="1">
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="类模板中成员函数创建时机">类模板中成员函数创建时机</h4>
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T obj;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyClass&lt;Person1&gt; m;</span><br><span class="line">	</span><br><span class="line">	m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="类模板对象做函数参数">类模板对象做函数参数</h4>
<p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol type="1">
<li>指定传入的类型 --- 直接显示对象的数据类型</li>
<li>参数模板化 --- 将对象中的参数变为模板进行传递</li>
<li>整个类模板化 --- 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="类模板与继承">类模板与继承</h4>
<p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="类模板成员函数类外实现">类模板成员函数类外实现</h4>
<p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数类内声明</span></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="类模板分文件编写">类模板分文件编写</h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="类模板与友元">类模板与友元</h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="类模板案例">类模板案例</h4>
<p>案例描述: 实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line">			<span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">	MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾插法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组容量</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="function"><span class="type">int</span>	<span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">MyArray</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line">			<span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line">	<span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line">	<span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类模板案例—数组类封装.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">	array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(array2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line">		<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建数组</span></span><br><span class="line">	<span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入数据</span></span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">	pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="stl初识">STL初识</h2>
<h3 id="stl的诞生">STL的诞生</h3>
<ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li>
</ul>
<h3 id="stl基本概念">STL基本概念</h3>
<ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="stl六大组件">STL六大组件</h3>
<p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol type="1">
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="stl中容器算法迭代器">STL中容器、算法、迭代器</h3>
<p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​ <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>
​ <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr class="header">
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr class="even">
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr class="odd">
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr class="even">
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、--，</td>
</tr>
<tr class="odd">
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody>
</table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="容器算法迭代器初识">容器算法迭代器初识</h3>
<p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="vector存放内置数据类型">vector存放内置数据类型</h4>
<p>容器： <code>vector</code></p>
<p>算法： <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中放数据</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">	<span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">	<span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">	<span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种遍历方式：</span></span><br><span class="line">	<span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">		cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">		pBegin++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种遍历方式：</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种遍历方式：</span></span><br><span class="line">	<span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vector存放自定义数据类型">Vector存放自定义数据类型</h4>
<p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		mName = name;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		Person * p = (*it);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vector容器嵌套容器">Vector容器嵌套容器</h4>
<p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">		v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stl--常用容器">STL- 常用容器</h2>
<h3 id="string容器">string容器</h3>
<h4 id="string基本概念">string基本概念</h4>
<p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="string构造函数">string构造函数</h4>
<p>构造函数原型：</p>
<ul>
<li><code>string();</code> //创建一个空的字符串 例如: string str;<br>
<code>string(const char* s);</code> //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code> //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code> //使用n个字符c初始化</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="string赋值操作">string赋值操作</h4>
<p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code> //char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code> //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code> //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code> //把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code> //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code> //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code> //用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 = str1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>​ string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p>
<h4 id="string字符串拼接">string字符串拼接</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code> //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code> //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code> //重载+=操作符</li>
<li><code>string&amp; append(const char *s);</code> //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code> //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code> //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">	str1 += str2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">	str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="comment">//str3.append(str2);</span></span><br><span class="line">	str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="string查找和替换">string查找和替换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code> //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const;</code> //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const;</code> //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const;</code> //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code> //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code> //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code> //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;</code> //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str);</code> //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s);</code> //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="string字符串比较">3.1.6 string字符串比较</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回 0</p>
<p>&gt; 返回 1</p>
<p>&lt; 返回 -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const;</code> //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code> //与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="string字符存取">string字符存取</h4>
<p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n);</code> //通过[]方式取字符</li>
<li><code>char&amp; at(int n);</code> //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符修改</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="string插入和删除">string插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);</code> //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str);</code> //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code> //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code> //删除从Pos开始的n个字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h4 id="string子串">string子串</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code> //返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">	string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="vector容器">vector容器</h3>
<h4 id="vector基本概念">vector基本概念</h4>
<p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-166964389469549.webp"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="vector构造函数">vector构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v;</code> //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());</code> //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code> //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code> //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="vector赋值操作">vector赋值操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p></li>
<li><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p></li>
<li><p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">	v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="vector容量和大小">vector容量和大小</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty();</code> //判断容器是否为空</p></li>
<li><p><code>capacity();</code> //容器的容量</p></li>
<li><p><code>size();</code> //返回容器中元素的个数</p></li>
<li><p><code>resize(int num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p></li>
<li><p><code>resize(int num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​ //如果容器变短，则末尾超出容器长度的元素被删除</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">	v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>判断是否为空 --- empty</li>
<li>返回元素个数 --- size</li>
<li>返回容器容量 --- capacity</li>
<li>重新指定大小 --- resize</li>
</ul>
<h4 id="vector插入和删除">vector插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code> //尾部插入元素ele</li>
<li><code>pop_back();</code> //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code> //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code> //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code> //删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	v1.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	v1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>尾插 --- push_back</li>
<li>尾删 --- pop_back</li>
<li>插入 --- insert (位置迭代器)</li>
<li>删除 --- erase （位置迭代器）</li>
<li>清空 --- clear</li>
</ul>
<h4 id="vector数据存取">vector数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx);</code> //返回索引idx所指的数据</li>
<li><code>operator[];</code> //返回索引idx所指的数据</li>
<li><code>front();</code> //返回容器中第一个数据元素</li>
<li><code>back();</code> //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="vector互换容器">vector互换容器</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code> // 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//互换容器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">	<span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//收缩内存</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="vector预留空间">vector预留空间</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//预留空间</span></span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">			p = &amp;v[<span class="number">0</span>];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="deque容器">deque容器</h3>
<h4 id="deque容器基本概念">deque容器基本概念</h4>
<p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1547547642923.webp"></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1547547896341.webp"></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="deque构造函数">deque构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT; //默认构造形式</li>
<li><code>deque(beg, end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code> //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code> //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">	<span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="deque赋值操作">deque赋值操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque&amp; operator=(const deque &amp;deq);</code> //重载等号操作符</p></li>
<li><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</p></li>
<li><p><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2 = d1;</span><br><span class="line">	<span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">	d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">	d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="deque大小操作">deque大小操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code> //判断容器是否为空</p></li>
<li><p><code>deque.size();</code> //返回容器中元素的个数</p></li>
<li><p><code>deque.resize(num);</code> //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p></li>
<li><p><code>deque.resize(num, elem);</code> //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//统计大小</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">	d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空 --- empty</li>
<li>返回元素个数 --- size</li>
<li>重新指定个数 --- resize</li>
</ul>
<h4 id="deque-插入和删除">deque 插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code> //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code> //在容器头部插入一个数据</li>
<li><code>pop_back();</code> //删除容器最后一个数据</li>
<li><code>pop_front();</code> //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code> //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li>
<li><p><code>insert(pos,n,elem);</code> //在pos位置插入n个elem数据，无返回值。</p></li>
<li><p><code>insert(pos,beg,end);</code> //在pos位置插入[beg,end)区间的数据，无返回值。</p></li>
<li><p><code>clear();</code> //清空容器的所有数据</p></li>
<li><p><code>erase(beg,end);</code> //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li>
<li><p><code>erase(pos);</code> //删除pos位置的数据，返回下一个数据的位置。</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	d.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	d.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">	d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	d.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插 --- push_back</li>
<li>尾删 --- pop_back</li>
<li>头插 --- push_front</li>
<li>头删 --- pop_front</li>
</ul>
<h4 id="deque-数据存取">deque 数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx);</code> //返回索引idx所指的数据</li>
<li><code>operator[];</code> //返回索引idx所指的数据</li>
<li><code>front();</code> //返回容器中第一个数据元素</li>
<li><code>back();</code> //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="deque-排序">deque 排序</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line">	<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="案例-评委打分">案例-评委打分</h3>
<h4 id="案例描述">案例描述</h4>
<p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="实现步骤">实现步骤</h4>
<ol type="1">
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> score)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createPerson</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">		name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line">		deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">			d.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		<span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">		<span class="comment">//去除最高和最低分</span></span><br><span class="line">		d.<span class="built_in">pop_back</span>();</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取平均分</span></span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator dit = d.<span class="built_in">begin</span>(); dit != d.<span class="built_in">end</span>(); dit++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> avg = sum / d.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">		it-&gt;m_Score = avg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showScore</span><span class="params">(vector&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//随机数种子</span></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建5名选手</span></span><br><span class="line">	vector&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">	<span class="built_in">createPerson</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、给5名选手打分</span></span><br><span class="line">	<span class="built_in">setScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、显示最后得分</span></span><br><span class="line">	<span class="built_in">showScore</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="stack容器">stack容器</h3>
<h4 id="stack-基本概念">stack 基本概念</h4>
<p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1547604555425.webp"></p>
<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为 --- <strong>入栈</strong> <code>push</code></p>
<p>栈中弹出数据称为 --- <strong>出栈</strong> <code>pop</code></p>
<p>生活中的栈：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-166964389469550.webp"></p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1547605111510.webp"></p>
<h4 id="stack-常用接口">stack 常用接口</h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code> //stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code> //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code> //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code> //向栈顶添加元素</li>
<li><code>pop();</code> //从栈顶移除第一个元素</li>
<li><code>top();</code> //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code> //判断堆栈是否为空</li>
<li><code>size();</code> //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出栈顶元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出栈顶元素</span></span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>入栈 --- push</li>
<li>出栈 --- pop</li>
<li>返回栈顶 --- top</li>
<li>判断栈是否为空 --- empty</li>
<li>返回栈大小 --- size</li>
</ul>
<h3 id="queue-容器">queue 容器</h3>
<h4 id="queue-基本概念">queue 基本概念</h4>
<p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1547606475892.webp"></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 --- <strong>入队</strong> <code>push</code></p>
<p>队列中出数据称为 --- <strong>出队</strong> <code>pop</code></p>
<p>生活中的队列：</p>
<p><img src="/2022/11/28/c-plus-plus-summary/1547606785041.webp"></p>
<h4 id="queue-常用接口">queue 常用接口</h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code> //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code> //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code> //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code> //往队尾添加元素</li>
<li><code>pop();</code> //从队头移除第一个元素</li>
<li><code>back();</code> //返回最后一个元素</li>
<li><code>front();</code> //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code> //判断堆栈是否为空</li>
<li><code>size();</code> //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建队列</span></span><br><span class="line">	queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">	q.<span class="built_in">push</span>(p1);</span><br><span class="line">	q.<span class="built_in">push</span>(p2);</span><br><span class="line">	q.<span class="built_in">push</span>(p3);</span><br><span class="line">	q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列不提供迭代器，更不支持随机访问	</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出队头元素</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//弹出队头元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>入队 --- push</li>
<li>出队 --- pop</li>
<li>返回队头元素 --- front</li>
<li>返回队尾元素 --- back</li>
<li>判断队是否为空 --- empty</li>
<li>返回队列大小 --- size</li>
</ul>
<h3 id="list容器">list容器</h3>
<h4 id="list基本概念">list基本概念</h4>
<p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p><img src="/2022/11/28/c-plus-plus-summary/clip_image002-1547608564071.webp"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="list构造函数">list构造函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code> //list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code> //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="list-赋值和交换">list 赋值和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符</li>
<li><code>swap(lst);</code> //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2 = L1;</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">	L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">	L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">	L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">	<span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="list-大小操作">list 大小操作</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size();</code> //返回容器中元素的个数</p></li>
<li><p><code>empty();</code> //判断容器是否为空</p></li>
<li><p><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​ //如果容器变短，则末尾超出容器长度的元素被删除。</p></li>
<li><p><code>resize(num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>                      //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重新指定大小</span></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">	L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>判断是否为空 --- empty</li>
<li>返回元素个数 --- size</li>
<li>重新指定个数 --- resize</li>
</ul>
<h4 id="list-插入和删除">list 插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">	L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	L.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	it = L.<span class="built_in">begin</span>();</span><br><span class="line">	L.<span class="built_in">erase</span>(++it);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除</span></span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">	L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">	L.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>尾插 --- push_back</li>
<li>尾删 --- pop_back</li>
<li>头插 --- push_front</li>
<li>头删 --- pop_front</li>
<li>插入 --- insert</li>
<li>删除 --- erase</li>
<li>移除 --- remove</li>
<li>清空 --- clear</li>
</ul>
<h4 id="list-数据存取">list 数据存取</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code> //返回第一个元素。</li>
<li><code>back();</code> //返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素 --- front</li>
<li>返回最后一个元素 --- back</li>
</ul>
<h4 id="list-反转和排序">list 反转和排序</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code> //反转链表</li>
<li><code>sort();</code> //链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转容器的元素</span></span><br><span class="line">	L.<span class="built_in">reverse</span>();</span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">	L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">	<span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>反转 --- reverse</li>
<li>排序 --- sort （成员函数）</li>
</ul>
<h4 id="排序案例">排序案例</h4>
<p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">		m_Age = age;</span><br><span class="line">		m_Height = height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">		<span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p></li>
<li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p></li>
</ul>
<h3 id="set-multiset-容器">set/ multiset 容器</h3>
<h4 id="set基本概念">set基本概念</h4>
<p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="set构造和赋值">set构造和赋值</h4>
<p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code> //默认构造函数：</li>
<li><code>set(const set &amp;st);</code> //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">	s3 = s2;</span><br><span class="line">	<span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="set大小和交换">set大小和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code> //返回容器中元素的数目</li>
<li><code>empty();</code> //判断容器是否为空</li>
<li><code>swap(st);</code> //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">	<span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>统计大小 --- size</li>
<li>判断是否为空 --- empty</li>
<li>交换容器 --- swap</li>
</ul>
<h4 id="set插入和删除">set插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code> //在容器中插入元素。</li>
<li><code>clear();</code> //清除所有元素</li>
<li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code> //删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	<span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">	s1.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>插入 --- insert</li>
<li>删除 --- erase</li>
<li>清空 --- clear</li>
</ul>
<h4 id="set查找和统计">set查找和统计</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code> //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>查找 --- find （返回的是迭代器）</li>
<li>统计 --- count （对于set，结果为0或者1）</li>
</ul>
<h4 id="set和multiset区别">set和multiset区别</h4>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//multiset</span></span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="pair对组创建">pair对组创建</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="set容器排序">set容器排序</h4>
<p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong> set存放内置数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定排序规则</span></span><br><span class="line">	set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">	s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line">		<span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(p1);</span><br><span class="line">	s.<span class="built_in">insert</span>(p2);</span><br><span class="line">	s.<span class="built_in">insert</span>(p3);</span><br><span class="line">	s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="map-multimap容器">map/ multimap容器</h3>
<h4 id="map基本概念">map基本概念</h4>
<p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="map构造和赋值">map构造和赋值</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code> //map默认构造函数:</li>
<li><code>map(const map &amp;mp);</code> //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code> //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">	m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="map大小和交换">map大小和交换</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code> //返回容器中元素的数目</li>
<li><code>empty();</code> //判断容器是否为空</li>
<li><code>swap(st);</code> //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">	m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">	m.<span class="built_in">swap</span>(m2);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">	<span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>统计大小 --- size</li>
<li>判断是否为空 --- empty</li>
<li>交换容器 --- swap</li>
</ul>
<h4 id="map插入和删除">map插入和删除</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code> //在容器中插入元素。</li>
<li><code>clear();</code> //清除所有元素</li>
<li><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code> //删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="comment">//第一种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">//第二种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	<span class="comment">//第三种插入方式</span></span><br><span class="line">	m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">//第四种插入方式</span></span><br><span class="line">	m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清空</span></span><br><span class="line">	m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">	m.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><p>map插入方式很多，记住其一即可</p></li>
<li><p>插入 --- insert</p></li>
<li><p>删除 --- erase</p></li>
<li><p>清空 --- clear</p></li>
</ul>
<h4 id="map查找和统计">map查找和统计</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code> //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计</span></span><br><span class="line">	<span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>查找 --- find （返回的是迭代器）</li>
<li>统计 --- count （对于map，结果为0或者1）</li>
</ul>
<h4 id="map容器排序">map容器排序</h4>
<p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//默认从小到大排序</span></span><br><span class="line">	<span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="案例-员工分组">案例-员工分组</h3>
<h4 id="案例描述-1">案例描述</h4>
<ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名 工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入 key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="实现步骤-1">实现步骤</h4>
<ol type="1">
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Worker worker;</span><br><span class="line">		worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">		worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">		worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line">		<span class="comment">//将员工放入到容器中</span></span><br><span class="line">		v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//产生随机部门编号</span></span><br><span class="line">		<span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将员工插入到分组中</span></span><br><span class="line">		<span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">		m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line">	<span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">	count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">	count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">	index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、创建员工</span></span><br><span class="line">	vector&lt;Worker&gt;vWorker;</span><br><span class="line">	<span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、员工分组</span></span><br><span class="line">	multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line">	<span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、分组显示员工</span></span><br><span class="line">	<span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line">	<span class="comment">////测试</span></span><br><span class="line">	<span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="stl--函数对象">STL- 函数对象</h2>
<h3 id="函数对象">函数对象</h3>
<h4 id="函数对象概念">函数对象概念</h4>
<p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="函数对象使用">函数对象使用</h4>
<p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 + v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyAdd myAdd;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyPrint</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">		count++; <span class="comment">//统计使用次数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	<span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyPrint myPrint;</span><br><span class="line">	<span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="谓词">谓词</h3>
<h4 id="谓词概念">谓词概念</h4>
<p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="一元谓词">一元谓词</h4>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="二元谓词">二元谓词</h4>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//默认从小到大</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="内建函数对象">内建函数对象</h3>
<h4 id="内建函数对象意义">内建函数对象意义</h4>
<p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p></li>
<li><p>关系仿函数</p></li>
<li><p>逻辑仿函数</p></li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="算术仿函数">算术仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code> //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code> //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code> //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code> //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code> //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code> //取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="关系仿函数">关系仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code> //等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code> //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code> //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code> //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code> //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code> //小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自己实现仿函数</span></span><br><span class="line">	<span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line">	<span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="逻辑仿函数">逻辑仿函数</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code> //逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code> //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code> //逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="stl--常用算法">STL- 常用算法</h2>
<p><strong>概述</strong>:</p>
<ul>
<li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p></li>
<li><p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li>
<li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li>
<li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p></li>
</ul>
<h3 id="常用遍历算法">常用遍历算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code> //遍历容器</li>
<li><code>transform</code> //搬运容器到另一个容器中</li>
</ul>
<h4 id="for_each">for_each</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);</code></p>
<p>// 遍历算法 遍历容器元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _func 函数或者函数对象</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历算法</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="transform">transform</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>//beg1 源容器开始迭代器</p>
<p>//end1 源容器结束迭代器</p>
<p>//beg2 目标容器开始迭代器</p>
<p>//_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="常用查找算法">常用查找算法</h3>
<p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code> //查找元素</li>
<li><code>find_if</code> //按条件查找元素</li>
<li><code>adjacent_find</code> //查找相邻重复元素</li>
<li><code>binary_search</code> //二分查找法</li>
<li><code>count</code> //统计元素个数</li>
<li><code>count_if</code> //按条件统计元素个数</li>
</ul>
<h4 id="find">find</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);</code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="find_if">find_if</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="adjacent_find">adjacent_find</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);</code></p>
<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查找相邻重复元素</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="binary_search">binary_search</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p>
<p>// 查找指定的元素，查到 返回true 否则false</p>
<p>// 注意: 在<strong>无序序列中不可用</strong></p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//二分查找</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="count">count</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);</code></p>
<p>// 统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 统计的元素</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="count_if">count_if</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p>
<p>// 按条件统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h3 id="常用排序算法">常用排序算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code> //对容器内元素进行排序</li>
<li><code>random_shuffle</code> //洗牌 指定范围内的元素随机调整次序</li>
<li><code>merge</code> // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code> // 反转指定范围的元素</li>
</ul>
<h4 id="sort">sort</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);</code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//sort默认从小到大排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从大到小排序</span></span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="random_shuffle">random_shuffle</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>洗牌 指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);</code></p>
<p>// 指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打乱顺序</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="merge">merge</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p>
<p>// 容器元素合并，并存储到另一容器中</p>
<p>// 注意: 两个容器必须是<strong>有序的</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line">	<span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">	vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h4 id="reverse">reverse</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);</code></p>
<p>// 反转指定范围的元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="常用拷贝和替换算法">常用拷贝和替换算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code> // 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code> // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if</code> // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code> // 互换两个容器的元素</li>
</ul>
<h4 id="copy">copy</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// dest 目标起始迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="replace">replace</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p>
<p>// 将区间内旧元素 替换成 新元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// oldvalue 旧元素</p>
<p>// newvalue 新元素</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h4 id="replace_if">replace_if</h4>
<p><strong>功能描述:</strong></p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p>
<p>// 按条件替换元素，满足条件的替换成指定元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _pred 谓词</p>
<p>// newvalue 替换的新元素</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="swap">swap</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);</code></p>
<p>// 互换两个容器的元素</p>
<p>// c1容器1</p>
<p>// c2容器2</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(v1, v2);</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="常用算术生成算法">常用算术生成算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code> // 计算容器元素累计总和</p></li>
<li><p><code>fill</code> // 向容器中添加元素</p></li>
</ul>
<h4 id="accumulate">accumulate</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);</code></p>
<p>// 计算容器元素累计总和</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 起始值</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="fill">fill</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);</code></p>
<p>// 向容器中填充元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 填充的值</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="常用集合算法">常用集合算法</h3>
<p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code> // 求两个容器的交集</p></li>
<li><p><code>set_union</code> // 求两个容器的并集</p></li>
<li><p><code>set_difference</code> // 求两个容器的差集</p></li>
</ul>
<h4 id="set_intersection">set_intersection</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p>
<p>// 求两个集合的交集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="set_union">set_union</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p>
<p>// 求两个集合的并集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="set_difference">set_difference</h4>
<p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p>
<p>// 求两个集合的差集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>
// end1 容器1结束迭代器<br>
// beg2 容器2开始迭代器<br>
// end2 容器2结束迭代器<br>
// dest 目标容器开始迭代器</p></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line">	<span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">	vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>组会记录</title>
    <url>/2022/05/19/reports_record/</url>
    <content><![CDATA[<h1 id="年组会记录">2025年组会记录</h1>
<h2 id="年2月">2025年2月</h2>
<div class="timeline undefined"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>202502组会记录</p>
</div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>20250227 eFPGA测试</p>
</div></div><div class="timeline-item-content"><p><a href="/slides/reports/20250227/report.html">open slide</a><br>
<iframe src="/slides/reports/20250227/report.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
</div></div></div>
<h2 id="年3月">2025年3月</h2>
<div class="timeline undefined"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>202503组会记录</p>
</div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>20250305 eFPGA问题修复</p>
</div></div><div class="timeline-item-content"><p><a href="/slides/reports/20250305/report.html">open slide</a><br>
<iframe src="/slides/reports/20250305/report.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>20250313 Yosys使用adder宏</p>
</div></div><div class="timeline-item-content"><p><a href="/slides/reports/20250313/report.html">open slide</a><br>
<iframe src="/slides/reports/20250313/report.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>20250320 Yosys综合优化</p>
</div></div><div class="timeline-item-content"><p><a href="/slides/reports/20250320/report.html">open slide</a><br>
<iframe src="/slides/reports/20250320/report.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>20250326 Yosys综合优化</p>
</div></div><div class="timeline-item-content"><p><a href="/slides/reports/20250326/report.html">open slide</a><br>
<iframe src="/slides/reports/20250326/report.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
</div></div></div>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/05/19/test/</url>
    <content><![CDATA[<h1 id="外挂标签">外挂标签</h1>
<div class="tip success">
<p>为简单的一句话提供的简便写法。</p>
</div>
<p>带 <u>下划线</u> 的文本</p>
<p>带 <emp>着重号</emp> 的文本</p>
<p>带 <wavy>波浪线</wavy> 的文本</p>
<p>带 <del>删除线</del> 的文本</p>
<p>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></p>
<p>密码样式的文本：<psw>这里没有验证码</psw></p>
<p>彩色文字<br>
在一段话中方便插入各种颜色的标签，包括：<span class="p red">红色</span>、<span class="p yellow">黄色</span>、<span class="p green">绿色</span>、<span class="p cyan">青色</span>、<span class="p blue">蓝色</span>、<span class="p gray">灰色</span>。超大号文字</p>
<p>文档「开始」页面中的标题部分就是超大号文字。<br>
<span class="p center logo large">Volantis</span><br>
<span class="p center small">A Wonderful Theme for Hexo</span></p>
<div class="checkbox green checked"><input type="checkbox" checked="checked">
            <p>绿色 + 默认选中</p>
            </div>
<div class="timeline color]"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>时间线标题（可选）[</p>
</div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>时间节点（标题）</p>
</div></div><div class="timeline-item-content"><p>正文内容</p>
</div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>时间节点（标题）</p>
</div></div><div class="timeline-item-content"><p>正文内容</p>
</div></div></div>
<div class="btns circle grid5">
            <a class="button" href="https://xaoxuu.com" title="xaoxuu"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">xaoxuu</a>
<a class="button" href="https://xaoxuu.com" title="xaoxuu"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">xaoxuu</a>
<a class="button" href="https://xaoxuu.com" title="xaoxuu"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">xaoxuu</a>
<a class="button" href="https://xaoxuu.com" title="xaoxuu"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">xaoxuu</a>
<a class="button" href="https://xaoxuu.com" title="xaoxuu"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">xaoxuu</a>
          </div>
<p>作者: Chaospring<br>
链接: https://chaospring.com/posts/4770/#%E6%8C%89%E9%92%AE-btns<br>
来源: Chaospring<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>脚注footnotes测试<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，脚注英文<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，脚注中文<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>
              <div class="content">
              <p>这是一个默认打开的折叠框。</p>
              </div>
            </details>
<div class="tabs" id="tab1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab1-1">预览</button></li><li class="tab"><button type="button" data-href="#tab1-2">源码</button></li><li class="tab"><button type="button" data-href="#tab1-3">配置参数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<div class="tip "><p>默认情况</p>
</div>
<div class="tip "><p>default</p>
</div>
<div class="tip info"><p>info</p>
</div>
<div class="tip success"><p>success</p>
</div>
<div class="tip error"><p>error</p>
</div>
<div class="tip warning"><p>warning</p>
</div>
<div class="tip bolt"><p>bolt</p>
</div>
<div class="tip ban"><p>ban</p>
</div>
<div class="tip home"><p>home</p>
</div>
<div class="tip sync"><p>sync</p>
</div>
<div class="tip cogs"><p>cogs</p>
</div>
<div class="tip key"><p>key</p>
</div>
<div class="tip bell"><p>bell</p>
</div>
<div class="tip fa-atom"><p>自定义font awesome图标</p>
</div>
<div class="note modern"><p>默认 提示块标签</p>
</div>
<div class="note icon modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note primary modern"><p>primary 提示块标签</p>
</div>
<div class="note pink icon modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note icon modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了....</p>
</div>
<div class="note pink icon modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p>
</div>
<div class="note red icon modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p>
</div>
<div class="note orange icon modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p>
</div>
<div class="note purple icon modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p>
</div>
<div class="note green icon modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p>
</div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red" style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow" style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan" style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue" style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray" style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div>
<h1 id="mermaid绘图">mermaid绘图</h1>
<pre class="mermaid">graph TB;
subgraph 分情况
A(开始)-->B{判断}
end
B--第一种情况-->C[第一种方案]
B--第二种情况-->D[第二种方案]
B--第三种情况-->F{第三种方案}
subgraph 分种类
F-.第1个.->J((测试圆形))
F-.第2个.->H>右向旗帜形]
end
H---I(测试完毕)
C--票数100---I(测试完毕)
D---I(测试完毕)
J---I(测试完毕)</pre>
<pre class="mermaid">sequenceDiagram
Title: 小明买书

participant consumer as 小明
participant store as 书店
participant publisher as 出版社

consumer ->> store: 想买一本限量版书籍
store -->> consumer: 缺货
consumer ->> store: 隔一个月再次询问
store -->> consumer: 抢完了
loop 一个星期一次
consumer -x +store: 有货了吗
store --x -consumer: 正在订,有货马上通知你
end

store ->> publisher: 我要订购一批货
publisher --x store: 返回所有书籍的类别信息

alt 书籍类别符合要求
store ->> publisher: 请求书单信息
publisher --x store: 返回该类别书单信息
else 书单里的书有市场需求
store ->> publisher: 购买指定数据
publisher --x store: 确认订单
else 书籍不符合要求
store -->> publisher: 暂时不购买
end

par 并行执行
publisher ->> publisher : 生产
publisher ->> publisher : 销售
end

opt 书籍购买量>=500 && 库存>=50
publisher ->> store : 出货
store --x publisher : 确认收货
end

Note left of consumer : 图书收藏家
Note over consumer,store : 去书店购买书籍
Note left of store : 全国知名书店
Note over store,publisher : 去出版社进货
Note left of publisher : 持有版权的出版社</pre>
<pre class="mermaid">pie
 title Pie Chart
 "Dogs" : 386
 "cats" : 567
 "rabbit" : 700
 "pig":365
 "tiger" : 15</pre>
<pre class="mermaid">%%{init: { "sequence-theme": "hand" } }%%

timeline
        title England's History Timeline
        section Stone Age
          7600 BC : Britain's oldest known house was built in Orkney, Scotland
          6000 BC : Sea levels rise and Britain becomes an island.<br> The people who live here are hunter-gatherers.
        section Bronze Age
          2300 BC : People arrive from Europe and settle in Britain. <br>They bring farming and metalworking.
                  : New styles of pottery and ways of burying the dead appear.
          2200 BC : The last major building works are completed at Stonehenge.<br> People now bury their dead in stone circles.
                  : The first metal objects are made in Britain.Some other nice things happen. it is a good time to be alive.
                  2200 BC : The last major building works are completed at Stonehenge.<br> People now bury their dead in stone circles.
                  : The first metal objects are made in Britain.Some other nice things happen. it is a good time to be alive.</pre>
<pre class="mermaid">%%{init: { "sequence": { "wrap": true} } }%%
sequenceDiagram

Alice->Bob: Hello Bob, how are you?
Bob->Alice: Fine, how did you mother like the book I suggested? And did you catch the new book about alien invasion?
Alice->Bob: Good.
Bob->Alice: Cool</pre>
<h1 id="github-style-alert">github style alert</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; [!NOTE]</span><br><span class="line">&gt; Information the user should notice even <span class="keyword">if</span> skimming.<span class="variable">$a</span> \leq b$</span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">
Information the user should notice even if skimming.<span class="math inline">\(a \leq b\)</span></p></div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; [!tip]</span><br><span class="line">&gt; Information the user should notice even <span class="keyword">if</span> skimming.</span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-tip" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto">
Information the user should notice even if skimming.</p></div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; [!important]</span><br><span class="line">&gt; Information the user should notice even <span class="keyword">if</span> skimming.</span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">
Information the user should notice even if skimming.</p></div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; [!caution]</span><br><span class="line">Information the user should notice even <span class="keyword">if</span> skimming.</span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-caution" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Caution</p><p dir="auto">
Information the user should notice even if skimming.</p></div>
<div class="markdown-alert markdown-alert-tip" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-light-bulb mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>Tip</p><p dir="auto">
Optional information to help a user be more successful.</p></div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">
Essential information required for user success.aaa</p>
<p>sdfkahsdkfhkaskdfhkashkdfhkashdkfkashdkfhkasdhkfkasdhkfhaskdhf<br>
ashdkfhkasdkfhkas<br>
ahksdhfkasjkdfhaskdfh</p></div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">
Essential information required for user success.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<br>
sdfkahsdkfhkaskdfhkashkdfhkashdkfkashdkfhkasdhkfkasdhkfhaskdhf<br>
ashdkfhkasdkfhkas<br>
ahksdhfkasjkdfhaskdfh</p></div>
<div class="markdown-alert markdown-alert-caution" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Caution</p><p dir="auto">
Negative potential consequences of an action.<br>
tesesdfksdhfkksd</p></div>
<div class="markdown-alert markdown-alert-warning" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p><p dir="auto">
Dangerous certain consequences of an action.</p></div>
<blockquote>
<p>test</p>
<p>esskdf<span class="math inline">\(a \leq b\)</span></p>
<p>sdflsj<br>
sdfsdfhkaaosofosajdf</p>
</blockquote>
<p>sdfsdf<br>
asdfasdf<br>
asdfasdf<br>
asdfasdfasdf</p>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">
sdfskjdhf<br>
sdfskhdkf'<br>
askdfhkashdf<br>
aksdhfkas</p></div>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto"></p>
<p>sdfskjdhf</p>
<p>sdfskhdkf'</p>
<p>askdfhkashdf</p>
<p>aksdhfkas</p></div>
<h1 id="admonition">admonition</h1>
<div class="admonition admonition-note">
<p class="admonition-title">Hexo-admonition 插件使用示例
</p>
<p>这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。</p>
<p>提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。</p>
</div>
<div class="admonition admonition-warning">
<p class="admonition-title">Warning</p>
<p>这是一条采用默认标题的警告信息。</p>
</div>
<div class="admonition admonition-warning">
<p>这是一条不带标题的警告信息。</p>
</div>
<div class="admonition admonition-note">
<p class="admonition-title">嵌套链接及引用块
</p>
<p>欢迎访问我的博客链接：<a href="https://www.example.cn">悟尘纪</a></p>
<blockquote>
<p>这里嵌套一行引用信息。</p>
</blockquote>
</div>
<div class="admonition admonition-note">
<p class="admonition-title">嵌套链接及引用块
</p>
<p>嵌套admonition</p>
<div class="admonition admonition-note">
<p class="admonition-title">嵌套admonition
</p>
<p>子内容</p>
</div>
</div>
<div class="admonition admonition-note">
<p class="admonition-title">如果 $k \leq r$
</p>
<p>标题为公式，内容公式<span class="math inline">\(k \leq r\)</span></p>
</div>
<p>所有功能</p>
<div class="admonition admonition-note">
<p class="admonition-title">Note</p>
</div>
<div class="admonition admonition-abstract">
<p class="admonition-title">Abstract</p>
</div>
<div class="admonition admonition-info">
<p class="admonition-title">Info</p>
</div>
<div class="admonition admonition-tip">
<p class="admonition-title">Tip</p>
</div>
<div class="admonition admonition-success">
<p class="admonition-title">Success</p>
</div>
<div class="admonition admonition-question">
<p class="admonition-title">Question</p>
</div>
<div class="admonition admonition-todo">
<p class="admonition-title">Todo</p>
</div>
<div class="admonition admonition-warning">
<p class="admonition-title">Warning</p>
</div>
<div class="admonition admonition-failure">
<p class="admonition-title">Failure</p>
</div>
<div class="admonition admonition-danger">
<p class="admonition-title">Danger</p>
</div>
<div class="admonition admonition-bug">
<p class="admonition-title">Bug</p>
</div>
<div class="admonition admonition-example">
<p class="admonition-title">Example</p>
</div>
<div class="admonition admonition-quote">
<p class="admonition-title">Quote</p>
</div>
<div class="admonition admonition-attention">
<p class="admonition-title">Attention</p>
</div>
<div class="admonition admonition-caution">
<p class="admonition-title">Caution</p>
</div>
<div class="admonition admonition-missing">
<p class="admonition-title">Missing</p>
</div>
<div class="admonition admonition-error">
<p class="admonition-title">Error</p>
</div>
<h1 id="reveal-slides">reveal slides</h1>
<p>后面有时间的时候，可以去看看下面这两个用markdown创建slides的方案.</p>
<ul>
<li><a href="https://martenbe.github.io/mkslides/">MkSlides</a> (successor to reveal-md)</li>
<li><a href="https://sli.dev">Slidev</a></li>
</ul>
<p>reveal slides还可以优化，参照下面的链接</p>
<p><a href="https://xieby1.github.io/markdown_revealjs/README.html#/title-slide">Markdown RevealJS</a></p>
<h2 id="直接利用revealjs对markdown的支持">直接利用revealjs对markdown的支持</h2>
<p>首先在<code>source/slides/</code>下面闯将子文件夹(或者直接创建markdown也行)，然后创建一个markdown文件，用来存放一个幻灯片。并且需要添加如下的Front-matter。其中permalink是指定其被编译成html之后，在public中存放的位置,建议就统一存放在slides下面就好了。然后就可以直接用markdown来创建slides了，其中不同的页面通过<code>---</code>来分隔开。然后在需要引用的地方，可以使用<code>&lt;iframe src="path" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"&gt;&lt;/iframe&gt;</code>来进行引入。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">title</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">narutozxp</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-05-19 20:45:27</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">slides/test_slide.html</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">slides</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p><a href="/slides/test/test_slide.html">test_slide</a><br>
<iframe src="/slides/test/test_slide.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<p><a href="/slides/mkslides_example/c0.html">c0</a><br>
<iframe src="/slides/mkslides_example/c0.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<p><a href="/slides/mkslides_example/c1.html">c1</a><br>
<iframe src="/slides/mkslides_example/c0.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<p><a href="/slides/mkslides_example/c2.html">c2</a><br>
<iframe src="/slides/mkslides_example/c0.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<p><a href="/slides/mkslides_example/c3.html">c3</a><br>
<iframe src="/slides/mkslides_example/c0.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h2 id="使用pandoc实现将md转换为html">使用pandoc实现将md转换为html</h2>
<p>只需要在markdown所在的目录运行<code>revealjs.sh mymarkdown.md</code>就行了, <code>revealjs.sh</code>脚本存放在<code>blog/source/markdown_revealjs/bin/revealjs.sh</code>。</p>
<p>如果需要在本地查看编译后的html的效果，则需要设置<code>REPOROOT</code>环境变量，将其指向<code>markdown_revealjs</code>的父目录————<code>C:/Project/blog/source</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REPOROOT=C:/Project/blog/source bash C:/Project/blog/source/markdown_revealjs/bin/revealjs.sh README.md</span><br></pre></td></tr></table></figure>
<p>如果在后面添加<code>-V lxgw</code>，则会使用《霞鹜文楷》字体。</p>
<h3 id="语法教程">语法教程</h3>
<p><a href="/markdown_revealjs/README.html">教程PPT</a><br>
<iframe src="/markdown_revealjs/README.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h3 id="当前支持的主题">当前支持的主题</h3>
<h4 id="hustic">HUSTIC</h4>
<p><a href="/markdown_revealjs/themes/hust/index.html">HUSTIC</a><br>
<iframe src="/markdown_revealjs/themes/hust/index.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h4 id="开芯院">开芯院</h4>
<p><a href="/markdown_revealjs/themes/bosc/index.html">BOSC</a><br>
<iframe src="/markdown_revealjs/themes/bosc/index.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h4 id="龙芯">龙芯</h4>
<p><a href="/markdown_revealjs/themes/loongson/index.html">LOONGSON</a><br>
<iframe src="/markdown_revealjs/themes/loongson/index.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h4 id="中科院微处理器研究中心">中科院微处理器研究中心</h4>
<p><a href="/markdown_revealjs/themes/ict_mtrc_proposal/index.html">ICT_MTRC_PROPOSAL</a><br>
<iframe src="/markdown_revealjs/themes/ict_mtrc_proposal/index.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h4 id="中科院计算所">中科院计算所</h4>
<p><a href="/markdown_revealjs/themes/ucas_ict_thesis/index.html">UCAS_ICT_THESIS</a><br>
<iframe src="/markdown_revealjs/themes/ucas_ict_thesis/index.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe></p>
<h1 id="wavedrom">wavedrom</h1>
<script type="WaveDrom">{reg: [
    { "name": "IPO",   "bits": 8, "attr": "RO" },
    {                  "bits": 7 },
     { "name": "BRK",   "bits": 5, "attr": "RW", "type": 4 },
     { "name": "CPK",   "bits": 1 },
     { "name": "Clear", "bits": 3 },
     { "bits": 8 }
]}</script>
<script type="WaveDrom">{ signal : [
  { name: "clk",  wave: "p......" },
  { name: "bus",  wave: "x.34.5x",   data: "head body tail" },
  { name: "wire", wave: "0.1..0." },
]}</script>
<p>外部图片链接</p>
<p><img src="https://svg.wavedrom.com/%7Bsignal:%5B%7Bname:&#39;clk&#39;,wave:&#39;p......&#39;%7D,%7Bname:&#39;bus&#39;,wave:&#39;x.34.5x&#39;,data:&#39;head%20body%20tail&#39;%7D,%7Bname:&#39;wire&#39;,wave:&#39;0.1..0.&#39;%7D%5D%7D" alt="wave"></p>
<h1 id="echarts绘图">echarts绘图</h1>
<p>hexo 实现echarts有两种方式。</p>
<p>第一种是直接使用<code>echarts</code>类型的代码块，里面写入<code>echarts</code>所需的<code>option</code>。然后再<code>echarts</code>代码块的上面添加<code>&lt;script&gt;</code>标签，其中添加变量和函数的定义，如果某个图不需要额外的函数或者变量定义，则可以不需要添加<code>&lt;script&gt;</code>。剧吐实施可以参考<a href="#柱状图bar">柱状图Bar</a>里面的第一张图的实现。</p>
<p>第二中实现方式是，直接在<code>source/custom_html/</code>下新增一个<code>html</code>文件，直接在里面添加所需的<code>js</code>,<code>css</code>等文件。然后在所需的地方使用<code>&lt;iframe src="path" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"&gt;&lt;/iframe&gt;</code>进行引入。具体的实施方案可以参考<a href="#地图map">地图Map</a>的实现。</p>
<p>第一种实现方案可能会通过<code>script</code>标签引入过多的变量和函数，它们之间可能会冲突。因此建议简单图形通过方案一来实现，复杂图形通过方案二来实现</p>
<h2 id="折线图line">折线图Line</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=area-stack">Stacked area chart</a></p>
<div id="echart-1" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-1'));
                        // 指定图表的配置项和数据
                        var option = {
    title: {
        text: '堆叠区域图'
    },
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross',
            label: {
                backgroundColor: '#6a7985'
            }
        }
    },
    legend: {
        data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎']
    },
    toolbox: {
        feature: {
            saveAsImage: {}
        }
    },
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
    },
    xAxis: [
        {
            type: 'category',
            boundaryGap: false,
            data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日']
        }
    ],
    yAxis: [
        {
            type: 'value'
        }
    ],
    series: [
        {
            name: '邮件营销',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [120, 132, 101, 134, 90, 230, 210]
        },
        {
            name: '联盟广告',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [220, 182, 191, 234, 290, 330, 310]
        },
        {
            name: '视频广告',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [150, 232, 201, 154, 190, 330, 410]
        },
        {
            name: '直接访问',
            type: 'line',
            stack: '总量',
            areaStyle: {},
            data: [320, 332, 301, 334, 390, 330, 320]
        },
        {
            name: '搜索引擎',
            type: 'line',
            stack: '总量',
            label: {
                normal: {
                    show: true,
                    position: 'top'
                }
            },
            areaStyle: {},
            data: [820, 932, 901, 934, 1290, 1330, 1320]
        }
    ]
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=area-pieces">Area Pieces</a></p>
<div id="echart-2" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-2'));
                        // 指定图表的配置项和数据
                        var option = {
    xAxis: {
        type: 'category',
        boundaryGap: false
    },
    yAxis: {
        type: 'value',
        boundaryGap: [0, '30%']
    },
    visualMap: {
        type: 'piecewise',
        show: false,
        dimension: 0,
        seriesIndex: 0,
        pieces: [{
            gt: 1,
            lt: 3,
            color: 'rgba(0, 180, 0, 0.5)'
        }, {
            gt: 5,
            lt: 7,
            color: 'rgba(0, 180, 0, 0.5)'
        }]
    },
    series: [
        {
            type: 'line',
            smooth: 0.6,
            symbol: 'none',
            lineStyle: {
                color: 'green',
                width: 5
            },
            markLine: {
                symbol: ['none', 'none'],
                label: {show: false},
                data: [
                    {xAxis: 1},
                    {xAxis: 3},
                    {xAxis: 5},
                    {xAxis: 7}
                ]
            },
            areaStyle: {},
            data: [
                ['2019-10-10', 200],
                ['2019-10-11', 400],
                ['2019-10-12', 650],
                ['2019-10-13', 500],
                ['2019-10-14', 250],
                ['2019-10-15', 300],
                ['2019-10-16', 450],
                ['2019-10-17', 300],
                ['2019-10-18', 100]
            ]
        }
    ]
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=area-rainfall">Rainfall</a></p>
<div id="echart-3" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-3'));
                        // 指定图表的配置项和数据
                        var option = {
    title: {
        text: '雨量流量关系图',
        subtext: '数据来自西安兰特水电测控技术有限公司',
        left: 'center',
        align: 'right'
    },
    grid: {
        bottom: 80
    },
    toolbox: {
        feature: {
            dataZoom: {
                yAxisIndex: 'none'
            },
            restore: {},
            saveAsImage: {}
        }
    },
    tooltip: {
        trigger: 'axis',
        axisPointer: {
            type: 'cross',
            animation: false,
            label: {
                backgroundColor: '#505765'
            }
        }
    },
    legend: {
        data: ['流量', '降雨量'],
        left: 10
    },
    dataZoom: [
        {
            show: true,
            realtime: true,
            start: 65,
            end: 85
        },
        {
            type: 'inside',
            realtime: true,
            start: 65,
            end: 85
        }
    ],
    xAxis: [
        {
            type: 'category',
            boundaryGap: false,
            axisLine: {onZero: false},
            data: [
                '2009/6/12 2:00', '2009/6/12 3:00', '2009/6/12 4:00', '2009/6/12 5:00', '2009/6/12 6:00', '2009/6/12 7:00', '2009/6/12 8:00', '2009/6/12 9:00', '2009/6/12 10:00', '2009/6/12 11:00', '2009/6/12 12:00', '2009/6/12 13:00', '2009/6/12 14:00', '2009/6/12 15:00', '2009/6/12 16:00', '2009/6/12 17:00', '2009/6/12 18:00', '2009/6/12 19:00', '2009/6/12 20:00', '2009/6/12 21:00', '2009/6/12 22:00', '2009/6/12 23:00',
                '2009/6/13 0:00', '2009/6/13 1:00', '2009/6/13 2:00', '2009/6/13 3:00', '2009/6/13 4:00', '2009/6/13 5:00', '2009/6/13 6:00', '2009/6/13 7:00', '2009/6/13 8:00', '2009/6/13 9:00', '2009/6/13 10:00', '2009/6/13 11:00', '2009/6/13 12:00', '2009/6/13 13:00', '2009/6/13 14:00', '2009/6/13 15:00', '2009/6/13 16:00', '2009/6/13 17:00', '2009/6/13 18:00', '2009/6/13 19:00', '2009/6/13 20:00', '2009/6/13 21:00', '2009/6/13 22:00', '2009/6/13 23:00',
                '2009/6/14 0:00', '2009/6/14 1:00', '2009/6/14 2:00', '2009/6/14 3:00', '2009/6/14 4:00', '2009/6/14 5:00', '2009/6/14 6:00', '2009/6/14 7:00', '2009/6/14 8:00', '2009/6/14 9:00', '2009/6/14 10:00', '2009/6/14 11:00', '2009/6/14 12:00', '2009/6/14 13:00', '2009/6/14 14:00', '2009/6/14 15:00', '2009/6/14 16:00', '2009/6/14 17:00', '2009/6/14 18:00', '2009/6/14 19:00', '2009/6/14 20:00', '2009/6/14 21:00', '2009/6/14 22:00', '2009/6/14 23:00',
                '2009/6/15 0:00', '2009/6/15 1:00', '2009/6/15 2:00', '2009/6/15 3:00', '2009/6/15 4:00', '2009/6/15 5:00', '2009/6/15 6:00', '2009/6/15 7:00', '2009/6/15 8:00', '2009/6/15 9:00', '2009/6/15 10:00', '2009/6/15 11:00', '2009/6/15 12:00', '2009/6/15 13:00', '2009/6/15 14:00', '2009/6/15 15:00', '2009/6/15 16:00', '2009/6/15 17:00', '2009/6/15 18:00', '2009/6/15 19:00', '2009/6/15 20:00', '2009/6/15 21:00', '2009/6/15 22:00', '2009/6/15 23:00',
                '2009/6/15 0:00', '2009/6/16 1:00', '2009/6/16 2:00', '2009/6/16 3:00', '2009/6/16 4:00', '2009/6/16 5:00', '2009/6/16 6:00', '2009/6/16 7:00', '2009/6/16 8:00', '2009/6/16 9:00', '2009/6/16 10:00', '2009/6/16 11:00', '2009/6/16 12:00', '2009/6/16 13:00', '2009/6/16 14:00', '2009/6/16 15:00', '2009/6/16 16:00', '2009/6/16 17:00', '2009/6/16 18:00', '2009/6/16 19:00', '2009/6/16 20:00', '2009/6/16 21:00', '2009/6/16 22:00', '2009/6/16 23:00',
                '2009/6/15 0:00', '2009/6/17 1:00', '2009/6/17 2:00', '2009/6/17 3:00', '2009/6/17 4:00', '2009/6/17 5:00', '2009/6/17 6:00', '2009/6/17 7:00', '2009/6/17 8:00', '2009/6/17 9:00', '2009/6/17 10:00', '2009/6/17 11:00', '2009/6/17 12:00', '2009/6/17 13:00', '2009/6/17 14:00', '2009/6/17 15:00', '2009/6/17 16:00', '2009/6/17 17:00', '2009/6/17 18:00', '2009/6/17 19:00', '2009/6/17 20:00', '2009/6/17 21:00', '2009/6/17 22:00', '2009/6/17 23:00',
                '2009/6/18 0:00', '2009/6/18 1:00', '2009/6/18 2:00', '2009/6/18 3:00', '2009/6/18 4:00', '2009/6/18 5:00', '2009/6/18 6:00', '2009/6/18 7:00', '2009/6/18 8:00', '2009/6/18 9:00', '2009/6/18 10:00', '2009/6/18 11:00', '2009/6/18 12:00', '2009/6/18 13:00', '2009/6/18 14:00', '2009/6/18 15:00', '2009/6/18 16:00', '2009/6/18 17:00', '2009/6/18 18:00', '2009/6/18 19:00', '2009/6/18 20:00', '2009/6/18 21:00', '2009/6/18 22:00', '2009/6/18 23:00',
                '2009/6/15 0:00', '2009/6/19 1:00', '2009/6/19 2:00', '2009/6/19 3:00', '2009/6/19 4:00', '2009/6/19 5:00', '2009/6/19 6:00', '2009/6/19 7:00', '2009/6/19 8:00', '2009/6/19 9:00', '2009/6/19 10:00', '2009/6/19 11:00', '2009/6/19 12:00', '2009/6/19 13:00', '2009/6/19 14:00', '2009/6/19 15:00', '2009/6/19 16:00', '2009/6/19 17:00', '2009/6/19 18:00', '2009/6/19 19:00', '2009/6/19 20:00', '2009/6/19 21:00', '2009/6/19 22:00', '2009/6/19 23:00',
                '2009/6/20 0:00', '2009/6/20 1:00', '2009/6/20 2:00', '2009/6/20 3:00', '2009/6/20 4:00', '2009/6/20 5:00', '2009/6/20 6:00', '2009/6/20 7:00', '2009/6/20 8:00', '2009/6/20 9:00', '2009/6/20 10:00', '2009/6/20 11:00', '2009/6/20 12:00', '2009/6/20 13:00', '2009/6/20 14:00', '2009/6/20 15:00', '2009/6/20 16:00', '2009/6/20 17:00', '2009/6/20 18:00', '2009/6/20 19:00', '2009/6/20 20:00', '2009/6/20 21:00', '2009/6/20 22:00', '2009/6/20 23:00',
                '2009/6/21 0:00', '2009/6/21 1:00', '2009/6/21 2:00', '2009/6/21 3:00', '2009/6/21 4:00', '2009/6/21 5:00', '2009/6/21 6:00', '2009/6/21 7:00', '2009/6/21 8:00', '2009/6/21 9:00', '2009/6/21 10:00', '2009/6/21 11:00', '2009/6/21 12:00', '2009/6/21 13:00', '2009/6/21 14:00', '2009/6/21 15:00', '2009/6/21 16:00', '2009/6/21 17:00', '2009/6/21 18:00', '2009/6/21 19:00', '2009/6/21 20:00', '2009/6/21 21:00', '2009/6/21 22:00', '2009/6/21 23:00',
                '2009/6/22 0:00', '2009/6/22 1:00', '2009/6/22 2:00', '2009/6/22 3:00', '2009/6/22 4:00', '2009/6/22 5:00', '2009/6/22 6:00', '2009/6/22 7:00', '2009/6/22 8:00', '2009/6/22 9:00', '2009/6/22 10:00', '2009/6/22 11:00', '2009/6/22 12:00', '2009/6/22 13:00', '2009/6/22 14:00', '2009/6/22 15:00', '2009/6/22 16:00', '2009/6/22 17:00', '2009/6/22 18:00', '2009/6/22 19:00', '2009/6/22 20:00', '2009/6/22 21:00', '2009/6/22 22:00', '2009/6/22 23:00',
                '2009/6/23 0:00', '2009/6/23 1:00', '2009/6/23 2:00', '2009/6/23 3:00', '2009/6/23 4:00', '2009/6/23 5:00', '2009/6/23 6:00', '2009/6/23 7:00', '2009/6/23 8:00', '2009/6/23 9:00', '2009/6/23 10:00', '2009/6/23 11:00', '2009/6/23 12:00', '2009/6/23 13:00', '2009/6/23 14:00', '2009/6/23 15:00', '2009/6/23 16:00', '2009/6/23 17:00', '2009/6/23 18:00', '2009/6/23 19:00', '2009/6/23 20:00', '2009/6/23 21:00', '2009/6/23 22:00', '2009/6/23 23:00',
                '2009/6/24 0:00', '2009/6/24 1:00', '2009/6/24 2:00', '2009/6/24 3:00', '2009/6/24 4:00', '2009/6/24 5:00', '2009/6/24 6:00', '2009/6/24 7:00', '2009/6/24 8:00', '2009/6/24 9:00', '2009/6/24 10:00', '2009/6/24 11:00', '2009/6/24 12:00', '2009/6/24 13:00', '2009/6/24 14:00', '2009/6/24 15:00', '2009/6/24 16:00', '2009/6/24 17:00', '2009/6/24 18:00', '2009/6/24 19:00', '2009/6/24 20:00', '2009/6/24 21:00', '2009/6/24 22:00', '2009/6/24 23:00',
                '2009/6/25 0:00', '2009/6/25 1:00', '2009/6/25 2:00', '2009/6/25 3:00', '2009/6/25 4:00', '2009/6/25 5:00', '2009/6/25 6:00', '2009/6/25 7:00', '2009/6/25 8:00', '2009/6/25 9:00', '2009/6/25 10:00', '2009/6/25 11:00', '2009/6/25 12:00', '2009/6/25 13:00', '2009/6/25 14:00', '2009/6/25 15:00', '2009/6/25 16:00', '2009/6/25 17:00', '2009/6/25 18:00', '2009/6/25 19:00', '2009/6/25 20:00', '2009/6/25 21:00', '2009/6/25 22:00', '2009/6/25 23:00',
                '2009/6/26 0:00', '2009/6/26 1:00', '2009/6/26 2:00', '2009/6/26 3:00', '2009/6/26 4:00', '2009/6/26 5:00', '2009/6/26 6:00', '2009/6/26 7:00', '2009/6/26 8:00', '2009/6/26 9:00', '2009/6/26 10:00', '2009/6/26 11:00', '2009/6/26 12:00', '2009/6/26 13:00', '2009/6/26 14:00', '2009/6/26 15:00', '2009/6/26 16:00', '2009/6/26 17:00', '2009/6/26 18:00', '2009/6/26 19:00', '2009/6/26 20:00', '2009/6/26 21:00', '2009/6/26 22:00', '2009/6/26 23:00',
                '2009/6/27 0:00', '2009/6/27 1:00', '2009/6/27 2:00', '2009/6/27 3:00', '2009/6/27 4:00', '2009/6/27 5:00', '2009/6/27 6:00', '2009/6/27 7:00', '2009/6/27 8:00', '2009/6/27 9:00', '2009/6/27 10:00', '2009/6/27 11:00', '2009/6/27 12:00', '2009/6/27 13:00', '2009/6/27 14:00', '2009/6/27 15:00', '2009/6/27 16:00', '2009/6/27 17:00', '2009/6/27 18:00', '2009/6/27 19:00', '2009/6/27 20:00', '2009/6/27 21:00', '2009/6/27 22:00', '2009/6/27 23:00',
                '2009/6/28 0:00', '2009/6/28 1:00', '2009/6/28 2:00', '2009/6/28 3:00', '2009/6/28 4:00', '2009/6/28 5:00', '2009/6/28 6:00', '2009/6/28 7:00', '2009/6/28 8:00', '2009/6/28 9:00', '2009/6/28 10:00', '2009/6/28 11:00', '2009/6/28 12:00', '2009/6/28 13:00', '2009/6/28 14:00', '2009/6/28 15:00', '2009/6/28 16:00', '2009/6/28 17:00', '2009/6/28 18:00', '2009/6/28 19:00', '2009/6/28 20:00', '2009/6/28 21:00', '2009/6/28 22:00', '2009/6/28 23:00',
                '2009/6/29 0:00', '2009/6/29 1:00', '2009/6/29 2:00', '2009/6/29 3:00', '2009/6/29 4:00', '2009/6/29 5:00', '2009/6/29 6:00', '2009/6/29 7:00', '2009/6/29 8:00', '2009/6/29 9:00', '2009/6/29 10:00', '2009/6/29 11:00', '2009/6/29 12:00', '2009/6/29 13:00', '2009/6/29 14:00', '2009/6/29 15:00', '2009/6/29 16:00', '2009/6/29 17:00', '2009/6/29 18:00', '2009/6/29 19:00', '2009/6/29 20:00', '2009/6/29 21:00', '2009/6/29 22:00', '2009/6/29 23:00',
                '2009/6/30 0:00', '2009/6/30 1:00', '2009/6/30 2:00', '2009/6/30 3:00', '2009/6/30 4:00', '2009/6/30 5:00', '2009/6/30 6:00', '2009/6/30 7:00', '2009/6/30 8:00', '2009/6/30 9:00', '2009/6/30 10:00', '2009/6/30 11:00', '2009/6/30 12:00', '2009/6/30 13:00', '2009/6/30 14:00', '2009/6/30 15:00', '2009/6/30 16:00', '2009/6/30 17:00', '2009/6/30 18:00', '2009/6/30 19:00', '2009/6/30 20:00', '2009/6/30 21:00', '2009/6/30 22:00', '2009/6/30 23:00',
                '2009/7/1 0:00', '2009/7/1 1:00', '2009/7/1 2:00', '2009/7/1 3:00', '2009/7/1 4:00', '2009/7/1 5:00', '2009/7/1 6:00', '2009/7/1 7:00', '2009/7/1 8:00', '2009/7/1 9:00', '2009/7/1 10:00', '2009/7/1 11:00', '2009/7/1 12:00', '2009/7/1 13:00', '2009/7/1 14:00', '2009/7/1 15:00', '2009/7/1 16:00', '2009/7/1 17:00', '2009/7/1 18:00', '2009/7/1 19:00', '2009/7/1 20:00', '2009/7/1 21:00', '2009/7/1 22:00', '2009/7/1 23:00',
                '2009/7/2 0:00', '2009/7/2 1:00', '2009/7/2 2:00', '2009/7/2 3:00', '2009/7/2 4:00', '2009/7/2 5:00', '2009/7/2 6:00', '2009/7/2 7:00', '2009/7/2 8:00', '2009/7/2 9:00', '2009/7/2 10:00', '2009/7/2 11:00', '2009/7/2 12:00', '2009/7/2 13:00', '2009/7/2 14:00', '2009/7/2 15:00', '2009/7/2 16:00', '2009/7/2 17:00', '2009/7/2 18:00', '2009/7/2 19:00', '2009/7/2 20:00', '2009/7/2 21:00', '2009/7/2 22:00', '2009/7/2 23:00',
                '2009/7/3 0:00', '2009/7/3 1:00', '2009/7/3 2:00', '2009/7/3 3:00', '2009/7/3 4:00', '2009/7/3 5:00', '2009/7/3 6:00', '2009/7/3 7:00', '2009/7/3 8:00', '2009/7/3 9:00', '2009/7/3 10:00', '2009/7/3 11:00', '2009/7/3 12:00', '2009/7/3 13:00', '2009/7/3 14:00', '2009/7/3 15:00', '2009/7/3 16:00', '2009/7/3 17:00', '2009/7/3 18:00', '2009/7/3 19:00', '2009/7/3 20:00', '2009/7/3 21:00', '2009/7/3 22:00', '2009/7/3 23:00',
                '2009/7/4 0:00', '2009/7/4 1:00', '2009/7/4 2:00', '2009/7/4 3:00', '2009/7/4 4:00', '2009/7/4 5:00', '2009/7/4 6:00', '2009/7/4 7:00', '2009/7/4 8:00', '2009/7/4 9:00', '2009/7/4 10:00', '2009/7/4 11:00', '2009/7/4 12:00', '2009/7/4 13:00', '2009/7/4 14:00', '2009/7/4 15:00', '2009/7/4 16:00', '2009/7/4 17:00', '2009/7/4 18:00', '2009/7/4 19:00', '2009/7/4 20:00', '2009/7/4 21:00', '2009/7/4 22:00', '2009/7/4 23:00',
                '2009/7/5 0:00', '2009/7/5 1:00', '2009/7/5 2:00', '2009/7/5 3:00', '2009/7/5 4:00', '2009/7/5 5:00', '2009/7/5 6:00', '2009/7/5 7:00', '2009/7/5 8:00', '2009/7/5 9:00', '2009/7/5 10:00', '2009/7/5 11:00', '2009/7/5 12:00', '2009/7/5 13:00', '2009/7/5 14:00', '2009/7/5 15:00', '2009/7/5 16:00', '2009/7/5 17:00', '2009/7/5 18:00', '2009/7/5 19:00', '2009/7/5 20:00', '2009/7/5 21:00', '2009/7/5 22:00', '2009/7/5 23:00',
                '2009/7/6 0:00', '2009/7/6 1:00', '2009/7/6 2:00', '2009/7/6 3:00', '2009/7/6 4:00', '2009/7/6 5:00', '2009/7/6 6:00', '2009/7/6 7:00', '2009/7/6 8:00', '2009/7/6 9:00', '2009/7/6 10:00', '2009/7/6 11:00', '2009/7/6 12:00', '2009/7/6 13:00', '2009/7/6 14:00', '2009/7/6 15:00', '2009/7/6 16:00', '2009/7/6 17:00', '2009/7/6 18:00', '2009/7/6 19:00', '2009/7/6 20:00', '2009/7/6 21:00', '2009/7/6 22:00', '2009/7/6 23:00',
                '2009/7/7 0:00', '2009/7/7 1:00', '2009/7/7 2:00', '2009/7/7 3:00', '2009/7/7 4:00', '2009/7/7 5:00', '2009/7/7 6:00', '2009/7/7 7:00', '2009/7/7 8:00', '2009/7/7 9:00', '2009/7/7 10:00', '2009/7/7 11:00', '2009/7/7 12:00', '2009/7/7 13:00', '2009/7/7 14:00', '2009/7/7 15:00', '2009/7/7 16:00', '2009/7/7 17:00', '2009/7/7 18:00', '2009/7/7 19:00', '2009/7/7 20:00', '2009/7/7 21:00', '2009/7/7 22:00', '2009/7/7 23:00',
                '2009/7/8 0:00', '2009/7/8 1:00', '2009/7/8 2:00', '2009/7/8 3:00', '2009/7/8 4:00', '2009/7/8 5:00', '2009/7/8 6:00', '2009/7/8 7:00', '2009/7/8 8:00', '2009/7/8 9:00', '2009/7/8 10:00', '2009/7/8 11:00', '2009/7/8 12:00', '2009/7/8 13:00', '2009/7/8 14:00', '2009/7/8 15:00', '2009/7/8 16:00', '2009/7/8 17:00', '2009/7/8 18:00', '2009/7/8 19:00', '2009/7/8 20:00', '2009/7/8 21:00', '2009/7/8 22:00', '2009/7/8 23:00',
                '2009/7/9 0:00', '2009/7/9 1:00', '2009/7/9 2:00', '2009/7/9 3:00', '2009/7/9 4:00', '2009/7/9 5:00', '2009/7/9 6:00', '2009/7/9 7:00', '2009/7/9 8:00', '2009/7/9 9:00', '2009/7/9 10:00', '2009/7/9 11:00', '2009/7/9 12:00', '2009/7/9 13:00', '2009/7/9 14:00', '2009/7/9 15:00', '2009/7/9 16:00', '2009/7/9 17:00', '2009/7/9 18:00', '2009/7/9 19:00', '2009/7/9 20:00', '2009/7/9 21:00', '2009/7/9 22:00', '2009/7/9 23:00',
                '2009/7/10 0:00', '2009/7/10 1:00', '2009/7/10 2:00', '2009/7/10 3:00', '2009/7/10 4:00', '2009/7/10 5:00', '2009/7/10 6:00', '2009/7/10 7:00', '2009/7/10 8:00', '2009/7/10 9:00', '2009/7/10 10:00', '2009/7/10 11:00', '2009/7/10 12:00', '2009/7/10 13:00', '2009/7/10 14:00', '2009/7/10 15:00', '2009/7/10 16:00', '2009/7/10 17:00', '2009/7/10 18:00', '2009/7/10 19:00', '2009/7/10 20:00', '2009/7/10 21:00', '2009/7/10 22:00', '2009/7/10 23:00',
                '2009/7/11 0:00', '2009/7/11 1:00', '2009/7/11 2:00', '2009/7/11 3:00', '2009/7/11 4:00', '2009/7/11 5:00', '2009/7/11 6:00', '2009/7/11 7:00', '2009/7/11 8:00', '2009/7/11 9:00', '2009/7/11 10:00', '2009/7/11 11:00', '2009/7/11 12:00', '2009/7/11 13:00', '2009/7/11 14:00', '2009/7/11 15:00', '2009/7/11 16:00', '2009/7/11 17:00', '2009/7/11 18:00', '2009/7/11 19:00', '2009/7/11 20:00', '2009/7/11 21:00', '2009/7/11 22:00', '2009/7/11 23:00',
                '2009/7/12 0:00', '2009/7/12 1:00', '2009/7/12 2:00', '2009/7/12 3:00', '2009/7/12 4:00', '2009/7/12 5:00', '2009/7/12 6:00', '2009/7/12 7:00', '2009/7/12 8:00', '2009/7/12 9:00', '2009/7/12 10:00', '2009/7/12 11:00', '2009/7/12 12:00', '2009/7/12 13:00', '2009/7/12 14:00', '2009/7/12 15:00', '2009/7/12 16:00', '2009/7/12 17:00', '2009/7/12 18:00', '2009/7/12 19:00', '2009/7/12 20:00', '2009/7/12 21:00', '2009/7/12 22:00', '2009/7/12 23:00',
                '2009/7/13 0:00', '2009/7/13 1:00', '2009/7/13 2:00', '2009/7/13 3:00', '2009/7/13 4:00', '2009/7/13 5:00', '2009/7/13 6:00', '2009/7/13 7:00', '2009/7/13 8:00', '2009/7/13 9:00', '2009/7/13 10:00', '2009/7/13 11:00', '2009/7/13 12:00', '2009/7/13 13:00', '2009/7/13 14:00', '2009/7/13 15:00', '2009/7/13 16:00', '2009/7/13 17:00', '2009/7/13 18:00', '2009/7/13 19:00', '2009/7/13 20:00', '2009/7/13 21:00', '2009/7/13 22:00', '2009/7/13 23:00',
                '2009/7/14 0:00', '2009/7/14 1:00', '2009/7/14 2:00', '2009/7/14 3:00', '2009/7/14 4:00', '2009/7/14 5:00', '2009/7/14 6:00', '2009/7/14 7:00', '2009/7/14 8:00', '2009/7/14 9:00', '2009/7/14 10:00', '2009/7/14 11:00', '2009/7/14 12:00', '2009/7/14 13:00', '2009/7/14 14:00', '2009/7/14 15:00', '2009/7/14 16:00', '2009/7/14 17:00', '2009/7/14 18:00', '2009/7/14 19:00', '2009/7/14 20:00', '2009/7/14 21:00', '2009/7/14 22:00', '2009/7/14 23:00',
                '2009/7/15 0:00', '2009/7/15 1:00', '2009/7/15 2:00', '2009/7/15 3:00', '2009/7/15 4:00', '2009/7/15 5:00', '2009/7/15 6:00', '2009/7/15 7:00', '2009/7/15 8:00', '2009/7/15 9:00', '2009/7/15 10:00', '2009/7/15 11:00', '2009/7/15 12:00', '2009/7/15 13:00', '2009/7/15 14:00', '2009/7/15 15:00', '2009/7/15 16:00', '2009/7/15 17:00', '2009/7/15 18:00', '2009/7/15 19:00', '2009/7/15 20:00', '2009/7/15 21:00', '2009/7/15 22:00', '2009/7/15 23:00',
                '2009/7/16 0:00', '2009/7/16 1:00', '2009/7/16 2:00', '2009/7/16 3:00', '2009/7/16 4:00', '2009/7/16 5:00', '2009/7/16 6:00', '2009/7/16 7:00', '2009/7/16 8:00', '2009/7/16 9:00', '2009/7/16 10:00', '2009/7/16 11:00', '2009/7/16 12:00', '2009/7/16 13:00', '2009/7/16 14:00', '2009/7/16 15:00', '2009/7/16 16:00', '2009/7/16 17:00', '2009/7/16 18:00', '2009/7/16 19:00', '2009/7/16 20:00', '2009/7/16 21:00', '2009/7/16 22:00', '2009/7/16 23:00',
                '2009/7/17 0:00', '2009/7/17 1:00', '2009/7/17 2:00', '2009/7/17 3:00', '2009/7/17 4:00', '2009/7/17 5:00', '2009/7/17 6:00', '2009/7/17 7:00', '2009/7/17 8:00', '2009/7/17 9:00', '2009/7/17 10:00', '2009/7/17 11:00', '2009/7/17 12:00', '2009/7/17 13:00', '2009/7/17 14:00', '2009/7/17 15:00', '2009/7/17 16:00', '2009/7/17 17:00', '2009/7/17 18:00', '2009/7/17 19:00', '2009/7/17 20:00', '2009/7/17 21:00', '2009/7/17 22:00', '2009/7/17 23:00',
                '2009/7/18 0:00', '2009/7/18 1:00', '2009/7/18 2:00', '2009/7/18 3:00', '2009/7/18 4:00', '2009/7/18 5:00', '2009/7/18 6:00', '2009/7/18 7:00', '2009/7/18 8:00', '2009/7/18 9:00', '2009/7/18 10:00', '2009/7/18 11:00', '2009/7/18 12:00', '2009/7/18 13:00', '2009/7/18 14:00', '2009/7/18 15:00', '2009/7/18 16:00', '2009/7/18 17:00', '2009/7/18 18:00', '2009/7/18 19:00', '2009/7/18 20:00', '2009/7/18 21:00', '2009/7/18 22:00', '2009/7/18 23:00',
                '2009/7/19 0:00', '2009/7/19 1:00', '2009/7/19 2:00', '2009/7/19 3:00', '2009/7/19 4:00', '2009/7/19 5:00', '2009/7/19 6:00', '2009/7/19 7:00', '2009/7/19 8:00', '2009/7/19 9:00', '2009/7/19 10:00', '2009/7/19 11:00', '2009/7/19 12:00', '2009/7/19 13:00', '2009/7/19 14:00', '2009/7/19 15:00', '2009/7/19 16:00', '2009/7/19 17:00', '2009/7/19 18:00', '2009/7/19 19:00', '2009/7/19 20:00', '2009/7/19 21:00', '2009/7/19 22:00', '2009/7/19 23:00',
                '2009/7/20 0:00', '2009/7/20 1:00', '2009/7/20 2:00', '2009/7/20 3:00', '2009/7/20 4:00', '2009/7/20 5:00', '2009/7/20 6:00', '2009/7/20 7:00', '2009/7/20 8:00', '2009/7/20 9:00', '2009/7/20 10:00', '2009/7/20 11:00', '2009/7/20 12:00', '2009/7/20 13:00', '2009/7/20 14:00', '2009/7/20 15:00', '2009/7/20 16:00', '2009/7/20 17:00', '2009/7/20 18:00', '2009/7/20 19:00', '2009/7/20 20:00', '2009/7/20 21:00', '2009/7/20 22:00', '2009/7/20 23:00',
                '2009/7/21 0:00', '2009/7/21 1:00', '2009/7/21 2:00', '2009/7/21 3:00', '2009/7/21 4:00', '2009/7/21 5:00', '2009/7/21 6:00', '2009/7/21 7:00', '2009/7/21 8:00', '2009/7/21 9:00', '2009/7/21 10:00', '2009/7/21 11:00', '2009/7/21 12:00', '2009/7/21 13:00', '2009/7/21 14:00', '2009/7/21 15:00', '2009/7/21 16:00', '2009/7/21 17:00', '2009/7/21 18:00', '2009/7/21 19:00', '2009/7/21 20:00', '2009/7/21 21:00', '2009/7/21 22:00', '2009/7/21 23:00',
                '2009/7/22 0:00', '2009/7/22 1:00', '2009/7/22 2:00', '2009/7/22 3:00', '2009/7/22 4:00', '2009/7/22 5:00', '2009/7/22 6:00', '2009/7/22 7:00', '2009/7/22 8:00', '2009/7/22 9:00', '2009/7/22 10:00', '2009/7/22 11:00', '2009/7/22 12:00', '2009/7/22 13:00', '2009/7/22 14:00', '2009/7/22 15:00', '2009/7/22 16:00', '2009/7/22 17:00', '2009/7/22 18:00', '2009/7/22 19:00', '2009/7/22 20:00', '2009/7/22 21:00', '2009/7/22 22:00', '2009/7/22 23:00',
                '2009/7/23 0:00', '2009/7/23 1:00', '2009/7/23 2:00', '2009/7/23 3:00', '2009/7/23 4:00', '2009/7/23 5:00', '2009/7/23 6:00', '2009/7/23 7:00', '2009/7/23 8:00', '2009/7/23 9:00', '2009/7/23 10:00', '2009/7/23 11:00', '2009/7/23 12:00', '2009/7/23 13:00', '2009/7/23 14:00', '2009/7/23 15:00', '2009/7/23 16:00', '2009/7/23 17:00', '2009/7/23 18:00', '2009/7/23 19:00', '2009/7/23 20:00', '2009/7/23 21:00', '2009/7/23 22:00', '2009/7/23 23:00',
                '2009/7/24 0:00', '2009/7/24 1:00', '2009/7/24 2:00', '2009/7/24 3:00', '2009/7/24 4:00', '2009/7/24 5:00', '2009/7/24 6:00', '2009/7/24 7:00', '2009/7/24 8:00', '2009/7/24 9:00', '2009/7/24 10:00', '2009/7/24 11:00', '2009/7/24 12:00', '2009/7/24 13:00', '2009/7/24 14:00', '2009/7/24 15:00', '2009/7/24 16:00', '2009/7/24 17:00', '2009/7/24 18:00', '2009/7/24 19:00', '2009/7/24 20:00', '2009/7/24 21:00', '2009/7/24 22:00', '2009/7/24 23:00',
                '2009/7/25 0:00', '2009/7/25 1:00', '2009/7/25 2:00', '2009/7/25 3:00', '2009/7/25 4:00', '2009/7/25 5:00', '2009/7/25 6:00', '2009/7/25 7:00', '2009/7/25 8:00', '2009/7/25 9:00', '2009/7/25 10:00', '2009/7/25 11:00', '2009/7/25 12:00', '2009/7/25 13:00', '2009/7/25 14:00', '2009/7/25 15:00', '2009/7/25 16:00', '2009/7/25 17:00', '2009/7/25 18:00', '2009/7/25 19:00', '2009/7/25 20:00', '2009/7/25 21:00', '2009/7/25 22:00', '2009/7/25 23:00',
                '2009/7/26 0:00', '2009/7/26 1:00', '2009/7/26 2:00', '2009/7/26 3:00', '2009/7/26 4:00', '2009/7/26 5:00', '2009/7/26 6:00', '2009/7/26 7:00', '2009/7/26 8:00', '2009/7/26 9:00', '2009/7/26 10:00', '2009/7/26 11:00', '2009/7/26 12:00', '2009/7/26 13:00', '2009/7/26 14:00', '2009/7/26 15:00', '2009/7/26 16:00', '2009/7/26 17:00', '2009/7/26 18:00', '2009/7/26 19:00', '2009/7/26 20:00', '2009/7/26 21:00', '2009/7/26 22:00', '2009/7/26 23:00',
                '2009/7/27 0:00', '2009/7/27 1:00', '2009/7/27 2:00', '2009/7/27 3:00', '2009/7/27 4:00', '2009/7/27 5:00', '2009/7/27 6:00', '2009/7/27 7:00', '2009/7/27 8:00', '2009/7/27 9:00', '2009/7/27 10:00', '2009/7/27 11:00', '2009/7/27 12:00', '2009/7/27 13:00', '2009/7/27 14:00', '2009/7/27 15:00', '2009/7/27 16:00', '2009/7/27 17:00', '2009/7/27 18:00', '2009/7/27 19:00', '2009/7/27 20:00', '2009/7/27 21:00', '2009/7/27 22:00', '2009/7/27 23:00',
                '2009/7/28 0:00', '2009/7/28 1:00', '2009/7/28 2:00', '2009/7/28 3:00', '2009/7/28 4:00', '2009/7/28 5:00', '2009/7/28 6:00', '2009/7/28 7:00', '2009/7/28 8:00', '2009/7/28 9:00', '2009/7/28 10:00', '2009/7/28 11:00', '2009/7/28 12:00', '2009/7/28 13:00', '2009/7/28 14:00', '2009/7/28 15:00', '2009/7/28 16:00', '2009/7/28 17:00', '2009/7/28 18:00', '2009/7/28 19:00', '2009/7/28 20:00', '2009/7/28 21:00', '2009/7/28 22:00', '2009/7/28 23:00',
                '2009/7/29 0:00', '2009/7/29 1:00', '2009/7/29 2:00', '2009/7/29 3:00', '2009/7/29 4:00', '2009/7/29 5:00', '2009/7/29 6:00', '2009/7/29 7:00', '2009/7/29 8:00', '2009/7/29 9:00', '2009/7/29 10:00', '2009/7/29 11:00', '2009/7/29 12:00', '2009/7/29 13:00', '2009/7/29 14:00', '2009/7/29 15:00', '2009/7/29 16:00', '2009/7/29 17:00', '2009/7/29 18:00', '2009/7/29 19:00', '2009/7/29 20:00', '2009/7/29 21:00', '2009/7/29 22:00', '2009/7/29 23:00',
                '2009/7/30 0:00', '2009/7/30 1:00', '2009/7/30 2:00', '2009/7/30 3:00', '2009/7/30 4:00', '2009/7/30 5:00', '2009/7/30 6:00', '2009/7/30 7:00', '2009/7/30 8:00', '2009/7/30 9:00', '2009/7/30 10:00', '2009/7/30 11:00', '2009/7/30 12:00', '2009/7/30 13:00', '2009/7/30 14:00', '2009/7/30 15:00', '2009/7/30 16:00', '2009/7/30 17:00', '2009/7/30 18:00', '2009/7/30 19:00', '2009/7/30 20:00', '2009/7/30 21:00', '2009/7/30 22:00', '2009/7/30 23:00',
                '2009/7/31 0:00', '2009/7/31 1:00', '2009/7/31 2:00', '2009/7/31 3:00', '2009/7/31 4:00', '2009/7/31 5:00', '2009/7/31 6:00', '2009/7/31 7:00', '2009/7/31 8:00', '2009/7/31 9:00', '2009/7/31 10:00', '2009/7/31 11:00', '2009/7/31 12:00', '2009/7/31 13:00', '2009/7/31 14:00', '2009/7/31 15:00', '2009/7/31 16:00', '2009/7/31 17:00', '2009/7/31 18:00', '2009/7/31 19:00', '2009/7/31 20:00', '2009/7/31 21:00', '2009/7/31 22:00', '2009/7/31 23:00',
                '2009/8/1 0:00', '2009/8/1 1:00', '2009/8/1 2:00', '2009/8/1 3:00', '2009/8/1 4:00', '2009/8/1 5:00', '2009/8/1 6:00', '2009/8/1 7:00', '2009/8/1 8:00', '2009/8/1 9:00', '2009/8/1 10:00', '2009/8/1 11:00', '2009/8/1 12:00', '2009/8/1 13:00', '2009/8/1 14:00', '2009/8/1 15:00', '2009/8/1 16:00', '2009/8/1 17:00', '2009/8/1 18:00', '2009/8/1 19:00', '2009/8/1 20:00', '2009/8/1 21:00', '2009/8/1 22:00', '2009/8/1 23:00', '2009/8/2 0:00', '2009/8/2 1:00', '2009/8/2 2:00', '2009/8/2 3:00', '2009/8/2 4:00', '2009/8/2 5:00', '2009/8/2 6:00', '2009/8/2 7:00', '2009/8/2 8:00', '2009/8/2 9:00', '2009/8/2 10:00', '2009/8/2 11:00', '2009/8/2 12:00', '2009/8/2 13:00', '2009/8/2 14:00', '2009/8/2 15:00', '2009/8/2 16:00', '2009/8/2 17:00', '2009/8/2 18:00', '2009/8/2 19:00', '2009/8/2 20:00', '2009/8/2 21:00', '2009/8/2 22:00', '2009/8/2 23:00', '2009/8/3 0:00', '2009/8/3 1:00', '2009/8/3 2:00', '2009/8/3 3:00', '2009/8/3 4:00', '2009/8/3 5:00', '2009/8/3 6:00', '2009/8/3 7:00', '2009/8/3 8:00', '2009/8/3 9:00', '2009/8/3 10:00', '2009/8/3 11:00', '2009/8/3 12:00', '2009/8/3 13:00', '2009/8/3 14:00', '2009/8/3 15:00', '2009/8/3 16:00', '2009/8/3 17:00', '2009/8/3 18:00', '2009/8/3 19:00', '2009/8/3 20:00', '2009/8/3 21:00', '2009/8/3 22:00', '2009/8/3 23:00', '2009/8/4 0:00', '2009/8/4 1:00', '2009/8/4 2:00', '2009/8/4 3:00', '2009/8/4 4:00', '2009/8/4 5:00', '2009/8/4 6:00', '2009/8/4 7:00', '2009/8/4 8:00', '2009/8/4 9:00', '2009/8/4 10:00', '2009/8/4 11:00', '2009/8/4 12:00', '2009/8/4 13:00', '2009/8/4 14:00', '2009/8/4 15:00', '2009/8/4 16:00', '2009/8/4 17:00', '2009/8/4 18:00', '2009/8/4 19:00', '2009/8/4 20:00', '2009/8/4 21:00', '2009/8/4 22:00', '2009/8/4 23:00', '2009/8/5 0:00', '2009/8/5 1:00', '2009/8/5 2:00', '2009/8/5 3:00', '2009/8/5 4:00', '2009/8/5 5:00', '2009/8/5 6:00', '2009/8/5 7:00', '2009/8/5 8:00', '2009/8/5 9:00', '2009/8/5 10:00', '2009/8/5 11:00', '2009/8/5 12:00', '2009/8/5 13:00', '2009/8/5 14:00', '2009/8/5 15:00', '2009/8/5 16:00', '2009/8/5 17:00', '2009/8/5 18:00', '2009/8/5 19:00', '2009/8/5 20:00', '2009/8/5 21:00', '2009/8/5 22:00', '2009/8/5 23:00', '2009/8/6 0:00', '2009/8/6 1:00', '2009/8/6 2:00', '2009/8/6 3:00', '2009/8/6 4:00', '2009/8/6 5:00', '2009/8/6 6:00', '2009/8/6 7:00', '2009/8/6 8:00', '2009/8/6 9:00', '2009/8/6 10:00', '2009/8/6 11:00', '2009/8/6 12:00', '2009/8/6 13:00', '2009/8/6 14:00', '2009/8/6 15:00', '2009/8/6 16:00', '2009/8/6 17:00', '2009/8/6 18:00', '2009/8/6 19:00', '2009/8/6 20:00', '2009/8/6 21:00', '2009/8/6 22:00', '2009/8/6 23:00', '2009/8/7 0:00', '2009/8/7 1:00', '2009/8/7 2:00', '2009/8/7 3:00', '2009/8/7 4:00', '2009/8/7 5:00', '2009/8/7 6:00', '2009/8/7 7:00', '2009/8/7 8:00', '2009/8/7 9:00', '2009/8/7 10:00', '2009/8/7 11:00', '2009/8/7 12:00', '2009/8/7 13:00', '2009/8/7 14:00', '2009/8/7 15:00', '2009/8/7 16:00', '2009/8/7 17:00', '2009/8/7 18:00', '2009/8/7 19:00', '2009/8/7 20:00', '2009/8/7 21:00', '2009/8/7 22:00', '2009/8/7 23:00', '2009/8/8 0:00', '2009/8/8 1:00', '2009/8/8 2:00', '2009/8/8 3:00', '2009/8/8 4:00', '2009/8/8 5:00', '2009/8/8 6:00', '2009/8/8 7:00', '2009/8/8 8:00', '2009/8/8 9:00', '2009/8/8 10:00', '2009/8/8 11:00', '2009/8/8 12:00', '2009/8/8 13:00', '2009/8/8 14:00', '2009/8/8 15:00', '2009/8/8 16:00', '2009/8/8 17:00', '2009/8/8 18:00', '2009/8/8 19:00', '2009/8/8 20:00', '2009/8/8 21:00', '2009/8/8 22:00', '2009/8/8 23:00', '2009/8/9 0:00', '2009/8/9 1:00', '2009/8/9 2:00', '2009/8/9 3:00', '2009/8/9 4:00', '2009/8/9 5:00', '2009/8/9 6:00', '2009/8/9 7:00', '2009/8/9 8:00', '2009/8/9 9:00', '2009/8/9 10:00', '2009/8/9 11:00', '2009/8/9 12:00', '2009/8/9 13:00', '2009/8/9 14:00', '2009/8/9 15:00', '2009/8/9 16:00', '2009/8/9 17:00', '2009/8/9 18:00', '2009/8/9 19:00', '2009/8/9 20:00', '2009/8/9 21:00', '2009/8/9 22:00', '2009/8/9 23:00', '2009/8/10 0:00', '2009/8/10 1:00', '2009/8/10 2:00', '2009/8/10 3:00', '2009/8/10 4:00', '2009/8/10 5:00', '2009/8/10 6:00', '2009/8/10 7:00', '2009/8/10 8:00', '2009/8/10 9:00', '2009/8/10 10:00', '2009/8/10 11:00', '2009/8/10 12:00', '2009/8/10 13:00', '2009/8/10 14:00', '2009/8/10 15:00', '2009/8/10 16:00', '2009/8/10 17:00', '2009/8/10 18:00', '2009/8/10 19:00', '2009/8/10 20:00', '2009/8/10 21:00', '2009/8/10 22:00', '2009/8/10 23:00', '2009/8/11 0:00', '2009/8/11 1:00', '2009/8/11 2:00', '2009/8/11 3:00', '2009/8/11 4:00', '2009/8/11 5:00', '2009/8/11 6:00', '2009/8/11 7:00', '2009/8/11 8:00', '2009/8/11 9:00', '2009/8/11 10:00', '2009/8/11 11:00', '2009/8/11 12:00', '2009/8/11 13:00', '2009/8/11 14:00', '2009/8/11 15:00', '2009/8/11 16:00', '2009/8/11 17:00', '2009/8/11 18:00', '2009/8/11 19:00', '2009/8/11 20:00', '2009/8/11 21:00', '2009/8/11 22:00', '2009/8/11 23:00', '2009/8/12 0:00', '2009/8/12 1:00', '2009/8/12 2:00', '2009/8/12 3:00', '2009/8/12 4:00', '2009/8/12 5:00', '2009/8/12 6:00', '2009/8/12 7:00', '2009/8/12 8:00', '2009/8/12 9:00', '2009/8/12 10:00', '2009/8/12 11:00', '2009/8/12 12:00', '2009/8/12 13:00', '2009/8/12 14:00', '2009/8/12 15:00', '2009/8/12 16:00', '2009/8/12 17:00', '2009/8/12 18:00', '2009/8/12 19:00', '2009/8/12 20:00', '2009/8/12 21:00', '2009/8/12 22:00', '2009/8/12 23:00', '2009/8/13 0:00', '2009/8/13 1:00', '2009/8/13 2:00', '2009/8/13 3:00', '2009/8/13 4:00', '2009/8/13 5:00', '2009/8/13 6:00', '2009/8/13 7:00', '2009/8/13 8:00', '2009/8/13 9:00', '2009/8/13 10:00', '2009/8/13 11:00', '2009/8/13 12:00', '2009/8/13 13:00', '2009/8/13 14:00', '2009/8/13 15:00', '2009/8/13 16:00', '2009/8/13 17:00', '2009/8/13 18:00', '2009/8/13 19:00', '2009/8/13 20:00', '2009/8/13 21:00', '2009/8/13 22:00', '2009/8/13 23:00', '2009/8/14 0:00', '2009/8/14 1:00', '2009/8/14 2:00', '2009/8/14 3:00', '2009/8/14 4:00', '2009/8/14 5:00', '2009/8/14 6:00', '2009/8/14 7:00', '2009/8/14 8:00', '2009/8/14 9:00', '2009/8/14 10:00', '2009/8/14 11:00', '2009/8/14 12:00', '2009/8/14 13:00', '2009/8/14 14:00', '2009/8/14 15:00', '2009/8/14 16:00', '2009/8/14 17:00', '2009/8/14 18:00', '2009/8/14 19:00', '2009/8/14 20:00', '2009/8/14 21:00', '2009/8/14 22:00', '2009/8/14 23:00', '2009/8/15 0:00', '2009/8/15 1:00', '2009/8/15 2:00', '2009/8/15 3:00', '2009/8/15 4:00', '2009/8/15 5:00', '2009/8/15 6:00', '2009/8/15 7:00', '2009/8/15 8:00', '2009/8/15 9:00', '2009/8/15 10:00', '2009/8/15 11:00', '2009/8/15 12:00', '2009/8/15 13:00', '2009/8/15 14:00', '2009/8/15 15:00', '2009/8/15 16:00', '2009/8/15 17:00', '2009/8/15 18:00', '2009/8/15 19:00', '2009/8/15 20:00', '2009/8/15 21:00', '2009/8/15 22:00', '2009/8/15 23:00', '2009/8/16 0:00', '2009/8/16 1:00', '2009/8/16 2:00', '2009/8/16 3:00', '2009/8/16 4:00', '2009/8/16 5:00', '2009/8/16 6:00', '2009/8/16 7:00', '2009/8/16 8:00', '2009/8/16 9:00', '2009/8/16 10:00', '2009/8/16 11:00', '2009/8/16 12:00', '2009/8/16 13:00', '2009/8/16 14:00', '2009/8/16 15:00', '2009/8/16 16:00', '2009/8/16 17:00', '2009/8/16 18:00', '2009/8/16 19:00', '2009/8/16 20:00', '2009/8/16 21:00', '2009/8/16 22:00', '2009/8/16 23:00', '2009/8/17 0:00', '2009/8/17 1:00', '2009/8/17 2:00', '2009/8/17 3:00', '2009/8/17 4:00', '2009/8/17 5:00', '2009/8/17 6:00', '2009/8/17 7:00', '2009/8/17 8:00', '2009/8/17 9:00', '2009/8/17 10:00', '2009/8/17 11:00', '2009/8/17 12:00', '2009/8/17 13:00', '2009/8/17 14:00', '2009/8/17 15:00', '2009/8/17 16:00', '2009/8/17 17:00', '2009/8/17 18:00', '2009/8/17 19:00', '2009/8/17 20:00', '2009/8/17 21:00', '2009/8/17 22:00', '2009/8/17 23:00', '2009/8/18 0:00', '2009/8/18 1:00', '2009/8/18 2:00', '2009/8/18 3:00', '2009/8/18 4:00', '2009/8/18 5:00', '2009/8/18 6:00', '2009/8/18 7:00', '2009/8/18 8:00', '2009/8/18 9:00', '2009/8/18 10:00', '2009/8/18 11:00', '2009/8/18 12:00', '2009/8/18 13:00', '2009/8/18 14:00', '2009/8/18 15:00', '2009/8/18 16:00', '2009/8/18 17:00', '2009/8/18 18:00', '2009/8/18 19:00', '2009/8/18 20:00', '2009/8/18 21:00', '2009/8/18 22:00', '2009/8/18 23:00', '2009/8/19 0:00', '2009/8/19 1:00', '2009/8/19 2:00', '2009/8/19 3:00', '2009/8/19 4:00', '2009/8/19 5:00', '2009/8/19 6:00', '2009/8/19 7:00', '2009/8/19 8:00', '2009/8/19 9:00', '2009/8/19 10:00', '2009/8/19 11:00', '2009/8/19 12:00', '2009/8/19 13:00', '2009/8/19 14:00', '2009/8/19 15:00', '2009/8/19 16:00', '2009/8/19 17:00', '2009/8/19 18:00', '2009/8/19 19:00', '2009/8/19 20:00', '2009/8/19 21:00', '2009/8/19 22:00', '2009/8/19 23:00', '2009/8/20 0:00', '2009/8/20 1:00', '2009/8/20 2:00', '2009/8/20 3:00', '2009/8/20 4:00', '2009/8/20 5:00', '2009/8/20 6:00', '2009/8/20 7:00', '2009/8/20 8:00', '2009/8/20 9:00', '2009/8/20 10:00', '2009/8/20 11:00', '2009/8/20 12:00', '2009/8/20 13:00', '2009/8/20 14:00', '2009/8/20 15:00', '2009/8/20 16:00', '2009/8/20 17:00', '2009/8/20 18:00', '2009/8/20 19:00', '2009/8/20 20:00', '2009/8/20 21:00', '2009/8/20 22:00', '2009/8/20 23:00', '2009/8/21 0:00', '2009/8/21 1:00', '2009/8/21 2:00', '2009/8/21 3:00', '2009/8/21 4:00', '2009/8/21 5:00', '2009/8/21 6:00', '2009/8/21 7:00', '2009/8/21 8:00', '2009/8/21 9:00', '2009/8/21 10:00', '2009/8/21 11:00', '2009/8/21 12:00', '2009/8/21 13:00', '2009/8/21 14:00', '2009/8/21 15:00', '2009/8/21 16:00', '2009/8/21 17:00', '2009/8/21 18:00', '2009/8/21 19:00', '2009/8/21 20:00', '2009/8/21 21:00', '2009/8/21 22:00', '2009/8/21 23:00', '2009/8/22 0:00', '2009/8/22 1:00', '2009/8/22 2:00', '2009/8/22 3:00', '2009/8/22 4:00', '2009/8/22 5:00', '2009/8/22 6:00', '2009/8/22 7:00', '2009/8/22 8:00', '2009/8/22 9:00', '2009/8/22 10:00', '2009/8/22 11:00', '2009/8/22 12:00', '2009/8/22 13:00', '2009/8/22 14:00', '2009/8/22 15:00', '2009/8/22 16:00', '2009/8/22 17:00', '2009/8/22 18:00', '2009/8/22 19:00', '2009/8/22 20:00', '2009/8/22 21:00', '2009/8/22 22:00', '2009/8/22 23:00', '2009/8/23 0:00', '2009/8/23 1:00', '2009/8/23 2:00', '2009/8/23 3:00', '2009/8/23 4:00', '2009/8/23 5:00', '2009/8/23 6:00', '2009/8/23 7:00', '2009/8/23 8:00', '2009/8/23 9:00', '2009/8/23 10:00', '2009/8/23 11:00', '2009/8/23 12:00', '2009/8/23 13:00', '2009/8/23 14:00', '2009/8/23 15:00', '2009/8/23 16:00', '2009/8/23 17:00', '2009/8/23 18:00', '2009/8/23 19:00', '2009/8/23 20:00', '2009/8/23 21:00', '2009/8/23 22:00', '2009/8/23 23:00', '2009/8/24 0:00', '2009/8/24 1:00', '2009/8/24 2:00', '2009/8/24 3:00', '2009/8/24 4:00', '2009/8/24 5:00', '2009/8/24 6:00', '2009/8/24 7:00', '2009/8/24 8:00', '2009/8/24 9:00', '2009/8/24 10:00', '2009/8/24 11:00', '2009/8/24 12:00', '2009/8/24 13:00', '2009/8/24 14:00', '2009/8/24 15:00', '2009/8/24 16:00', '2009/8/24 17:00', '2009/8/24 18:00', '2009/8/24 19:00', '2009/8/24 20:00', '2009/8/24 21:00', '2009/8/24 22:00', '2009/8/24 23:00', '2009/8/25 0:00', '2009/8/25 1:00', '2009/8/25 2:00', '2009/8/25 3:00', '2009/8/25 4:00', '2009/8/25 5:00', '2009/8/25 6:00', '2009/8/25 7:00', '2009/8/25 8:00', '2009/8/25 9:00', '2009/8/25 10:00', '2009/8/25 11:00', '2009/8/25 12:00', '2009/8/25 13:00', '2009/8/25 14:00', '2009/8/25 15:00', '2009/8/25 16:00', '2009/8/25 17:00', '2009/8/25 18:00', '2009/8/25 19:00', '2009/8/25 20:00', '2009/8/25 21:00', '2009/8/25 22:00', '2009/8/25 23:00', '2009/8/26 0:00', '2009/8/26 1:00', '2009/8/26 2:00', '2009/8/26 3:00', '2009/8/26 4:00', '2009/8/26 5:00', '2009/8/26 6:00', '2009/8/26 7:00', '2009/8/26 8:00', '2009/8/26 9:00', '2009/8/26 10:00', '2009/8/26 11:00', '2009/8/26 12:00', '2009/8/26 13:00', '2009/8/26 14:00', '2009/8/26 15:00', '2009/8/26 16:00', '2009/8/26 17:00', '2009/8/26 18:00', '2009/8/26 19:00', '2009/8/26 20:00', '2009/8/26 21:00', '2009/8/26 22:00', '2009/8/26 23:00', '2009/8/27 0:00', '2009/8/27 1:00', '2009/8/27 2:00', '2009/8/27 3:00', '2009/8/27 4:00', '2009/8/27 5:00', '2009/8/27 6:00', '2009/8/27 7:00', '2009/8/27 8:00', '2009/8/27 9:00', '2009/8/27 10:00', '2009/8/27 11:00', '2009/8/27 12:00', '2009/8/27 13:00', '2009/8/27 14:00', '2009/8/27 15:00', '2009/8/27 16:00', '2009/8/27 17:00', '2009/8/27 18:00', '2009/8/27 19:00', '2009/8/27 20:00', '2009/8/27 21:00', '2009/8/27 22:00', '2009/8/27 23:00', '2009/8/28 0:00', '2009/8/28 1:00', '2009/8/28 2:00', '2009/8/28 3:00', '2009/8/28 4:00', '2009/8/28 5:00', '2009/8/28 6:00', '2009/8/28 7:00', '2009/8/28 8:00', '2009/8/28 9:00', '2009/8/28 10:00', '2009/8/28 11:00', '2009/8/28 12:00', '2009/8/28 13:00', '2009/8/28 14:00', '2009/8/28 15:00', '2009/8/28 16:00', '2009/8/28 17:00', '2009/8/28 18:00', '2009/8/28 19:00', '2009/8/28 20:00', '2009/8/28 21:00', '2009/8/28 22:00', '2009/8/28 23:00', '2009/8/29 0:00', '2009/8/29 1:00', '2009/8/29 2:00', '2009/8/29 3:00', '2009/8/29 4:00', '2009/8/29 5:00', '2009/8/29 6:00', '2009/8/29 7:00', '2009/8/29 8:00', '2009/8/29 9:00', '2009/8/29 10:00', '2009/8/29 11:00', '2009/8/29 12:00', '2009/8/29 13:00', '2009/8/29 14:00', '2009/8/29 15:00', '2009/8/29 16:00', '2009/8/29 17:00', '2009/8/29 18:00', '2009/8/29 19:00', '2009/8/29 20:00', '2009/8/29 21:00', '2009/8/29 22:00', '2009/8/29 23:00', '2009/8/30 0:00', '2009/8/30 1:00', '2009/8/30 2:00', '2009/8/30 3:00', '2009/8/30 4:00', '2009/8/30 5:00', '2009/8/30 6:00', '2009/8/30 7:00', '2009/8/30 8:00', '2009/8/30 9:00', '2009/8/30 10:00', '2009/8/30 11:00', '2009/8/30 12:00', '2009/8/30 13:00', '2009/8/30 14:00', '2009/8/30 15:00', '2009/8/30 16:00', '2009/8/30 17:00', '2009/8/30 18:00', '2009/8/30 19:00', '2009/8/30 20:00', '2009/8/30 21:00', '2009/8/30 22:00', '2009/8/30 23:00', '2009/8/31 0:00', '2009/8/31 1:00', '2009/8/31 2:00', '2009/8/31 3:00', '2009/8/31 4:00', '2009/8/31 5:00', '2009/8/31 6:00', '2009/8/31 7:00', '2009/8/31 8:00', '2009/8/31 9:00', '2009/8/31 10:00', '2009/8/31 11:00', '2009/8/31 12:00', '2009/8/31 13:00', '2009/8/31 14:00', '2009/8/31 15:00', '2009/8/31 16:00', '2009/8/31 17:00', '2009/8/31 18:00', '2009/8/31 19:00', '2009/8/31 20:00', '2009/8/31 21:00', '2009/8/31 22:00', '2009/8/31 23:00',
                '2009/9/1 0:00', '2009/9/1 1:00', '2009/9/1 2:00', '2009/9/1 3:00', '2009/9/1 4:00', '2009/9/1 5:00', '2009/9/1 6:00', '2009/9/1 7:00', '2009/9/1 8:00', '2009/9/1 9:00', '2009/9/1 10:00', '2009/9/1 11:00', '2009/9/1 12:00', '2009/9/1 13:00', '2009/9/1 14:00', '2009/9/1 15:00', '2009/9/1 16:00', '2009/9/1 17:00', '2009/9/1 18:00', '2009/9/1 19:00', '2009/9/1 20:00', '2009/9/1 21:00', '2009/9/1 22:00', '2009/9/1 23:00', '2009/9/2 0:00', '2009/9/2 1:00', '2009/9/2 2:00', '2009/9/2 3:00', '2009/9/2 4:00', '2009/9/2 5:00', '2009/9/2 6:00', '2009/9/2 7:00', '2009/9/2 8:00', '2009/9/2 9:00', '2009/9/2 10:00', '2009/9/2 11:00', '2009/9/2 12:00', '2009/9/2 13:00', '2009/9/2 14:00', '2009/9/2 15:00', '2009/9/2 16:00', '2009/9/2 17:00', '2009/9/2 18:00', '2009/9/2 19:00', '2009/9/2 20:00', '2009/9/2 21:00', '2009/9/2 22:00', '2009/9/2 23:00', '2009/9/3 0:00', '2009/9/3 1:00', '2009/9/3 2:00', '2009/9/3 3:00', '2009/9/3 4:00', '2009/9/3 5:00', '2009/9/3 6:00', '2009/9/3 7:00', '2009/9/3 8:00', '2009/9/3 9:00', '2009/9/3 10:00', '2009/9/3 11:00', '2009/9/3 12:00', '2009/9/3 13:00', '2009/9/3 14:00', '2009/9/3 15:00', '2009/9/3 16:00', '2009/9/3 17:00', '2009/9/3 18:00', '2009/9/3 19:00', '2009/9/3 20:00', '2009/9/3 21:00', '2009/9/3 22:00', '2009/9/3 23:00', '2009/9/4 0:00', '2009/9/4 1:00', '2009/9/4 2:00', '2009/9/4 3:00', '2009/9/4 4:00', '2009/9/4 5:00', '2009/9/4 6:00', '2009/9/4 7:00', '2009/9/4 8:00', '2009/9/4 9:00', '2009/9/4 10:00', '2009/9/4 11:00', '2009/9/4 12:00', '2009/9/4 13:00', '2009/9/4 14:00', '2009/9/4 15:00', '2009/9/4 16:00', '2009/9/4 17:00', '2009/9/4 18:00', '2009/9/4 19:00', '2009/9/4 20:00', '2009/9/4 21:00', '2009/9/4 22:00', '2009/9/4 23:00', '2009/9/5 0:00', '2009/9/5 1:00', '2009/9/5 2:00', '2009/9/5 3:00', '2009/9/5 4:00', '2009/9/5 5:00', '2009/9/5 6:00', '2009/9/5 7:00', '2009/9/5 8:00', '2009/9/5 9:00', '2009/9/5 10:00', '2009/9/5 11:00', '2009/9/5 12:00', '2009/9/5 13:00', '2009/9/5 14:00', '2009/9/5 15:00', '2009/9/5 16:00', '2009/9/5 17:00', '2009/9/5 18:00', '2009/9/5 19:00', '2009/9/5 20:00', '2009/9/5 21:00', '2009/9/5 22:00', '2009/9/5 23:00', '2009/9/6 0:00', '2009/9/6 1:00', '2009/9/6 2:00', '2009/9/6 3:00', '2009/9/6 4:00', '2009/9/6 5:00', '2009/9/6 6:00', '2009/9/6 7:00', '2009/9/6 8:00', '2009/9/6 9:00', '2009/9/6 10:00', '2009/9/6 11:00', '2009/9/6 12:00', '2009/9/6 13:00', '2009/9/6 14:00', '2009/9/6 15:00', '2009/9/6 16:00', '2009/9/6 17:00', '2009/9/6 18:00', '2009/9/6 19:00', '2009/9/6 20:00', '2009/9/6 21:00', '2009/9/6 22:00', '2009/9/6 23:00', '2009/9/7 0:00', '2009/9/7 1:00', '2009/9/7 2:00', '2009/9/7 3:00', '2009/9/7 4:00', '2009/9/7 5:00', '2009/9/7 6:00', '2009/9/7 7:00', '2009/9/7 8:00', '2009/9/7 9:00', '2009/9/7 10:00', '2009/9/7 11:00', '2009/9/7 12:00', '2009/9/7 13:00', '2009/9/7 14:00', '2009/9/7 15:00', '2009/9/7 16:00', '2009/9/7 17:00', '2009/9/7 18:00', '2009/9/7 19:00', '2009/9/7 20:00', '2009/9/7 21:00', '2009/9/7 22:00', '2009/9/7 23:00', '2009/9/8 0:00', '2009/9/8 1:00', '2009/9/8 2:00', '2009/9/8 3:00', '2009/9/8 4:00', '2009/9/8 5:00', '2009/9/8 6:00', '2009/9/8 7:00', '2009/9/8 8:00', '2009/9/8 9:00', '2009/9/8 10:00', '2009/9/8 11:00', '2009/9/8 12:00', '2009/9/8 13:00', '2009/9/8 14:00', '2009/9/8 15:00', '2009/9/8 16:00', '2009/9/8 17:00', '2009/9/8 18:00', '2009/9/8 19:00', '2009/9/8 20:00', '2009/9/8 21:00', '2009/9/8 22:00', '2009/9/8 23:00', '2009/9/9 0:00', '2009/9/9 1:00', '2009/9/9 2:00', '2009/9/9 3:00', '2009/9/9 4:00', '2009/9/9 5:00', '2009/9/9 6:00', '2009/9/9 7:00', '2009/9/9 8:00', '2009/9/9 9:00', '2009/9/9 10:00', '2009/9/9 11:00', '2009/9/9 12:00', '2009/9/9 13:00', '2009/9/9 14:00', '2009/9/9 15:00', '2009/9/9 16:00', '2009/9/9 17:00', '2009/9/9 18:00', '2009/9/9 19:00', '2009/9/9 20:00', '2009/9/9 21:00', '2009/9/9 22:00', '2009/9/9 23:00', '2009/9/10 0:00', '2009/9/10 1:00', '2009/9/10 2:00', '2009/9/10 3:00', '2009/9/10 4:00', '2009/9/10 5:00', '2009/9/10 6:00', '2009/9/10 7:00', '2009/9/10 8:00', '2009/9/10 9:00', '2009/9/10 10:00', '2009/9/10 11:00', '2009/9/10 12:00', '2009/9/10 13:00', '2009/9/10 14:00', '2009/9/10 15:00', '2009/9/10 16:00', '2009/9/10 17:00', '2009/9/10 18:00', '2009/9/10 19:00', '2009/9/10 20:00', '2009/9/10 21:00', '2009/9/10 22:00', '2009/9/10 23:00', '2009/9/11 0:00', '2009/9/11 1:00', '2009/9/11 2:00', '2009/9/11 3:00', '2009/9/11 4:00', '2009/9/11 5:00', '2009/9/11 6:00', '2009/9/11 7:00', '2009/9/11 8:00', '2009/9/11 9:00', '2009/9/11 10:00', '2009/9/11 11:00', '2009/9/11 12:00', '2009/9/11 13:00', '2009/9/11 14:00', '2009/9/11 15:00', '2009/9/11 16:00', '2009/9/11 17:00', '2009/9/11 18:00', '2009/9/11 19:00', '2009/9/11 20:00', '2009/9/11 21:00', '2009/9/11 22:00', '2009/9/11 23:00', '2009/9/12 0:00', '2009/9/12 1:00', '2009/9/12 2:00', '2009/9/12 3:00', '2009/9/12 4:00', '2009/9/12 5:00', '2009/9/12 6:00', '2009/9/12 7:00', '2009/9/12 8:00', '2009/9/12 9:00', '2009/9/12 10:00', '2009/9/12 11:00', '2009/9/12 12:00', '2009/9/12 13:00', '2009/9/12 14:00', '2009/9/12 15:00', '2009/9/12 16:00', '2009/9/12 17:00', '2009/9/12 18:00', '2009/9/12 19:00', '2009/9/12 20:00', '2009/9/12 21:00', '2009/9/12 22:00', '2009/9/12 23:00', '2009/9/13 0:00', '2009/9/13 1:00', '2009/9/13 2:00', '2009/9/13 3:00', '2009/9/13 4:00', '2009/9/13 5:00', '2009/9/13 6:00', '2009/9/13 7:00', '2009/9/13 8:00', '2009/9/13 9:00', '2009/9/13 10:00', '2009/9/13 11:00', '2009/9/13 12:00', '2009/9/13 13:00', '2009/9/13 14:00', '2009/9/13 15:00', '2009/9/13 16:00', '2009/9/13 17:00', '2009/9/13 18:00', '2009/9/13 19:00', '2009/9/13 20:00', '2009/9/13 21:00', '2009/9/13 22:00', '2009/9/13 23:00', '2009/9/14 0:00', '2009/9/14 1:00', '2009/9/14 2:00', '2009/9/14 3:00', '2009/9/14 4:00', '2009/9/14 5:00', '2009/9/14 6:00', '2009/9/14 7:00', '2009/9/14 8:00', '2009/9/14 9:00', '2009/9/14 10:00', '2009/9/14 11:00', '2009/9/14 12:00', '2009/9/14 13:00', '2009/9/14 14:00', '2009/9/14 15:00', '2009/9/14 16:00', '2009/9/14 17:00', '2009/9/14 18:00', '2009/9/14 19:00', '2009/9/14 20:00', '2009/9/14 21:00', '2009/9/14 22:00', '2009/9/14 23:00', '2009/9/15 0:00', '2009/9/15 1:00', '2009/9/15 2:00', '2009/9/15 3:00', '2009/9/15 4:00', '2009/9/15 5:00', '2009/9/15 6:00', '2009/9/15 7:00', '2009/9/15 8:00', '2009/9/15 9:00', '2009/9/15 10:00', '2009/9/15 11:00', '2009/9/15 12:00', '2009/9/15 13:00', '2009/9/15 14:00', '2009/9/15 15:00', '2009/9/15 16:00', '2009/9/15 17:00', '2009/9/15 18:00', '2009/9/15 19:00', '2009/9/15 20:00', '2009/9/15 21:00', '2009/9/15 22:00', '2009/9/15 23:00', '2009/9/16 0:00', '2009/9/16 1:00', '2009/9/16 2:00', '2009/9/16 3:00', '2009/9/16 4:00', '2009/9/16 5:00', '2009/9/16 6:00', '2009/9/16 7:00', '2009/9/16 8:00', '2009/9/16 9:00', '2009/9/16 10:00', '2009/9/16 11:00', '2009/9/16 12:00', '2009/9/16 13:00', '2009/9/16 14:00', '2009/9/16 15:00', '2009/9/16 16:00', '2009/9/16 17:00', '2009/9/16 18:00', '2009/9/16 19:00', '2009/9/16 20:00', '2009/9/16 21:00', '2009/9/16 22:00', '2009/9/16 23:00', '2009/9/17 0:00', '2009/9/17 1:00', '2009/9/17 2:00', '2009/9/17 3:00', '2009/9/17 4:00', '2009/9/17 5:00', '2009/9/17 6:00', '2009/9/17 7:00', '2009/9/17 8:00', '2009/9/17 9:00', '2009/9/17 10:00', '2009/9/17 11:00', '2009/9/17 12:00', '2009/9/17 13:00', '2009/9/17 14:00', '2009/9/17 15:00', '2009/9/17 16:00', '2009/9/17 17:00', '2009/9/17 18:00', '2009/9/17 19:00', '2009/9/17 20:00', '2009/9/17 21:00', '2009/9/17 22:00', '2009/9/17 23:00', '2009/9/18 0:00', '2009/9/18 1:00', '2009/9/18 2:00', '2009/9/18 3:00', '2009/9/18 4:00', '2009/9/18 5:00', '2009/9/18 6:00', '2009/9/18 7:00', '2009/9/18 8:00', '2009/9/18 9:00', '2009/9/18 10:00', '2009/9/18 11:00', '2009/9/18 12:00', '2009/9/18 13:00', '2009/9/18 14:00', '2009/9/18 15:00', '2009/9/18 16:00', '2009/9/18 17:00', '2009/9/18 18:00', '2009/9/18 19:00', '2009/9/18 20:00', '2009/9/18 21:00', '2009/9/18 22:00', '2009/9/18 23:00', '2009/9/19 0:00', '2009/9/19 1:00', '2009/9/19 2:00', '2009/9/19 3:00', '2009/9/19 4:00', '2009/9/19 5:00', '2009/9/19 6:00', '2009/9/19 7:00', '2009/9/19 8:00', '2009/9/19 9:00', '2009/9/19 10:00', '2009/9/19 11:00', '2009/9/19 12:00', '2009/9/19 13:00', '2009/9/19 14:00', '2009/9/19 15:00', '2009/9/19 16:00', '2009/9/19 17:00', '2009/9/19 18:00', '2009/9/19 19:00', '2009/9/19 20:00', '2009/9/19 21:00', '2009/9/19 22:00', '2009/9/19 23:00', '2009/9/20 0:00', '2009/9/20 1:00', '2009/9/20 2:00', '2009/9/20 3:00', '2009/9/20 4:00', '2009/9/20 5:00', '2009/9/20 6:00', '2009/9/20 7:00', '2009/9/20 8:00', '2009/9/20 9:00', '2009/9/20 10:00', '2009/9/20 11:00', '2009/9/20 12:00', '2009/9/20 13:00', '2009/9/20 14:00', '2009/9/20 15:00', '2009/9/20 16:00', '2009/9/20 17:00', '2009/9/20 18:00', '2009/9/20 19:00', '2009/9/20 20:00', '2009/9/20 21:00', '2009/9/20 22:00', '2009/9/20 23:00', '2009/9/21 0:00', '2009/9/21 1:00', '2009/9/21 2:00', '2009/9/21 3:00', '2009/9/21 4:00', '2009/9/21 5:00', '2009/9/21 6:00', '2009/9/21 7:00', '2009/9/21 8:00', '2009/9/21 9:00', '2009/9/21 10:00', '2009/9/21 11:00', '2009/9/21 12:00', '2009/9/21 13:00', '2009/9/21 14:00', '2009/9/21 15:00', '2009/9/21 16:00', '2009/9/21 17:00', '2009/9/21 18:00', '2009/9/21 19:00', '2009/9/21 20:00', '2009/9/21 21:00', '2009/9/21 22:00', '2009/9/21 23:00', '2009/9/22 0:00', '2009/9/22 1:00', '2009/9/22 2:00', '2009/9/22 3:00', '2009/9/22 4:00', '2009/9/22 5:00', '2009/9/22 6:00', '2009/9/22 7:00', '2009/9/22 8:00', '2009/9/22 9:00', '2009/9/22 10:00', '2009/9/22 11:00', '2009/9/22 12:00', '2009/9/22 13:00', '2009/9/22 14:00', '2009/9/22 15:00', '2009/9/22 16:00', '2009/9/22 17:00', '2009/9/22 18:00', '2009/9/22 19:00', '2009/9/22 20:00', '2009/9/22 21:00', '2009/9/22 22:00', '2009/9/22 23:00', '2009/9/23 0:00', '2009/9/23 1:00', '2009/9/23 2:00', '2009/9/23 3:00', '2009/9/23 4:00', '2009/9/23 5:00', '2009/9/23 6:00', '2009/9/23 7:00', '2009/9/23 8:00', '2009/9/23 9:00', '2009/9/23 10:00', '2009/9/23 11:00', '2009/9/23 12:00', '2009/9/23 13:00', '2009/9/23 14:00', '2009/9/23 15:00', '2009/9/23 16:00', '2009/9/23 17:00', '2009/9/23 18:00', '2009/9/23 19:00', '2009/9/23 20:00', '2009/9/23 21:00', '2009/9/23 22:00', '2009/9/23 23:00', '2009/9/24 0:00', '2009/9/24 1:00', '2009/9/24 2:00', '2009/9/24 3:00', '2009/9/24 4:00', '2009/9/24 5:00', '2009/9/24 6:00', '2009/9/24 7:00', '2009/9/24 8:00', '2009/9/24 9:00', '2009/9/24 10:00', '2009/9/24 11:00', '2009/9/24 12:00', '2009/9/24 13:00', '2009/9/24 14:00', '2009/9/24 15:00', '2009/9/24 16:00', '2009/9/24 17:00', '2009/9/24 18:00', '2009/9/24 19:00', '2009/9/24 20:00', '2009/9/24 21:00', '2009/9/24 22:00', '2009/9/24 23:00', '2009/9/25 0:00', '2009/9/25 1:00', '2009/9/25 2:00', '2009/9/25 3:00', '2009/9/25 4:00', '2009/9/25 5:00', '2009/9/25 6:00', '2009/9/25 7:00', '2009/9/25 8:00', '2009/9/25 9:00', '2009/9/25 10:00', '2009/9/25 11:00', '2009/9/25 12:00', '2009/9/25 13:00', '2009/9/25 14:00', '2009/9/25 15:00', '2009/9/25 16:00', '2009/9/25 17:00', '2009/9/25 18:00', '2009/9/25 19:00', '2009/9/25 20:00', '2009/9/25 21:00', '2009/9/25 22:00', '2009/9/25 23:00', '2009/9/26 0:00', '2009/9/26 1:00', '2009/9/26 2:00', '2009/9/26 3:00', '2009/9/26 4:00', '2009/9/26 5:00', '2009/9/26 6:00', '2009/9/26 7:00', '2009/9/26 8:00', '2009/9/26 9:00', '2009/9/26 10:00', '2009/9/26 11:00', '2009/9/26 12:00', '2009/9/26 13:00', '2009/9/26 14:00', '2009/9/26 15:00', '2009/9/26 16:00', '2009/9/26 17:00', '2009/9/26 18:00', '2009/9/26 19:00', '2009/9/26 20:00', '2009/9/26 21:00', '2009/9/26 22:00', '2009/9/26 23:00', '2009/9/27 0:00', '2009/9/27 1:00', '2009/9/27 2:00', '2009/9/27 3:00', '2009/9/27 4:00', '2009/9/27 5:00', '2009/9/27 6:00', '2009/9/27 7:00', '2009/9/27 8:00', '2009/9/27 9:00', '2009/9/27 10:00', '2009/9/27 11:00', '2009/9/27 12:00', '2009/9/27 13:00', '2009/9/27 14:00', '2009/9/27 15:00', '2009/9/27 16:00', '2009/9/27 17:00', '2009/9/27 18:00', '2009/9/27 19:00', '2009/9/27 20:00', '2009/9/27 21:00', '2009/9/27 22:00', '2009/9/27 23:00', '2009/9/28 0:00', '2009/9/28 1:00', '2009/9/28 2:00', '2009/9/28 3:00', '2009/9/28 4:00', '2009/9/28 5:00', '2009/9/28 6:00', '2009/9/28 7:00', '2009/9/28 8:00', '2009/9/28 9:00', '2009/9/28 10:00', '2009/9/28 11:00', '2009/9/28 12:00', '2009/9/28 13:00', '2009/9/28 14:00', '2009/9/28 15:00', '2009/9/28 16:00', '2009/9/28 17:00', '2009/9/28 18:00', '2009/9/28 19:00', '2009/9/28 20:00', '2009/9/28 21:00', '2009/9/28 22:00', '2009/9/28 23:00', '2009/9/29 0:00', '2009/9/29 1:00', '2009/9/29 2:00', '2009/9/29 3:00', '2009/9/29 4:00', '2009/9/29 5:00', '2009/9/29 6:00', '2009/9/29 7:00', '2009/9/29 8:00', '2009/9/29 9:00', '2009/9/29 10:00', '2009/9/29 11:00', '2009/9/29 12:00', '2009/9/29 13:00', '2009/9/29 14:00', '2009/9/29 15:00', '2009/9/29 16:00', '2009/9/29 17:00', '2009/9/29 18:00', '2009/9/29 19:00', '2009/9/29 20:00', '2009/9/29 21:00', '2009/9/29 22:00', '2009/9/29 23:00', '2009/9/30 0:00', '2009/9/30 1:00', '2009/9/30 2:00', '2009/9/30 3:00', '2009/9/30 4:00', '2009/9/30 5:00', '2009/9/30 6:00', '2009/9/30 7:00', '2009/9/30 8:00', '2009/9/30 9:00', '2009/9/30 10:00', '2009/9/30 11:00', '2009/9/30 12:00', '2009/9/30 13:00', '2009/9/30 14:00', '2009/9/30 15:00', '2009/9/30 16:00', '2009/9/30 17:00', '2009/9/30 18:00', '2009/9/30 19:00', '2009/9/30 20:00', '2009/9/30 21:00', '2009/9/30 22:00', '2009/9/30 23:00',
                '2009/10/1 0:00', '2009/10/1 1:00', '2009/10/1 2:00', '2009/10/1 3:00', '2009/10/1 4:00', '2009/10/1 5:00', '2009/10/1 6:00', '2009/10/1 7:00', '2009/10/1 8:00', '2009/10/1 9:00', '2009/10/1 10:00', '2009/10/1 11:00', '2009/10/1 12:00', '2009/10/1 13:00', '2009/10/1 14:00', '2009/10/1 15:00', '2009/10/1 16:00', '2009/10/1 17:00', '2009/10/1 18:00', '2009/10/1 19:00', '2009/10/1 20:00', '2009/10/1 21:00', '2009/10/1 22:00', '2009/10/1 23:00', '2009/10/2 0:00', '2009/10/2 1:00', '2009/10/2 2:00', '2009/10/2 3:00', '2009/10/2 4:00', '2009/10/2 5:00', '2009/10/2 6:00', '2009/10/2 7:00', '2009/10/2 8:00', '2009/10/2 9:00', '2009/10/2 10:00', '2009/10/2 11:00', '2009/10/2 12:00', '2009/10/2 13:00', '2009/10/2 14:00', '2009/10/2 15:00', '2009/10/2 16:00', '2009/10/2 17:00', '2009/10/2 18:00', '2009/10/2 19:00', '2009/10/2 20:00', '2009/10/2 21:00', '2009/10/2 22:00', '2009/10/2 23:00', '2009/10/3 0:00', '2009/10/3 1:00', '2009/10/3 2:00', '2009/10/3 3:00', '2009/10/3 4:00', '2009/10/3 5:00', '2009/10/3 6:00', '2009/10/3 7:00', '2009/10/3 8:00', '2009/10/3 9:00', '2009/10/3 10:00', '2009/10/3 11:00', '2009/10/3 12:00', '2009/10/3 13:00', '2009/10/3 14:00', '2009/10/3 15:00', '2009/10/3 16:00', '2009/10/3 17:00', '2009/10/3 18:00', '2009/10/3 19:00', '2009/10/3 20:00', '2009/10/3 21:00', '2009/10/3 22:00', '2009/10/3 23:00', '2009/10/4 0:00', '2009/10/4 1:00', '2009/10/4 2:00', '2009/10/4 3:00', '2009/10/4 4:00', '2009/10/4 5:00', '2009/10/4 6:00', '2009/10/4 7:00', '2009/10/4 8:00', '2009/10/4 9:00', '2009/10/4 10:00', '2009/10/4 11:00', '2009/10/4 12:00', '2009/10/4 13:00', '2009/10/4 14:00', '2009/10/4 15:00', '2009/10/4 16:00', '2009/10/4 17:00', '2009/10/4 18:00', '2009/10/4 19:00', '2009/10/4 20:00', '2009/10/4 21:00', '2009/10/4 22:00', '2009/10/4 23:00', '2009/10/5 0:00', '2009/10/5 1:00', '2009/10/5 2:00', '2009/10/5 3:00', '2009/10/5 4:00', '2009/10/5 5:00', '2009/10/5 6:00', '2009/10/5 7:00', '2009/10/5 8:00', '2009/10/5 9:00', '2009/10/5 10:00', '2009/10/5 11:00', '2009/10/5 12:00', '2009/10/5 13:00', '2009/10/5 14:00', '2009/10/5 15:00', '2009/10/5 16:00', '2009/10/5 17:00', '2009/10/5 18:00', '2009/10/5 19:00', '2009/10/5 20:00', '2009/10/5 21:00', '2009/10/5 22:00', '2009/10/5 23:00', '2009/10/6 0:00', '2009/10/6 1:00', '2009/10/6 2:00', '2009/10/6 3:00', '2009/10/6 4:00', '2009/10/6 5:00', '2009/10/6 6:00', '2009/10/6 7:00', '2009/10/6 8:00', '2009/10/6 9:00', '2009/10/6 10:00', '2009/10/6 11:00', '2009/10/6 12:00', '2009/10/6 13:00', '2009/10/6 14:00', '2009/10/6 15:00', '2009/10/6 16:00', '2009/10/6 17:00', '2009/10/6 18:00', '2009/10/6 19:00', '2009/10/6 20:00', '2009/10/6 21:00', '2009/10/6 22:00', '2009/10/6 23:00', '2009/10/7 0:00', '2009/10/7 1:00', '2009/10/7 2:00', '2009/10/7 3:00', '2009/10/7 4:00', '2009/10/7 5:00', '2009/10/7 6:00', '2009/10/7 7:00', '2009/10/7 8:00', '2009/10/7 9:00', '2009/10/7 10:00', '2009/10/7 11:00', '2009/10/7 12:00', '2009/10/7 13:00', '2009/10/7 14:00', '2009/10/7 15:00', '2009/10/7 16:00', '2009/10/7 17:00', '2009/10/7 18:00', '2009/10/7 19:00', '2009/10/7 20:00', '2009/10/7 21:00', '2009/10/7 22:00', '2009/10/7 23:00', '2009/10/8 0:00', '2009/10/8 1:00', '2009/10/8 2:00', '2009/10/8 3:00', '2009/10/8 4:00', '2009/10/8 5:00', '2009/10/8 6:00', '2009/10/8 7:00', '2009/10/8 8:00', '2009/10/8 9:00', '2009/10/8 10:00', '2009/10/8 11:00', '2009/10/8 12:00', '2009/10/8 13:00', '2009/10/8 14:00', '2009/10/8 15:00', '2009/10/8 16:00', '2009/10/8 17:00', '2009/10/8 18:00', '2009/10/8 19:00', '2009/10/8 20:00', '2009/10/8 21:00', '2009/10/8 22:00', '2009/10/8 23:00', '2009/10/9 0:00', '2009/10/9 1:00', '2009/10/9 2:00', '2009/10/9 3:00', '2009/10/9 4:00', '2009/10/9 5:00', '2009/10/9 6:00', '2009/10/9 7:00', '2009/10/9 8:00', '2009/10/9 9:00', '2009/10/9 10:00', '2009/10/9 11:00', '2009/10/9 12:00', '2009/10/9 13:00', '2009/10/9 14:00', '2009/10/9 15:00', '2009/10/9 16:00', '2009/10/9 17:00', '2009/10/9 18:00', '2009/10/9 19:00', '2009/10/9 20:00', '2009/10/9 21:00', '2009/10/9 22:00', '2009/10/9 23:00', '2009/10/10 0:00', '2009/10/10 1:00', '2009/10/10 2:00', '2009/10/10 3:00', '2009/10/10 4:00', '2009/10/10 5:00', '2009/10/10 6:00', '2009/10/10 7:00', '2009/10/10 8:00', '2009/10/10 9:00', '2009/10/10 10:00', '2009/10/10 11:00', '2009/10/10 12:00', '2009/10/10 13:00', '2009/10/10 14:00', '2009/10/10 15:00', '2009/10/10 16:00', '2009/10/10 17:00', '2009/10/10 18:00', '2009/10/10 19:00', '2009/10/10 20:00', '2009/10/10 21:00', '2009/10/10 22:00', '2009/10/10 23:00', '2009/10/11 0:00', '2009/10/11 1:00', '2009/10/11 2:00', '2009/10/11 3:00', '2009/10/11 4:00', '2009/10/11 5:00', '2009/10/11 6:00', '2009/10/11 7:00', '2009/10/11 8:00', '2009/10/11 9:00', '2009/10/11 10:00', '2009/10/11 11:00', '2009/10/11 12:00', '2009/10/11 13:00', '2009/10/11 14:00', '2009/10/11 15:00', '2009/10/11 16:00', '2009/10/11 17:00', '2009/10/11 18:00', '2009/10/11 19:00', '2009/10/11 20:00', '2009/10/11 21:00', '2009/10/11 22:00', '2009/10/11 23:00', '2009/10/12 0:00', '2009/10/12 1:00', '2009/10/12 2:00', '2009/10/12 3:00', '2009/10/12 4:00', '2009/10/12 5:00', '2009/10/12 6:00', '2009/10/12 7:00', '2009/10/12 8:00', '2009/10/12 9:00', '2009/10/12 10:00', '2009/10/12 11:00', '2009/10/12 12:00', '2009/10/12 13:00', '2009/10/12 14:00', '2009/10/12 15:00', '2009/10/12 16:00', '2009/10/12 17:00', '2009/10/12 18:00', '2009/10/12 19:00', '2009/10/12 20:00', '2009/10/12 21:00', '2009/10/12 22:00', '2009/10/12 23:00', '2009/10/13 0:00', '2009/10/13 1:00', '2009/10/13 2:00', '2009/10/13 3:00', '2009/10/13 4:00', '2009/10/13 5:00', '2009/10/13 6:00', '2009/10/13 7:00', '2009/10/13 8:00', '2009/10/13 9:00', '2009/10/13 10:00', '2009/10/13 11:00', '2009/10/13 12:00', '2009/10/13 13:00', '2009/10/13 14:00', '2009/10/13 15:00', '2009/10/13 16:00', '2009/10/13 17:00', '2009/10/13 18:00', '2009/10/13 19:00', '2009/10/13 20:00', '2009/10/13 21:00', '2009/10/13 22:00', '2009/10/13 23:00', '2009/10/14 0:00', '2009/10/14 1:00', '2009/10/14 2:00', '2009/10/14 3:00', '2009/10/14 4:00', '2009/10/14 5:00', '2009/10/14 6:00', '2009/10/14 7:00', '2009/10/14 8:00', '2009/10/14 9:00', '2009/10/14 10:00', '2009/10/14 11:00', '2009/10/14 12:00', '2009/10/14 13:00', '2009/10/14 14:00', '2009/10/14 15:00', '2009/10/14 16:00', '2009/10/14 17:00', '2009/10/14 18:00', '2009/10/14 19:00', '2009/10/14 20:00', '2009/10/14 21:00', '2009/10/14 22:00', '2009/10/14 23:00', '2009/10/15 0:00', '2009/10/15 1:00', '2009/10/15 2:00', '2009/10/15 3:00', '2009/10/15 4:00', '2009/10/15 5:00', '2009/10/15 6:00', '2009/10/15 7:00', '2009/10/15 8:00', '2009/10/15 9:00', '2009/10/15 10:00', '2009/10/15 11:00', '2009/10/15 12:00', '2009/10/15 13:00', '2009/10/15 14:00', '2009/10/15 15:00', '2009/10/15 16:00', '2009/10/15 17:00', '2009/10/15 18:00', '2009/10/15 19:00', '2009/10/15 20:00', '2009/10/15 21:00', '2009/10/15 22:00', '2009/10/15 23:00', '2009/10/16 0:00', '2009/10/16 1:00', '2009/10/16 2:00', '2009/10/16 3:00', '2009/10/16 4:00', '2009/10/16 5:00', '2009/10/16 6:00', '2009/10/16 7:00', '2009/10/16 8:00', '2009/10/16 9:00', '2009/10/16 10:00', '2009/10/16 11:00', '2009/10/16 12:00', '2009/10/16 13:00', '2009/10/16 14:00', '2009/10/16 15:00', '2009/10/16 16:00', '2009/10/16 17:00', '2009/10/16 18:00', '2009/10/16 19:00', '2009/10/16 20:00', '2009/10/16 21:00', '2009/10/16 22:00', '2009/10/16 23:00', '2009/10/17 0:00', '2009/10/17 1:00', '2009/10/17 2:00', '2009/10/17 3:00', '2009/10/17 4:00', '2009/10/17 5:00', '2009/10/17 6:00', '2009/10/17 7:00', '2009/10/17 8:00', '2009/10/17 9:00', '2009/10/17 10:00', '2009/10/17 11:00', '2009/10/17 12:00', '2009/10/17 13:00', '2009/10/17 14:00', '2009/10/17 15:00', '2009/10/17 16:00', '2009/10/17 17:00', '2009/10/17 18:00', '2009/10/17 19:00', '2009/10/17 20:00', '2009/10/17 21:00', '2009/10/17 22:00', '2009/10/17 23:00', '2009/10/18 0:00', '2009/10/18 1:00', '2009/10/18 2:00', '2009/10/18 3:00', '2009/10/18 4:00', '2009/10/18 5:00', '2009/10/18 6:00', '2009/10/18 7:00', '2009/10/18 8:00'
            ].map(function (str) {
                return str.replace(' ', '\n');
            })
        }
    ],
    yAxis: [
        {
            name: '流量(m^3/s)',
            type: 'value',
            max: 500
        },
        {
            name: '降雨量(mm)',
            nameLocation: 'start',
            max: 5,
            type: 'value',
            inverse: true
        }
    ],
    series: [
        {
            name: '流量',
            type: 'line',
            animation: false,
            areaStyle: {},
            lineStyle: {
                width: 1
            },
            markArea: {
                silent: true,
                data: [[{
                    xAxis: '2009/9/12\n7:00'
                }, {
                    xAxis: '2009/9/22\n7:00'
                }]]
            },
            data: [
                0.97,0.96,0.96,0.95,0.95,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.93,0.92,0.91,0.9,0.89,0.88,0.87,0.87,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.87,0.88,0.9,0.93,0.96,0.99,1.03,1.06,1.1,1.14,1.17,1.2,1.23,1.26,1.29,1.33,1.36,1.4,1.43,1.45,1.48,1.49,1.51,1.51,1.5,1.49,1.47,1.44,1.41,1.37,1.34,1.3,1.27,1.24,1.22,1.2,1.19,1.18,1.16,1.15,1.14,1.13,1.12,1.11,1.11,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.1,1.09,1.09,1.08,1.07,1.06,1.05,1.04,1.03,1.03,1.02,1.01,1.01,1,0.99,0.98,0.97,0.96,0.96,0.95,0.95,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.93,0.92,0.91,0.9,0.89,0.88,0.87,0.87,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.85,0.84,0.83,0.82,0.81,0.8,0.8,0.79,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.77,0.75,0.73,0.71,0.68,0.65,0.63,0.61,0.59,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.57,0.57,0.57,0.56,0.55,0.55,0.54,0.54,0.53,0.52,0.52,0.51,0.51,0.5,0.5,0.49,0.48,0.48,0.47,0.47,0.47,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.52,0.67,0.9,1.19,1.52,1.87,2.22,2.55,2.84,3.07,3.22,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.28,3.24,3.13,2.97,2.77,2.54,2.3,2.05,1.82,1.62,1.46,1.35,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.3,1.26,1.21,1.14,1.06,0.97,0.89,0.81,0.74,0.69,0.65,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.63,0.63,0.62,0.62,0.61,0.6,0.59,0.59,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.59,0.61,0.63,0.65,0.68,0.71,0.73,0.75,0.77,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.77,0.75,0.73,0.71,0.68,0.65,0.63,0.61,0.59,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.58,0.59,0.59,0.6,0.61,0.62,0.62,0.63,0.63,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.65,0.66,0.68,0.69,0.71,0.73,0.74,0.76,0.77,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.79,0.81,0.82,0.84,0.86,0.88,0.9,0.92,0.93,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.93,0.92,0.91,0.9,0.89,0.88,0.87,0.87,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.86,0.85,0.84,0.82,0.8,0.78,0.76,0.75,0.73,0.72,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.72,0.73,0.74,0.76,0.78,0.79,0.82,0.84,0.86,0.89,0.91,0.94,0.97,1,1.02,1.05,1.08,1.11,1.14,1.17,1.19,1.22,1.25,1.27,1.29,1.31,1.33,1.35,1.36,1.38,1.39,1.39,1.4,1.4,1.4,1.39,1.37,1.35,1.32,1.29,1.26,1.22,1.18,1.14,1.1,1.05,1.01,0.97,0.93,0.89,0.85,0.82,0.78,0.76,0.74,0.72,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.72,0.73,0.74,0.75,0.77,0.78,0.8,0.82,0.84,0.87,0.89,0.92,0.94,0.97,0.99,1.02,1.05,1.08,1.1,1.13,1.16,1.18,1.21,1.23,1.26,1.28,1.3,1.32,1.34,1.35,1.37,1.38,1.39,1.4,1.41,1.41,1.42,1.42,1.43,1.43,1.43,1.44,1.44,1.44,1.44,1.45,1.45,1.45,1.46,1.46,1.46,1.47,1.47,1.48,1.48,1.49,1.5,1.51,1.54,1.62,1.73,1.88,2.05,2.24,2.45,2.67,2.89,3.11,3.31,3.51,3.69,3.86,4.03,4.18,4.33,4.48,4.62,4.76,4.89,5.02,5.16,5.29,5.43,5.57,5.71,5.86,6.02,6.18,6.36,6.54,6.73,6.93,7.15,7.38,7.62,7.88,8.16,8.46,8.77,9.11,9.46,9.84,10.24,10.67,11.12,11.6,12.3,13.66,16,38.43,82.21,146.6,218.7,226,225.23,223.08,219.78,212,199.82,184.6,168,151.65,137.21,126.31,119.94,115.52,112.06,108.92,105.44,101,94.56,86.36,77.67,69.76,63.9,60.38,57.41,54.84,52.57,50.56,48.71,46.97,45.25,43.48,41.6,39.5,37.19,34.81,32.46,30.27,28.36,26.85,25.86,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.5,25.27,24.65,23.7,22.52,21.17,19.75,18.33,16.98,15.8,14.85,14.23,14,14.02,14.08,14.17,14.29,14.44,14.61,14.8,15.01,15.23,15.47,15.71,15.95,16.19,16.43,16.67,16.89,17.1,17.29,17.46,17.61,17.73,17.82,17.88,17.9,17.63,16.88,15.75,14.33,12.71,10.98,9.23,7.56,6.05,4.81,3.92,3.47,3.28,3.1,2.93,2.76,2.61,2.46,2.32,2.19,2.07,1.96,1.85,1.75,1.66,1.58,1.51,1.44,1.39,1.34,1.29,1.26,1.23,1.22,1.2,1.2,1.2,1.2,1.2,1.2,1.21,1.21,1.21,1.21,1.22,1.22,1.22,1.23,1.23,1.23,1.24,1.24,1.25,1.25,1.25,1.26,1.26,1.27,1.27,1.27,1.28,1.28,1.28,1.29,1.29,1.29,1.29,1.3,1.3,1.3,1.3,1.3,1.3,1.3,1.3,1.3,1.3,1.3,1.29,1.29,1.29,1.29,1.28,1.28,1.28,1.27,1.27,1.26,1.25,1.25,1.24,1.23,1.23,1.22,1.21,1.2,1.16,1.06,0.95,0.83,0.74,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.71,0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.69,0.69,0.69,0.69,0.69,0.69,0.69,0.69,0.68,0.68,0.68,0.68,0.68,0.68,0.67,0.67,0.67,0.67,0.67,0.67,0.67,0.66,0.66,0.66,0.66,0.66,0.66,0.66,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.65,0.66,0.68,0.69,0.71,0.73,0.74,0.76,0.77,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.78,0.8,0.86,0.95,1.08,1.25,1.46,1.7,1.97,2.28,2.63,3.01,3.42,3.87,4.35,4.86,5.4,5.98,6.59,7.92,10.49,14.04,18.31,23.04,27.98,32.87,37.45,41.46,44.64,46.74,47.5,46.86,45.16,42.77,40.04,37.33,35,32.74,30.21,27.7,25.5,23.9,23.2,23.06,22.94,22.84,22.77,22.72,22.7,22.8,23.23,23.95,24.91,26.04,27.3,28.76,30.7,33.39,37.12,42.15,48.77,65.22,252.1,257,237.32,221.19,212,208.67,206.89,205.2,202.15,189.82,172,165.3,160.49,156.8,153.44,149.62,144.6,138.27,131,123.11,114.9,106.69,98.79,91.5,85.13,80,75.53,71.03,66.65,62.54,58.85,55.73,53.31,51.75,51.2,56.53,68.25,80,91.01,102.03,109,112.37,115.29,117.68,119.48,120.61,121,119.45,115.57,110.52,105.47,101.58,100,99.97,99.94,99.92,99.9,99.88,99.86,99.85,99.84,99.83,99.82,99.81,99.81,99.8,99.8,99.8,122.15,163.65,186,182.96,175.15,164.56,153.18,143,136,131.37,126.98,122.81,118.85,115.09,111.52,108.13,104.9,101.83,98.9,96.11,93.44,90.87,88.41,86.04,83.74,81.51,79.33,77.2,75.1,73.02,70.95,68.88,66.8,64.87,63.14,61.4,59.53,57.67,56,54.6,53.36,52.2,51.05,49.85,48.5,46.87,44.92,42.74,40.42,38.04,35.69,33.46,31.44,29.72,28.38,27.51,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.2,27.14,26.97,26.7,26.35,25.95,25.49,25.02,24.53,24.04,23.58,23.16,22.8,22.46,22.11,21.75,21.39,21.03,20.69,20.36,20.05,19.78,19.54,19.35,19.2,19.09,19,18.92,18.85,18.79,18.74,18.68,18.62,18.56,18.49,18.4,18.3,18.17,18.02,17.83,17.63,17.41,17.18,16.93,16.68,16.43,16.18,15.93,15.7,15.47,15.22,14.97,14.71,14.45,14.18,13.93,13.68,13.44,13.21,13,12.8,12.62,12.46,12.31,12.16,12.03,11.89,11.76,11.62,11.48,11.33,11.17,11,10.81,10.59,10.36,10.12,9.86,9.61,9.36,9.12,8.89,8.68,8.5,8.35,8.21,8.08,7.94,7.81,7.68,7.56,7.46,7.36,7.29,7.23,7.19,7.18,7.51,8.42,9.81,11.58,13.63,15.86,18.16,20.44,22.58,24.49,26.06,27.2,28.08,28.95,29.81,30.65,31.48,32.28,33.07,33.82,34.55,35.25,35.92,36.56,37.15,37.71,38.23,38.7,39.13,39.5,39.83,40.1,40.31,40.47,40.57,40.6,40.49,40.16,39.64,38.94,38.09,37.1,36,34.79,33.51,32.17,30.79,29.39,27.99,26.6,25.25,23.96,22.75,21.63,20.63,19.76,19.04,18.49,18.14,18,17.97,17.95,17.94,17.92,17.91,17.9,17.89,17.88,17.87,17.85,17.83,17.8,17.7,17.46,17.13,16.7,16.21,15.68,15.13,14.57,14.04,13.56,13.14,12.8,12.52,12.27,12.02,11.79,11.57,11.37,11.16,10.97,10.78,10.59,10.39,10.2,10.01,9.81,9.63,9.44,9.26,9.08,8.9,8.73,8.56,8.39,8.22,8.06,7.9,7.73,7.57,7.41,7.25,7.09,6.94,6.79,6.65,6.52,6.4,6.28,6.17,6.08,5.98,5.9,5.81,5.73,5.65,5.57,5.49,5.41,5.32,5.23,5.14,5.04,4.94,4.84,4.74,4.63,4.53,4.43,4.33,4.23,4.13,4.03,3.93,3.81,3.69,3.57,3.45,3.33,3.22,3.12,3.04,2.98,2.93,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.92,2.9,2.86,2.8,2.71,2.62,2.52,2.42,2.33,2.24,2.18,2.14,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.12,2.1,2.06,2,1.91,1.82,1.71,1.61,1.5,1.4,1.32,1.25,1.2,1.16,1.13,1.1,1.06,1.03,1,0.97,0.93,0.9,0.87,0.85,0.82,0.79,0.77,0.74,0.72,0.69,0.67,0.65,0.63,0.61,0.59,0.58,0.56,0.54,0.53,0.52,0.51,0.5,0.49,0.48,0.48,0.47,0.47,0.46,0.46,0.47,0.48,0.5,0.53,0.56,0.59,0.62,0.64,0.67,0.69,0.7,0.71,0.71,0.71,0.71,0.7,0.7,0.7,0.69,0.69,0.69,0.68,0.68,0.67,0.67,0.67,0.66,0.66,0.65,0.65,0.65,0.65,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.64,0.65,0.65,0.65,0.66,0.66,0.67,0.68,0.69,0.69,0.7,0.71,0.73,0.74,0.75,0.76,0.78,0.8,0.81,0.83,0.85,0.87,0.89,0.92,0.94,0.97,0.99,1.02,1.05,1.08,1.11,1.15,1.18,1.32,1.66,2.21,2.97,3.94,5.11,6.5,8.1,9.9,11.92,14.15,16.6,22.3,22.8,24.48,30.38,35.74,42.4,57.14,94.04,112.9,123.4,130.4,130,119.4,120.7,116.8,118.1,119.4,124.8,143.5,204,294,319.2,328.4,365,350.8,347.6,347.6,325,331.6,319.2,308,308,308,308,296.8,300,281,278.4,270.6,271,253.6,233.5,219.2,207.8,205.9,204,189.6,178.8,173.4,160,154.4,146,145,140.5,130.4,126.2,116.8,112.9,106.5,101.6,98.51,82.67,67.3,80.05,76.12,72.3,71.02,69.78,67.3,67.3,68.54,57.6,71.02,66.06,59.12,57.14,55.16,55.16,52.19,52.19,51.2,48.56,44.16,43,45.92,49.44,44.16,36.48,35.74,35,32.36,37.22,32.36,32.36,32.36,33.68,32.36,31.7,35.74,29.72,32.36,30.38,29.72,28.4,28.4,28.4,27.28,25.6,25.04,23.92,22.3,21.8,21.8,21.8,22.8,21.8,25.6,22.8,22.8,17.8,16.04,16.04,16.04,16.04,16.04,16.04,16.04,16.04,16.04,16.04,15.02,14,14.03,14.11,14.25,14.45,14.72,15.06,15.46,15.95,16.51,17.15,17.87,18.69,19.59,20.59,21.69,22.88,24.18,25.59,27.1,28.73,30.48,32.34,34.33,36.44,38.69,41.06,43.57,46.22,49.01,51.95,55.04,58.27,61.66,65.21,68.92,72.8,88.09,104.9,105.7,110.3,111.6,110.3,106.5,105.7,103.3,100,97.02,98.8,91.07,83.98,88.09,81.36,78.74,77.43,77.43,73.5,74.81,72.63,68.58,66.4,68.54,69.78,67.3,64.82,61.1,59.12,56.15,53.18,50.32,49.44,44.16,36.5,42.4,37.96,37.22,33.68,36.48,35.74,35,35,37.22,37.22,39.44,32.6,34.54,36.48,35.74,34.34,33.68,33.02,31.04,29.72,29.72,29.72,26.16,25.6,29.72,18.3,22.3,21.3,21.8,21.8,20.3,20.8,25.04,25.04,25.6,25.6,25.04,25.6,25.04,25.6,23.92,25.04,21.3,21.8,22.3,21.8,20.8,16.1,20.3,18.3,13.22,19.3,19.3,18.3,14.4,13.86,13.36,12.9,12.48,12.1,11.75,11.43,11.15,10.9,10.67,10.48,10.31,10.16,10.04,9.93,9.85,9.78,9.73,9.69,9.67,9.65,9.65,12.08,8.67,11.7,11.38,10.65,9.84,9.32,9.07,8.85,8.66,8.49,8.35,8.22,8.1,7.98,7.86,7.74,7.61,7.47,7.31,7.14,6.96,6.78,6.58,6.39,6.19,5.99,5.78,5.58,5.39,5.2,5.01,4.83,4.67,4.51,4.37,4.24,4.12,4.02,3.95,3.89,3.85,3.84,4.41,5.77,7.39,8.75,9.32,9.18,9,8.94,8.88,8.83,8.78,8.73,8.68,8.64,8.6,8.56,8.53,8.5,8.47,8.45,8.42,8.4,8.39,8.37,8.36,8.35,8.35,8.34,8.34,8.67,9.65,9.62,9.53,9.4,9.21,8.98,8.7,8.4,8.06,7.69,7.3,6.89,6.47,6.03,5.59,5.14,4.7,4.26,3.83,3.42,3.02,2.65,2.3,1.98,1.7,1.45,1.25,1.09,0.99,0.94,0.92,0.91,0.89,0.87,0.85,0.84,0.82,0.81,0.79,0.78,0.77,0.75,0.74,0.73,0.72,0.71,0.7,0.69,0.68,0.67,0.66,0.65,0.64,0.64,0.63,0.63,0.62,0.62,0.61,0.61,0.61,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.6,0.61,0.61,0.61,0.61,0.61,0.61,0.62,0.62,0.62,0.62,0.63,0.63,0.63,0.63,0.63,0.64,0.64,0.64,0.64,0.64,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.65,0.64,0.63,0.62,0.6,0.59,0.57,0.55,0.54,0.53,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.51,0.51,0.51,0.5,0.5,0.49,0.48,0.47,0.47,0.46,0.45,0.45,0.44,0.43,0.42,0.42,0.41,0.41,0.41,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.41,0.42,0.43,0.44,0.46,0.48,0.5,0.53,0.55,0.58,0.61,0.64,0.67,0.7,0.73,0.77,0.8,0.83,0.87,0.9,0.93,0.96,0.99,1.02,1.05,1.08,1.1,1.12,1.14,1.16,1.17,1.18,1.19,1.2,1.2,1.2,1.19,1.17,1.15,1.12,1.09,1.06,1.02,0.98,0.94,0.9,0.86,0.82,0.78,0.74,0.7,0.66,0.63,0.6,0.57,0.55,0.53,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.52,0.51,0.51,0.5,0.5,0.49,0.49,0.48,0.47,0.47,0.47,0.46,0.46,0.45,0.45,0.45,0.44,0.44,0.44,0.43,0.43,0.43,0.42,0.42,0.42,0.41,0.41,0.41,0.41,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.4,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.41,0.42,0.42,0.42,0.42,0.42,0.42,0.42,0.42,0.42,0.43,0.43,0.43,0.43,0.43,0.43,0.44,0.44,0.44,0.44,0.44,0.44,0.45,0.45,0.45
            ]
        },
        {
            name: '降雨量',
            type: 'line',
            yAxisIndex: 1,
            animation: false,
            areaStyle: {},
            lineStyle: {
                width: 1
            },
            markArea: {
                silent: true,
                data: [
                    [{
                        xAxis: '2009/9/10\n7:00'
                    }, {
                        xAxis: '2009/9/20\n7:00'
                    }]
                ]
            },
            data: [
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.005,0.017,0.017,0.017,0.017,0.011,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.021,0.026,0.03,0.036,0.036,0.195,0.221,0.019,0.013,0.017,0.03,0.03,0.03,0.046,0.045,0.038,0.084,0.045,0.045,0.037,0.034,0.035,0.036,0.044,0.052,0.048,0.109,0.033,0.029,0.04,0.042,0.042,0.042,0.073,0.076,0.062,0.066,0.066,0.075,0.096,0.128,0.121,0.128,0.14,0.226,0.143,0.097,0.018,0,0,0,0,0,0.018,0.047,0.054,0.054,0.054,0.036,0.185,0.009,0.038,0.061,0.077,0.091,0.126,0.69,0.182,0.349,0.231,0.146,0.128,0.167,0.1,0.075,0.071,0.071,0.117,0.01,0.002,0.002,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.005,0.026,0.038,0.038,0.038,0.076,0.086,0.109,0.213,0.276,0.288,0.297,0.642,1.799,1.236,2.138,0.921,0.497,0.685,0.828,0.41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.018,0.024,0.024,0.024,0.024,0.006,0.003,0.046,0.046,0.046,0.046,0.043,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.204,0.303,1.028,1.328,1.524,1.41,1.362,1.292,1.191,0.529,0.501,0.944,1.81,2.899,0.859,0.126,0.087,0.047,0,0,0,0,0.011,0.028,0.028,0.028,0.028,0.017,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.099,0.159,0.297,0.309,0.309,0.614,0.818,1.436,1.195,0.553,0.542,0.955,0.898,0.466,0.386,0.556,0.388,0.221,0.192,0.192,0.187,0.166,0.18,0.302,0.158,0.009,0.009,0.009,0.009,0.009,0.007,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.004,0.032,0.032,0.032,0.032,0.082,0.149,0.204,0.247,0.262,0.49,0.51,0.533,0.746,0.847,2.393,1.188,1.114,0.475,0.043,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.017,0.017,0.021,0.042,0.079,0.111,0.126,0.122,0.133,0.846,0.102,0.077,0.067,0.056,0.005,0,0,0,0,0,0,0,0,0,0,0,0,0,0.011,0.017,0.017,0.017,0.017,0.006,0,0,0,0,0,0.01,0.03,0.054,0.067,0.07,0.25,0.251,0.494,0.065,0.054,0.054,0.064,0.084,0.077,0.101,0.132,0.248,0.069,0.117,0.115,0.087,0.326,0.036,0.009,0.009,0.009,0.009,0.009,0.004,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.02,0.039,0.04,0.04,0.04,0.229,0.079,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.023,0.069,0.082,0.082,0.082,0.503,0.774,0.038,0.012,0.012,0.012,0.016,0.02,0.028,0.051,0.06,0.064,0.19,0.15,0.164,0.139,0.13,0.085,0.031,0.023,0.022,0.007,0.005,0.005,0.001,0,0.02,0.048,0.048,0.053,0.056,0.036,0.008,0.008,0.004,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.013,0.017,0.036,0.068,0.095,0.233,0.272,0.377,0.722,1.494,3.756,0.954,0.439,0.442,0.462,0.373,0.249,0.214,0.1,0.044,0.037,0.023,0.002,0,0,0,0,0,0,0.02,0.024,0.024,0.024,0.024,0.004,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.008,0.017,0.017,0.045,0.186,0.308,0.241,0.241,0.893,4.067,4.494,5.015,3.494,2.057,1.411,0.718,0.407,0.313,0.339,1.537,1.105,0.218,0.136,0.03,0.005,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.037,0.448,1.2,1.309,1.309,1.425,1.223,0.471,0.767,0.423,0.273,0.412,0.646,0.481,0.239,0.131,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.044,0.15,0.223,0.388,0.513,0.883,2.828,4.786,5.959,4.95,6.434,6.319,3.35,2.806,4.204,1.395,1.015,1.015,0.836,0.74,0.72,0.615,0.477,0.192,0.046,0.007,0.007,0.007,0.007,0.007,0.007,0.007,0.008,0.005,0.005,0.005,0.005,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.001,0.012,0.012,0.012,0.012,0.011,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.002,0.012,0.028,0.028,0.028,0.138,0.092,0.082,0.082,0.096,0.719,0.155,0.042,0.047,0.129,0.021,0.021,0.014,0.009,0.029,0.067,0.088,0.095,0.095,0.138,0.091,0.032,0.025,0.025,0.003,0,0,0,0,0,0,0,0,0,0,0,0,0.002,0.045,0.228,0.297,0.325,0.339,0.581,1.244,0.796,0.517,0.227,0.053,0.006,0,0,0,0,0,0,0,0,0,0.003,0.005,0.005,0.005,0.005,0.081,0.129,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.014,0.041,0.041,0.041,0.041,0.027,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.009,0.017,0.017,0.017,0.017,0.355,0.174,0.009,0.009,0.012,0.136,0.208,0.208,0.208,0.215,7.359,1.858,0.458,0.053,0.053,0.047,0.045,0.045,0.059,0.136,0.188,0.206,0.21,0.588,1.517,6.02,4.688,4.42,0.624,0.326,0.359,0.553,0.899,0.94,2.95,9.415,5.752,1.092,0.096,0.035,0.026,0.018,0.015,0.011,0.011,0.011,0,0,0,0,0,0,0,0,0,0,0,0.056,0.27,0.314,0.351,0.354,0.609,0.796,1.857,0.848,0.538,0.214,0.178,0.178,0.201,0.231,0.227,0.272,0.397,0.45,1.014,2.917,1.675,0.081,0.059,0.059,0.148,0.075,0.075,0.078,0.236,0.784,0.784,0.784,0.784,0.741,0.115,0.058,0.058,0.058,0.029,0.015,0.015,0.015,0.015,0.012,0.008,0.604,0.985,1.305,2.273,2.528,2.336,2.496,2.281,1.397,1.713,3.259,1.167,0.745,0.548,1.058,0.684,0.728,0.392,0.179,0.283,0.283,0.46,0.08,0.099,0.099,0.099,0.1,0.143,0.137,0.238,0.317,0.262,0.225,0.792,0.426,0.332,0.261,0.11,0.093,0.102,0.171,0.292,0.504,0.605,1.745,2.485,1.964,0.33,0.171,0.259,0.242,0.215,0.366,0.354,0.205,0.203,0.262,0.153,0.13,0.137,0.362,0.691,0.295,0.433,0.154,0.056,0.053,0.053,0.053,0.051,0.047,0.065,0.078,0.091,0.206,0.813,0.102,0.151,0.05,0.024,0.004,0.001,0,0,0,0.021,0.021,0.021,0.021,0.021,0.013,0.013,0.013,0.013,0.013,0.013,0.013,0.013,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.008,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.018,0.021,0.021,0.021,0.021,0.003,0,0,0,0,0,0,0,0,0,0.024,0.173,0.261,0.267,0.267,0.534,1.354,1.772,0.72,0.218,0.018,0.018,0.028,0.036,0.032,0.194,0.082,0.035,0.286,0.027,0.038,0.038,0.027,0.021,0.014,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.016,0.017,0.017,0.031,0.047,0.043,0.056,0.104,0.149,0.179,0.205,0.328,0.998,0.522,1.851,3.727,3.273,2.204,1.169,1.006,1.179,0.74,0.741,1.065,0.925,0.671,0.497,0.431,0.327,0.277,0.126,0.581,0.207,0.359,2.485,0.038,0.036,0.003,0.003,0.003,0.003,0.004,0.098,0.023,0.021,0.021,0.022,0.041,0.041,0.043,0.045,0.043,0.014,0.014,0.014,0.014,0.014,0.014,0.014,0.031,0.046,0.063,0.119,0.107,0.092,0.085,0.065,0.06,0.054,0.042,0.039,0.046,0.044,0.028,0.028,0.02,0.013,0.013,0.013,0.013,0.016,0.032,0.031,0.031,0.031,0.028,0.011,0.011,0.011,0.011,0.011,0.023,0.024,0.024,0.024,0.019,0.015,0.015,0.015,0.015,0.015,0.015,0.013,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.011,0.017,0.024,0.026,0.061,0.172,0.206,0.213,0.267,0.511,0.668,0.157,0.017,0.017,0.017,0.046,0.054,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.001,0.017,0.017,0.017,0.017,0.016,0,0,0,0,0,0,0,0,0,0.01,0.017,0.017,0.017,0.017,0.012,0.017,0.017,0.017,0.017,0.012,0,0,0,0,0,0.003,0.031,0.066,0.093,0.112,0.122,0.202,0.068,0.041,0.022,0.011,0,0,0,0,0,0,0,0,0,0,0,0.002,0.005,0.012,0.021,0.021,0.019,0.033,0.03,0.026,0.026,0.034,0.095,0.024,0.024,0.024,0.023,0.019,0.018,0.018,0.018,0.011,0.03,0.045,0.044,0.044,0.044,0.022,0.009,0.024,0.033,0.033,0.033,0.024,0.009,0,0,0,0,0,0,0.003,0.017,0.017,0.017,0.017,0.014,0,0,0,0,0,0.032,0.032,0.032,0.032,0.032,0.005,0.008,0.009,0.014,0.014,0.009,0.005,0.004,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.007,0.009,0.009,0.009,0.009,0.043,0.063,0.084,0.098,0.101,0.213,0.334,0.383,0.43,0.448,0.511,0.801,0.835,1.642,1.614,1.496,1.496,1.476,1.068,0.481,0.22,0.119,0.099,0.07,0.072,0.063,0.076,0.14,0.205,0.28,0.297,0.3,0.479,0.877,1.098,1.611,1.629,1.686,1.686,1.631,1.528,1.862,1.703,1.531,2.196,0.395,0.416,0.453,0.728,0.917,0.986,1.17,2.171,3.011,2.909,3.301,1.377,0.778,0.799,0.947,1.039,0.879,0.76,1.372,1.674,1.674,1.68,1.823,1.793,1.162,0.783,0.216,0.152,0.152,0.152,0.049,0,0,0,0.117,0.127,0.127,0.127,0.127,0.127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.003,0.005,0.005,0.005,0.005,0.003,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.309,0.364,0.364,0.364,0.364,0.063,0.01,0.01,0.01,0.012,0.015,0.015,0.11,0.55,0.824,0.825,0.829,1.39,1.429,1.342,1.43,1.636,1.717,2.135,2.203,3.191,3.022,1.589,0.86,0.807,0.645,0.595,0.588,0.557,0.552,1.271,0.708,0.677,0.629,0.714,0.203,0.133,0.061,0.062,0.018,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.001,0.072,0.29,0.438,0.53,0.557,0.873,1.039,1.04,0.208,0.049,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.03,0.039,0.039,0.039,0.039,0.098,0.008,0.007,0.007,0.007,0.007,0.007,0.007,0.007,0.007,0.007,0.056,0.062,0.065,0.065,0.065,0.047,0.216,0.256,0.315,0.4,0.502,0.449,0.47,0.571,0.814,1.153,0.774,0.202,0.086,0.075,0.071,0.032,0.019,0.003,0.004,0.004,0.004,0.004,0.004,0.004,0.007,0.072,0.153,0.256,0.306,0.404,0.698,0.733,0.823,0.715,0.563,0.404,0.293,0.217,0.213,0.202,0.202,0.294,0.704,0.797,1.359,1.101,0.72,0.514,0.539,0.434,0.389,0.387,0.386,0.375,0.369,0.319,0.239,0.183,0.136,0.062,0.052,0.096,0.119,0.119,0.114,0.127,0.132,0.139,0.169,0.191,0.278,0.254,0.214,0.237,0.221,0.143,0.129,0.125,0.109,0.1,0.087,0.06,0.038,0.029,0.029,0.028,0.048,0.053,0.053,0.111,0.125,0.102,0.097,0.097,0.039,0.02,0.02,0.02,0.014,0.004,0.031,0.043,0.047,0.052,0.08,0.144,0.182,0.176,0.171,0.149,0.112,0.025,0,0,0,0,0,0,0,0.016,0.031,0.031,0.031,0.031,0.015,0,0,0,0,0,0.005,0.005,0.005,0.005,0.005,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.005,0.005,0.005,0.005,0.005,0.001,0,0,0
            ]
        }
    ]
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=line-easing">Line Easing Visualizing</a></p>
<script>  
var easingFuncs = {
    linear: function (k) {
        return k;
    },
    quadraticIn: function (k) {
        return k * k;
    },
    quadraticOut: function (k) {
        return k * (2 - k);
    },
    quadraticInOut: function (k) {
        if ((k *= 2) < 1) { return 0.5 * k * k; }
        return -0.5 * (--k * (k - 2) - 1);
    },
    cubicIn: function (k) {
        return k * k * k;
    },
    cubicOut: function (k) {
        return --k * k * k + 1;
    },
    cubicInOut: function (k) {
        if ((k *= 2) < 1) { return 0.5 * k * k * k; }
        return 0.5 * ((k -= 2) * k * k + 2);
    },
    quarticIn: function (k) {
        return k * k * k * k;
    },
    quarticOut: function (k) {
        return 1 - (--k * k * k * k);
    },
    quarticInOut: function (k) {
        if ((k *= 2) < 1) { return 0.5 * k * k * k * k; }
        return -0.5 * ((k -= 2) * k * k * k - 2);
    },
    quinticIn: function (k) {
        return k * k * k * k * k;
    },
    quinticOut: function (k) {
        return --k * k * k * k * k + 1;
    },
    quinticInOut: function (k) {
        if ((k *= 2) < 1) { return 0.5 * k * k * k * k * k; }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },
    sinusoidalIn: function (k) {
        return 1 - Math.cos(k * Math.PI / 2);
    },
    sinusoidalOut: function (k) {
        return Math.sin(k * Math.PI / 2);
    },
    sinusoidalInOut: function (k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
    },
    exponentialIn: function (k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
    },
    exponentialOut: function (k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },
    exponentialInOut: function (k) {
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },
    circularIn: function (k) {
        return 1 - Math.sqrt(1 - k * k);
    },
    circularOut: function (k) {
        return Math.sqrt(1 - (--k * k));
    },
    circularInOut: function (k) {
        if ((k *= 2) < 1) { return -0.5 * (Math.sqrt(1 - k * k) - 1); }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) { return 0; }
        if (k === 1) { return 1; }
        if (!a || a < 1) { a = 1; s = p / 4; }
        else { s = p * Math.asin(1 / a) / (2 * Math.PI); }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },
    elasticOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) { return 0; }
        if (k === 1) { return 1; }
        if (!a || a < 1) { a = 1; s = p / 4; }
        else { s = p * Math.asin(1 / a) / (2 * Math.PI); }
        return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
    },
    elasticInOut: function (k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) { return 0; }
        if (k === 1) { return 1; }
        if (!a || a < 1) { a = 1; s = p / 4; }
        else { s = p * Math.asin(1 / a) / (2 * Math.PI); }
        if ((k *= 2) < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

    },
    
    // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
    backIn: function (k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    },
    backOut: function (k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    },
    backInOut: function (k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) { return 0.5 * (k * k * ((s + 1) * k - s)); }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    
    // 创建弹跳效果
    bounceIn: function (k) {
        return 1 - easingFuncs.bounceOut(1 - k);
    },
    bounceOut: function (k) {
        if (k < (1 / 2.75)) { return 7.5625 * k * k; }
        else if (k < (2 / 2.75)) { return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75; }
        else if (k < (2.5 / 2.75)) { return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375; }
        else { return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375; }
    },
    bounceInOut: function (k) {
        if (k < 0.5) { return easingFuncs.bounceIn(k * 2) * 0.5; }
        return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
};

var N_POINT = 30;

var grids = [];
var xAxes = [];
var yAxes = [];
var series = [];
var titles = [];
var count = 0;
echarts.util.each(easingFuncs, function (easingFunc, name) {
    var data = [];
    for (var i = 0; i <= N_POINT; i++) {
        var x = i / N_POINT;
        var y = easingFunc(x);
        data.push([x, y]);
    }
    grids.push({
        show: true,
        borderWidth: 0,
        backgroundColor: '#fff',
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowBlur: 2
    });
    xAxes.push({
        type: 'value',
        show: false,
        min: 0,
        max: 1,
        gridIndex: count
    });
    yAxes.push({
        type: 'value',
        show: false,
        min: -0.4,
        max: 1.4,
        gridIndex: count
    });
    series.push({
        name: name,
        type: 'line',
        xAxisIndex: count,
        yAxisIndex: count,
        data: data,
        showSymbol: false,
        animationEasing: name,
        animationDuration: 1000
    });
    titles.push({
        textAlign: 'center',
        text: name,
        textStyle: {
            fontSize: 12,
            fontWeight: 'normal'
        }
    });
    count++;
});

var rowNumber = Math.ceil(Math.sqrt(count));
echarts.util.each(grids, function (grid, idx) {
    grid.left = ((idx % rowNumber) / rowNumber * 100 + 0.5) + '%';
    grid.top = (Math.floor(idx / rowNumber) / rowNumber * 100 + 0.5) + '%';
    grid.width = (1 / rowNumber * 100 - 1) + '%';
    grid.height = (1 / rowNumber * 100 - 1) + '%';

    titles[idx].left = parseFloat(grid.left) + parseFloat(grid.width) / 2 + '%';
    titles[idx].top = parseFloat(grid.top) + '%';
});
</script>
<div id="echart-4" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-4'));
                        // 指定图表的配置项和数据
                        var option = {
    title: titles.concat([{
        text: 'Different Easing Functions',
        top: 'bottom',
        left: 'center'
    }]),
    grid: grids,
    xAxis: xAxes,
    yAxis: yAxes,
    series: series
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<h2 id="柱状图bar">柱状图Bar</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=bar-animation-delay">柱状图动画延迟</a></p>
<script>
var xAxisData = [];
var data01 = [];
var data02 = [];
for (var i = 0; i < 100; i++) {
    xAxisData.push('类目' + i);
    data01.push((Math.sin(i / 5) * (i / 5 -10) + i / 6) * 5);
    data02.push((Math.cos(i / 5) * (i / 5 -10) + i / 6) * 5);
}
</script>
<div id="echart-5" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-5'));
                        // 指定图表的配置项和数据
                        var option = {
    title: {
        text: '柱状图动画延迟'
    },
    legend: {
        data: ['bar01', 'bar02']
    },
    toolbox: {
        // y: 'bottom',
        feature: {
            magicType: {
                type: ['stack', 'tiled']
            },
            dataView: {},
            saveAsImage: {
                pixelRatio: 2
            }
        }
    },
    tooltip: {},
    xAxis: {
        data: xAxisData,
        splitLine: {
            show: false
        }
    },
    yAxis: {
    },
    series: [{
        name: 'bar01',
        type: 'bar',
        data: data01,
        animationDelay: function (idx) {
            return idx * 10 + 50;
        }
    }, {
        name: 'bar02',
        type: 'bar',
        data: data02,
        animationDelay: function (idx) {
            return idx * 10 + 100;
        }
    }],
    animationEasing: 'elasticOut',
    animationDelayUpdate: function (idx) {
        return idx * 5;
    }
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=bar-brush">柱状框选图</a></p>
<script>
var xAxisData = [];
var data1 = [];
var data2 = [];
var data3 = [];
var data4 = [];

for (var i = 0; i < 10; i++) {
    xAxisData.push('Class' + i);
    data1.push((Math.random() * 2).toFixed(2));
    data2.push(-Math.random().toFixed(2));
    data3.push((Math.random() * 5).toFixed(2));
    data4.push((Math.random() + 0.3).toFixed(2));
}

var emphasisStyle = {
    itemStyle: {
        barBorderWidth: 1,
        shadowBlur: 10,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        shadowColor: 'rgba(0,0,0,0.5)'
    }
};

myChart.on('brushSelected', renderBrushed);

function renderBrushed(params) {
    var brushed = [];
    var brushComponent = params.batch[0];

    for (var sIdx = 0; sIdx < brushComponent.selected.length; sIdx++) {
        var rawIndices = brushComponent.selected[sIdx].dataIndex;
        brushed.push('[Series ' + sIdx + '] ' + rawIndices.join(', '));
    }
    
    myChart.setOption({
        title: {
            backgroundColor: '#333',
            text: 'SELECTED DATA INDICES: \n' + brushed.join('\n'),
            bottom: 0,
            right: 0,
            width: 100,
            textStyle: {
                fontSize: 12,
                color: '#fff'
            }
        }
    });
}
</script>
<div id="echart-6" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-6'));
                        // 指定图表的配置项和数据
                        var option = {
    backgroundColor: '#eee',
    legend: {
        data: ['bar', 'bar2', 'bar3', 'bar4'],
        left: 10
    },
    brush: {
        toolbox: ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],
        xAxisIndex: 0
    },
    toolbox: {
        feature: {
            magicType: {
                type: ['stack', 'tiled']
            },
            dataView: {}
        }
    },
    tooltip: {},
    xAxis: {
        data: xAxisData,
        name: 'X Axis',
        axisLine: {onZero: true},
        splitLine: {show: false},
        splitArea: {show: false}
    },
    yAxis: {
        inverse: true,
        splitArea: {show: false}
    },
    grid: {
        left: 100
    },
    visualMap: {
        type: 'continuous',
        dimension: 1,
        text: ['High', 'Low'],
        inverse: true,
        itemHeight: 200,
        calculable: true,
        min: -2,
        max: 6,
        top: 60,
        left: 10,
        inRange: {
            colorLightness: [0.4, 0.8]
        },
        outOfRange: {
            color: '#bbb'
        },
        controller: {
            inRange: {
                color: '#2f4554'
            }
        }
    },
    series: [
        {
            name: 'bar',
            type: 'bar',
            stack: 'one',
            emphasis: emphasisStyle,
            data: data1
        },
        {
            name: 'bar2',
            type: 'bar',
            stack: 'one',
            emphasis: emphasisStyle,
            data: data2
        },
        {
            name: 'bar3',
            type: 'bar',
            stack: 'two',
            emphasis: emphasisStyle,
            data: data3
        },
        {
            name: 'bar4',
            type: 'bar',
            stack: 'two',
            emphasis: emphasisStyle,
            data: data4
        }
    ]
};;
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=bar-polar-stack-radial">极坐标系下的堆叠柱状图</a></p>
<div id="echart-7" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-7'));
                        // 指定图表的配置项和数据
                        var option = {
    angleAxis: {
        type: 'category',
        data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日']
    },
    radiusAxis: {
    },
    polar: {
    },
    series: [{
        type: 'bar',
        data: [1, 2, 3, 4, 3, 5, 1],
        coordinateSystem: 'polar',
        name: 'A',
        stack: 'a'
    }, {
        type: 'bar',
        data: [2, 4, 6, 1, 3, 2, 1],
        coordinateSystem: 'polar',
        name: 'B',
        stack: 'a'
    }, {
        type: 'bar',
        data: [1, 2, 3, 4, 1, 2, 5],
        coordinateSystem: 'polar',
        name: 'C',
        stack: 'a'
    }],
    legend: {
        show: true,
        data: ['A', 'B', 'C']
    }
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<h2 id="饼图pie">饼图Pie</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=pie-pattern">Texture On Pie Chart</a></p>
<script>
var piePatternSrc = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/4gxYSUNDX1BST0ZJTEUAAQEAAAxITGlubwIQAABtbnRyUkdCIFhZWiAHzgACAAkABgAxAABhY3NwTVNGVAAAAABJRUMgc1JHQgAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLUhQICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFjcHJ0AAABUAAAADNkZXNjAAABhAAAAGx3dHB0AAAB8AAAABRia3B0AAACBAAAABRyWFlaAAACGAAAABRnWFlaAAACLAAAABRiWFlaAAACQAAAABRkbW5kAAACVAAAAHBkbWRkAAACxAAAAIh2dWVkAAADTAAAAIZ2aWV3AAAD1AAAACRsdW1pAAAD+AAAABRtZWFzAAAEDAAAACR0ZWNoAAAEMAAAAAxyVFJDAAAEPAAACAxnVFJDAAAEPAAACAxiVFJDAAAEPAAACAx0ZXh0AAAAAENvcHlyaWdodCAoYykgMTk5OCBIZXdsZXR0LVBhY2thcmQgQ29tcGFueQAAZGVzYwAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAPNRAAEAAAABFsxYWVogAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z2Rlc2MAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkZXNjAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGluIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHZpZXcAAAAAABOk/gAUXy4AEM8UAAPtzAAEEwsAA1yeAAAAAVhZWiAAAAAAAEwJVgBQAAAAVx/nbWVhcwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAo8AAAACc2lnIAAAAABDUlQgY3VydgAAAAAAAAQAAAAABQAKAA8AFAAZAB4AIwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQAJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEBBwENARMBGQEfASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGaAaEBqQGxAbkBwQHJAdEB2QHhAekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQCXQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLgAusC9QMAAwsDFgMhAy0DOANDA08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQgBC0EOwRIBFUEYwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWmBbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkHKwc9B08HYQd0B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjSCOcI+wkQCSUJOglPCWQJeQmPCaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4KxQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5DBIMKgxDDFwMdQyODKcMwAzZDPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62DtIO7g8JDyUPQQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJEegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsUrRTOFPAVEhU0FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReuF9IX9xgbGEAYZRiKGK8Y1Rj6GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwbFBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0eHUcdcB2ZHcMd7B4WHkAeah6UHr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGhIc4h+yInIlUigiKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaHJrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8rAis2K2krnSvRLAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+RL8cv/jA1MGwwpDDbMRIxSjGCMbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDecN9c4FDhQOIw4yDkFOUI5fzm8Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4gPmA+oD7gPyE/YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUSRVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxLU0uaS+JMKkxyTLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGbUeZSMVJ8UsdTE1NfU6pT9lRCVI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9YfVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyGXNZdJ114XcleGl5sXr1fD19hX7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9ZZJl52Y9ZpJm6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5rbsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52m3b4d1Z3s3gReG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7CfyN/hH/lgEeAqIEKgWuBzYIwgpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuHn4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zKjTGNmI3/jmaOzo82j56QBpBukNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfgmEyYuJkkmZCZ/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUStuK4trqGvFq+LsACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfguFm40blKucK6O7q1uy67p7whvJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6ybnKOMq3yzbLtsw1zLXNNc21zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY11zX4Nhk2OjZbNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T85YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXxcvH/8ozzGfOn9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26/kv+3P9t////2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCACgAPIDAREAAhEBAxEB/8QAGgAAAwEBAQEAAAAAAAAAAAAAAwQFAgEABv/EADkQAAIBAwMCBQIEBQUAAwADAAECAwQRIQASMQVBEyJRYXEUgQYykaEjQrHB8BVS0eHxJDNiNJKy/8QAGQEBAQEBAQEAAAAAAAAAAAAAAgEDAAQG/8QALhEBAAMAAwACAgEDAgUFAAAAAQACERIhMQNBIlFhMnGxQoEEE5Gh4VJi0fDx/9oADAMBAAIRAxEAPwD6XqfVIzVMqsXiupJjNwvruFz6Dj219ZX43J83b5BYY9Qpp5YoAISApaytZWBvYC9rH19Bo/8ALTuXnV6hKzdEg8XqUjUhkCxgSL5TbgDvb1411e3+nuc9f6uotTXRpJY3qQhba8yMykAixsTbP/Ok99MIZ2Rqm6aIqGWbwFUAkKkk7sWzbtz830X5Nc2I+Prc/wAzHWIzTdMo7zLDIZgRGisMXAzdjjOba6jtmWxlSNP06ISSNNuhlKjYm+0bEA2KtwT7HOjzfqVob3GYHjh6bE89VPtQXkIOzbfIJXt3tbGi626IjA7ZJjqqeSVPBaRo0BZmKswLW5Wx4HqdaI/czE+pR+olkiEtBTVqyttO5wQp7Gw59tZ4HVkj19qMitU1UdF4BeSSR9wN7y3Pc7bWJHpe2teNV2AUMg3PUqGnSWUyqk1tl7W3EG/fIH6frq/hZwk/I98jlMtVV1SRziqdFIBC7YyAeb/YD50VKnUpq9y3BWJK6U8UE8UaO7Hew2kX4HPY299YtE7WbFvqLVj+NWyPSqXWJAisBdSSufvYqL6VTD8obPfUE1TDAfCaRxeMSsuwW3C4NyD7jSxYdCI2lSRqinidoywARgApsLA3vg5Pbvp9PTD52RyOqFad+6OPbgLZnN7i5yRoceMXLlBSCGpTx64SuCCViUbAyWwbjJJyecYvxq9nVZznrF6l4IJZXoIKttse5LsVU7gdtibDk/vqmp+TI4O1n03SaymDGNaOBJdg3pJ5+973GDz6683yUt7vU3+O1f1ATTwif+NKRvJKRRwDHm+9raRVzr/Mim9/4iKV0Mk0hikqpdwGGOHW17gXAt2xfWvBDuZ8jeoCkrYmcGON0ldmu2y7EckdwePjXWr+5B/UZq6tEp12QzSve5Ctnm2bEnJI0SvfbG2izQ0k3SfCjR/HH8YSLewfvz6ntm+mNi2wONep2ngSq2/TTSxEoHazhcdwLD1Jzrl4+kgcvGC+njSmMj1ZVpmPmaQEkg2B/wA9tLk7mScevZKFUVqZZQ0skDA+H4SlmITuBa1ifT0086yHc7h+kdSkfqbtJRytDUQjbvGw7xgjF/QD11L0OPT5LS3fcuoY0RVNNTAgWsWOsXf3Nev1IUghhieP6Qh2a7SGNR27jtbi/Hrrc1d2YdZmST1uGILBuRomdfNdSS1v9p4+xx8a0+NZncI307qCRTwUl5ZFdrgggHi9u3xz6aNqb3FW2OShTR76pnpqUuA38SnaVixGe3Y+/toLhixhr0RmOnKdLlkdo1jmYbFjUZa/AvfHra2g2/LIinWyX1bp95UaogkDF9niR2dDnAtgcdufnWtL9YMztTvUlarFVT9Ofa0M3T7MzOoDFTf/AGn8v78ayMtb9M0drX9kSpno0FoKeernK7Ymv50HdlucW9OL6VuX25DXj+tjsDR00UEcKO1NHcAG/lt3YXyc9sdyNBNe/YywH8Rnq3UPHo5aVZJQBJudyW8t7HA75uPTRp8ePKK/ydZFaUU5RJI50Ryd7NM1rixsVHc9vT500TrIBH7jc1PTRwyVTzkQKVTdM+ZrEbifRRb07azLWXM7mvEDdkufbHV0z09QyQuXBkbG0WXPsMgeutDzEmb71N01VHTVI/8AlsFETNcXZZeAABbFzYe3v261VPJwg+xqajWKgp4YpnaouTKm3cFIPm359eP10S22VOpWuV9gfpKiOSJ/qYjJYxrGIAotbdn14Glyr+pONv3/ANpQ6fUVLTQwQ1MbyG7MiRA7ST5gc849NZ2K4qR1bbgxeqp6mOtUpU+GxkZpPKLbeDc9hm1vfSrarXyS1bD7BVXUZ6jqkh2p4gQKroT57A8C/Nu2rWhWsNrNmA6RR1T7lMSxFXWG6+W3Hr9vtfVves6tbS7HQUsTTRmojSVgFujm5OCc3xe4xrFvZ7yalA62LPMqyTUkkcszuQC4TLDvz9gD76uaciTc6YhVRTT3rvokiip5GkJkKeguMf0/41pVD8d9mdiz+WeQtMrlSZHjC7WO0XsQP5Rgd865/icfzByzwU/09zD/ABG3kBgLWyL2z+b1tqgsuhKFfXKqxMmzY6kswbccfH6enzoVo/cVrE+ZSoRRIJaaZ1UGOzsVzfGFPGdeji/TPPyD0j4eJKZxANpKlgFhF73Nu/rbQR3uMTOpmhmiinRZJaiIopR9sdsWyTnIv799dYU6nVsb3EjVIJWlRZJfDmKh41N+M3GbdtPi+MJY9lnb1V/NF06oMZypCpa3bWO0PWa5f9STU9R8UOs+2KQsqoAl/DH3JsPf41sfHnkxfk33qZlovFbbLJHJGWLECQKts/ltgNn0truWeS8ZoUFPLUCnoLSK2C8TFV4vtOeRYZ1OaG2ncBfxnFkNI04iLpMD4ZZpTZe2298i4B9dXN9k3IWIwJ02P6ionH8v8Nmbwb4v6eY/pbRd5dEpmSdT1UhrUWlYzuswVd2CCBfKkkWFuNa2qZ+Uzqu/jKVZVVUQfdVCColO1ztAjI3Yuv8AL7Y1nWtX62aNrH3kNSwwxqZ4fE+rk/PAi3BW44OB72uO2gq9PkQHp7OGeat6hDHOgpJPDYMQBeQEjGO3Ou4lTrudrZ76hG6eqz1dlSmpE2bTAtiDt7evx66hdw+2Voa/UV6rSqjrEQ3kNiGcttHORf8ANzgadLb3Dav1GaCheZY7QRbiDtvnZe54OCfft76F7BFSuwNHSkVccUUMbwASFma1uAe+QRnHvnVtbrV7nVrjmdTIiH1W6noEVIb7mTO3y2BJ7etvgnXb12zs76JW6fKoiUSUrnh95cbmvybd83F9Z2P0zQx9Jv8AEUsBkgVY1RWchQs1wfKQM9zzgf313xDO+RrF6VhvWN62OHan5d4VBz3Gb+59dJOvIRP3PdOcNO6USxsZfMQqAkZFwWv3511jrbTqveVjtb0muq6Wd0lSPbcqpNyTbFrYHH76FflrVCK3x2sbINOamGcw1PULRRyBmVjlje2bAG2OR/fWziaExFHFn0vTFlhNS1I9Oisn/wB8dO7EAD/Odea+Ocv8z0U03P8AEVhknqaireomkEZ2LEyBVLDPm8xJFz97W08K4BJrbdkqrjnPTq5I2cwngSzg4YAcWwDnWpmmzJ5Y5GUtVRXjZE/hhgn59l++bZ/70f6Ys0m2pKeMgpFCzGTZuZSQ23/cB9/11xZZzUI2lN1N6NJaKnjgitfem1CPYAnP30G1ByzFxumhIeyqEsoeZkLgOTEyDda45A9Ab632v1Mfy+4KWmphMjmKXYoEr7pSTk8GzeudIXzYcD6henQ0CKW8CNSbktsDD2C3Nu1vnRs2fuOofqe6jXxrGVaqSJFAIsgJupBOLntbXVp/E5vHjUyxnYtTDtXA/iWx+uhhFr+5HSlgClzV+Im4M7hgZEHoO5457ftrVs/qZAfuEqYVdIUEQmpWUFbMSAuc2BsD7f8AmuLf7MrU/uTAR6YRpADChYgJAlhKguQQx4b1xb113T2yeTa/Twb5ZWK1BB2ITfJ78W5135Pnk7awBP0wjRmeSMAOVcbWCkC3PIyRb11f6pH8ZMqohNP4sP8ADQym9nyAPUDB51qdGTJ7ZSMjpAn1UoqYd4KSLyx3flvzf2PprLO+uppv77JQl6gnTIRKhq3oFdnRkj80TE29Mc6zKc/c2ac+PZ5CxVU1bPEXSFat0BVdu0SDkHm19RqVOvJxZt/eFlrlqFqIjHTvHMEuBu3LZTcEetx276hTMYuWkUEZjRPG2xqieQttsi+9zze4t++lp9Sdylsi6jQx/SpDBTIGJK4Zsfm++ce/xrPuj3HhY6kyCjqo0ogijeiPthUlbXUi9yb9ydNsOwlUyOiSekEscJSTddZXJuEvi1/5ibffRwt7FrWBaqqDBDGY1WIsLkJ5iBe4vkW48va50ipuw8lMyZ6nWzRQHedrIyyGIR38pIzf0weB/bVrU+pLWfuLzpTSeCIpgtriXegaxPYAnnt+ukNiHK9ZHumrRo/iLFO7NfIjuD7fr/zoXbeR1Knc9JTrV+PGKKUBksoeZhk4HlUf9a7k172c1LdZFKOnraaZJfAMKSuFvYAqVNwAS3cc3xjVtar1shVO8jtU9dUVclMhsXBEiLUEI1s2G0Wue49DoVKhr/iKzZcP8x7p1MoepaI0zMijdCkZYjJ4uMHI0L282Oh6wFW0giKMyMJHQWMhAADCwI7jHppGeyKwPhpC00bvEjQsVUp5bKTfduIzYf4dXdx/cnmn6nmq1kkRHkkBIukq3IJGOO1/8xruOdknL6Y5C8bqRPXKpFjbadw7jLf1t66KP0RCfbEOtf6fAYTS1LysEO8eNYHuCBgeun8Zd9IPkaHjFaWGiloZ3eCNl/mJbdZbdjfmxvp25CENcTZuGLp0lLdIwsrKQFCBiSCDf7nt765bjL+KR4QU0lJBNPLId/lYbVVQGwRgfOs1dQIwEFZyOlq4o1jWmp3VQFDFluQO5vruQ9zuLJtSHqoysKPFLkoxAs2LlmJxn0v3GtT8fZk/l5J9SZIRGxptgVVEgIFgSOccHANtMR+4ET0jlNC1FVmWSRWsNwUXYqf94+bWI7aC8jIw4uxNqyT6mSN4FEm3+chAn/5zzxn/AAaXEzdh5O5k9VtVT1UCiSOolJZg4urLa+PQny4GrXAkttn2ESOqmroqWd2QRNkN5SLj1A9u19ctQ5E45LxZzq1NLQyR/TxeJLNlFdgwmFsgtwcffUpYsd/U69Wr19x7p8tSskslNFKsy28UTSgRx2IAVu5Ho1rjvoXzxjovpPQ/UL1RZJWmigKlSEI3U7bb7bel73/bGo5xw/8A2Lvd/wDpH6iCip62KKrieSrqTgGS42jNyAfnQGybXwiSo5b1huo0vT0pXmaAKiRKwAQsEYd/e9+LfbUra25stq1zck15FnH/AMdF3KGtGLrY8cjk3I41p2ewGJ1PGkSYRBWiWXB3xgszEcr2tyfYeupySXBjdHQUvT+lT1nn+sjDDyNcucsbfHc+vFtBs2sV+oyoHL7hZJfGjjFWfBiwdhBJF7ZP3Hyfvrszydu+yWJanqHVQlQKgbAAgjKgKBc5zwe/xrXCldJlybW7JqF6aHxjCJAw/h2IsL5JNwf/AHOuSz7KNTyV/GjhSMsajc9/4YQqBf49/wC+scWaaEIZqGWFYplX6lzYRvuB59PuDm2plx36lGqRfxGH0cVPFEyFip3uCb3O31tyL/P31c9WdvgRwUskhQMISwYMpVGLBu+24FtHlkvHYm9PUkSo8zQyrtO8bQGOObki2ffv6aWn94cf7RHqTrBDAz08kk4mEm9n8hCjN7+x1pU196gs56S5TTj/AFyMRJFC7RAMYyGDAHtj8xv6HWFq/h3Nh/OQ5unpD1oUgnl2yxERkt5ohc3U9uwt7HW9b7TcmLTL5sEJ2o1khRWCFiFDbLn3HJ/bSwt3DrUyAraueppljVLTFfFjtGBx3uQPNwNWoVZFbElfUS+KYZIYwzBlKM/HGe/trXOtme95Ow9ImgqGZgBZ7ho5LbRbB5H3Fu2o/LpO/wCVjHoaL6mJ28WZ7kBJELlbWySCcXyONBvk0K7NpX1GxbU1xbvuv/8A51OBLrH66R2qjTQVLJVEb2EiqCqbfynGL2NuPU6FcDU6itq4PcxTTOYadWaJdhIKbN1rjBxktz8X9dVDWEXILpSztVIs6zhZFEh2vtUHve4+Lkf+26B1OoO4zlVQxGEwCaabYPMwC2F/c+lj8DnXF32c0MzZpaI3p2Ncy+CobL3JNyRkZW18Y1OXvU7h53CTVjyVXgGOc04clSEDMfLm4t+/pnGuKgb9zmz53k51yCvWihEyOIRESpYBwvrbbzjsNd8dq717OuXzHyE6rC8TvPSSswcKnjTAq23F1bbg3F7evGuo6YzrmOkNT0Iqo7iWaJxHkPLkgc/fuPtot+P1KU5fcnxSQJ1CAPOqSbyse7Y1kAuG3HIv9s60dR6gMH2U6pqmrChFLREhCqqRfm3Ixi1vjWQVr7NFs+RSqhqAKdqeEpFGGIVWvtN7A/r69r6Qnc5HqMC9JE7Sp4gkjC/mADDk3ybLc9udT+ryXz2DajaKiqKqQEuYyRuYBXXYRa3oLWt9tdy14k7jhsaeolqYKCaUo0cgEo3NZSCMBrduLeltHAUJeSgxQqo6u8VA6NMfM0pj2gAKcebP83Oc8820v9O2k65ZWBrqqUhYUqKYSgAyCJDZbrhTcDsPnVrX7ySzHZ6SOelgq2qmDsvnEjAA35soz/nGiWRa5EhYLbASdL6bSNCY5Y4FR0YhyDuOSTtJ75ydUvdhtSpH+m9WhRVko51O4+XdtRE2k29/bWd/jXqxNK3DyM0HUJK2bxUcsCSqGKFpC3tuNgBbRtQqZLWzZ2ckRmiqDNTtLdcNLJYr+n376u9mM7+5J/VAlqennkUs0g2nyluCPUka0p+yC36np571ERMcispVBI2Qbi3F8rm3/muDpkVYr1aNW6wrBYfCCEZNirX5Cre9vf8AvpfG/jJc/KENLVhIpl/hhG2vGgCkEnDG4uRY9yTn213KvknG3sD1mnP0yvZmlBZdoUk37jB5xj7aVLGyXHJFiq7mOFEM0jLv7IXAHBuL2sefYfOtWv3Mh+p9LVyxyt4kVDJJI2WYFduzGSOf07jXnqJ6z0KPhFZpWp5jBU09VJSTorQ+IB2e+0ge2b5zbVDex7IVzp8h3kpd7bK6njW+Ea91HocaP5fqPr9xJKYGR53opUhLtepYLvvjdcHkCwt9/vq2+h/2mQfaf7wkfUYTAI545SYiRD4asvjc2IPwdF+N3SU+QzGEhrFepaRGeSodxGNgsRb/AGgkdxgdrX1GmGPkpcX+Z2fw2AqZ46oUzRKCkpBuSCQSb974tj+/GnQzuntGJ1VTNN4AEMyPJcKUXw1ZRfOMdhcHjTKhvcLZfqNUCeBXQSypIKYgyAFGJZivN/nP/Ghbswiq46kP1uoRK6jWFZ2pX3OYSpDLkbgBi9wePY51Pjq8XfZbppnkPFVr1CN1p5Fgpp03LGtiSD3N+O3lI1OLXt9l5cujyKwwMKtUZFC2sS1zdTbPbNlAGkvXUgd9w9RHC9V0+Pw4FUSsQ+w3FgTfHGcc6JoLK5oSrPVO9PKUMAkaUIF8OxB9eeNZlcZo20k2ppmhaE1M6l3Jchtwv+WwsD2tjWlbbuEFjPWL9QhZCUC3jYDeCbqD6t6cnv299WjDasYnE0NKz1M4dMbIwBv7i5Hb/Lagi9ErodsSoIZJPo/p3lSpYFizCwsbglj2sBi3GdKyG7DXXMnqWmZq2RIZFABIM25vMSDfPfk65sZ3OKu9RXrFGIJVWSFduzcCQWPHe/e+O+nSxY6Yb1avZKVbHv8Aw/SSTIkCLCpJMlmJI4tbnOs6uXQ7jt3Q0yJ19PQy7JI1lWWGPzvvA3G1gPLbvY/+6VWxJYrkL0Orp6YRx0Ypo2dt2++9jzkhRn9Rz99H5Kr7FSweS/JNURUqyQsfHUtcM6QKwzixu2sCouPn/Wa8nNP/AIkmWfxaVppot7Ol/CJJvYcZF/XPa2tcxwmeqawtdUyyUVPSCakoyzKQkCmWRbA2LHjm2BnUrX8m3bFa3QGETpvI1T4SNO8KG0rxk2Nw2fNYH9dO31sBveSX+IKmpSrhmpqdpSMPGrhttlzk4Bzx760+MMxmfyKOk3LWSCSjaol3RvF/GDMSLdgfjXFfclbebHKmMorbatxZjvO5QXB4a/a2fsdEf4lf4Yn1dKem6gIrwM20MjpJusvDKfTkcaVNsbDfBya6NRwtRQxTUreJCPM4lZVOc4B+/Gp8lndGKlRMSd6hElY6R0VPsVLyK7IzeS4yOw4/y511HO7M65vRDCjpSLv06UuedsIIv7amv7i4/wASq8lVNA1HOiU0MG4Fiu7Itcc/21nlR5Hey7ZOL1I70R8SSSRpDclYNx2EC9/MBwO4HtnWvPzJnx/cd6dBQ0srhDG1UY7CTbdiQDgsxwMG/wCms7trf2jqVr/eD6tVNWgJFUUwgiUqx3AeIfQDFgP7HSpTj6Q2vviQtdTxLTqs1VGsDQnZt23OQLd/Jj5xfUrZXolsAdsV6T09m6pRCqkk+mm/+und/MV+Sf8ABq/JfKvH2SlNTfI11+l6fQ9TpGoEv4cqp4ZkuymxPlBN7AjgdzqfFa9qvOL5K1qnGOTRQzVVT9B4ciGPwzI6r/DJGbX97Y7euiKBylQV4yZTQp9epedYl2qWYyG5AObAf4L41o2c8mRU32G6nIIKtTFNJ4cIBayFhbsbn1x/h1KdnZ7Lfp6YKOeVqmGUUrpGS838RghsALGwPsO1vTVQzNnC7uQrLPMkYkknUeGFuq4QWHP2BB499TQ8lxfYs6rVv4cKMlIyh3MvnLE2ve5AuLA2t6aQte32RB6+o3LJDHVCjpK6VyT4sm5htcKABxwBcE/trMFOViJQeNWe6ctFDFSxSR1ghmYgOFJ8Q2wB7c5112yr1LQqB7FBUS1HUGenp4iAfIZ2KuACR9ubAaYZXuFdeoSuQzzXnkjlDoo3R7kAuLgDi4wL8a6vR1Ot2xynoIIeisXhh8dIiAzA/wASy3BHocdtBut/4jKhX+YQ1/SqVd1OtM4RUTw0j3kWFzz2zolL29lbUr5Eulzu9GXijhiTfdnlAsV4AuSLWzk+4071N7hpbTomOndXNfUyJ08MGuQsgIK2FsqQB7ck8663xlTbTi6uExG07RzMgplG0s8uGkNj3vfORpYGQ6uxyWkd+n0cgqIpWcqxd0ZtrXPJJtYegF9Dl+SZkWdDuxzpnhVPU6kV06OJIADFGCFdhg2Uc+uhfa1OJNKBZeU+feRNyxQLFEYW27pXBY5IJIXve2tzfWYueELVyUz0TJEW+rmQDw1jJJNje9xbOobv8TnM/mMxzwJRmTwpZqmnYmcNFkq3/gxoo7n0xCZsT6l4MpZZqF0UAskjEKQpuoBtfPHB06b9MNg8ST6Kpp2qKr6aCaLyrKi7gbkrtIF/c6SOdw6D1HEqamkWKNRJZRa7MDcMQNo/2+45HbnUwt3O1r1DeCpyWdSeVEnHtzqbFkoN9VWV0NGHSyfljWMgM24Eg25A5J0Pxqcpfys8YrUTtR9UqIHlSZgwBZibqSBfB+fge+kHKokKtbI9xU1BrZjTU9O4h3AyNIdqkG4Bz2uTjvzpZx7WTeXQSlPJQU8ggKRStYBxHENrc2sbWNrZHsfTWYWTZptRyCYip6jJNW06bmhIgRgoRdt8kWvi99XONcqyf1OpMQ0zN1SA7aZoxHvD7GO8dyOLAYHvfXNvxkK9yW6zQV5jQhpjuZSwuduOCb2GDk89uNamJsyRHCUOmxQiRZ52n/iC7LKpIXvdbYP/AHoXV6I64OssUVXST1rU0DxGOJQ3mTaPgcf3GsbVsGs1raq4QPWTFURxM8cbCY2azZkut7DHseNL49r1+pL/AJGxSKkIYFwJG8MF41Ht5SPb+2k2hK/xOfR0KT04jWBYyDdpLkWAxft3Prq8rIycaGSnVrRL0/waWKNtrkF0S5Ycdrd9ZV5ctZpbjmEHB09anpzVhj8qSM8krSbWFsCML2HH3Oub5bjKV2vKZgl/1COliaqamSNWCiMBSwsGsf8Az11U4a5sI8gNyJqyUs5meojd2EiNI8e64ItfHbHb+mmnIzITp3YhUV0kvVIS9NL4CsAzOAi5UZPmz/3bTKhX2BstpU61NVy0tOsEdKFi2t4rSML3Ugrt5tm+fbWfxlRdml2yGSd+HmElJFvmlgpyDJJHGAim1wAT3PGBzp/L09GsPxed9Ed/D8VJJHNLXRSS06VC7IgLxkYPmJsD35NvnWfytvKzT4yp3aVIWu7/AElPT06IW8WV28pHbaLDPHH99B/9zsZ/BkkS1YCJE0rTIysGLkJscG4uCCWuR/TOtCv3kz08nJJpeoLTQpJJKq2Loshx3N2NwL+w9eNXCus7W3UPS0ir1qRI/Cp0WM4jYgfy4LdwNui2/HuUPyg6tKCQ1UbtKrF2kIRgDclSLDv3zq15GJC8XqDp4J6avDTTlgb8sCEGTY++k2LHRIVR9neoS13hmaMU4jZiMplrEcD5sf3GpUr5KtvYsKqVpYBW08UsiFlk2v8AypggE3vn0wNPiY4w8n7IvT1EonkRkMwUiNQpACIchfduNVqfuTk/qGaCmRZJGfdJIgUDzKFLLi3bBzxxqayoHcWi6SssSSSQyNI6hmYSR5J5POq2RzZxj9T6PqFGYESoMsktWbpZm2hje1j7evPrrGl96zqO9M73uSZhLFNHHSRlp3YGY481t25cdhe/7a06TuDsep7plOk0Bm3IZo2YkSL5bk2vbsbWGutbHJ1a72+w9eKmFvGlkp1Mce1FF7Fbntf8wuB/mTXHolRO2eSKUuKiSOySwMwB37SLjJHe55/41dPJMfciPVeqTOKdUhNkUI0pe98HHYnnnWlPjO+4LfK9dT1Mr1lPEQ6qzSlZGCXIOBhv6du2ucqshtifTwSQmjbfvjjj3RRSDK7u4N83yMjnXmR5dT0mZ3IdDOsNdVh5pZFeygZNxtFhjtj9zraxoZMquLsz1CCB+qUCU9K6oUAUBjHcAjjN8k5Pz86tbWKusN61bGEPKhqKiohirAkZdUAjl3kAAXW5yPzXv7aPgKR/aD/3mylPFUrHCaptqMxZCAWKm17nk831NsmuSZUcNheqVETUsa7ZVUyA7fGDFiLG+2+QdSlXYr26j0MUVRvJ3Koa/kjdgxtjJ0FaxgMls1PS9NoJxE7udzEggFTY2uObfvxrT8rWSZfjWowFI/1ojmhaCIxKwtJIMXF8XvfnSscemQsW7JNnaKsq2ppmDMCjQEOWAFgoOTzduOx0wamkGlnGfQBXjpJKGnERlWytIRtLY5B7HWHS8mbnRxIp0WmEHhfxIGkDuyblLEEHJF+9r2NgPbSu7JQYh02uFfBWUs0k306SqZo4wBdlzcnsLW760tXilj2Z1tyGrC9Ofx66RYZYYE3OD4j7yMKNpPBOPQ/00bGHcVUXqdqKalXfKJfqLkELHEVW54W5F7WznXFreTkPZufrMZoooy9KsqFWXY28qL2JJwvrqHxvLZX5AMYSClhXqUT1JIjcb2EZAsCwGce4JAtyL6ivHqUDe5vqVOldWiodZNiyhUUjLngj9tSrxMnWNtpFKqoT6uSnqXaZ2XdHGFw/Ofbn40g60kX6YCo6g0PSJI0oJnKyGJJHIC7WSy5yQPU841eO23Z3LK5GKaSsrringgiaRGCu4LFTfNu2fjUcr6y928i0EFf0yeWCpnCulmMyx+INwv6nJAOdLSxpDjVxjVBRnxJhV17+DKp/hugv5bFQP+edS1v0RFd9YkaG5JIQ37+K2lv8wd/ol3qhhFQjQy1JaL82+7F/WxI5A/r7azpuY5FfN02LVB+hZSqTmUgA3sAi3JOft++kflC/jMUjSNVymo//AI4UyNscHZfI3Di9v8zrrZnXstd38p7rFTLPU01qZoKYPtAUds+Y3tc3GTqUqA96zr2VOsJ6ihqaiqp0adiHilZCzbFjtc7VtzyOdWyAuSVFc2cio6YyU9MYEVtx3tGbtIxPOeddztjbZ3E6MjnWjMghVImiaKQdhi5U4H8psP00Pjx3uK+kJHPBSCeVIdjjxCodN2fW/v6jXNW2GzixXvJIo5FNdA80+3dHks1grDO4Dk/HprWw51AWNxlWmc1PXjNWAzU8CKgIBa4vwAtwcY/fWVjjTK9bNDLW23eTdclP4QWnp1hmeUsZGYAgA/JNh766vL7ep1uP0dyRU1W+oAgaGOaOIiQgGS25rls9829M60K9dzNt31CVtb4LRsZ3kadVG4IAzNexH25xbvbXVrv1ObZ9yxFWR/R1MUiyeJHtUeO5sLDsL/01k1eQk1LGIz1O8S0cSRwl0ZWDoRcNcethb4vqI72zhM8kQSSy0sxm2Qhw62B8xXAx97fv663wHqZao7FKlIHqaOoqBuUopcQ223vb2+/zpCghBhospdbWh8YIjtDJKiOwhzdhuuthi3F9Z/G2+5retfqJvSVJpYvAgnkiV2JDuERiBc2W/JGLE6XM3uQo5FuiYkmqfApYJpCGeJ0BETBiOL54GlfzO4Kve9T6GgZpIp55a1ogguVjjtuPGTbv99YWMQCbVdNWKVzUY6eHp4GnqGkKqsjEKTck9rWsLm/+3VOXLFnPFNCZnrIIOjyU8SxIx2l3eMMxN+bL85Fhq8XlsnLrICijrDV7GkZ3RGKRygKStrrcc4I0rJklR3GMz3pY4w1QXKSAEK3BGbC1z8m2idvktuj2I9Tpph1yBYKhkaWJFZoMWTcSbY4tf9dKqceyGw8vYSZPFappPq6rwfBG5BtI3DAAsAwxb9vXUP8A1ZEn1sx0Sslp6qJjUhVRghYgbS2QfYjKn/zVvUseSVU+49Xy/WVz1NUkYMalUj8TwwO263px/wC6FTiYS2WzrEOn121jNKN5J2HYbhmtZV9he/8AfTtXrCSlt9lkUVa43OBvOTsgW1/b21nyrHxtGViqUpIlqHprRt5Gd9oJv/bOjtd62d+Wd5J/Vq2STqEUj1EMvhEWZbtt9yLWtf8At6a0pQK4EF7rbdi08scs6babbG0bxAkgNK177yxsbHNr+t/TSBD2RdzqbMCTu0829KdLDan5Ab9vX+9tdyTok4j2wkcDP1KmjoqQsH3hzJJYlbcAfB/zGi2Cq2YivZxIxHTyS/TyMAgLeUh2YEDsDxfUbBpLwXuD6jLURpFPvaHfNa5UG1iOWJyPXXVB0nWU7lXqgpo6IRmcK87MGjvgjuLDg59tZ05NvPJpcqHvsgdKiNVVl5IC/wBMLCIqCWVfQk+l/wDLa2u8Tp9mNDk9nkNWUbxB6yKnpllmk3bXkJIAwALDHNvvqVvv4rLan3hFp5+pVsgjp4hDQti/iEgkkBrXP9MemkFK9vsLzt0eRfrUM1P1Gmhd4xGCq7Yo8Hi3rxk/Ol8aIslywhKXXqCSGGKoqah3I2sic7Pbdjd821n8VxcCafJTDVhqOlph0uoanFw0imIot7rbJJOfUW5Nr6lrW5GzqleLkd6giRdOpDFTPO7IqxxM9yD5Rc2/W9+2hRWzrHYyphPnqWkhJn+sljjNrMpa5W9uxOOPe+t2z/pmJU3uFngpI6mgCy2LTIQZMKSFLC2PS+OMfrBUdlw0yc6vSuvVSkNT5SgZmClLKbg2PIv5se2u+NOPZOuPLplMRUZoH+kVZamKYlA15Rt7k3PHI1ltuXfk0yudeyP0ueV6qsWnhljinu+42BA3E8D1uSM9tbWDDZlV1cjdCluoVBM73KKSkUZ3cNm+TY+1tG3h1FX1hWpSaR+otDuEYZULXay7jm5xcm36aJbvjEnXKNKyy9FM1R4q06RnwYolFySc3IGfbjRerYexH9Osl1LwxdXpRRWVndkO5rkBrkC/pfPzpgtXlAuWMj0lT4lAirBcs5ZmzaxUjP3B0SuPsS6SO5qEr6RwktxG0IZ1uTkFvn09/trTpEgdEYGvkQ1jmKFk8VGZ5XDLc82APJxzxq1OpG3cWpBAauqMhjSKGJJokk2tZ8iwFs9v01zoTjGfRUTj6COSNYVcKyiNU3B3BU59MEH7nWdjvGMeuouN7RpIYRvAZvD4N1NwbEce+l/GyH7j/gl/PN1HqqSNllWC4B7gG/GhqeBFh9rGop+nQ9LVo1jFUrn+MUYkgP2uNFrdt35OLUK9ezH4klgh6JOKKWnlmeQAsSN78+UKBgdvi513xVs3/Il+S9SvTIxEZaFvEjkkmFpMBgAcFU9/W2tu/wBeTLpfZarvGlgSJZAlMjBlsoAaxGee1rf9axrh39zW2vW9RZpZppEghSMws5jMxJDkn78Wv76WB2wuvRFqmWso4YqarZGUEoHa1iu2/Hrp1K2drAtq9Wh+rS76aMyywWAug8UM+4flH9R66NK99RWs53AR+JVGol6fCUQbgSreHdrDgkX7HP8AxpOVwswfku1If6p6eJaeNfDmYbC3Ziw7WPoP66PDXkx80MDuM/iQmPplJS0y1CqcSOIxusMkZ5PbHrofEbZWP5XKgSd1eob6qniLRpTpsQxsthEtyVt6njWvx16X7mV7dhNdYpZz1np6TSklmPn/ADbQQuMWF+x1PjscXCK9XkCwv4gWOjopoJDEsi+GyWS9wWAvk3Gb6nxrZGd8gVMiqVSjpKRVSv4012hQMexBYWAwc+2CPTTa/lpBv44x/qVHDRUn1EiytVSKEYXCC9hhRc8c49dZ1s2cPJpahU19ifTYUj6ZUgCB1KeQsm5hcHI++L2wL6dlbEFQKsQnh8c9OBaJJYSLAsRe262T8EfbWg5szsDkc6rRzRdYH8WNUWnWQEBmKi5AFjg5HfQpcazS9UtGOmSzyuYN5AE+5sorMBwb29wfTRuB3LRXqQ4EFH1WraSnqJFpnZwoO66tZiDmwz39ta7yqY+zPGtuyV+kifq08n01JcW/mkK2AJz+/wCusvkT4ztmnxjfwjFXS1SUr+LLRQQrZCBdgSCbWznuNStq71sTVzuIw9NnroXQVFRIo/MsMYVVx3NxYH050rXKw1osKaRYoaTcsIRHG+X874sLXOB31OXbkvH9xud3pKFoXEtrlksLDcOAbdzcD50Q12Lc6mJBAaGgEK2DY2XG5nNieeAbsb67vXZHMMhng+oWnqKmRjGkFgN2GAuLHv6X+NTc0Is3tnz1fMH6r09pKeE0pielsf53GVPzg9++tQTcZmo/UL06SI08t6hUIdk2iUgKLcm3+Y1bbCZkzT9TcJHNCrTtNaIrdiRY7cnj3sPUa5p9MpZ+pXPVOog4emUf7THx7cay/wCXWa87Sj1aUzRysqzSRmUgkLZcti1+Bfn1to/HXPZ3yW3yLtFV1VRPIKaEQKDG29iwBNr7QByfW+ltagb3DlrO5JVQirLG0o8VY2O1I8LuGckdvXPbHvqOmEyz7ZR6lI1ZRggRLeTeRl2kIFsjFlGAO2sqBVmtlsScZXjYwRPK86t4kl2/IL9yvOSvJzew1ph6wa+TkYhaOKRoBJGkjbZJGIMw4ZRe9r2OP+9d34MnR3koVwhalilhKK4jdYyNoUqQLWv6GwOhXRxitiaRzp8rCOCnEcs8jyGQoq8G3G74voXPXyOjmEn1yyN1KhXyJJE5O5iFc3twLenrrSuFWC3dj+Iz1COamvLNVgxwrc8OUXOB7/1/TRqj0EVtPuKrSNWdaRappfIFZQ4swUAC9+3J9hpcuNOoePK/cCVpYvxO0MEjnYTu3zljYjkW9x99X8n49Z34l8Ix+PJ4DArpBZnCiPy8kEZB/Tv6aP8Aw1XxZf8AiLHuRISp/p0DF3NRHGCdr22k/l81rW9r29daY7M9MmurVCRRlZ6vxxLZpPAXeVz3bjacjB5GjQ3wyK7h2z34daM0UkSwJBCWYpNLIN9uwAHIPNr99X5dHdnfG1TAgur09KlPQu0vibI72VnUkc5HINjjVpaysN6VA2L1EM8nVmakpQ0apdg7Knhri+BfN9ITj2yNfy6JT6OlU80sdXLRUixyKQkqGQ27Wbi3BtrL5EzTWafHr04QMMUv+tV0W6eWKUHcIo7BiALXBsO4P2GrpxGdjySD/D8VXD1SsjaJ5YirsymcKMNwbc/86vyo1GH4hLZH6r6hZJYFNJAliwu5OwX9z+a99Guex23yI9FLxvLSf6u0akEEx7bOpvzm2M2OlfvvIadObD0NPTxUEtPJMJpGPhlpJCwPGAv/ABo2VdIgDqP05fqPTJBbeIWc7o72ZwFx5h/l9B/G0Z+VZGrWNR0BHgRgyHLgWvtU8YzbHPz8616v3MrflSYkmkq6WI1TVmyniuuBtHIABUZ5GrxB6+5zZTv6gdsMkdI8gENPFUoLyqwcrexPoLE/Oq6eThPuUOqywR1NTB0qphggZwyOACtiAcFvm51nQU253FZNyrE4qUrTwzeNKqAmPc62vlTcegx97nT5d5Bn3OOLOw8Pp4seC9yP31Z2svQ13UK7p7RqsZMjEvKJDtS1icG/7+usmlK22IvexhHZ5DTdOlXwyABsbfPYEmwwMZ9/30A5W/8AEatT/wAyLD9JV1LpOqRlSNsEa9hx5v6kcXGtXlU0mY1s4wssSR00sUKvEWv4ipIw8UcZ+AeP+9cLus5qeETh6aKCGap8UszR7kRLkA7wNxPc5+2q35OZIU4m7B12+FKdaioChagIgcjkixsBng/HbSqiuELVA1hqo+BTKgnjna+9SsZI9Ra3ByP31K9vmTno92Nfh6vq5olkSGaaNmIZilhHa1rE2PYaPy0qPsXxXum+yekMrmq6rKIZXDBi+Dgc2BBxj/jTU6oQ5bu73GZailrZpamWxdH3J/CChSB/+SM4/bUK2qYTm1bKv+JR6JUQ1EEk9W6B2ARdykjDEm98DtfWXyVRwm3x2E1ilQkn1f1VKKZA9SBEIwFYrngjN7adczH9Q290/cU/Fkf8GFZJpHZQEkk3AsGJHkAyeAO/zpfCwfKdQ1JFS0qQsF3qCQzrGF3MLgkljc2xn0OpZbaSgGMz1+Fp4XlghkgjSM38LO655JP62Gr8TnS7J8tdNDIXpRhXpakkLLICTKTcrm1h6Y+NS4tpaIVkHqFc8dTSRkRvs3U+2NxtucXzx8n01rWpizJu7jLcEqfXiSrqUiTwbBUa/iXNxex5xfjtrJHMCaljdWOrPR/Uh0YDc4Zi6liB5vt2++s+NsyaFqzVUIv9YAjmeeJkIDBLXNjcngYA4trq7x7MnW4tvYn0VfHrpI2iIDM4vI2I/Nz69uONP5Oq7D8fdp2vjgpVqKaFJTOzHYVVQTx397n99dRXFkvhp9xT8Px0gqnSSMyO207S3AAN7kG1hnS+Vc6nfGG9ylEKdaOpo44yD4hs8a5IvcC4v7/rrJ3S0ZmcY30utmf66jZWjp1mN5HYKVUKOBbPr99G9Tq33HVe6yNV1dK/TY6ceaATbRHHe7XDBeM4P6a0qJbfuZ2Rrn1Ful1lOkE0Uq1EskYBUrHdTY5GfzAW550rDvUlUTuBllM9CaOSN95s6xRkeUdizXPpgfGr48pPrjG7zPVGrq6dJd0S7YQ1ggAthbc2HP8Axo9BgxdrqQVSK2shWOKER06bWZVa4yCb/vpHE7YHXon1UHR6Z4I2aCYFlBIAHp868z8lt9m58dc8i1LGPAbEpMhJclrKpJseM/5jWi9wB1N0fTIKuBZvFWVVZiW27hbNzc8/96NvkauS1+MTYr1EQwdRYxbBDF5KdASdyBvMSPTB0qK179kuBbrz6k+rnMfU6ymcuWdQwJhO0Ag3sTgYwe/xrSptRmd7ZZIKkajNknqC0UcboTOxs/oAO3HGlYt6ENWvln/rKsMNKvT9q/TqyTAiSwLKuMjJyDrJbctmoV45CVZXqNNMZIguxxGqscOLXz3GRo1/BiXmROlrJvo44qcEyxmzkCy2JNiSfjsOL6bU3WDk5hEVjqXSaZplVBe8UYH8fAPfkA3zbg/o9qYZM8XuPfQu1BIlRJTlGFxuNiCRYYA9NHmb1Fw67ye6LTyGmrROIdgZwEa7LgY8vGp8luzIvjr7sN1WgampKWRZGectZii4UYO0D14ue2jS/JT6ivTAfuc63TIIfDSOPZGy71itd/zX8zZtgZ1fjs7s69TyLUNPHF1eRZFcShi6vus0gyQfQ2zp2drMwy/cbrKlDRKu145ZACX/ACAgckrwDa/B0a17lbdSd0hWqEhilW5JwrH1z/nzp367Iad9MF1GgaKSoCxU8dPvALlbE2sRfFiMX9fXVrcc/clqJv6h/wAPRUscFbUuu8QlEVkjuNhFyQbYPPOj8rZQj+KtQWWIqhY6OoeZLxJIsiFztPewzcm1+2sWvZk1HruQ6/qVRVdcSOKniRZTZBIfLH7kAXN89x+2tq0409mVr8rZkf6H9XBPsWanin3su4LYjzDNzzz+2h8gJ35H8aj1MzdMhkmlaSpqJCBtcMzG+ew+f6apdDyRqbuwH4aiUTzJHCplZAgIWwRcm+e/Gr8r1J8UpSVLfVPAWjjZlDlQpBItY2P21mV62Nt3kF0+YLHUqsalmkVkLEAuSLZPrq2PJw5JHTumS1MgjMlTTLDIp2RTDzA98g9yc60tcJnWrac+nlSpqUhqqmCNdy+eNdwsxH5zY5xgX5PrruQmpO4v0zMG+Ty1FRTQptssaOY2cXIBB9TxfVcPCcancKtSFpBF9LHGoYMZIX3Ne2QbG9u9+M6nHvdl5dZkPLVtF0+yRRR3VRc3UoAPXki2dQrrK2wgY1rhGoSCsdbCzBR5h6/m1fxnbb9ShRwRwmrNVUMA12jjG4spv5QACcWA50bK5hCAbrGqeRI6eRIYa6SZrsC0pTH39Tb/AAaKK9pkY9dDsQEUimbdKGmZSu+ww17WX1AHGe99abuddTPM3vuMRurJKoXxGC3jU3JdvU35Asc9/bQxIhInQUJlraWpeNJJ0dHuqkIBbls8HOna2CSVrqMqfiWXpqUc9NelQtKjLITdmNxuFxkcfOsvhLqW7mnzNATqTKJKHY8kNFLKke3e0cRW/O7m3qP01rZv4syqU9CI/SVNQtRDRQTq6SBSXlBULe5UjPybaXIO7Q8F6rL7UbMfCjFPJJ5JA+0KPy8j0HP2B1jzPWbcXw7gqySVqR1AeOzXUIQ3C3Kni2fnn21ahsiuQlBIsVNJSkkysoCAnjOc/rnUsd7LV6yP9SjaDpRYI5ZhbcrnAtzb47e2s6O2yaWMrsh1q/XPUSK7K9MwIY2Abjdcdx/g41vX8MP3MLfmr+o1+HzLLDurII6/xIAQ35GHvf0/Q476PygP4uS/FqfkbJ/U5knLpC7iK4U/yEk28vv2xrShnszs69RGidvrHhR3XwSATGRu9LL3OCPfHzpWOtkq9ynKKeWKXbCylxvLT898Ek82z6f00OyabVkWGtPiVIKf/HkBc3LW4+P8vzrVp5MS4bLFP1Col6d4NLTiSNVubFQABbIvYkex9fbWVqBbVm1brXCCeaDwI6lqdUqUN9wcHOOD6E+nprsfN6kU9zuN9HlMdbIY7tIBsLBCRyCM/b1+3ofkBI/jXZT6garMkUQRvFCKtwpI+Mk9saypx8ZpffZJijqI5KZqeVElkCxsCLkAsLeh9daqO7M6ieQoSFOsUqMCk43ozEFixHNvXFuddq1Z2HIlGGMzmtpImPiAKyFRlPf+v7ayXMszQN0JP/0/wGyYJKgb/M6HNrm597X1pz3+0HFJNCSVMrzUvTYSEU4jG1S17kkdwP720+q9LB29hD0kNP4Sb4Up3mBLTFRIwseLXHcW9NS2/UVcyaSlgbp1QhqnkLMb+JZEFweB35+3rqK8hyd1xyD8OSSleUT75WhF5JD5WF7Bffvxq7jmSJ1uxdJaoIvnrRjhY7j7Y40uv4kP95aqD5nmkp5oiI7gLYHZ+vqe2gfoZy/aRrprtMpJiYXBEjrGXNj3BPfjQuZ9x0d+pN6jVK+2BWAiUlo7kX4ANsc60pXO2Z2tvRMUyfUlCZVhgQuZZI0JS4NrccfPrrrOfyzg37wjdLFE4jiRvqFa5XfNawtctYfHcenOjZTt6jqD17FupQuhCmNGaJFeIBLecHDWx7m3txpURhuJHJI6iOnR49niTgI7BipU+qn+/voaLj9R4hsY/D1P9L1GWlcx7IyCVJ/muTlucg6HzPKvIi+Iy2MbpolHV+omS6jaDETkXW5AHxo2fwrkdT83ZMjmhEMSVbohSURhUBJF84HN7n99aY68Znp4zUMgPU4wtM87zSMXsAoXBwL9r2/XXJ+PuZOH8vN2J9SkaTo1VSyT+HFLbMbklPNZrX/L/wBHvpVr+Y5Ba2VTYSBEXoc9awLuiMqhCEO3i23uOf0/XlW5UnAFOUSoZp1gdKeECpwHkZjbnF/j01pYN78gqoYexiTp0aVSLVMZahpgZJCtgosD+XgcAaPNTryPgD37DfhWFF6jVyHaFBJBVbAckgn/APro/MvEJfhDkwvUzGsVQ0SbkkBB25sS1rX/AH9tSm9bLbPqSaFgOiNQxRQVE848QXFygGSSe321pb+vluZM65w45sL0uiaClb6iUNGLDw45Lea3BJz/AE+Nde2vU6leJE5BT09R4iyETSi0hMm4C3c+gyPnTNTIFN37lVp50p45zJuS9lYRna3oucDn+msuIuTUtYNjHVOpRwxiqlkiSVpEY3UXJtzYHj99ClP9JHa5/UyPS1RR3SLx97SHcwgYg+fJue2tWsyraE6w01F1GmmSY+IZCQTHtvdeT6Xt+2uplqpLfa2GPdDq5KLrVck8hqC0ZLBELML3I+PvrP5KlqGTT47NbOzvUZqmslKRUymMMxu7gFR64GuqFTVnWWzgQVK9ejPFHHSioCNtBJFzsva9uc6tuPsld8k/pslSbVFdUUiNA9jHIl7G+TYW9Tz86dg8PuGr9v1H3pzJWySNNEqxsGMzLu3m18Lc40Nwj9Z2liSLpwCiQyeZGaQXZbMCAo7H++udbTjCsGaNiSTFKT6/U2v9r413Ih4x1YHkplknllWZlBtcDaQR3HI767kbgdScXNXuZ6hsWqpqeJGke9mNyMWvjOL4+L66visl/QIulA8jVInLePGSImFiSDjyni3v3vpc/M8ncPd9lTpkKurQNM4ViWLBjtvjFuG4PsM6yvbOwmlK/SxKo8KkaSPwJGDNtBbIt6fNjz66Ztu9gcr1kFUdMHhpOqRrIGJI8RhkrYAdgBb30j5PqR+P7hDLCTNGKomKNSQgTfgcWHN7jRx9yXTzZvp0+2rqnqYZTGweVpgu08chTknjXXOjJaPbsc8MSVlOK2WwcMrQRc2xY+p45OP01nuDxmnSmyX0zxJfxBLLBHGoprXB45wcdwQe+LnWt8Pjx+5lRW+n1H9rnq1ZK08gIZQ1lttUNkKOeSR/XWfXEMmnfJdnOs04SGanaUvxdCu4gWzjuc6vx27GT5K9JJdNt/0RlihIqY9wkifACC9rn3AJ/bWrvPvyZB+OHsx06qipwviyEShlXwmYecAc+5tn11b1XySiHsM9UZOpq0NOYISxZmkwVb8t2zgG1vvolcr2xNtt0RmkiikQSmSR1mBvt7ci9vQZGjaydRVqJv7mOs1UVPQTUShy8HlbeSwCsPzegBJ/rrvjqry/cnyWA4/qSuhpSUlFN9R4c0tMUezR8qcWBHtc841p8jZTPuD461K9/UL00eAjz09G0sUdRZyxATa3C5BI+e2uu70stAOwmp4jUios1PSyw2ctEu64PYE4F+ONQcz7l4735KNJSU0/R3qJZTJFTnayGYgXJ422yc8aztZL4fc0rUacn6ilFGqSi0UQWWyRqqcXJ5573OnZ6gDuNfhuQmlr5J4ARGHu5bgg8WPBxfvzofL6BH8XisQ/ENTU1kkZQMk0a+JHHgkqpBzn0Xn30/jCpBdbM6Zkquv1EtXGq0/hBSpbPilSVFgb+o13da4TurWVlSSClp+m1CxpIs5GEQniwO0eoHe+s+Vmx+o+NQf3EqeVZKmKdKtkvt/iPYNcDixvcY49tNMMSEe92QaeGROqzVMsoEzIQUYqSSWuQvofcftfWqnECZAltZek6lTPLE6UwieGQb5Y5bueRa98Z+dYlH9zZtBS10cr71mVWJKyCNiWYXPLc3zxjVK5ObQRCX8sNQV7cDGlsP8Asy7FTQCOKNZZiSCpJcsVJF+2Bf51k2dXJSp5slTSCOijZ6iZ3BKu6sANwOLW7W/W+danb5Mno9jUMTSzIYS7xNtu20q0gPI3X7C9/toLh3GGvU07bKtqYbSsYUbZJNqrk24yTkeg1x2bE9OQFbHTS1X1C1LAxzeGtpCF4BIAHx65t86tWwZkN+O7spRU9GvSyTGJJAWYyM2FIJNwPgazbW5TUK8ZKoTGpbykK62a1yykAfe3P6a1sMxqkdr2hlrYHpoNqEFyVXBsM4yeDoUEqix2RsITVXFDHLEwvMNhUiRAhCdzfvf39tSqv8S2A/mD6TPSUnUZtmwF2ACqtrgflvbkc/Or8lbWrJ8dq1tNpNI7XpUaSY4Mj8WJ9e+O+uQ+5Sz9ewNGxnUyyPIZJfLcm5GQL44yLWtxq2M6PqSrvb9xyCnpzTVXj2Kq4/ImbYFjnOb/AK6DZ0yMqY7JdDTAdSnkenMUsBvKBJcsl+Rb2sbel9a2t+Jj7Mq1/J08huqMhrpIIwdk6iHxEyFOCpPvwPsNGg5r9RXTcPuBppvpUNP4d56i6eETjccEfr+1tVN7/UhbOv3J/UgXaMz3KEiNmJw7i4zbsMWB1pX+JnZgqSfw2eplpRMdojKDYoi7Xt/nzqtfoZC/rkqdMrJ/NHHErttBDKxA3KLg24PH31nep6zSlnyJNFJTNVxGWMIsVype4c4PPoQ1/wBeNLRxkxNJzp7ySU1Qs5jvDUJU2Pcgixte+L2118EydTcYHpksiwyKVepmjkBV0Q2tuvYYIGR/TVuH9pKfxG4quQVs1GsBFG7GZi0mbKTcAC5/l76CdFvuaD3xhasua2eJ0kBIY3JXCgWx/wB+uoeTn2CjMH+oy1EpAjE8YI3X3EXHOl3mEmm7OSQz1XVpKeScSvADIZZHIFsYx39hrhCu5Ci2zYh0uzV22SmjaOBigAcm9zu5IzgjTt57DVd8jfUhS/6jMz00cFjcgoG2La5vb1z/AINCu8fdjsm+RmDqUMtEaaljg2kBTuRWkJJwwXn3zbUaI6ylxMIjDJHFDJ4YEIMgYzToC4FrHA9u3GfXSRYRCG8aZ/OrPtbI/wDrX9u3xo8SXWf/2Q==';
var bgPatternSrc = 'data:image/png;charset=utf-8;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAIAAAAiOjnJAAC9+ElEQVR42pSd2Y7kSHJF6/9/TVLPaCQ9qmvJjJ2MYERmdY/edO49EYbCAJIggGAySV/Mzc1td48vx8uZ67Rebx8f959/XK63z7//1/XxsW738/Z49M3ltt0+Pj/+/DvvufPm8cef76fL+Xo7r9ft4+Oyrut244GSl+uVwsv98/p42A7/blT/48/rPW9oc39e6YtP98+fvDkvl+P5TPXTsjz++OOwXKlLLynw8+ft8bF9/uR5vT/o98BToVq2O23eUutCRV4u23a4XOmLr9SyX+pS67ws6317O53P63Jazsvt9n7YHU7parmu++Nh2W5ff7ydrwslKQ8AhWelHVu73D94zzNgMBBaXm6bYxQq3gMD+AEnwMZX3q8tSV3uvAc/tAmclqE1mgJm8HC+Xnnm0+1+B57bx+N4Ccy0fFrXw+XCpxPY/ky/oGX7/OBhd1rokQea4g0wAw/z4p1+gZxn4KQuzzRFX+v9vlxv+8u6dHbAKFhiXrjfHo/75yd1T5TuXFOe+/FyoSTvjstyWpddZ59mwT8zDlSAxHjFyT/95/ELzTlgKjNPPFOUQjwf1+1JEJ0kCE58cQ8ibiE7O4Y0gUYQmePLej0sIUfrcucCxZ9//n2TkrbHUkKhTObjg7o8B1Ao7P288JVn2r91Phy2U3jZHjbrG6AFWc4TqIegadDuHAV3SjKdIP37bgfU4Oh6v19uVEmPAZi/P38elxtkDTAOE3wx2dzFz/5ypU2u6Z2W7YVn+hVvfOKaMjTF9DCFNGg73EEan1yuFKBlq1D9vK4MBySADQADq7szaya4zTS/hgkOKEybLG/mhdY+SvTnZaUxF/NS1gCEIgcc8pKSXXgZ7+kKEdz5ZNe0zzNzdEjvGzMoVMXGjbrC8PHHH1S3LgTKMy2DW+6iglq/fT2HY22lUCCY1bmVNkM6bZc7azHX54sq7w8GzZ0x8P64XFw0TIwU9nY8UfvSkrykFs+UcQXvLisVJZSQ/Iua96cT7Of9FJAAGsJmFUIEoJsyp0s404/j6bicQT2jBcXSIkigPI1QlzYZju3LU+mXdcbXHSQFK/p8MNGHy5keWbgQDKyZ6iykA7x7u4FZ+l1vN56py0yDDaaQcdEmJbnznoHzHpyAU/jtVrxDEPzbh82VFhiud/AgYYVRdZ6ouBR78kKeKUxfHcgDgIGQWpftg/LyQjmoCxL0AvzpeudZ3G5p8JY1WTKiJCTrfA081FXyXMKxgnawB9uuXAq5s5ZYeFRnfuWF4tP55Q1VsjjXm6u97IA3EVbSLvD/C4S1bgW66+9RuUNpiZd1xgQrgyjT9bdJf3yVY9GWw6a59pR/ufaXhf7yqQVoh7oOMnWvojv4FQXQEAUUQPvz0sJ/QFJUhJi4Ikqua6Z/uaaLdeVlGc/Wxpm5XO/ns0jkTndCqPCCLr/tdtBQqRaiCZzgFHa1Ox72p+OP48HlCCpo35LnFpjxCjNixfUmVXGHy64VZLKoTyagy4YuHK9YhbvQghwx8qFKBS1TlzZ5prsSnPCHD7EIFWG8dCyZ9eL8zsAfFA4SbF9Spp2SfoQdrdG5cx/+5PIukKyhzngml95pWXggnfC/KDM0FaE0Y2Fc15BmvlKMlzIdoQIGcf4fu/sXwbIayHFVgVmaezuePyjXajJMV6rikpXEMCipyOOZKtVpuGDgF2aI94BCLXEtn+QOb1BZUc9QYWKZKi7V3qAhEIe2AQUor2XXrCTlL5dLZClabZ9+qehioJhMXplF+e+79zMTFFaa+aN9SIo3cFzuKFxlGBuLGBCUlVyKrfMW3Cl8eaDlAZ6uwQYNAiTvHa9QCQN11QdoR4TIOUQIwm6roBHbyqPKrw1CrCgM9VBGiUbLwCDXgSjvnVFhC7lXsKhfgivaUQJakYti4gphR0nnaHlhjGJMHDiEF4a+I4KeCIRfUoBn2iyeo71wty/FkXP0l2/Ll4zkhsJO05v6RCashI+CBjlTDpKUnZYxPFTeYaQAoXxUbDMfLQ/6rjzJHiEReRLVaZP2qcJX+VwqRtZcFTE8y4R5EBdwDlEsy3X1i520o+CuNiobOJUXwvZsU7H+6KRSrOrq7Xg+8YZm4YyIRXgVhMX9DHcJMV25Q2cQNC+RznIdeINE7AJ1iSuYaM1+5WeZ8kJoeQBgIclshJNiY3zQDguJf61ShY9GmCF1uDsk6zpZXsqD462+f1MhoYsRtdQ9R+9R340IkxU5p7diw/JARXnVHuelpH9DygEGwo7yzi/FxPmwIUQ/LYhnVR3qqi9R4N/er18iZZcl5JW+M4awnAKN0GHF0LG0FbW02quED/NPf9W4VaRWqaGqA8qdzNmJ16AIi67yix2kOiKWpS3FeZ+DiypJmTMF0NAf/YpT+6Idni0PqJCsbQI5MHctbq1+U4yC9CJoO1bCQmeIxU7D7fth9+hcQlgMjudrxQTFWHhYlKpBYMw1pogXP4gGmcqtWFLj4V+5BV+1yxi7oopLxhayWzKWMsuUgcwsQAsVnXfbUQzVLos1Z/vgypnuEg0Zibc1rBGYLxGXV1WR0BCoEHv2K535RqHZ5RFBjy4rzJpcdznlq4XodhSrVg2KrMvdNfO399sXqTUjDCfHC5DBaN0osGS52h1yBVcP08ubrtqsFbpBv6aYiwl6f5SeriUsyVG2HCW6dp8rTFN0q02r+NAMpqLMWTar3NEaFQbaUUQqUGT1iO8hbvtS9HRED/rl5fEcq3DLDF2wXdCRIa/D6YjNiBoXu+yC7GKMtKyZFv0JXUcbVqpy7Io2AFOs8MbeFUaatOCTabC8TocxYixMZzopysb49LTQxR7Y0DpW6Chqq8ylGF+RVsuLnWsbioqsqBtIjjKq0eCnMJGCzfwKsJqP4kI4I5HOi+iVuSoN9RJoyap+8NKZou6A9zc4Fn/GitEqkUtRSPaujpY6bWXYJt0i8pSpVXc+BU4arS2z6bsacbkoIMp1FIvaCqdCT0m1PwYs+a/FFPBwp6TiD4K+p1hYrqJQVVS2ilih7ogbYebZyYY46taKxgo96SWp8QXS1+/7fd6fT6c4jbQJYF3UUZwBYUSD41XqqaMoVngjNcg7LSAMTAMVFWGjWsg2xiPIJaujF2iFwhKuSoX4L4taK7BWbDdgfjscVTn0sY26IjVkFmrxKSjUw8StuBI/KgbA5lctWWBmXpRuzpqLShqSf1MR5Lj4nS+x/dcf65fdeUUwMVtMdvjqPY4TJCh0A8i0zhvgC5HdYide+on7j+MFXPOGxbq7LJe7ZR4wWKr8vjsc2xpluLPoYMuUpDzv94twb/zLRRmeqU7LO96swSZvfEldIAQ8LpAKVHylNd5ToFXi8KEiHe3XG4aQ7XCnOvDwcM4QYO8LREQtyjMcfCKAzR1VlDK/v4OM2/vxeLis78fTab1hJ+4vFyxcLqGiHWEDfp7TTuEprlYaF1d8dVw0W9yulAE84Gcs4IGx8MYyu4U34BlaDI85pt8zA6Qd1FzxTC3wJvC4VCiPsgHw3w8negQSxkt58bk8otVxiSsu5yjVewkqI+I9XwESLFmXZ+50l7ot6Xhpn17AOZBnvrYP6wK243V+qc79t99PX5Ru3sdAU80EdJm/XE22KbuuX+ccrl5HkaJT7qU/DTfmGCmyX+XgCdooE9aDp6j1k1aPzJ/lZYPUlQ0ocXRFKuytOCtbSdoVTNd5IzzaWVwvz43+C7AMBeb5Xi8JD7swqitsbK3njDEe6le7VDfSQSoSZmj6S3VGjDNZhV3rSWTuRqwUKi3EwSdCh3ubDdqrlX62/IqQZBYVYfq9dNxz4ciVB8PRbZzL57qscZzGvs7Aq+qoOlNdXN1qUgiGuDUKokEa0VxxwTNjcS6oK3k4C+Jt3ODKShXrv35fv1j52rnhPuKpk3SSxckMnXUYtSKZRUMZFMZxEso2pSQWkx4RVSuepV0NDSbJNhWdslzlFwVAB+9pU/br3AwMEgeisPJaqySDqVabpQwGkdHQDe9tk0vwdMzqUMVJEw8yjlMaT5zkho4V23BNVIcxVuU3lEG/uCJjD+oA1AJSBCv1WLVMarTa1yJx1MBQjTiavgKdu5q7i7Zi9BlGU9Mv3VM5/s96sG4OpJo7zGNhgFgeXTxX6o51rHNVlaZ4DtkFYNZhJ+66JaAEkCCYAmNRGtIZ7dsgGLxz5tS1vXRSFJ0s/mIj2v3MY3DSRv4dPxYN+T/fGJ5231oVEhlhAMtpY2yZxZdJqa+Z+ajllTlQAGu5wEtdItLZp9RTQOvLjk7gG0NOWsJqY3BX9dO0X6jsUa8JrJi6OsYcjwPO3K/oSYePuo/HIhNN2j6wax5AcU2/mj/12ThnoBJ2hWcLyOkxSIgfK2Ya9jJQjSoDtDqyucbC0hLUIQzM9qjSDTZUTbJQy5nECQwJskbOAkNnIRiGUcVOD42uPMdTVZeQXqLAeV0vnZfiUEdrkC8XT7SnmK9ld1b7dESWgRo05N9ryui4N7xYPGjzbuCKYs6XNKBVK/IRrJ9ywTriHZ0zRd2/fDt90dXmpVip3oqUiZ5hYFh/mmxQ4tU1x4NCUA8bTWk+KDj0hepYU0xwye2wg+zL6ZcChqnSsnQzcS6dkBTTKpRedRBrEDAkCvCv/nHlEf3KCbyESlNRXsgDc2kXTMaP/Z5ZCRtYLhiJy8YQEg9mIqFF6yompCErcqdxrNGBR2HB81iOim+nAbITCVrQOkiBGoQxkYq5zyDqE2ZJ9Tpu4ovXULj3WcSKSbmIA0zj9cu39wis8Z0qYUu7YYdi0tl3HhXf4pz3LDMGomHHe8flXPMvipADLPGljIMyovCvb+sXGlLcGJuT5BlJVv/hIJmHkOtSsyc4s8iChF27EcMloImu6xGWo1B+rMK1HfFV/iT71epUllMAMapDxUifrF5xSUl0Q+XpOGCBX7E7ls44A3XQG+8LQTwiXoFHXaTWVmKCh8bLQBbFeD7XEb/U5j1ckI41G7eMS8tIqBTBsjHHq+h37RpHK9sLUfLcCQ5rNFRFIyNWdNft8fgvsfUKPAXAZ4wq8SZ+jBjSFKyOa7znWvTwYLFEdd2njjdAvoJvXfkpg0Ry4U081ygcd732smfKaLEaOdD6o19EBMXk3/SiDNUx9m/4sRh5hloJjbpHu5IkK5i1svQrL3VI6oj7hb1vpHZgqxljQoHJSup61WEom40q2rQQujfKxteJsjlbLgj5tuydivqi/iHK5jTwrP2sU3HGzFfgV/YZ67VHS9bjvymkZPinRnhC4k25AeMgRE8E08+IYGA8aFKovhgH1Lek61wBLTwOgfLKeubeeF8DD+E9lDE+oaImVMXtM8YPHXNnvDrqUDn6/Km3Rbz5zBe+uialUdQyCUuVBkyOe1mtVB4hfrCFPyqODePqRAVXsnOcyYpCBcvEeQ3pOoPSK59US6AHnbHRsaA7Oh5Jp5jQbmKNIgvkrqwe+bzi4NLgiRVlxWg2iA+4EW+4EA0jNCubQiLqFrpeoV3Fn236XnGcr/3Xvtq+xpcTfLUKoPLeLozfcRnQlZ/L0vkqb1B8y67HWox63nQuppx++VdFnguC00wz7E9dDT01Fc1V+6VBvo5Wp7Ti2S4gC9a3iKr2w5VP4xPaGcMo2flAAabKJC2EnRaZqoXyd8ialvVg0/J4QWnHVc1iEGadsUjbQciG6D8c6UuTXDSKJTn9cs90TAhy8K/IUzL4huE7QaKLvhIrRHjRkIy0OjLSDfkSU4sBXzsGc8S0HLcqlbTIKjRpiU/SkBF1RYCOypJgjBpN05Yv/9y05p6LSZYzDlLqUl4SV20fyyVEfw0MtimLHpFkvzz7Xv5hO5Qpuw5TdOWpl6g1y1ZZDDWOMBtP78cdBMcSZEZRd3gJ6WkJav0JD9UV/Uyw4iwpU+V5AANyeK4ox522TpzOjABF9nMhFWnUiraOV7FEgCNXEazbRT7Ng/ami4p+kwvFw+Uiy6eK5XXbGn8TyUwczcqAjZyOI972VXsGz7Ir+1IsjpVNwEehwV00GlUzwvPbt8sXvFGqVq48cwoQEOfoHCc9xS4dZ90Y31W7r2qN8TJ5qRGeEQ2qR2oMslD5Hwyc8iPmFFuKFdm7EQmpWdgoqfpJv/I5yzgeBqyk1+zXJpKhTtxN0TCW79PD0sk4VjvEVYHbPbQSlh4hCDsAFU+3RVumF1uYsQCwwSJDFCbrfcRrAGJhh2dWlGEZBZliy7ouejVO9Ujtiao7wj8B++B5gg22kLX6yKwp/oBNB5CoE2ZKKriNzau/MzTjuTF42/Uk3CrKKX+s9qZq1AD50FbIVMudWi/xyurKvKiIJ20G75w+2bjU408/QU/YR/T6vam7DCzMSRfzFm2RlY14PlyTvghCj3XgclU43nmDtDokLzbpficIvOyN6vmkb7dV6HHa1BfMv7T2Vv8472lHvzAvp+7baeU9dSljgXxtSAAgvx/O/Ms01jOeujq4gZleIFnec1GG9wDM+w4NGPp+4dP67Z0c5eAOdyvG0bfdHhSRvkODlKdfqtu1eKP37/sTveBiJSGMKkSH9FkjbrgX5lVECRh3H9pmMCYYoJ1oCYjl3xkvYwdUfethQo2FOBHvjmULbsUnXynmv8eilH95SRneUIU3mCm8YQYL8+pccAkGdXn543ChpP+unQLqWoDr2/4kxvy0PAKSUIGT375evuBclj2ibEnOpf0btgjkpX69RhKv3GWVWmQ0qsNQku/KhsBR54nsnkAxD1Rxccv2Jq4nm1UsKjpdWDq6GC21RnjT5uSC6mseMUTdeaakCTljRdoXZRS1ZgrwUg4kC7SwvtYf+wOg6nwnnUaz5skXt66cddUyn3jfcktHAGYkEUzuz6ek3CAHKzLU5+iXviZZnudxIPGso9K0IozQSV8x/mGin05I449c5lfqplaqKiVNN9KZqUVpO4pRSjKEcdJifVeBuU96GZdzZLrOCDGQo1UbpmvXsbdusuHxRBijpEB1LJLpWISPEAR4NAccEYAP+u14hL9RX7mrhTjuRAJqGnp13D91F8SouZdE3DA3kCxmQ4+jUsegLFq1TBHOezOkRYeuNieAZ61Z8cUi1rKb8sDjPE0mp+LJ9hWLk/WqKqb4MGJqmSJarw+u6tAHVALRYL5V71lhZoa8tJXUk+ofyajhUopy8EB5lQeeHZ2i0DFqgkkWimOE+8SGwSQeB+Ndk92gkaFOyaVLzFjF+/nCfbLGXau66cGzIxpFQniwfHHArsXGPXiL+mG+gzgRzzBp8WwLjNp+5RS4XoNhE7WrsHO3JPP1r29X/FggmrYjbs3hh6hNS4JhSp4osO5u4A5Y5qMh5lQIeOau3wWCqy5F3Xjt+XTMCk51Y0ezMUElVP/15Kl6hze4AsahoCUy7lPuU1fFU+KwLiV9tmW/6qFRmzHTZpyZ2kH1roGgj5IRABg5pSRmxB02xmKYilxlrqXsT/12Qa4OArmFYAjJpL7IGLSIJ25oJFE+pH1H78JMLxFhL+tbnLiKRKnYEDl0pCNt/MZwHUcn+6/TdQFa5iVEWd+6TlexJPC6fPnKs/1q3o6ECfK3IEovtJ7eR9meUiVpM6xFc2p1yFa43MyHMVFfy/mV40YAK4mXDdnGeJGkoKeq1ScKH7thARZtTjCFnYDZXmYQ2jjaZBHaFJAYZ5S9jwijmHx4xJlrlMtnB8xiAmba0VoZp98rfysGNkOzX7V+Ny1pTzneLKptU5ApFhFt6BL06yS1/AbeZDlUNBVbEcZX3yvchY26PGip/Ro/FU44FiXFsNvpmCTVDNOTxJvJLWMpy5ZYSNzHueW45GouYJ2rWsGxB+tCq28ymavCLGyKPJ0gbi3RxQjOdUlMlp8BbHMew4bqTJgk4XAs0maiDZTTwLR4XspyXVLmam6VVtATVIVNW94OoKBjNcynG1o+2cy4pTlVNx6IuzEYv57KY8Q4FodpW8Iqo6avieh1q9kTd3Pnq85VlZVJk5Vu1KhYwWbljvjXwroXMATHWJp42OmCEckteGlGZadtjUpQNbHTGRo61RclJ6AWnB60lqOzNOO21VXLm7HwJ5xijqgO21G2tLZ41rJzRPTurFPM8s6CIlvvjEJQ/YzlLa2b7Qne7FcnrbFRLuZFHcudTqDI9GK4o2vDVDCJQ+UBclccS9Nc4k03NTq0HiJTxCL0QoKqep/JIN2aIs1gYi581GkuZMbd9NF1gxsXL43Iks6L3TQ8VlIz4eTYCcMYRAiiLlTpC2nqrxfRELnxR52K0rHhLZ1vrjzeeOm7c7ZMqhGz8vBJcNXZOHkgmzGWSkxURiAxYdoItwtUwc3QeM9X8KIjt2NMGdREWSO8AbyriYIEqjA6MxzNpxUqF7dbPcdJO5FTexc22XBQWl4IzFY3g9Ri7klUtDkWd6tO0geYmvxSW1MsyoOzrbS+tG5UcamcM6LiPNHPrnPLK+OUpOp2vzquxzHrzg7wrF9Dzy2NmEWsPpdEP+WaTo76Kp6rAdfOwa0H3WUVLG8bMFEe4HhGrKiarPXsMew4juv+oR0M9eY7qFetFerbRMcYklNoms3sZ1SXB+hxNU0cQ3ZtVE7FWS3VhegmBRVSnm3T/CRzttykAHFoXZYaQEQAC3tr6A2tkfEayOPBbNLKygAQ66woQvi4J5F5Yto0x+jXmdZvJ2yz6YN+VV4dl+JSi0QrWFE+7EFr137NQVBgSbWyDcUufGVissYxee/YX4KyeQOVy8aLsjaawII4k1kIle1oObr3U8LipelJqqTOC5pftP6akOqCllEERRTSwSvvJ6hXPCtcTecINrtnsMlGWalKYsiuznRKgr4AKgttttDlx2HPgmYCoEuETh2Gi9aHzlVZrn05Geq8PBs7mz2uOuIUJVqFcuaI1FoubtWX0dIyZSadq3G9pxjV6TcbNGpUriou7jbbJ3b2Z5ZZKCCKvJ4F94oxXpYQnI/32kEGXkzkRaxIQ6Nn3Aq2DNU4o6LK3sf/YpqQsph2VN51POqcxKnr+jFCL/ziSpevytyYMvarqEWqqN1WHD83v7Ae3OStzWg7ikLT70yxYkRjmAsMvEallpeHRj/B/8Rk3awmxXdf4W0NdQf7t7Icn0OGiZzXz6G+1rubBZKCg76C2KlNtCpln96OpsV9e38PZyK3KVvaz278UDpU6KR9Gf6sVLe8flQ/M1FOa1GtRVOALhQN7twVAGrpgjdH1C1lqi9atSb0OSLrMihPi+AT90dbxr2SWS/uxHjb12j9ic/TuKFhU8WHsDGFaVluUcgVH3KapqBkmrVktRNd5XwVKtsxyw/cAuFwi7idf+EWk6tpO8ZVRaB3M1uEzbTHuCo6lkY2M49qw0A1GpWM0EEpphGjKjZmari8eXaA9Gv2PQgUVwKgZRo/Fvyf7pFtJBOTJ9Nkt5rWhPOS5L582+/fTieKNTP6yqKvvZDDKnbxMm/NNomf3ZRw2qHAt8MRWQl51Sl8Oca9u/L1mW2Ns7FuaJ3XcPtDk+t10L+dV0Di+dgCfO0wNut+P1xMzOcZ5ZTe499fopkFtsBM3Uush0YeaApI9P4DMw2+fOIHyqD8AjxvWizhLfpyEwDQCliT94lJnIOoLZgJBupl1uN/CiSrCfhU0b/Ps0nxgaFtWgtNzhGZ5A6GqasHnxbcNJB+Gb6AWRKwmyw/sNkR47WuZYCHYkJ4iFc9uUBtZ4mTHZ9+rgsDyRztj5Y0C76bG8xh32iTfknIowozaNo7xbg7ove45o/0BbTMhf2KWx4SK4wtXd7QTe7X6lgIfvexxDji0rLTU8rXxvh+0q7mq9FrKsJjtYOQgL+/vy1hnrHVIyCabMSD62xEoRt7JknBdBEtHcWKdqJORTPfGYPOT61It4dPag1jLqdZEP9orsh3VApglmODRz3LkeCNiL8ypBMsJy5hjoDWn8qQsbPaqmez+/8h21bxBEIVSf+Qbasla7atKTezDb8JcFxMTLKfJ991sm3dkAfd/3+zbatdoB8nYFU0ktYSvwYPWv11l2T7g5apJhSs2pxv3TEE9xgsUzypeKpTPBvPhVfpJTDSr1Navpu0GRBSoX4HFA1RPhR3Wc3UKdABXe7NXRUVcubfKoNJT3Nrnr77wM285SEjNHtVM4pPzeRcbUdDCaAnAVXXnNkdcldFgEmMJor4zEu9lIoMLYPqZz+BxL3hJpO5MUG7z5NnZr+a9r8+YVb2ZGPK0jXf9CbDFcYyHbY/Ah2olMW/bnI34cTtnZNx6vIwncbDeQJzZYotWEaHs65XYeC9n4TH3e7gSnNY1KmVKvLUVvWFKqYtaaYopAb3ckk7LvVOW6DM/gwxPMldzGt9M49ahbU0oxk7R95deBGFSZXsXnIJsNSjpXDv/pDkX6c/9Vk8Y3WEACgCSKsqaR4Jg0Tp0Qjgmbr0oTXn3Gvh0w7F3Bs408DzZHvqH/c9zyKrxtdqis6R1jvrQCJGZHtiFk3o6vkitenWPuuQHAtLO8hsWnwijI7hwznMqdI/JHInLcSNGKqAxt0mTdm4JIjmYfYUcJcNuBq1gmdjgvGcyXCk7jOAmHhaIqGzsYXyiUJuiUKWNzyddsIgJmX5PE9cVdw2oXTTsey4ZLGzh/TQKKQpZVNMqUIZFpIx4mHhYfNymdeOB3Pt6UhLi38FPqIwdNcKuEApwd2tOFysFaQbIgzUlxKNpCYHK8rgDcjy6agPohs7o+5V/cTCAiYdQghEZ9FQ46+bC6S82VwArG5MeMUQ6SJ0TJuU5B7uGGRF2Hn6io7E1/4fynjS1aLPXZipqwiG+c/mAnl4c9NuOk0wR/7nzQVRBP/PzQWOiCq/bi7Q2agI0wU6cUM9CEyw1qWi39CkgtLFAN7MU2Vqtfi0vzSDjN9R0iHriNatjxj1EBtdifbu3Sxf21GsOzp3kbjhxTw2xaUlaR/idhut6vzwPHElVHGQsu65POZLjUrZF8nlsWM98K6+q5s7k0yzRPlF2HEd6tbysA3IkabNFHBz+r1E0LON4rvXfOOtPEkZJ79VFPJsnqfxDbqO/UKn61XFIsbBAmcNBSsuH51LycikuXNtQDUJzUYZG1/t8elCbGorcpOLZ8+E0VfJMGUnQy4e3WE25q/ZoQYrEYWKp0lQHnFJSeqO79EGFRmqXLWRH6/NF3kGafYFxiBZ63qQmBDyPFawjJ+m1FO1oGXzLH53kumvUQ1QxBt1lcSpKMXo6EaISToh1pcfx5ZVOdxjPXlvWutqLBrUcTccjkErHERZQ6FsT2tM+rDQBBOcTAceQkD3xHzMO8PQa1SEN1cSt2BLTKcilZLnIsJMEsqX+DIYnYSARQvqN3JU3qvfeHQiQEPEtABscCj3lkU36vTvz9ngQF3eSF4MuI0E5gqUBXhMAVKrHXHGG6WY3mfKeMLMDvJikjr3v6aCmAFrqo+OR1kaZWSrkwUqa5SCJ+2iml+4nbFLY20eKaD4YJFAOutWHlnRQ3lPLpF9Gg2kOxnk6DQ6fo2N2peuUWOmVRuSPcYb9ZBxhs1BbeZNqBh4D8U8vdlZhIZ6Gfu4ZOcUHXAF/KNKOomW5B4HKRNjW4CiqdJTSS+wol38CCFwyQKqUh5ThWLs4FujA+V0Db56oTIjTEHTe4MJYEqeD5lyV2ZxIZJUFAwwm0o1WaaIM0VkfZsZj+xdR18n+GGShvFv6FujwQODlOM53WBxrdcrVj4kyUZNNn83qvda9hYlmowMV+GcnaJoVv/T6+N75ePkUpdWgnFtNzOIRlVyCtWx+KpANLSq7EOJBjPALGGp1HtIjid+aRXyTIFoGu1XMQRRSjGKpBFttKYoVHSKT5efNESbapy8AXtjjer+he4dL7gyIU8VQnY7KUazrhSXE6+MKAS/kwzjjkLP10OuEZapEuABLM/t586uGpiijbk300MHqcnNqPYQYsM7dy5PLNKGMpGX53EYzl683hM8oQVVDQN5teCuho2rYmfzu5aOxzAZYIFQdo3iwUGrPBlP/NQlbf4Cz83Z95y+Tc7HQBIbeJ0FNyJvomDppR5wbc/JxlEkzQYQKs4+RyWdrSH6R4RJVa5yz7/UIezZhbzRatOhylggu9ETGJEswBCQ+wqVazqT1WVVyRtnXEQ7lxhW11TlMF2H8hrIlE+Z/utuKEuOT38MeVNudGIbxnWRTy/Z/rUYk2r0uxzo4XgYw4/jUS9IeoJi6lCopeChhtvJuGElXTefZF+vpg3b1WHyWyNrOjk0/tUc3Wc34o+u3Zfs5kEsO6N7cVU0fYDnFFijxeNo9aTnKIXNUIU4gM2zcb++v5l1noGkZOLEsz3cDem04zZ8ihlmbhZlEpHlE4q85cVaJtXHcM0cEmb8RPHk+cSKA5NbdFypDptBOlvRVYr7Jse+QTqSAiVNnJdJh4g3ud3VuGGnOSjy2bOcxaExMUUheOOZuu6FNKTrGh61wYNx01RDW/TIcjWuLxuTn9GvRGy/6lgecHdtbBtodXDKqo2T5uyGb7t39BKds/g8j+uV61AfNykvvH9rKB+vBiyKa3c51zl7q5/69vX9HQnC2Z5cZlXTJWByvkqa6hEl8bwvlE9WOF+py1cPqGmD6+7p4L4dmuX9FY9w3NPxFvCpfeXN9/jKObjnjKlIRSQmUQHKUAsGiUMP2P7z7Z1evh+O40HmX8qAJp7pFzjJbvVQF1pA3HOHlJHsbyeo1tDCDTB2+tABzIx+BtLhdHQLzwYDeOYrZ8LoiPdEF2r57Fk9tMyz3nNd5GB13OX5WvVAONe67NsaYyeGcaJYcbUFIe1R97pzRAsGMICTNgWJPP3icKU8b3zJoOyXOy1Q116oaPI7qHA6UqvbHbCUPbEHGIg9ePIP778f4sS3ayjHgAGY4Q57/gvuhvfjwf1DTdDrgpCEo+rGyFcbkIeFCdfVjqDcV2BpP+6P++sDSWFAuiHP+ot1S2pFwmM9VQFOBm+AzdC4+0a4TDWRpcdByoNH7upZqZDVGbtsefYoR2RfuU6Eo4ekT5zRAxddgub20PWuY9wddohCoAWSi6kKnww/ERuXsvJuRIwP2oxKJd74ftJI9L3Z16/HzfXfUInayYQZGPLkuELlpp6qHkzerEl2LEv3dRoAcDuxBrUW9MTpfK9Kw/A9cFvw6FeQdISaNapCUpEtbLGv5wgdt51pfBhL1SJxmOPiNonUxilsEvPf2GLfHeWL2esg2uQWTzUBaDfvwpb350wZ3A/RpiiBT1y6T40pgZ83hNwtxXU+AbQykfnW12BohbrdPXfTrm7hM2XUGxQHLBGTyils+gowrK3LS/gWqw43hMpynderidunJVahrL6+sY/Zk/hR72J9b0cK2xr8kWdHRPnvu/1aiTnW32TAqerqeNQUGBFDmXE31EM4wM+JOpvbJbSC1d/dlaoDVgep7w0nGOExeV+RVBieMi5XJY4W9Dg/x8kMMrXN4UzMoGlRomvSmucc0dmoolPXjsx67YKnTKB1sJ4h6uF4yj77NcAwiU9JTcYs52LJ8kpHQ3Fq5ZBw+7gyZ8LK+/ZnYBIlJmSgYd8Nu8xbSvIWmg6rq4qq7wBilbbONxd3PFLMLu6DJuT8NE/aGNZW9TMFXqchGKuqz9ckkCwAJx54RDd1Hb9xTF3Jw4dYwR6yHS9fQ5wsCXiYkAAVDzo8zYeURFzlkwtQqBbgkYVoJSFlpIzZL+mzShgCYvIg1MPU/cEGBTz8ctQvjxyaU4Fs2RSatV6DOd7cU31o3yNDWj4WogkdwN8NeVeDSHOUvI5NT6qxltCahaYnhfJvCfjEtrU19wAbJtFGHvev6802tU//+n350hyjUyIbr/AcFWSnsjtH4hkppokiSlIYGb8sHvDvIWamx5h6hYZUq9Az/v3tidh31G355AwqduE9oIO72jRdMMFNKQnQs+1EEdAM0uYMLisFlE0aE9JfFKPSsSkoW1m0iaayd4ChL4OegzIaNDYqHfgLH56xOaINpURZw3KyU0WMJKKVNNmhQ0bGDRWUE/QUJJ/NIB0LdFJMJ8XIEVmyjWjnRrh79qm5OoMHBqgF136BkLEsegosZhqMYpTCk60q31IEp/17DPM6ijMdzLXsRqgYrV4VBbcWkik3EHROTY6FhYFVUWXAf05Q2fPiFaqrU/FSexhLLQAd4hFe9YYbT6RvnnuG51mn36XbyJSV/voD7EpLJ2Ra85tpRjzF11wpGUjW2+RNKFkmkdx9dnrXYnvXuS8MOledwmtT+F1GxuaM/DP9aB3AYwob/NWfGDEShXCnpFbqEKtvaNMNIMDjHi/ey0dNdT8X0bIWOYdLX57nL1O8tvm7uENexuwgHbUoSgqYMOhSHzEqMOG5VVVN8WBEY6V62gzodTe9DmExM+5TuhNmxRmtuR1mTjGxjDs0zfiT5XOHiZhDMOemqryKW96jAhlz/BeOigR68Ntc0ODL7fYK+32TcUWTd2QWjUI63YYANZnjHD/CU/3qeHg+bxmMnojjooM+knF24R2aI7tQq+o8n8LJlgvPerHNGdT9WAZ+17FZ0sl8jMjXZcVDfWCwHVNS82ZOUDY+6Ek17p00e52XHsfNTCiSjMrNEeKuSwMgimPFkCqFbzwG3FrOt+7v8dKZzKNr1BQgxYriDKKkTeH00Db+pR2dmaYJvX4/pqpMjRUVfFqWZzy4KhPVRJ1Ht+fP71sNNgpb/AByO890mI0eHWPqGm+WkuTufJX0EaOeuiNN66QtZYe4YxXO+q7zMxjfqqaZGqHWxtBgp4EPldPtK7HsDvem4Gj9xRLEP1BnqR6jHjdiwKHHWjTdwA0IeBBUknTs8sljg/CTAQBxRo8q0KIxkGzgj64V0PXLbS418yFdkbVk89JghSfDON/u4eGlLJ2O7iV0Ya7b9sJXnZMS07B37orCSSDTJ+TEKILnVx6MnWkicXdv4JiZSxNfVZYVSYxIme7d47Ung5S6isWyjWhLuuzd9rh75ctrDQTV0YA1XBCUYGzR4p79jIp4sLhreoiMX6NhzhqlL3Qs0avvSlAlTaOfFi7TSfvuBnt0yNlMURqKM01no6o3FDO/LuEyklT7dW1qfDJCT5X9YS2vE2NDLlXa0LHg/JALTMj4icIO0mFScb3ysmwGtSaWWsCosUbvsexCqVlYkz8Os8zLZnrxIKEEF/KJ2oYNN7mw8nXE2cdMxgY7iWqYwKXbQE5ZDIrpXXmYTFoRoEgS6W6y9TQVRZiwmX+nKLSuZbQYzEU5dGOZ/zaNJ5/049OIB0LdZ9dhhZ3tdBGmFsX4Cw4NfKmTxU6E7vtDS4zatQceauQGtxCHVp6eAp5n+zXEBK7cJgMe9NdPqk8l0joGULlRhv9SLRrerpbZJPrwSEU8/z5Pmzm+onhuT1s7DR5bYJYBfcxGALov+9GnEN42v1ih9/zRT1zfD3uegdxfEwkose9QxbQcwzC181tmoQW39kM6sGjF6xyRQwuU17WBX85otK585wk4Xaw/utPGCTZdzo1v0HqTeUJSQMJI2fMoMHVoxdrFDSuT02FhrhzPEoEhW/0FvPRZD9AccSYRm2Xg9lpFKl/nGHcVKU87co7h4YoVp1ALcSzKcPKunAkno1YacfLEfH9lw7P8tL6rZpyakXGyXxmPeyJkUSHHNR2ZZTV7YhXlvP+627lxS6+Hv83EJ0WhLhK2V4BVMSCd8Ilp+u3riXPec3QM8wHimDPu8cz237dmvXDpSr40e517XPBb/MWmS3vSCMVgj9Gse4aJLma4C3IN/sQICfKQaYM9uMuvcB1abOETYpHqNIWT11NQvr7vqchXuoN7UYuVd0jL8ZXj/6Vu/eYrX3X+0gJD5WG3pF/qUgBfPxRa5/7CFTAY1OFI48DDnXYYqbnn9P51d5jzVcgLYCyeKvM8vjydJgxidMFOufMGK9ETY1p+pbynsohM/n3vse8025dXHuhO2GAbYJJiDkFUCMO+yHwvACaYgx/xDyo8eebYO3yLcXHRJsXYFcJ49elbt2UeXE4Nowalv7/toFrRbtee/CNWyYjvWNI7l1TBv2tjEtAGFYuKjWly0sUPdf8Z5R0eoMMwilgPUhtfCPUVKLWS1qywRtb8RS6GZ5xInbFZjlph8U2jgZnDGT78/P23RJERPfAk6Hitqm5eDXWhYdVbalEi77uSEJ3uHYVpmYmGgxQ+R8tbmZmcSWPelTS/7KjGqohUtEFMuhu4azGsHZRJY6DPZf1rXNw1qtEwbk8VNdN8FTHjbAQGq+hI5NnzZHjQi61atlTVTey/2hsIVLUCA5OhqrKvdQaWzB01mX1caKavgPmUqTFosEEmZJwRlsyzVqcZH1VIkjdBC3OE+DioZYeKflVkhq46pQypcxVIDPjmgLjx7Otc/dtbzm5gksJunX6a8MeAKt21gEwtil2WYih99R3s6x3Rg4Wg0VIzyyyip8mDjQPgoE/LZiiUtW6704kp1nFv2NUMpNJiGJLs3Tg/kEAEplgBw1vTiKml6m0a8U1q2MIAxtrSSjc9Rl0HVNIUvajwQaCKRTUDU18UsjaraNNb4XFCVYakp5RUZHsm55wA8xJh/o6mB81pbcWwFza33GWaw3sqktoyCPGk2tnOT129RHyiPBh4nRiTBBtYVCjb4HfrAk+1YYhZEaxj4qHJMj86zIMewWPzQSbfVTcYFwzJH+1qHm+WJGMxV8ztIWJJ94TPqpt8zWkz4F1j0Iw8tQdDYMah3DFhnpp65VYDsNKdbvgQz5BxLtFXh2HSkSvyWXZBsWcc+FuBbAujTVVUjX9P8NHLegokW0f7QXk3kepfzhQypE6P6RxzLKAOSTdizBZ7idXzcHT50rveYNOm06b5GrXduFNrTk2ZLfyMy3if6NIy4tJfZaSBMvMrlboMRCzCk9Fqbekj1TGm9a1ll9ZAeNBV7biasviU26l1uUvCOeLZUJL7XFy3IM115U8EgCsakVc5QabrNMqpIL7o09etwOV43WTre2BQjnGJFuBBJho/cFyM18IazsluIHjsEUfRQNuNKRymZDCG6LsFV34GmykZPSLsu1EEHqObsbUePFASwgJoaM7dO9FYy/wa0kGon2jEfplNEKqY6xK/xmu/6e1NTNDtGyKaHs0+NX1Fd5EuAJmNbswRQyZiG5eka7IY9E1IxI9KbTc9m5w4R0TTl6JN16I573oOKaDT3DwwWotYaTa9SPdg87ZvEno0FfNYXglPuVy0iHgyLCo6V+dpUq5FgpwSeNzyhOhUFCq/kvbYPXma/djsYNvfCTRoUyB7KHcDbnQ0Iv4cqzbtzM9vmT2rCxAl1fQeQ1i1DBLxU7tgIVHMAIBDFlehPPOxEEwHj1wLZGHF5nF3SE/4qOYusVLVhbmX3mmCup2VW6/E7G7VbEjbcF+1sTne6PysSZg9kJ4hyJ2K9kssiE91rn6YBGaygG5xBqPBhbDTGp1DAGcbuFsPpLD5eW3DNUtXM+o8QHIxQ9zd7mZeF9MPQfNslvCcBjMbPRAYisLPCh1g1DUQTyZoaVh9iJj3dgTvMa05cdLqBgzKMp8elNIkYMpHazSFBGibij0OUoUUd93Rzmg4Ys+TMWJ9T1NNWAV2V05F/5wlAQDgZ37/EeTzVUfMxAeN96kMmOWrQ9FEZ7cXSMTY1ypYWpHKByeCWtlXiPhUytIZa9LcCdMzjAfFUp3f4YCe3K4ennTSG6vzkypdyrjpNJu3yK9G1hTSOk4b4U7Klyk6aDl6R1HqqYuQokGkO95w/eluhD9VMdJ7hGbgKpnE/utk2zVTQH7O3f2DBoJUs1gMOrVXo7aRVhEHtFPzOyyBr67p2W9uL7ox55hh5snxUoWE1XLZKDSmylQLvHsigW5bnt0W64Z9Htyz5KkQ/uROYc5cjIjXfzYn5SlJdQE430gGypvia4oKD6oKPGPHheYadNebLU7cOONiiOb04voKRElWAf36oavgSqVeYXe6FvmtImz6XQ1DxUGKtArrrggfJqzDQytJ5LrxSKrS2RjeUClmXoOJ7TqyYWzxjzdWqJjTcepS9hdvzORELMYOOGX8JcHb4RzHBACo1TFJLkHPbmymKyrdojKuyBuvsVbSHLUlQbi4AaNBtM0kEDdQ0CbTqUgF5iQArmGrc4SVyda2T7/BQ4kbIOtay2JzK8q3/TuYVCtA9ABndMoehsi4WKKDqysIN0JXO4a6TJIpcXU4h4eZ3TBpM3Oo2hz6dZe+66ikBcWuFoySJ+2E+mEqUSfc+wnkSnNTVMAzJbUKfY+r05gVsBmjbJV0x30sZV429XI2Zz/zGpxEHiIKAUtmTiuKJLeHOyRjW/7MmiOJmty2PJjLQ28BxSQtxRZl0GaoqLyLNCmTUIWC/mqcb5qcnnfKaYAW4CUaiWuU+TOeaOJyTdkPdmBL3IxKH/Qv8UTjm0/rbE5B0ivoKfDgl76MiwOzucueJt3AS5yldG3etzag00C5SRFBAXDrn94KAMPZpnVC4a6lTQfKrTEAtCiKua78LTHN+MRJm/Oufp033YfnUe9alIkHdBT/EE+s0Injxh/H41mB3mP0dNNHXQFO1UoVZS0wf3J3f34KO3kV7+ccHrDB/DqD8mn3/c7PEO27E1pNUT43MfunKNR1DmQaFxIHdwzayWzUsDKgpsfITAG3rsNmoZsmGUau63+KJ607DXl2Jw/vvWgHVAKWv5wrlnmgEWUTPlWjRnWJZZAaO0CsbkcZ+ISrZ7LM/vfMRorVQ+bWgHTE5YnnGvlG1oBBeJbuSxGntuMPGfPcyQhUZv4AUhhYDhfxwNXwsEPtGyWXGVfu3ZBLeSqnmQX8y+qXz6XlhsNRJ7qozkCF23NOoXGLX7JCDHV3i722rRijF6obK/Q4z2bMVt+tquAmC2kRQanE1P9OGRA4RmszUPS93WiNN6qGXKb6oPjP9kbezG9jcf+P/eML/mia8E5pLh27CP59vNs3z1hnAP7+Jws3zxue2ZPnp4OXHJhR3/EpOfKnnhGPt52L40rirkXso4PUpbvRF1ntPDdp+t7McQ+HSZiInHTURlpod+gBJnpf6JQwEXECvra7uwnyerqhQdOuycX250b92VWeTQbXV/5e7zCX7QNefPR1NKfl88q4gIErQ+uQ6YKubZlF7K+bigEAYHQ4bP+bqztbbmRJrjVc7/9sGnZLupP1oCoWSZAAiV29j+n2/O4fES1rMxQqmciMOcKn5e7f+5RoerO2dh2JmUKuV6r23vrr80v9qo+NSRqhrCU1oGdSu9T3rAWXjTBDCd4A1v4dqyxjKZqnp1XX2Haz0urLzMLaS3q3Eiqz8utOtW/yVaaRzF/Tl6iHiauzW29GlBH5X9bEKdS+9LaXHfN+qgGh+Md08fsMICB/1XVRj8bsMR6Rw2lJFdv4cwjo3b7/9P3jm7XP+tixLN4mVKEk2Fy/bSN+QjTRfl1uYLa1LB1ONehT9rgTxPbkDazGSAPhSI715V3mXarUtPbtgGrktbK80TjTIdmtS7AQ2oqDtOyCJHvgHAdpSYknGEnPCLk2UItVkNb+oxRAMmj1pvylfYJW1F8SGdNq79ae7mx2k1lh1K2v6+0JYSGdTA1rNChmX1a7KyDPHDArnM5o7PhT6lYv6Ac2ruWyjncXpOBAiaSbv8Sz7CiNcnE9iqnd+YK3trgQyvdZL6idP5bGCfuBdcG3iTkAyMo2Cu6MuwITAjtoAQnM3n3jb349/1tBQU48hXGmWG2H8HbLSUzcNwx7pyKOHjiuVraWI1ViwzFldN0kzZ3xpbmIttBAVDI7hrSzq7Uf3Aj0SMPRpIo01LjXgBOP2fHOuryS40sXFsfLQnTAdcCFSbwMqwf6chI8sS63OMRLue+sUyXzSayuXMdYYTFPCaTUUcc8wixD/OHm+tCXTtC2lk5zjM6Sgjl0xPG0ZDlutEQil42Y9ksH2THTsHBkQGt6i0lDptPrqpexCjMawOJrue/cat/yOoHCFQK94WouajMwZm99IcWXMYf1bQbZ2k+ap5h3HBFix1/DGBoo6gnqlZOq2OvYBorfQTeQ0uv2GPIoclbZKnImflnjqO/aZBSPqQxMf88A58MEN6YtoO870Gg5XRSIRXPQwHVu91if6uKnz34nJmUDnXQG+ECtUCF09DVg3JVWnU1QZbMDr+i64dBhcU0dY6QbEVSgx/rOxlp6lMohdXYkxNvVACACXFR/tm/x+HwDSQbCieVg4vQaNi6eeovtMOCaIeBF3x08LeiT9YMEw35HPo1UdeZxNDqRj0g5tGsdhH3oontGvmoHWMSU9wovairGY2PdtOG92wuDt4s41GZncI2JUp/MDPLvgb/OZ7foiPPTho01uuKwaCjc7+DScO4nVDMnlLEVskjEM0BTNFu1D0+K869Bjrt1Chj4FGf8DsO+BUU+lsSeN2od0T28PAa726DIex4UqV+xt7uOP+E5ez2JDBmVNGsiIq11tllpTEWGie34tSclZ3DSr3VPCeLQdh+VPzCj14U149lXEpwFynGoosRc7YLCbN5aeZaRIC5K0Gkg4Nn3mzmWrB5jIb3ZLLi1K8DEQt/HBp0hanxkpK79FDGLPR+ZjhOH3dhc9nCNpHsbpg4WaEkVaXfHyjjMkrXKGQ/g6np3cghuqEg8ibg9Mq43v7WtXvQMA5Tye57HOcIFRnZS0ULtXhZrf0JRUFGd5FkyU0znabNObvSTx6FqOFk4HqHJJvPndvgETKOhFh1FjOQ5/JdTwZb1riXIDr3+MKybif0vVkn1Ruz+vvFkdE+Wtr65YyTdfGxuffo9sFKnseNaALR/CphGnLQavq8ShPQ0+qdN7kWOGzXpRoVgFIOMQxb7dUwcj6EUjI6egvJFnnqD0CSl7GUt7k9SLWBjfyL3/fS8ZB07lWjSOFD4AYH104q9J3frH/qLxDcmgOp9J0YQpdkEZ1WtMoxeNNUM+wddayUv1ECgsvEtYAoTiIC6mxdCI9xph0p2hwnL5lzWYnzZcWZ9TsS844k/pFCAV3gYiqWmRnSHKub3iGGnHMKFtNeF45YWVuw5lLhynTpS4p7kiOI7pJOsQTGVkR4xBNdl9FUW6p6pMVKeDMO+bYtM9A3C0baOFLK/YnduD4Qk3FzvOt6tJHwuEsPVwvwhxA0WQ1OsT4WnIF2l2kSscQRiZWIr629eh5yUhII+obnhCp/qzSpW9uEbzB3lXx1p6dRfR3vVQdJS4AkE/L4Bgiu5eukRsaqN4eiiNv605ACMCsIByeLRt2wgVQ34X+1yPEvhxBPpwRHOAuK+K0AtaYay8HUhJLXcDNJDOTuQuUcAs4HK4dyFArBquzZNo8fqHfn1Kt3h3PXKRGOz69cHEmaUaRz4nR8RnZM94aTKPQmu2kn9yYGib6aSh8V6zMxd1xNBE7DhDvDGDiqyCbCkxFsXlv0+6YFGa/+lyt+ONehyTDSmzhWrn92eK8GDb5gqhDzRsD51Kum1i8IFIFVV6iOmGRzEoMSWQAu2gy2TJDyesknCS4hn0TPYNbkXkLPuT12XF8yQjPn1ETT5i7StR91tJ97wvsQnjXxzMt3Dj3B/HTGIIYgIItMEIND6gV6bqTYzGfkNAenIWLMPud42qOXGvGssDV9IDDR4jFNm9+0EMYAYO8mqRM5Zbuo+8bHqarXylaNypGonFyBtfS8v8kHqIbnIJo8M4eu5nzP9SvtLRAKbqTVy+wozWbfJ3iP2byx4JA9TSR03wv8iukgAqHCEcpBJK2dACZ/TTjZ59izH8onq0bcE2nWEgULDVkTo5SGCnRxNIWBPje+6B5yp9yXfVUpgRM4qwYbBNnCOqMtHWqz9ouz37q62dxHeeoUBPqIznXoIHMRz03+gO6L6cHcDDeK7168isp5xY8IXQsf6btktVZUni+FIlKLpYLOwqanhf7DIX7F9BFc6ccV7hhMHcN9KsqOg1mZ5mti7cLpj0lm9SMtCrDe0fIZGDFLwMU60J7KjyE8pxJjfAd9IFifPNkz0w4w4nCbxXi6XJl+otwaC1DnbYsVsCWe7Xqwj/+kb6wfvoMjKLL7Xn+x9bVaTwduObh1I/2SNg7FECoXWqQa+kLtEqnTOsJeNTtN19dbUCBaAPDf8BtrWbMIcOb3omcrhCznS3G6Y2XKrTOrdao/015EDH+rb5iT5Aqjw6TsJw0ZRJ0DSwpZuj7gBNoxM9LyDyLxAKDbGnbFrT0qSHa2NNJS4++4nfR/XmM5RvipFBiWex55jgdh5kP7+BB0QBqH5wuqdZwTWm8BrlRdhqm8djrJxtglEDP/by2TU7NCLNtH8gjYvnnrinHR/Qq4v1F0wE6HMuyga+27TW+WDlm/Y8Sr6gPIWFF4MmZctsJVYyRUV9rxjKeDN80YV7LoH6McT3ES/WWX3a1xR9z3Tux2T1StVab0QU0WEll4Zu0I1VstltOQbSv7Sd5rulJDJ/PX0bdH03Wl8U6BXfoPzvEj/p1FGzxnbdWVugXNdH3uruqo0Oauexn/UmCqa721Ym6AOUqa31/tO4dJ3zPW+e8sgMX+G8d8A8TOpejHNGzR9Ha/wBrnSKv95B3ajvQ8aRspW1ouujdsG4XlnVNi65jCPkWiV15G+//xUI0banHoVO5Fzaswcz1lH9smm7Eu93jeQe21rbdRUUYnkzq1fcVSV1vH1L3++fCNGttep3WicYcYx0R2P991t7OqOaDkRyAgQEN1EDUkHkm+vlDFo40puhwkNspKdcLSDh3Ysw1Lyum64x8i4fG7Eom9UVcC03pXqzamDTkFrHASpdsIGnbRy4mp22GCT6xFXx2Xm+P9cJAlLxUWvW70OwgWl3I/DJ+QMVYI4HLQ+9RHUp1MBWezFCs/et5qt18qHaanS2iAiRk8z6PIfZPdtZKAbevekpRghaTm82rbC1mD8ib3sjB8r83YHt9Q2lkqDDVSg8o5kmts5BVYMTCTEsP99xSC6Cd5QSja2vPjBn1qFJ9ehxDPsHGBzYyscvnigMjdROraCUVmJ2dd1F9AgoLGUQ5wLLA4+TNQ5EFd3yTbWaRMMjTMTV6Ee22atgNqn1wcZ8Qs8LUGphSUREvd8jg9JK++rku1IoCKRZ6X7LT4Iu76FR7O4KbEINX7lKPvz8ryMkeRN/1BmVq9gcWwpySuUWF0vjGRIOXs+GRPSC3sg9BJjwyeiv33HsrT1W0MLK/oUpkCSInjARqPyAdrIGd3nSSFeK0mwevW3fnmmAZHThjDR880jNKzwTFED5J4U3K/1dDRq0I7rZTm7WtxDjg5MVS0sRJatRnDbCOhi3mub6KagtiRZT/Jv+20zU7x3deBBPQTaseIom9fX2J14m0wlsktATyPbHBC62XKU437W5cprZFQg18Zo8nksPl8YcKHrIibjLrFiP2mrt9aXdfz0RZhpfXfk7s6ItR7EHx0PkWTL5wvKNa9+zU4VlUlYbBivYas3Hr249hJLVQfoS5uNU6/MGiAulWzWydiGVTiCrjmecOoHmAFEroR1DZ2j+ucCdUjK9YtivfY0zpTP1hYlDrubKDdgM5gq/pvO421JtQzLxQ/nE0c1ct9osOA1omDq7dN164xNto0E9gN5Zr4+ZZfY+WWB5aDBocZ1N3tTTsnq3de/5O5pmzBGKQXpJ6FlVk9/B31sCnF5dsOR+PYzQ0lxKo3bwxEDNmPYC0ZKedtoeytWcoqx/y9wr1EgKr5uikriTCuOwFWZ7TB2t3Ht3dP0JGKhwKw06oBR8S0i/oRbBdDrZiRDcDbuITMBK9ORn48Zbqfh78fhqQYAtdYGBAtRYCvEEsBYdhGL446jCH58xe1r5dQjsq0TUYTzfkIrY5imGY/0d86AOlvLhRDng0oPbgqcylXNdcxwwcEe/VltZv5qD4sU1IdOmDE74u6kqPYTP5bqjvlL7CeOHrSjIEaCtkHtonK9BYMqUs2fCrwGFQRc4CHEuImMYQSldSQSL5G/E3P3xlsmwMKGXeiabjOet2dQDccjt+763BjFd9OkOSr68AHk4vzXnz9wVxSYPQOlZMJelta0BGlc0WWCtKBtuseCwY+I18Pb5nyHOl8EovgAjROl1HDrEtA/VMQjIfJn7K3xX91w8we5KuIe25FcG6y2Q14JpA/8av1lW+yoqCPAlZJr1Phj32Sj7JrdENsgeJqILo5h44/hi5wJe/xMM/cgAiKmxDbUHSltzC8kLa5x4DS7t7se6hyhXzmXuqH+dgFrb7fAllE486NcU8SNerxP02dRTrSZNqVjkPkJ+1KbuLrXlOom0IJC95oIOxW9bhfTK3L1ui5NfAfOFJJoUpyIuyp+X7xh3eXQLVQfwkdrsKZTaQdmc7O4QetiyTvAK8SBxzpGNQpR2XlGMS1ULtdCtu363zSsnf+k95mbrVFDmSTI/Wu4n+WreMY21guLG6IGbi83RFX/0zbjIOm8pKMRlOC1qaYr3+MfKaTsrs0JoSdizJIb9rshcOLJgC2JA0jjgP2qruFWgW3WfgzuUcu5crSQiVxVfYLmCYTR/cZK8M7ddXNqngT98kLWGImluNVzFAVVgqeljRKsm9bNpAxspkJF76R2tzCpEC/rctlN4fZprcggXEMjMaxssCXLoNzhUp5W+da7jmVMNFNjF50chIi+ORta9XLmJDTgmhNIzcRlddaCoceF4XlP4OiTkZA6EcyhD61g7+54/SENE5wuO9VaJ0d7TuzNkhgftWz7IH3ZK/tAurZ0qoKPIeMj9sAyEperX08a4hMqZ8NiT/NYuxn4s3tWqUMrAZ4i0PNSY3A0bfnyZzziLVLYT8x8An2LOUhSjtlA7mfKVlZl+e0+nXMlN7CwqTJ3rB5gpnUdGy3cO5w+fB6MSRfYgPeFcYuMB7sGOnXcD4cUuqopMCHW2S75zqQvTDdbEqxFxwAaP/qYTJVrDCG+JW3xceitXDSh3ZEkjp1kt1k6Gw3wZCog+lWI8N2RQkdU18wjLHSM363irtkW+m6nol+wABse4sOxRDe4rv0XiXcaLEOQBFSxPUD/zhH8bX2FefTz+tL3SuiVVV8NVocdGq9JCj5hsTkxM+syUQsYZpJWszMnB5AjUeZkwOfhDiZww5vKodx/TC4P2xQWm8o6/ozg0sdZpc044+gG5oxrNYNE20bsz2ZQO99XfnIsxfVTKSeZD2ZrIzyadAeKWCBRlQbKAYRqSQ8wHJi0ck0e5tq5x/IKY9lOav2i3Lvv72z1a8IcT5t+kkSJuEsp37eU4M2leapKjgBOzkFhrzvravlb8oMDk0yaed9ph2Ot/N7CqQj7NqrFjX3qRBz2LkZ4V97IRGvE4A8TuQGo6hrYsB6JW7fwnsHZpXGOFLZiKp+343JX1x0HAJv1ShrCgTzh275EYBIoBy/BbSvBfW6ffAIua6NMQpRLUd8vC6KC1xBBWDImw9UdyILkL3AaBwlU53FeqMSqYGa2+Go5hC3YDPfJeXFVlUgz38/UpIs/uHOHYWfsgkolVQV0MfaAqCR8YXU1v45bkXMkOJbXslqGFKZDo0zvuE6HLrRLU5Th7C9PcdGXgext0Jjud7Gb/i4uTRrbPj2TmWWR8otqT9cc1VjdNz3+00Zu6Vpq07mz6v4+FSuPaN900xWVrrliL5Tgi7PuJ6r2qNX8ermsBn9UqRviZtrQ9ejfr5vKNYB2e3XL7BNF6Ple79dKTv5809Qyo67eP+TC1PU2OOCquNSkNQYIhiMkSx4AqbI6XU60mZo9kPZ1Cwif0B02BlFoBI2plmZoYrXf59ceriOVXEW1X2l/e34xMpsNdXrd/Z5p627cm/fe6qLXKdkVLqT73xaMUaXCxejvzMv6sZSHKCiv0atwbev5RmBtG2NpENreWxfh9Rv51fjXd8F8JGV9W517bdtI+hf2D8lsu+ZM0Fg1/hPRr4VGS0SOoCAlKPE8QWIWwQ2q9QvZavSB3Pl+0fuxhcnUQAyUbqrdLIadJV9Dl4f9xREF9IphWLSZrukXiBSHtN02wGF3OmZG1pMZZW3YrH7lQ6iW3hUzsxORJpaM2bAOfZk9N0S8Mt/R8YVosveth9lzyvfI1kAqHjqF1sfKJf8PuvfEEoONFkiy+zBMJzNgr/duow/JuVofNsTheaFPN+rLSB6VL2jAxlbtVHM8zMl38gwKKRCHA5LfiVClnmTM5SKLHLdWIMzAoKEeKpwWSUIrxBrT2TdjwPuyKwdIR4Vp/EHGKWbNHfLXM6TRuja2QjwdK/1Sw1kNUB+iUDYKMD1I+Ibev7Nv98yCQAiPWBm4lBjeaQH0sBweMJmgUT+XQvd83yDRxrQXezjHBAEduvauqGKMnd8FTBMCae0zFKeNUhCU7GKRRXJyv+ra2Jh38/SPTm9zf16o3ZG/dXWfka07Pd/aoiwlUdZxPnpd7875pFeEOJBna/UsqeDQLMHNhlVYxc270NYyhqr3bVdPd3LaIa81IPUarhpb083aTANsb58crcAzIrJiA7jJ9w3J3sNSXVJgAvzQ8uB9q5uvQ89XQlXIWENwqd7dPyNpkvsGCrF7bIrapDWU3v1qL3G6rK7fvl+/DT8BSrGYNf5urEJcsI+TGtrPWkTAFj60NoHxM+Fxx+4Yl3iCO0bPUyT2kaGvo1okGSglUBOgyg7YLujH6xWdG/NIn2g0yIrTkWavCwxpuihiVxxMzZYfSsNEcj9/kq658NOlvd3IdA39ZK9gTKTyWceEKzdfSuDuW+gb0Xrymfdi41YbBLCgSuWxeF2hoReF6D1KXdCav/74IThKImpTIKugoYaJpQslHBBIT4jyelTJIunXF/iWHmOCk9rzuq3lGcpdh7+GjWQc+B5CEROoo3dgPD3vxZrXM8L+wJ/tCha96EOza1s358SiEKIyaJFR0cIYxXK1YFmm2WroonDojwyro1LrXYIh3FwH6TphDrkBt+jQ5lo++vE1ccRxg5GsEP6Kc+cRlbdMNZLATQNpOamz2mM5OVPg3Bs1+pVq791lIOazqV/njgjhFhaPF+0UT1Uea0dFZBTspPZ0n72SHbNmxKDUWn4lND1isHCa7deutZMONp4XFI77FxhPL64yr+reheUZO4/oPyve8vy+cFRhhF7IpIxihAbCP8Rf008DjIz0Il2DmHL8ndidaLkw7xVorDgNkJ2vi6mkfKbW6UDlmYNiLO5NwqzhAvn0dj/Fr0NBvN36OHHee4g6kZBJqV81daPjnfWHYbKhZ46FYov95EEPzSwlDgtu90cMXifx1nuKRyxUpIoGYWEw72RP6tlG77gDlHpJoOVFqyFzFnckP8taDd5J3VAt2Jq+yY9thtoP6ds3CbeH1SX6Sg2AgZ653MglCGK/UuZJZsZK3cNjPN5fF2x9EZqQSC/nr/iGbKxCz8PCA4H9Wv9sCDPPjIQ/uAMww3Hu3V/fhLNm/mofeldagxNOAmdzWK6WP7wyJTOD/cInByu/cLxRiNsPjQYNKgcksZyRs2qXtqg5ikmoDRQoPYnNYqmj7qfyRY4VdfK7Cobwb39bzbv8EZIPtuGqRvpCUXWRp2qt6eoAYh48NRDmMhPAh42UBDhJWxal8GjCE/oJ0YFT5XvEGsV418xVMi4EVIYpaqT0BVk0hZzKmTh92Lwc4KII81JvjlsWTJ/TnhXOX3dxMARRq3KdZXTn9S+DxjKzgugNBAXsJC6TO4Z0xshH71apkC9CUPenZnA8qZtdw/l0QdnYR2qCyt+Sv+Shk++JCxfYD6XryV5BaEiWp16pUxC2eJvuAEWKedb2FvwchnihOyOwm3THSt/9WTMii/W6jUuv4QBmkYSSZcPoz9aT9UDyW33pbOZ/+e+f38BOkoCY3jbo4FiwxT2X0EtAqZ7pGnmibIyoedd8PIydsyzAZloWONDhEJfO8ouSbKPHTvL+OZD2TNoQhrNpQIi8xQDwsrqrulSbsbqzpmVwXRtIJcBj1QZ23CGay9dXMqVuU968CivfN3j08Fi7oGXHoDSmzORgwhfyeaChM0MNrkRRFVJTQV+ECmpMfr4+d1o4Gxi4Lsu9kaeQG3GpGzepR5Cw8atbXAMlPvYDPInd8ySHOlL2y6oxkaokVpxcHScbir7BBtX4iAbVkxzy+rXR4CrcCSr+6uyN9caLXo2QtBlfhfNkxyRl9yuPwAMfOqHqGvN//cvrN/B+IJ4+AqzzAZSgcfXm07F+hcUjnoQ2hNDFwIo203clVAcTB8Um1Tb3j9U4D1SXbAXItQr0e/eFZxXWhwgjWHeMCCm9XxcwPQpPs0JK3223Cs+F6CDZ9oB4qvK1/kCmN6tqTJ6IS1TVdVAO7G6q2jHZgujJXk/dIALMTNWRoNfRt1eSVXmrkq+vML4rFy8iPmhN9V4gW+j9wdGI7qy80OgkSr4PHQlNofDgWC7XJws/lAFUnIMHfAUZSYTiy7nM6IykkCHirDSDx0eL6z0rKuZEgDueg9opWBy39XWm+IJEk4JF/gFy+VNSYRU4tPcs/WxqZWroNYwhZoKAyk2+XcXSxDtPSl/l4BDX321QowQucp8yHQbSMEEtznbckwxFFim01nOA7hWED8VZq/v4sQw0b9mjbp6AYCKFQpNKiWZ6Tox4ru4ddexlbSGo1C4gSAHxKhPepl9r27o8TIxrHpfHbAc6sYQ+7g1A5d2k8jGsBNqNSm6gZoi2Rw0gMa0TjgUT/dqlfCNNk4t7OFJNNwEBIe7ZsRu27JAnEFn4AGbQ2XKbGrgy2ba7tjobMUmp+obfwoEBojHvyvjPziunoTMSnCQSzKpGGPSMkK2V+dv392+Lkv6dgrseToTxqem+KvhrcG/xZBLjnzv8F+bcdfSoVOMDCR/AeDqfzW15G5M4gHma2bZ45KO5pMUO7jLS/sbaL3tnwp3MnJDgvRu3mAqj7+dNmrrD/Sn5asul5+mO1wBQ1YNSf91yHgrfUZ6FLu+tCOJltOrTvP7smfpVq/7y42kV35+9mGqeop8evB61v3u4KtYMcBcB/7Jmhn6qXohy8Xb4B9SXHris5r378PhDnjbwfaNR4+tUMdOFfKne/XwyUUzt4fTDLPenhKv3qeKtjq8NYBqzSP/Jtrpwe+HUafn1t2LrIPR6v4od34WAOS+Th/ZnaqfG/8nQLW5kkP7vY40AbK/NTbTo8E134995LrOrvK8V3njWNklrn5vECe0xo1R1fbpfZ0UHGtiMUJEc/vnq8PvuT8jGjnrZQbh6ioUsYozcHjj94yTJT1Dklo4HMU5zV7r3jBBnY40hTi/Aa+1r1SuiIcLRfVYq6c4k/yDtS8/JenV/gISkMa6uRmcbIxLuDWCrYnuGTv+9pyTl3i5HaoFz+LTIt8gmXftBXPgt/lh9Sg+QhshitUrYghOhlLzmOEFBeibC0ZEJGkU67ht54jskQKN8kUgzwGdHSK2a9iyLsrJeA3jFNTcs9chFnyplwwZt6pX2g8xZbOpb+/p+Ice3iVTThaMIEr9GpmUQKpIEWl2cgeu7XlNzmHRK0K7ZKMVoHWhyMrnolMZLGEgDuubPgUwdbKFDvp8chuKz9QzFiTA9woqm9OOBBHbYoGBIgTTaGb0C9L35dk6e/h4e94ExoW84P3lBqez4C3TSLLKRC++Xvu7QgoaEFoCDAGmZ1kc+Mz50DB1oNLmykilII5E4Mxqv7lMibKsavn/4UZLsQFZScwj/anYpdVXa86u25b42AK++zSJn4jkgH85qrOn8+rHVT6uWhO2+7whTCK/z2VADABv4VSzB8e+rRw0jiY+2+XXJH/k6bpQJCBSHxAb617RKVYyvqOT97l2AsLEMAgxjB0X4OQiIQTd8f/o+ZHiZCcAY8TCPbyA0j/UO7t13T3acdpMCkGWGwvO+7Wsou7/0G6rwf80lp952UjujgSPHws7jYLrOgFo5cbsOHm0goVR72mTyiEHpRS0XLVKokrrHTZ6xEuJgMRcforXQ+CcD8l5vyOLQo5LVS2kJ/Uf/UtX1LnLvUId07VrUF+tM7j+cqEN0OB54+UWJQaJW14jMg3+vLTPmMO+spX1rFW1IEqicRbUkW3PvNmjKhIBdgPgdJkJMgKOw7VNpwWbqy611tvuTfZNE2UULqxLg7Qgr5Hqw73p0HFJMAdmQnMFpxSJLGkWLGn8++7OwkpYbbdAowCmuGrN7lhSKA26TSdUkiNkQ4E84siUoq3xHRKBARcU4qFTxc2cONiLUK879kRD2gBu3rg84Yzr3Y//eomRs/zSCmiRjxaOd/4jPeSzizhVpI3kKMba0FNbJfUqoCxL7NhPs7na/w6k7DSWjlkO0t2SjtTGchVB+hEfsMKxLYB5Ctx0oOAzVbp+YigaK4+jJG9o1td8uuw/QMU79lu/7UoZYnJpKg0DJTlvBwNXCajkiTzQaUOrgAvWXsh48FU6w5ysEcRc9hvQqsXJdBrBjZxTwrHcPSyA7ySRpWhv+9PN1j5zEkK4ZWDobhIgRA9NOpQTjScfw19bhci5PCZftJrghAOy31CqQJrdr6d1sAqo/aXBJNC0du0e8CgTlIFflXsfPrbIOzlim5EnTIrsuULxdVfmnVZFIillUWIKCncK7NJn2GOOXgGwDRVxepwPmjGAU81iF4SYcORrJgGij90ocZ9/pDaqaUtT6q/aayqGNsgbYpGHkS9LYthXW3yQuR5Df21VP12KGMtRByBRSG1shpkI6E6l7oRXI5jN0wyHMgMvf0XKhjxR8r/klCRr5nkFVnCZHY9CHHfO4aFfFfz3dvy1JunMAB5/gSYI0gJx3zc2cf6OgYfFJfOWEJmOSWwN2otDCdygbNyJ3xz6bgxgplH4Co3GqEbALylYYQoGsIgE1gNBgX3bqsME5/Jyy9YcJQSolNJ3pGnciGtbkMn2AHk+Y5y5WERA4bMnNXWTyEThuSxZ3ZJCzi7nfM6nv0X6JHyn1CBZCILiZg5UeKifhq/IPUo8+qTIr2UgCccCciNm5KsBGaczbk2AmLNksqVuwC+SSAjkJV2w0DiAaz5dwHrvPgsBgOD5gUOuvE2u5KzG3h58WYlmY8Zh3sTmAI7ATvYVnZx3pIkJ0UNonS/4YoUl5slcSQ4bh2KEUAA0LQhHKrWXRq3cZlBEshhchcg6Oe6NAjaabPgbtAHekxqTEsrZ4w1Llderws2t2uZdJM07JKw0TZXEPMyHziZNUEipXbgtKVIUvCvTKCjlWuU2kiMyxOSa7iX7jmaYNiEheJM6fjLjs5cxf/dr36JMa9J08kGWKx+50kXKkaeZzd8gHzP7HIwYp8y32sRftjQdOv8wos7xaW20P2lEcmzQOYBf2WKS20nDGjYYzDFPBjL2QL6DnCaVRNxH9OhJncpDZjXO1nEwWzqRN4MU0Pv3tEOcJDHBx1u7wWCxWLN7wsvVt65PiZ04pEBd2sWqVL6Rjli7RSbN6QprcSRfb0gFZgcqoHJh85FI8T1QMXes+l7dVNk7trO5RNMrSc6pZdoS7Xzt/YIZkQ+HgIt+iyjiM+aBWDkdZB4Ozqho5NtZUMBLszuwWaC0LV7QZrPemOhOERzxPgXFrXmudDlOkJ5pGrSJRsqxBmn/ukSNy/doWL6ojAve6ILmdWG1j+6cLfh+AfhTRaGvXfCcpe2lZ65GpQfpRzBMytJNSvD9KH+w1izsJ+iSWYqxkh9ZBRjmIBvCevrGzmPdRN4A5Cy3MhGesZbEH9ogk9Rj36sri4HXYJgiQ1zcuDzPT8Q0NEJcPIiv4PBtcEpagaqA4L/snybF+miQRCpoMAotsIrK6O5CFaeTySnlWIfZ3rMMjh9vs5mwp8JZJo4Lk0iNE4mVCrNmir1igNQz+rHeRb9JZcBqHN1ahtm3Y44jRaGsJH9h2oHLYt77b30JRkELiDagVYqH6ThFqb9Qq5A+ysscieUghGD4SCV2D93haPBnfO3GXKxPlaTzFrnaoiEBG805ylA3pbTNAN2yND5sjmJMM+PTs5EGOdABhYnPMi3v6uj6ho4bHan10nGamWdj7td2zyP9BaqddHY356pRBntOkl0+1PxupaH7PLIx6IGM7Z9FmeO1foqDI59k3HHc6xyAxr7fR2woHv9rhMbb1a08uRr4oN6/02psW9aVjcJXOo5efohY1T8G9odgXoVWZW/7PVWqHyay1ldl3ExPTxqjQ8yD89UsEm7muvxsnfTHvbyKV964Bqb+Q4GHee7cFNHRtrQsFaoMBr4osDZ1O++dVr2tMbetO9dZfOvfaXF+qgtJ/8f7zeo81mNrWdFRFdLmxqp3//f37WCPCln1p228Cu1Plb8kp0y/MA72+QWYmY2p1xZ+yFqTBafTUPkOxTS2ezPaXFXzGR+h8geArWfT87nur+90RD6f5rQruEReh8/fDD2Aw74iCw0Agg8iB6x6idQSj63AmObYbsG+EdmR0xK7lbKhkWhaSClE1eQacYR3Sb2KBCvgmm/IJANFU0VERzUhYFULTXU8AOQTD4MxDeh0BePX4AKXSMIEKqu5pnwwW8rZZJPiLrnj13EVKXTnMhPOjeBuhaelds45rlNlBHBGJ6dZ3flpu6Pqm8T+KSn6UlEYs8fwlq6Jy+vUgeGskWy1o69hhF7Lbh2WWyz8ei6JS2o5+bYJABBZEOtaF5hhJWfI6Jm2aW1AlIAPaUS6AYKtc3pHC40RJlUiElHl/PY5uPUlapBzm4jDqhkrpZzyayIgcpHqfIyXGXHJHkIRH/vSJNgEtQ30FS0SvIzBXvW6HRQJqCrFgjsph3kXokzfmBgQBnlDrnxZgiAwx5iDHFcL1gGqbwUS2cD5bFcIXUszgDan9JX9B4HRmRKQoP6urVSLDKn+sJCy+2q1UiHvWa5uncyLyB9qAVRJ9tH4JQUs32Mj2PB5frpTKfBp/ZbH2cQ7vl5XsELi/PM2ChsLFKozfAAh119do4vCaFSVAHCnVmkhGpv5Y3eYMvsztlSCduHSVUuOSpk9aYYH1mOopVzl+uu59DhpcIM2mM0h/u4bPw/syJYHZ/PY/129YH3urZhkR5qpNSjZ2Q8Y4cI4eo9KMlrGy1SVakOaYY/99VzQ4B/QjmYLkQn1a48BOqCqw2NQHXAAg5R0Y5oPSqyN9TsTtjLi0o958eMa1GSqHZPC6Ik8M1jRbcOwPmPeLtHVN5InyIxo7BR72hYW0hdgzMu9n4xMqUpgDZdLCr73vKzIql/Fq5wxIGuVUAqpK71/jl3ubUAb0HfC3kJWMAT3Tgj6wMO7/NgMbmlAl3LVrBgwgONPrGtGbWTREpBpaLosgKtkZhuUS0OtqSGnjfn3t5xP6mwGNXNks0A2Z8RqjfMEH/qNQkZc11QFooyDIECUYG19/wpBQHjIkt+zIIE2GSIRI2wU6av2evUhSMN8Uhu1gEe4pMEH6DUoUDWxGnDG6SlAyZ2HTUJmO6+piOOsCBGWdpb4gOkytEEioSdCXE6pZWihUiU48Uth9LmVIVXPDf1/k+pbX/1VgyjQxORmXW+IKLLODBOytuUpoGYlx1Z9dVyPX/qV3o0mPreTE0Z/drEzNWJPGLZFClBi4cmKHI1aguUf2aC6481MPUyJedjfKIHkUmMQ6cEviNrQq25+05z3TacdE0ULBKYnOwCFb3gq5PEmaPGWQy3/PYTWCzc4KudZzJGH5rqpejA16fSoWhmqZGt4XxCNLakXF3iFD+dI09OkdSBYrcQzYy+KoS5JfCmGNhsLEvS66pmvU0JkPBEzaWhTRV9Ac1nGaYu7CLRYwXDZ8klQfeIF43oYbCOnY47oD5lCbiT/Ia6QKpOJMgwMDohXUGL1ehwjQvzGAcvqwOXumvtTPWigorZgr3Rf7VJQbSl0nJWWhhdIDg1vfcBIUipsNjyJgVrYs9jzGKI392njOjCxJZQKi/EO25uwfL+qNliPh6uZcFfZCVk55ElEq4+Aa4rcFTX78QqQR/B9J3YcUzjK3AwZMN6Y3h5uw2Jh3GEJK25MUqS5ZKxCny5fAKL+bhkZQSIUGBbaw7112nzHRaCgl5Jxnu11k0xPQ8WRAoXbitFSZ3JLAFpilGW1EpmwKBXCzKNv0A2smMK/Tad2UDh7GATp57b5XmHfcFaTGy543WN0mWNoph8FDjB91fKUlmTYO8DxKqKmAMTMNmyRX+BCwHKHFU6O3ULi77RaadkJjxx1SGdKP0/jzlWDOW0JRLk966TEtkw8anp7hIgDXWqusJ7Y8eUbYgpsFZO5lgSQAJg4qsZz7szZzopSxgi66mWZZOtkojhtSLZmgIA1Kdw+uFA2mE4O5qVwJMvmUkQL4u8Gzg+PA3tRbwQJYqfrQTDZGFrXhTguQig8+vwKX+rDNXZdvuEswjshSeLJw1c/Bl4lWsDhp6sQ+tJojq645jB3wJDYCwhTk6KT2a+i7aJhIhRFZRk9LmZjWM3W8xw7CrPLRGoSM0BqRhdKEIG22kKSeQfrrQh8tgdXkrAHXCoVLfdh198mqs/Q3j9Wu2k/PIFjXjWzTocpTmUnekdO8sUP37gl4RkEtJLODR+g8mmderJYUuypSyOzWN123BdqqhYwgYNKNsfMqfGKQbhpcbNdok50QREo2u8ZliUtHy8wcNv/EqARPI21ys6R3Tulnb/H3YjNB5ikM27LkEYkn5ZkWhjqUqSq67hTE9gFvDTO+h/8D7DUbAB1nmW9Bt1DM3Mn+wEeNk5YY69LdQg2QAEB9+EXSgEsU1WHGDzFFV9cg0bcHjKyqxaDPLEMVLEueJk2G+td5S73533X+oSAW32VLINhXMkc6IcEjf5vlYMhZ96tr2zYPMGGJZiMAGj8LY8g5e8nFoLXExG/bUMHXVMSHqkJGCRwF9VCjJ/Q3RXQ96nlp9HgNCQrSouxdsS3Zc7RH1JpJebI2yDtYBd28oF4VB0dQKZIRxOArQk+SGlgle9dKN8f85ZlHGosawDlEDpLXBaY1HGQcG2U5hiGR8JZ2Ui8KYYCB6L75iIzuON6OWZpJYJQam0D7pEioTCYdinVZLaJcgHtyGpy4Lr0eGri57II1pu/6UtsYaCOj/VSDQVbqmtNasupOHTj02oNZXO3abFQ+x0zplV+l+C1AIPGJOyRyaeGMRDxqYYmD2sJi6zySIzlfpqBUvn2zt3oGl8O6ErFjtTSGjAEsXRJanaBqxzOUV+muh+mLbP78PXsFukEMUmySuigyGH+/TDoiilC2pkMXplxo77TJUY7rI6VqF88LP+/JPv0KWC0ayZWK2Z0PGPbx1HsEbBm89tMi1gesN4xxerLxyEhy6aeFw3fnPpr6VfLGPYggXxta4uDei+B+7aJ2trJrjLjnQsz3fCX3p9ArNSOv2doQV57EVxW9G0ND7V7DmtH9rlX60rq/dbPgM6KZV0v8firyoZLbl37qfhzVJn2d7x0B0WZ+r1OxYtXYReXAztfHrBTV6y0jpvyaWplBztstMwjT1B+VwMkgc0JjUr3T5tXI1/2erzsNo9GuXilSq2jGeawgg88GTu/XVeVHd+WV/Z1fgpS58ZuNLQS9me0t0z2R+p8v3emaX0JN6k9eCIPWX1j9bSe9Yk8J3WzkJ4s9MileqDMc+rF909PyDBI3uv7yVlu4H7nghDQVgrLHgDea40cWyU+ZkgVhQlIbGvvjcykRbBa398rsXaVBMGKeyF8930qiZaiuvT/uMUmd1I/N4m1FS0y0zBe1vOslkXMBmSmECYwvMtSsd3MBTByhZvvKtg82UwuTZMkZXYvwURWNXpAb5kURbHp3JWi2hN9bB7UnUsjpnF6QgxB4UoOA7Ip9WrH1UTiT59WxdaL0XcnissrFL2s/TrxrlE50kP4kuYNZ96F24iuACqWIJhXyB+yauwNpoLW1oNN5HvWHHK5HIJNg+2yyDkKozC9bIZjU3x8Yzm09JfW1ffzH/24IL9oOCbeW+5Ek14mquRVN+/Kysw7cQvzGdFcO0VeY6IbVKFSpn9pmrBzLryxF2IxWldNYW7KVXIc5mSWzLuJ07AT9KdlGu1MyIzApCIXKsSuExcaizbxu4rHrMmcbqOinunaJj8yBNIDGQyhUBasIvDKjliBmVXekJ2RdCb0lkvtVkOYlsrEE5Nak0epNYSvImxx3l+07c9P3l+e+KdxbxENkF08BATAClqTG6/ELUdIdONLmCEBcfHXazhOaP1EG7ZYsTWx6ybaEAu0+NokczbcCCR6dwKZsJe2eBL6iIQ8pPJFJKBIP3G+RjaPDdJxUqyfhKKpS3grcPZWpCiSGEHGZY8/rurbVk+WoavHE6+0nadbk5uNv6QiJbjb0xKizSrrPMTWSIfJ2Q0/72p+C+5BGaxuoExOYbSSJfPUySsAnUXCvZDf4xE4scW9srZYscA7GH+qVX0NjLTmUJSuUN00yDSR1rtzM9aWRpECRpwnuqGtgvcaqa+Ucs2CEyIpPfVrz6nvP9CJUEiUwB/xuVo7PjNVGNgAv5he+B/wXzkd8VGjSfsXLC0zKpod7YyucBm88C8ZclE3OxAgihCDOErk79sRh3hmA2FOPbz+Q5BD+1X1jsXuSkZjSKJrqlRYHELpUnPQO0V2TWseYkzlbg9Z0ciAlw/auLA0hTgk+iXdWkIQkqQTmS5GZxC6/rvKCiZBbjrRb8UDQf2yXbKttBrCqWKvqpRnn8y6yHJtJbA2lKJdlBvLrMrMc2uo7edtK5cRhTcQ+sgyeNMH3NCPrp0plIIiX5yk8oQXrIA+A2iBv4/Pqz87zXPuP5p3kLtd6x7k0LcIF8FURrxuEJkb5CGQyPyBbkqs3R+xvBHnKaijQu7SB+xMAOgrDatT9zuAOVHI9lQSSKlDonFgVRPGDzXKuotOrFPhAnqiyOkogOYHtkVsaBySyFggH0K8dmBS+YniaTu40cX/DMy05c7MWw0BXV+9S9W7YCFsNyYssDq/T2j1ezhCS1aUjHe9JWGKtiufBSX/rGhjMCPbSFFzfeUtHhoT+ftr8+JZvvaCnMejVG7Gzr3SkGu889ytq/Y7ed19VI2saz+Zp2waKtUl6sVUi0DdLMwVpbaiuKrWYxCbFpIoh3VqnUpGWew7+HTrJSitHErwTWo2zSf2tnV0LpCj/4JI8ltbZeJxc8Gfdx0Zv1v4vVLechuZ9vpftbo44pouBM3e2HJDA3/7n9g0TTbtFsGxi6p6oASATFAq2vghJstbALo7O9wYLv4LoxuaTv++gRhGyGAVZ9joWIBp6vepqN+Uq0I5QY3wTMEmrJHMCjYs2s1qjDIojLwEgawMtgjQESNcglyKuvPVv7XQcQFh1CPCYd3Gqug+uLTya4HK9WwO4kcGWsKOxBywUeyQYpjSmz/poFQLrcTxZBeyddRUjlSQo9+TX56GhZWp82mhsWBTx4vZwalIk0voQUrv1zc2ua2N+33AjJ7ozGu1+d+Q6bDQq0PNAs6ih8LXimUPd1BhOE0d5jiUgE3RTRRIdjFSIN2qwWOnZ5C1DGRNIHDA3DMMS/Ccd9S0kOlqGfAhID20NqtE32xmpc6WYDf60mKH61rZgQaP0qsNUNcjrUeJBrrbP+GqKhNP2FYN0/tyIEvWC4ezAtoDlBa/mhygqTq8g+mxHLSy8pk1CM04Xyn2XpCLzjAKxm7UnCYuxHLtZ+ZDcy4YP2g46oBaOBDrfz41unw5LJPjAdR65Hcd/a7fHfTc/IMkIFsDHTkRJQzkNyCJhUsSEFnO1+6IBHimb40NzBPnJ7onlIIOve8hsSw63x69T5hHKVZI7W7A294y5nsBrcirT2/Ie4dVOgcZpE4PlPOsBAfWS3boGoLYnCGuOAVIhk4sMFKAvHeniq5BOD1RDVAyG2Dghcj6rpU3vI1MDtz7GxMy6kcieJwc03rVTqvC65nivdsTxldTDojJn5BWIm3WPjpu0UQdFkiEsVxoCXSHINOVh61vLXxYJQvK6wfVvuuHlBQeIS/KAbO4VinUkTL3vCx/C7zKKg810YsGN9Ty3YTIgNSwNeGSRwnmOybVeiIGb+pQfLwVmY5U0yjV8jWM3CKrqxS53LWfbEb/EFzraBJZmMALCfjVyw4cUt7j/M3WDQ6jioOi7PrZCGvA+Fqy4mnTZshH3TOyObBSolSi88PIWPjsUkQSV6fn2GcGETxyIi51UITHgbHxWFSQ+98hegfQCmxHhBEgSgrEOy32/XupDeflHjPizrH2TKm4WSRP9BVdsKKsXhoeJ83LtzlBSOS/4VB6FEBcj+YX3pJSGGFc+/RU6phZ1cjDzKV/yC8zQy/JYEKQsmH0Ij33XO+Al8vJLwsBSjArBtGwsmtkbED64e3bDyGK/onrcT0SBJxiyMzYUf8QvAi/tT13jt0B9qgVlx8jTs3C0oVk42RI9gEmYnNAbjT1t2By5WTxaTC3z7jRD6akn7s+iqiVKbYt1serj93Js0oA3HxuFZoKeiQwz+OhNxxr7n/21MgGrOzAaxJfFrYuIspFMKm0U5b1OZf/npx+w2x1d4qFXTguBzjo7WbUAYtO8L+B6SqOJbuYrrbXbUvg5yyVF0fMqoEuXGvqeeD8q7BRIXcObr1J7Uo+KkJNE3P1q76deGVD/xIcczvJ5ewrf3XVN6smywg66fMPgjKo9q+U+k16ttv31+UXW00rbi0FZ1Z7aUAP+/PTUM0VAzdUgaau2AarLklqbm5fQrYwEaz+o2d281J5w+g1aQ21eKj+VSteV0zg87yDPyK8OvW8xeajLiz4/s9NMza/DtIokA8D+svNe80StWQvHbMfKWavMm0D5XZs48Xx6vlYNNBlV7uChwMVvXm5UnR+C4EqfhJpY9S3z3oddJI62s7H20BTNWSVwsHHw0DiI87TBxD4lXcIqYcKwd9kxaC6ooFZiZc8aboOLvdz0XdBEXB6RcOAety9zEzhJ9pRqaSz6Uw5EJz8R+LI+hhH3kx0DShNZ7MO9k7WeBEoZ2DXVcdNcIcJiwxnThKVo3WAQF/KgyMTrJ6gNtwEYtpRn/7zBBLMqUvdzsa/lkIAL7xkWUAAI0Q+BU6In/BzFGuHqDtqEocYuYz+AZ5rBypFtH2t/8jCKM3iglxX4T9kx6hWtE1n45IiMKG9QkM9v3Ks9UX30qseZ4rgp9prqLax+reL+pNzqYo79BeLBof9YjJEAaJLz/sID7s2MNnhJLoeif4NUcC2idIWWMRbdcYy3Mw7cTBg03BsgDVd3oWAY+eE9qJ47+dAaMBtAvJUYhgiCAbJDr+w2emdHfYW3dKTytyUMJahJv/LRq7SGEWiHFjTHjRcn0+sLSEwViUe3mX/nXXisauwjziD0pWAKnSUtu0rrGzB6MbqzK3qmsdJf5I/7cRpjhO+Qbww4H0CSvnAEMolSCaFoPUDh2fl03NMpojHNjp5+JSFi2M3IVHrUDQ/EKt3P1E1FzimRjcnxQCoEDpE8aLTwy5ufiNCCt8ofcVudBz8WsowIzQvTu8u43CjwEBexxLZQb9d9oDQhm3eOh0YTF+QE7CNBqyimSWf4Npty4HIbfpcDSAuL4LOBNwaaR+UDVjCZqtdJptnt1OcFSZKFQegOS2jfuGOHcYdHvzYmTjtSqqg1bKPjr7zrTIjvwX5VRYO3K6np527faFjobJeCivfusQ9SVg8qlR/Reg+gM0cD1/oj/a2wooXDbp8ci5ytu9N51tgKyANJRhMhCVfzC3EKQS641VGEtrAOahcey6oCPf+PHx+reV9dFPiE86kXYN4tXiHFwS16EqLSMUvmSuUoUxQzTuP1srh1MTydKIRSztoRZjZjlsovxD6F8ob861qLySN8m+gq0wlRzSFG9Ku8NuiazxG9IXu+YpSrq4XV3JABIz1jm1uBA2xrp+FepynlNz3xmGmjaMSClgvIORJphdX+lctkB5ktRzROJdswykwhJj4LUhc8cAQkYiukS+vFyLQcjt2pus7+If1CKqw8Lqx3ZYoYU8mL+QEvm3HjkAIRH/PEuseB4qRgNhGVbCR54Jhltj/SN2WKYG6NQ7X0bT93Qle+cfbuCZXwZSs8kg7eqG82sj5jD3oInypDYhCm2+Kx6Lf+2Gnmug91FAN7JB3mOUfLkjDOYXPkiGNDNXcMbUfSQR85gLelBA+O2LnZ59iwSDpDZ8vhsw50fXpMR/ZanKBRblHGstOtwEU/MhMuTTB0a011PLC1pZtnpOp5Fr0LPmzmOBI8u9aqgi8lnG8k2WGHq45nDiAD7ei61Y/kIZ60pWNV9YZDWgT5g1ntRZQUcCorJH9/Cmc8XJFwDEjnWXfECCW507RhIQ4X1R1pH6ebO92iuf5TTkYMlpyMaedOTkbICIYjOc9GQUoP+bHzLVoXZVXbXaZyC9zR1UzjConQguk0xNrnKGa4BW3r87bBZMFFqPw5cFaXsYj3ooPFSwnssWen8m9da5vy5xyFvt0yZ71erd0htb1bXR1vlLrawywPqynXDf+tteo039PCTqzAPP+frTvbbWVJsjS83//FGoU8Q2ahgEJV5Zm2JEqUqC3mRd/3b/ZJ3n3RAEGFghE+u9u0zKzvPmJ9471YbMa5bZcd2t1a6QGBkPDaoV6pcIHTHWnNKBCOuA+hSa0qmnQcetWlIN1D94d5kpuEzqKj1DhvVog3IZwjdt3H2vYuBGy97t9GmG8InpgmEjWgfjPxxjnm/USh4adJJUZiizLIG48CNnrK4VzTSOLAMNw2FcpTw34qBqm0MNg3kbv4kUkuwoZICcZDiE9mRxS/FMmfZDRFQX6s3T4JWQqulz35ZVcXgqI+5z8OCA+PAeW4vTVJMxlcZClmGTGpwiM6FRuZwLRR6IN/LJEdNCbLjKRFq4mmTpxogJWJdbCscdldt85ymV8D0W3zXEw5pEs45uT//pWyC5LMum91HuRq92sY+RQ6lHFGUCeZ69sScilWJieOCVwAurM278UsDS/YTeHH2arprpRZO592A8By1d+WGpha7eEEIMETYDFsO3gBNKlxRuwk7BSygZgMxwuPWoN7no7eImk8a1Vlmi+MOF9FZHFOLPFeBLMH2WPT4LBqzbE0L1c02jZbqsNfa4DZxReFLl8zu4SUMg2PRYygp/MtSlx5n+bPUV9dkK/RbySSvxFujC5DuMcKIY3ztqUsFb2jpdO3Zcp4LHQqsiLYkEBCUhrpC+hOhAMB6sCT0tcawoBf1xYkdqjINj3GtFxRnUn1BemkFD3a6mUJZl8xWTqq2xV1oe8RQt+HLsuvLqFB36TCZbrvXSDQ9K4C3Qpgvg74MINJoE+UqwIO8Cxi13LSnAwg4oXSnmN1JLMkAxpPc9SHjQ4FpCrvLU62tDw9fMpHOkcqRDU5wr6ujUlgSOl3ZYmVNqOPPcT819kgzJBwU3XJMU7Oumzc80ODHLnZE+y56AeP+LQy8GK2giPwNeGCq/g6hM2mAUNbt/GWO1QCI/RZcCu6x6Nw2/9g4RHRBemphBYl6D2bxsvGAq0o/p/JXx0hnCww+I69JbLCAuB2W5o1elYGI0T/yjjK1btPo0E/MkT2dRDJlPusWwLB8brb/Mr/gmLtGENbu+bY3ZO9u8LmKPOETwYe5MmT7q2bgqPy7U5yQmQE3ax8S0EUePNL+RQXBQYX29MR0H3gKnqvypVNiIJKhEj6sE7l0ivXDHhGRyAGCwprFtbTasYHoL0B2VsulRipyi6advWyocDHeLdZSamtVzv/+vvTpevIZYQcwrpnen210h/FKhHJpF9DonZip9wX0j3GtTgnU9ooed+VVsl+3dgp71PdpnLtJ/DwDrHIa6tqdNx30PL7/pSW76OLbk7O1Y2XUujs6n3aTtV4KUYrrTb3mFSunyFZFuTenVGIj71hkFVVpz0V2xH4JL78y5t3R9e/OvSviDRzv3pDJ3cfQrw+sjcsL/JRXauUH+tN5TdKjVj1sg30riaNVr0Wbuibrnv+Bdg8xH0Xl8tG1Gm1fWz5KfzSic+UNTLfN/B95XddmT3ZLqxeKVKPhaCPfKqDXl8DRlWIrhPyqUnvSVF9sqz0r/g5w1+u9YUrQ0U1gykjN87PPN+dvqWWjUgNj/V4mdCDIp7Rkr8sQEVOutajIDPt8s6PYI19ODFfVyPvBKJlkGWJfwvjKOzbZfTO4lhK/zcOBZXZPpPHRqjqXkdKepd0EzIEqUIZUcy/nh4xtr1YMxCjIT3Aa8uwR1m6huilYJtmf0WT4snOwx2Zg5JjsxNkkVpB6nkBxjs5YD6rmpO7zKUMjg/PfGw6bADY34WL2XPo9USMUZQqZIgF1/GuJjUsHBIZJChXyQSUq+LBKifrp+s+otBoQK/PibU2U5FO6cBuMF4LRq+/jZsMid4Vi4Dg0qnRv903+xzOPjRgU2WhRXA4jbkMU/Jq/fzb87e/Hv+i1psRvAnv+SFIRqt4+fFhC8RUkdBGbpxN3duTc3+d0SZuLA+hluDgk6xRphUctCi8qyORHEosTUGCcfqSfjPUgGSIECETbPfb0PL9iX3aNYGFOqp6hbXhEFH7BVhbJv0G20RKbbnPzYr9ioyQVCjVKoRnne3dHkiaa0BqVWWKMoJcRp74nEXCOuF6F3TEJFVmLQR3aenUzu5YiCKRMPL0DC3Xjq2wC9Mkwdb4M4KLCS4nqFrXVF98EnlbCIDbr71bUcaq8oU97/O2kTWmrtXvdHYKQHySVIpEUn+7bjReGmcYyS0ETA14bmKfrs5WWmROlBVOwfvzb0/frCpxiGprv7XiNivfZAUGjGnRbOmxV9Mg49uRWx2YMFml4cJIQ1Eoqrw+B+0pYVAfbvI93zrDHwAi1zhJ2HDuWoX50/8uHlfYbuA4IPQ8Jj2/PBnh+ZfOdH52uL7MnqkiShDtb2VXKb4HcPmvgqKv/E/TkR6Ek8XyPWOhn/22yALa0TprdikUKjmXeWYGMJiG3rxe+rsrI3OtZ6gMu1nbnBwiIvXNmaLrlaCHLPYYJZalYzObNXm7e75vv+5xfhPSIhra3Akcj6M94b5r+QTrXi9LtlErZm0Ds+WybwKQia/UNcmMFinSbBXSAaWNQ7sgcn/NCH1tzLfdog7XK+oZEWNE3VwG8KTJfCdCRxUgRnaIO9Xo9UcA6a2OaEc6bapIYv1r4V6gghYjKzxG9x22vKirpRd7hX0NqXrciQduYfLjndHDbHCcGui4QUMpePjaN3kHjdk1Yudb+IlXWccmX9zFLu/J3u2zUV9eEKM+SJVgDZwguOe3FiFetHnUXTsl9WhLbinPi/Si9YVa67X9uj48FgfIq5bQVMGr1QYFQuDwAYl/5Xnr+W7WeHrUblavkwwgB5XsGS4tKbEFSGZBqorWGV1rzEwsoBHmxFE5Npi0yL0rdDm58ihBSPe//PbyreXp0MZtKEK0+JhWgvEi+24i6PEr38ruUu42kebyZKC4rQ+qWD/APbzCb9s30QC7iUiTSo7HRK90ngkK3VP4sL6T+L7qulFsIoVGmZa/+zihrvnjc5TbONCxkvPrUvmRh4ymfIsUkg8b14WOtPI5Pki12oCmOaQM495Nq1JpyKKIX7X5KD/FAkUQ4pO6L75o60ze4S54xEPiI7tc7MVI7hkntLX7hYm4i5vKHaOgbY0Dl/z2NiLu3e5Xb3Pkule61ubWN2K32v8OpxccwuyK3cwf+2vtQebezVQVyZHenhkNBbI4JTSJjnYhn37655LCy/p9A4eAZT5vZnMRVMj8NObXNUkSWROLaERjA08EFVFfa1yihLg5Dvnmo2vhzrrGRVXOCZLGkcYGykxxHE5a9yIXcIio6f0KpSlgGgU6fUFUL6JTLWAUxuvS9xe2vUWJTQFBEVdCrlvkzJRULP5dbBnZDHvXXFYmO2Ml1DskifFEnNyjzAPXkbsVF9K3HPFiGFUvBWl9we0NtGZXXjUKZjm49V0ZjoeX2RszAghfy87E9xH2aEEW07upcc887RROQnCKRkbqXnak2qz8+tUY7pNk0ret9JNFI3DcllOUHkYeV7tLdtIYkq5//u0SgnRmCK8gUCdo1EpJg6Kk+BInzn1iRceijO0dm0KUiNRL48UOBZ5asf3nmZcF+0YowR1XA46ufSCywLhDSla3fpyVAWzYztAgpArV4//EyXalJI6EH2BMGBRJgVnrnEar8BwyJC/6798fkBKrjXkO3R/C0YgvHQSq6QJufWnTaFi6ZuA6ZXbfeJ5zlAVCeO1Im3cjhXKhEzCxJXDxS9FUMUutZ7ShMutRD0Ts5v7yWKKJeLEWqld79KslS9S9L8d94DpdCyKna6am087u6idTHwRIRvvaI6m7MPGIPpWvtTQ8VqvPUdnxSDEYi1fFrN99Q7ol8VUinb1I/zUZakDgJf6D1kGFkAoJg9IkMZ6fLA8dP3LWv6+kCajDOtHCqkZnMowbZ4faQBptW3CFFYbaAuJYLP0ugtUIIqCkwiExK3LDzLxLpCPXeq8s93ZgLU1DJJJHWj0iMzaXbQMqiQNrATKOjJLIerdnKtDxJk1B9R6HiEpm1pRpou+UIMjcITcyGEgglXaKTFP5jqU+/coSFQfWzV4XfUTWcRN82SSMIp2yjVolEjzpb9c8ODjTUlBzihklyHR/yq9TNFBWf0fm8JS7/ZC7Om40BBv7x5/LvPP7+8zAvm/y5WgKhdLiJcHLbG2Lc4zRVN22PspfmgURFqqY32PX0AdCupM9n748Frnhdx956locOrCWFbCxXxNBBQKiJduvxogt1jlXy9sPQVAoEeSFB8VZ4j6HP28Z5KwVY1h78sBXDsvY8+CBJEfkTGg/Cn1OODyxSJSMoSArfXeTU0akpHcrH5tBU8BKjaUbMjoSz7X7frXH7JC2GeeLFha/7cdlzxebOgmCuyZpOinxQxXLRqle5FXt5r6i4mWx59gDGP8fe3DwsrS4zW+FOynqVw9nV5UZv19FwRCyCqmdZOMPqwiuZx2qXaRSWz31ABvCj3MNTlM6n4Wxj64ZjHpTmPZ5GQ31hHFfAPXAfxftPljsp0+d7JzIAr73fDU+bZRzOv0O5K7h0Ku9myHE24h9quvh+VohIqik9aphIbU3I+uUAHTfWQIh3rvd6bFt6jDUXfdd8/qO4pRhtXenm7dJ9qgE6uO1IrzCrT9cpy4ZUEXg6X4o/h5bYlrX7t2puq4bt5r6x9OlOwLXpBBP29Iz3e/5Cvzt+0M/9Xp3XFQyQ0XP//H41MNdVGAPKMcIXLfNMziT1fJSyTkhRrKrt18bjd++f28M3e9f4H2Vtj/T6VdULayuLvrA3Tfm9at4QbVk6722UUS9jyGdZk9ukelmDehdAy4N72VtDFK5PmzEHmumkn0avV9KNp7OQ2C0+y7569rYZS6RAh8Cmks/UyCbIGiy84kLEdhdjFRLuwXEsR/wpjss5Dju+kCVXBlVYQPhk9ou2aGcEwuy1gCe03MisujR1lRmN8/xbvcfh3SQw0/yv9w9ZSOOjcoHCVZd71YyoJUIelET8mMn0FE21gtRYkhSqFgKQ6w3uaxv+5jUSZLtX90kTWOJwGZ6GKmiNAbFIQkyQkdA83JDLld3GkWoipcWTXVR5pEKHUKijrXU+iaR9C5yXHuYDdr/B+FOc+bgoXxu0UcWkTltloRCELaHVa6OlLZat35a2WgSWnWq/fvj+7fR2SxzWltR60iAsc7e1BEq7mhPh8aE5LyOn/Q4U0iaigGsGpgCsNLZ8fSfC++k7sIbrgPjxiFm+mh85bp5mzYImu1YPlFuQDX4HD+97tJfaz92BBllyR4rGzZlHlad5I5CRd6QOXoERLBOUZamEsSQOdKxgCPtAtKsS7ujnln6JBAAxY7kkRD7JklpCemMdtsdxI5ik4TVHbFrkfXdG7OIhbDrGWoIEzSf5cZsJE7hRzruWwlz/TGNsdYpPoABcVRSVr1s2BKxOWuDtq1rP6TaC1gYyHXvgpuLBtgrbBhtYMYbYIdf/3qdDKtMDc1TFfRQ24hhrhV98rpitjhizyEhWOC2UuB/UBbJbd4WyCsigKgsMR/0ScNadfN+EuyOUN2HZCfQqKSSkhVyBOBYYSlsTrLJ26NG+k8ALPavjeEphsIwoVwbmFDYzhwbXRxVMjsd0Z0PcTNB42rlVVS0hvayPSC1E5zxwl0mjwseaFTKi1AAUCFgNv2kJ2mtuyDxUWlG2romzVURaOtxLaQg7U7TSQfbMxT3XTzsfLEbcsFQgsz7vdu/FBCSHmIi629DxDYKX2n3knZ9xK4mPAFSB8uhCDVHLGO9aB5psOii//H9NgpSCj12H9m/4MJegXFPHIjForS5+Z22dCoL2P66EWBkRiQqx3KdpEXibZIaWkOVE4HhvjxGqzVFVQJnAQ4CvSgUTNND6vw8pTZQ7HENdTwQ4xedXTq/UW/ulLwKhU1KRfKI0CwnFEuOepGeq5etkH5ySdgr1Nem4K7SKZlrvG3duxx7Wu7IGY6ezeSFEu59To5qdE44FI159YrdwHhi+klnlc9tuncPSWXbue7RRRHau4DONxRwlWSk4BpWm0mpg4BdkM/jSnnalpKzAm3gWpWqCEnt3W2qjA13hm39rWHINJjnSSFLB9k1BNuvGaG3EVe8PcmOpYWDgJDz5hU8qEOvNVGVVQyKKquiwNri0sjBB9cldDuTOI9yuAlyviijwFhdOzxaTevcwSdx8A58Jfh6MLta3w2ldWA/iN2w8z0SZc/IrNEHGYp81xJuCMiNuJ2XNetGsFjBGfv6kBbJYszbrS02SvepvCkqu1+Z0NiUZyluKhDROfZN0hNlptBqtbn1hD+zKyjKHXLZKJFyBpLaQIlqbdWqykQKt8HDCLq+L0/ZYtVCF0gqoC8wZiMg3T9AWyNTO0+UG5SEirhxE/KJmtqOla2jRVn51NSRvr/999M3ONQhE7gcg3J7FzGmGZUDV9Jv8b5oRAfBs5u+BQEOSi+MfETseoUGFZiTA5nUqV+5ZXBgd0klN425iDFI8CdaRqa8roFra9kWNSBPw0c3xn/QTpqHl5nl2DiozkVJtMAFg+QE4dM1+hihbNtQ9NHBMgtalA007R81prPnYGBi7aEk3KSHpIDF69CWNSbutCbQrJeViJFFXIE4wpNq9MskTydZyZCYgte3KHF+rHBMnAcNCwgf845qI5d9pBqtYQ1IjL+HOZUg62rpu9GQdsQxKfE9J44uOvshHXCcEoJeF0xbyf/+19s30YK45EJl9ahZlBKDEwgPme1/8zlHcV2iMZIvBDO7ap5gk2OE7uieiZHrdl0Ce4ANIYm0UwTyk6eUIPeiGILMkgO6w4kD6obadlC/m/8dbEbeQIjqdjBVTe1Jj3oCONGxLVptGgx2TImKEIxJdLGszYdA2Q6zyu/5epFSg50Ypmj68hWzalOefKYhanApRSsBxEVWQf5bnDuoEyljKxOvs/HWhgRXLwUYXhj6lDT3CdhaTSlpundrAEXuvjJVw6PuQpkxmVbtXCDxlJyVAAd2lFs2BntiN1uUqceWLX6HXweV5hXXaMCBkVI7saoRSrtn/h7zfltkHBnbvtlZHKAqs0wWYgG6+dC1aKpp7Oo7eZKznzxp3ZcrK1IIlg7nz0o11y3CjQUKwC89EB9rky2zVKQQ5RaU/P4Vlkl6ILFWwHUIYq77jthx6bGwuiNcAPnjcU7ZTYmzfawubAT3diHEiU49030mS2zTCcdNxbpK2pmkdSVF3H9g3Uis1ShcICmYVwIemY9k724k3FvSKHbq/1WBglVRgXbdnXrGLYV4gZQzrVAucGoVSJYGh31zO/JB9hdzteepQOuvCPIMCXCX0F2/L/fGzksgbZR6UWC93sUIkhaR4NoDdPm3/3n8FkGhMugDcXAigyeGUpdzPaPf6jG7oQMc29hqbRyHkuKouFn+mKOuwtn76l7nClzoujuO7h6RldEUzyii8Ov66FlPXA94CPqkQeGOLB21OJnSIUNGVD7DNrQn5rQ+wnHDUlbL0vflaZjDVscrNTKESZ3CZrHNxSYLeiYPD0HJ7r+uvQ+0AbyWsCxilrgPeADQIG2rECcQSZbsCSwqJ8WKQaPgRTQdq/3U6eK0rq5OnX5CvJLaKO36oAydOrU2uFELFOAWNScyp9vs+rrdPxQQcWy+ZM8nWYMz7QK6c+JI3uQXKYMGPQXpO9vg3/774duDfJ6jjZ3UxBNWesboXuzDVuz3wXqPyNP9x2SQcO7LE8QVlge1bxrznn9arW7fUd/VyXaA/7huItCHzsiNHg5g3ivpPa5A5bePldTeIbJ7sYvnBbBvGJzJ70r73x3JS1cDfu+ieiskKjOqaslUA8VfR2Wcyr47kwr1Rlcu9M1bPYrrrD3RYnaCJlWclp5Je56SrP6GM+6o790Godebuu5DxNOM13HRYzoSGrr5vrzUl37qleMW0LeWh7Xv4Xl39Phz+DWejYzcqtkhut8gXLYlcO5VIcrNZZoxWvjuUKPTjPd8LU+n35j3fD/V5nl+M5Br52U72L/anM2qi2qv741DPg29KNGrMPRT5urfK782V/K8m45+ofp96rWOP7K+ePg2Vgq6/srp4Z/SvDOUAr0IwTBUk0UvlcFmV2dTi7H1JN1EVQqhSTJCMtqpcCOZRypHvpfIKJ2CDBcyU3Ce7Hn5WsXqlOKsHp4QFzzPRNGUbKzOw31Lnshe6+gSFls0VHfAD2sYT+5mQsRsUqpMDR1+NGS9yyE9UtXuxDIeu+xae24kpiP9NVDIpdytN/lkVgShvO2O6MXClgDpExe42fRvs9g11/in5bsjfD3DD6B6DSlydj+1r6zd3JNSKWDnOFmjOEattUu3ItQ+W6Ryer7dQorn81j7xT6FAwOZRDQjguBcJN959zrpqwSv69+eYQWWeOvf/uv7t+9PD4IsVrcsOoS1lQtGYSP6I80sc2xHblVS3EntQrIQDhp1eFrkE4c+CFJaruuEWy3nIP3HgA/BRHtSSpXud+RQlGOtePF2nzW0LbuMEfjyCDjiKClH7AZu0JWwHMkddHHwUitgi+fpDvcBuZkgvRh8uO/x/edpSAcGjgI8Yzo30N54p+hg7+Io7rsNeNL2KzUjxQEHBNuj9ST8eDcTxqXr5aFaLYB+XVyWX3RfTLkuJBTmSIhaeaVvprPIEdLZgJAiqT9MVtk6ag+mm/ITjWYGaGFhvNBrIv8RkwWEmpsriBjPWCD1/iOpMDnCO9QEgPqc6dqFnCel67Qw8RChjzrx2J7W4DDMCuQrA3v7rG4QmhbZDML1Pstu2eRZr9L9gLu8jdENdV9pdFYz49RefABij1Jq0ae1h3XF+XqsApE53PrskI0rIdaKwBMCtlYsO92wYjOvozSSr/CEyqUYM2Sj21uO5LrAN9g9kposGMLXVqzjTcJY2FdxADqRCCjdnE2/mh1KO8FXSNNPO4aQmRuaG2WY0FnEApKm+47PSE93KDyBf0h/y9dOHDZBA2m/QLjYSSu/OcKts4J04cWdU3nmX8AeLT6GrNY9D2z2rjpbl7uwXiE6f/rn4zeMvSOud2jx9+kBI/SQpEsVSj4/zggdhqAp3GB27l+YSsTVFExMaEZm0RMgpGkUT4b2fOKYLUJ1TdojUc4OFtb2a5VQ1kG1c3Vnz1ntwBx15rKhHIv1+srKISBSiujcsUFTIBRQxe4KG6ThmsNiZVgtRz6CbPa9VvZ65PSi1GYvrxxxdWOnIGar17HX/VpYaZ2gGz3rU1Wt8Gqndm6LZpNl9xQUDmTI+hB+nJ6vMdFH0CZaj0ghpQ9EK1clbAnF7Ehqa1pgS6aAZRtte8MiCzhgZsWkkLLK2jh5aP//NtkGgd1sbbJmedAN1dT8VQ3tJccEh2oU+rqEfA8GUPlRzDQ6bEld03kgJRICKDpWLo7hxBObKj3wGc1XiqyhXydsdfcV6LSTEV6iaLYtUiQEafeBr7tPBUDz2SkLR0Xv0oQJOCZ/H1J4eXnhNSRyCzVHZX5fUsjGR/am3dX+SD8pqQ8jKaXiKgknEOMJiyrFLTlX20RzjcLHlwiCRdoSmSfPT+RVaueusSLtSQpSCWAEr+KcKDgbJw60CTfCV/FgXOsRXWtFifzG6tzDvCyX3H8gVkKUE4ph17qJRFbglxR8JOKR9HE4TmWBnK/72GDe4/1BQfjh6zD0ZhV337brJ/nZZJ/vmRxHKRgrFA8IQ8Jm0qJka+uZaa4MDjt/0ngI98BVDVqjyWAFS2bhQm7rU+K1TZsPwOX7GGGGeDHdQEhCRSbjyPLAU426RBimqGqyGGRi16gkE6dUP/IVgtAIH/exaYXlS0oiBgvBl8g6UR8ZpiKUtVloLoHsBIJzJEsbyQHmssIK88hs1JVDAyBCrhKPqq6+ZNdDCgUU5lwKxhMtw37gdXqX/yMtOSRjVbewjD9Wx/zO6O0YdmJRIXUfiWw0kKMt53MchK/h2lmZIwwtQCF2xby34SWDmYlYAP6vvz9/6zXYxW71KKttFSwU5A3ZrvoaxG44TMZG73SuwOKIP15zjx9fC2tZ3dHmU8pZZNTcf14uFKScaHu+4e5soNxPayC+DdgMdAO5df0HJUSZiFnG4rrgafCpWgXXWo3EDv6Mcnsk93VTpnUBkqhnWOZbHI0RmQtHwnWbrBCBZo4E9qrN9UWrWAuOUzjIgCRKxx4gGupkJt/xlNXisvbZlo5YPaIUsd8xNtdf5u1YTDb7GqYi43mUuh878dKtVT7nq0hhS9Bur2RKbD6J3CVIfLgr/cJyUYFysuhOJciaIUpepfEpx9s0a80FD1P29V+DJgvZ2DdnatSh/uP8ZYz5og5StHGmGHhhdxzalQW24VR8W0a4Vjq3AcDZs0hSSSuyJDTuVYq0wQnFSchH+rGgCZUywFGKtgttPt4ffWwszWhx1ACpdT4zhH3l0hFCvOfpe4VapO4bW+emo638I4L0PNLMCT0+ybIASERrOBpsFq6BEkFEUiP3LpfJnmwkNRhlMID1VJAWBi7axX6qXg/D8ldvN6X+Ei7mvnGmDEunrOjc9Kus0ZWGnCGUmOtKqKkYUPROCCR610ie6CnelYnDqdGd9t6eHUTvofgSF0hjgSvoYe384EyBl2y9Vy5FAxvZGNI3TBljoriU9Y2VflErQ0CbexqHeZ6zazO7mHc01Kz3JEmKTWrOQjbalarQ0K73mRuHp3h/sRhBa0YqHEhxmr25TwnOhZpkyviPtW8lQcKIOTN2RoXcBg8u+LFA+zJiyFFbyyKgXCcqE6MpQTD3L1nvZU50tDRuovW3VeQorHxwHUTfuPUrW3i/9go7I5hKVbc4ZK5nX5LDsXGG9+o8A+/pmdUyXLkL4IxTWiICJ3P98WdcGeWD+4YzPibPaUcy6N2qoKDipym4l1zujfIXqmKGrhFgV3WURJsm7P6amOR0tXhkcvw5HivxQ7pRcO8klIVjb9jMATiPqExPvVrdWZZl0Ov5NMhNmOgxPbC5N1+l4hzY+KyydzrZxxf5QrPkXPsetPVlNM6f4PTV8nfStAnEc6/enumB69ZYLRrZdasqpHaHJaB3pK3H3I/4Vn4lt8VrVUWNJaBmryK+5+ORL6mMN3ZKoybC+7TKnduH+CqRvIrSZmMy5UwVbzD11V40nl4XDb8Xx6IA0X+doauEiZC+W6cWis3SM+nJqjFeTRj30X1vgJrfH0WJaRDe+tTyetT9FOXGuYeFnu8+A8PbDsifdfnWBC25ND5p0l9Hs28Ge6CRYQ5R6erNb7Whhv1xuQiz0zefgPl1+3XZWENC1Y89Zvv7sHNUF7p/meA5E1lI2Jwd4ca5qp8q/3/955/fIGGYipif2IyoE2mAIiiwBtTZxAGwCjAsqd7tG0JKqMjODNeAyy3qVa6OpFk7uk9XJDqo5E2MetXLPCyXZN+y8sPmY+2rEdZesBBSiSwP7U7Zjvgw+rXSlmDdECyxoKSjAs5Zh+CBYvc81bwBoYOtDXRvlLSik9H9LiM4St06KKh1Hae770UO2dmIYFlrP/maERNT3NzD2Cz5/kxuDYYAuGwYe5g6VxgLJj8+Sw7RSKQ4CRSkXbQUSHwUkLiFE0O1kuu+wv1qnFlvG19B6upgH8G3CSgSjsJ+1hiKgrf9kGpH8/54KYuuPBZK/2ANGMHkX8AFlH5iHkMozDpoejfDLE3uzOtR0HFMEFhsFXfRfqCAofSVTxO9aJxpjTx3culM7e/UaYJmP4OaLKpiqPacUouIF1IHpwmJ1nVyXyUfVyfZgXqLGql6T8zM1d1POQILVtdjJW88HKGzxWNehO1zJR8UKF9IAQf6yMeeurA72AAqEvzohmmMjg+VEbigksmMOP36AjYTxdevrtEgmnrJ/V5WcW2HnKz9GzCyeeCofaXA5KFPOpuAXhuagRWOwvNdBMoFEVFw2CEVzmCPo2qrnPig8j+yd5F+WtANez9ROAs/fpEqi1TYGI1guEp2er8riFUy1KaVM0Zc6UFzhASu0UmRMv2B7rM6AWxI/lY/P3ZGW9pmmmKQiz1IRvUKh78MijD/13pIwKZ60edUyQubmUXTtcz1ViettwwRslRCrsomV+HQp/X+ZLWABpEPUV7nFhaJiWQkempnT9/V1eLg1tw4tEcrlpWp55MxW7JTzkL7j8S3XnirIr4PY3c2D6SQTPc9DNiotc+by4mkVr8WDjTTzF2gD2FLHkayuUyO+Kr2uRAdpLxoYvetM/oOMq+o9xFxoRJJ6wKqS6jWd0tHUELf4pGCOTV6UcOuERP5s+Uqs9zHpENh2Df7l/VBI7fH3Z1vEDazl7sDQtMtUWIctgfl2DUlJ8kIWkYyI9I7S2JLDa3Ehm9cpYWSbugOohMtqHispxktLPiTkXKXktZ+8VUa09rcNMvRgnJBPApELhcDx9c+FRhhalVVL9LA7956bbnL0ToC4KoM+qm6nJRjU1ojOpz+mHQYJ5a6dSKjHVZtbV5CPy0U4O66hmdeDNXLaady4q8RFxY6oZeajgMc+rFiDVVLdcVEUgSSi4k1tS0pb8XG2T9+3fLZAYc+zvzuu1gOujG2P0rvyHfDW/OQeAK4eLD8IQTI0KQTeh0XPw6rrQYIAkBp6DwCZ7xOC4jdRkKRtmmbjKt47GQ3I1VA5bx/mER6Hn8WrRGOQoZIIZavA2yd1vM3Ou6EtxXdhSnr2BOJhLDzvhIcX7+WbNsOiSGZL1qfuarGtYPF2ByXfMu3Jx1sbQIciSid8qz2JATm+rSMmSiEYO92ElDkVIWNxJ5jX/Yt/xu82k3Ji9gEfWYAYCcdn9t1WmFJ7Lq5YeGpihYHtvX9g8/BDLs5ruST55a9SKifKho2bhWziLJcr/VUBiH87mV93QRSg+VkyBLmDm/nvKDNZ7WrNM4U9wXQAgFwv2OolsVeYlXx2wVHvq3hv0UyOaFrytM6Bh2fuIOabY/W6C6QMPjU2iTwlwDU7FmNPo0tIrVJ/d+Eq69BlcZhQdh0PmtV36+VKYys6B1skZVsViRTQUa1UL073+8cbKxpKmyWRK4jJ+Z4a2VJw1VWwX6dXmy8JOoMwSNofdpt+gI8wwGf5oby5bKxlqHwJKxvj0plC5nIE+4IHxdH6X2oAacP2UpujuGljMNi7zrrSTu5t2ZbLiynZcfxRIoNtk6RZNs/nTqr8m60B+EtRXLthHEwVsan72EoIWNXs5VM2iDUI0oEbNlRYnu3FR8FOIHjayfsbqSwioTpF9ZBdOPnAVFu9q+Hp+8dmwxMUDGijuxuQO9vUBbA3W075tIkWzq6Pl7nu+dkFlIC/oRUAnrKG6R9plk9zF5WdbzKhsqsnXG24O4SaGaktsY0DQAz8rrUZkhRSBtgnu4vFRua1ZPHaYKnjR1mLEhJdDC1ma6odipfPnMxoTspSUlsBscmyBYpUFHjg8EX5JMdE/muPaJLODxk9GAnpT6tLok2iKh8sKDL5fSnJZL6SgqJzS4BxjP0scfYr2Cf2Ao5+nGjIgwy6qMM0LMEarIq/UDPt6AFpx2e+Db9dcZzpeEPwecFrJ6+lDq9GKQtrAeSQnVEDpZSbkCczT3BbxMYkIeG0NzgaWRUxMgRWstmW0BXgmx/OQ4gH5R4saugL592rrXLVinKNf6M4q3JGvKZ283cDCOMjFZCd/DIPY/8R2xoXG3BzcU60SzgJlLLyYNaH7EyfSB5Usy2KLsps0HVbU5eUW6Gb5AGV2YXSV+FuZZZuF+HaNaMjRDenZPac00O745YwPzuYJ9bZ7io0VnsshAjc9rT4Z6wSXe1pzJwonUjtjb/gMaW/NQY8tWzuPkVLndBiiTvC0A65Kxtxp5r967/FiWwE72LjXe/ELFl6qvRYTmKLiqkXqGt5dLMtfCXTDqpZTFYryuGcC2ESEkNyM+pa8MU0cSOZDAHyRBogEUJCwLyUQ6+eBRwR1kVOACKHtPicIRUprBSXLOFYpM9Zg5Vqapsa4bwxbUaJi7tCEQ/IX+bbWHmQwj42tDD5qxv03Ds1lJ61DYiW8phctmUs1Yw7uRyIzTQEmTgZyUnkgZXvnhoM9Fa2uLLfgn2f08hWfkRLI508hcxgVdFd5E2wBvj0E88h1O+QKZXqWwl2hBD1vfzbhWODNyElsKIohv7MTZjSq96xLxh7fakwJn2NquruFQY0E6FyuHdyhGjemMD5F2LMRA1ibhdX9qKLVk5gv+eJ/Tvj49CoCSbCM+yoO8XaGuR1jeAzODKBRUJedhFS6w+92IrrOO6c7Vv2OdO4GKkpIGtHMrrnhGlpLoqR/iaGG2K3cpcdfkkK4tK/v7wVL01pudhqCnBcylrdv94TJs8wcCruotVSd/kWW3NlRXWzZdNdio+TCWnTF/s9gvsef9WggD3q9+PeU6yG92reCnP29rKlKyVJnqff+vY85FxtGduWSNeuj95TWvMNOBT+3/djrwVT6ZnxlaxwPkN1TIXFdgdUX1S1PZv1dVyBozqqpGTQ3Vb2PM1knYeHL6bzUJVmL46W192KMZJrut61DP1kcqeirxPQkdA3Pik82LfzVrzpf0xSunWe75yGGZ6vebVTmsjNUbln0y2vdVw1d/rroqf0mMVu2FAIIuskElBrOa3Fd3xkrLMi1oBZChiDNtZ17ygkEUAtCpD+Dbg4kWAVJIOXzlZze9rHQNpt/X79XF1oSzN/OmY/SOdIi6L+FAJJOQNvCuVZiXz5pta8DeS3oyecKywwybiEako6dlXXfRGOmOCrF7SA7+xHmhlyHRHwj2KVkdmA81jwHn/tpZpCcYju897Xx9RdvUiqdfVro10uZ48srxIllSZLSakqmL7jrhDZbEQ05CtHfCGIWZjrQFrpZi+MMVKvNXJR5ShpjZZEMIYa9KSyB2OXkcg1DWLdQ1IMSvjeu3kSFy/QJIqc5h3uJHWjYVFLxXJEwCNFQUYg020amrWXpO2Nh4ml9QNH00LULNkga9B1WeUK4QjP0ME72pSt7QomPcB6g9RmA9WF7EWtK53IevXOeItYmdltB+qrlb1LhImnj2k9lKim+BphIkIEzaltvVw4463QybYRiq5j6ykbcrGEXmS87LrHEB6hToRgKQCIXIbEwmRVyE8ChdWnaZcxHJWMtBksMdGQHI1S4fZp3cbJeEYedIiPVdJkK8rM67MzxJPV0zJaaxADxofUj/+FS9bj3gLNy8U0cSm4wevncJeDilcRe7iz0ZMMURIMCILzfFrmSngJPuBECdPEDZ8cUI/eO4KP8R4Bxf7ukoBlvNZ4Osh/uUsPwcmDdbxGF4Joh0gDsJHF9zeZynvOGpDXY0KVB3rIdjxl51r1Bwdv6tBGe5VTADMKUhZRASqmElOhghxNenPwHsqlujXWgQl1eZGQxdOzrquIauafmn+apW29SsuSrAhIF3e+jD4vSXRaxMsgA9LH99G7zqDK1aG7F6XOrmHZTzs1xogYhnjI2RE/RIFo29i43EeblikcRBQBLKoeo8I/wVPmj1DGBSzA+P/FUV2TiZUpfsCB1UaVFKkHHbU7mWr4G5TyT+3sBaGdaVNXgl/MHcCNcFjsaOduJ01GmIJKbwuxI9NDR6on9ou8U9036YQ9yd9lCA4Pe8IxNRHSRtrAdxgfWihyBo1DExlJ/s+07byY212RHeflTrW4ajcZpRnsAb3h0BAeom6wZ5TmG7ItdoM2tb95A9QHFItg3fsVCupYomBMmb1lsNe/r4uHA/OxVaVNOmDqdp9j7Vgu7xDhK9zGAddSbKXox8yVL293v7bzFtUu+kXq2PmBQlugo0DGx8spEwi11XNzGi/LuRaUtkTAm2DbrI6157KZzZo0wrysVCXa0XJMVtLWI15BMZRYY0oaKi+1mwwlsSf/3j9Fv41RTAkZz/DEPbOZDHYhd92ovzkx9w1/7KiULIZW4VQ7aKD7oTNd+SmfYOfgE8SOyTlhPWE5YLyxgytXCZ34ZSGDeINAi10vB1Z8aqlNSqOLXsAZeBopxYzXftXVpq9Uasks1xV8hgMrIyeXETllW8d9SaEbuU3YcvujPZIbsQYi1VUjkzEIaJ6xQeQqZDPoxR+t13QtIgsmHsQDthcPMSIbHkVhbeQr7B+waBGeuKTKgTKmTUGKLJ2VoUziVeI4AakP0rd5CQis7rqi7Of1BkPXS96l+9713Wn+wKVJVHyMezDhiaOLTZ6EKEjR8O+CupxIzXXtl/+efn2cHlsdTtXIAlbWD2xysZL09PFdRlzLPyQid3K8kdIpQfYPzzE7lfhmrkrUeQc/sm2iHAIAY00SNVXD3u36jqxDmnoQiTB3vJu4pjANV0jDfL8sFTCTIKUNLgHzbcr9ZCGcaI0xDzyWAPbCt2H7KA7gBImZ8h0ylqAZCAK/So2C/+n2+5+3MbJXbWg59G7MoZClh67e/39xMysahQ4UZC3peb3HdIrjw/Bm9gkgHm6ZtPswICLTykgGt6K5PPTyeKBSnSxfIvIZ3fmIOHTIW+n8WsNZLrGdSmHk35sA60y70tsjOB4NWaizYgww6jSXXAD4a+xfrvF55jh9ikLK2SjmJkmQAjoftojBMhfbM8rEwcbO+hVZDR73Il96lSgnWrZwGPxO6XdZgIfWax0tCuPyPoCmlGlbNtVRJahknHqIHkCLfEM3pF6c7DRylQIzbugTsjHogZufbj0kPugT1sH7HHC4KwR+hnow8Hfgu6aEVa81n4FgO5zQk3Lx/7X8+XA57svkkz3KYcqWUAR/pWSg+C+pSq+L2m2JyuhGTGe3ewsRF7F/OFjyDdwjf03eVPJ4LSJXbcxNu3vlM+95Xn5uUoWuKuDqnEWeKcaqcfZClsMHSJDCr9fHvuNbh5nIMrKAGrXTYrUg3Pk5iFbQeql43FGRLc7mVYeLKPd96ApwCccoGt0U2htgeIIeBKn1TW9vIzq4/iwRuXe8m4DgxTW1WX7hr9Gstn7MGpsiFAAWtg2/Ws5AxCganSmMvm9LK4S+rb+oiZwHDthA5rTu6pDmLpwEN7XLNNj2G3xWrFT99WIQlw5aRBK54090OLYZK2vzV99ZOxvHWg/xt8cLxh/xB057tdyOrKkACSbMniVzAzDm/Efpqo+MjM3wnRGm4RrzicGmal3ocbmyGlXycLDwAp0v5YTP0UiagyrsRJkpiC/F5/2Hw8lwnx+5kuIHLDY8MoCUGE/IcX0K89BqYWcwAgHy0/dFovxaU+dxguVZJbHBCwicR5uBx/biwOWa02NbumIttCnF9njxItvE/QtqhEnDrluJE5qFwqTJ0gpmEDFsoJxG+8DeYaYDrVdgEDTQBFfXaquitpJFIq34y9ad5wfDRTHkypqcZCXjyQ1ShzO75I0tZGeL23Iym+5yG+FZ5UEuTYjrPwsqosc1ynBbsjuSQXvjOmx+EKtJS3GipBMZ6tLvrw7B7FDRmM55AGJjK7b/uEHZq3w9l7Z/Jl4SGCsj0x5ItV0ukN3MteKhFXzYNT+/v2tE+sFyD0+oCZLE9qdlnPa8+50JnSdtnrvp+srg95jYOrirdMjv/a9UU26Hh3jAufjmAa9fqP+nrQ8fYJj91i9LTb5YKgXsd7Jd9kspuKidKgEao77aI+kpIn/EHmmqrsYJfsGmem6z2j8N8pKspLAMumpezvmeh+ulgGqB9Lvp3pRpBpRXKq0+9UVcRw10qYe7V2B3TsURbPpPFjw+H0R/RO9nW66/gL4dz/uSoScGrwh44c8dYeGvW7Wwt8eHpN1JjvNhqqvbd0vtn4j0EX+NwLo97qcrp2O1TVFzdC9iVZ/Isx0X7raPv1aaeZFO3usiv54fJgBWbj64w7+ZTHyDXJdbspmrJ4HJsrMEKVYMPuA1nuycrJh8FfoXZGITLGYNoFAhdwBkA/t3jOB8dlvfo3H4v5hTxBZVxH1xkFbvGXem+0YenmqmiGUTqylQQgtCa6zqp4jE+0hWR5eJFOZKmb+wD/muFqU6WZSmeTKG3d5rGmCxwm2Jqm/sO9AwCJgVWnl17baz8F8cBMy7WzstV6fLTif2jfGBwGxKMDqkVwbYtBzZr/v3hXQvO+OesS9BcRFEcoZCFjfO4OJ7ovkviP9XbennXBikPaBme4DF4/Othsbk5XzRzXaizDsq1Qb+9LJpkEiY9KAZWoRH09j+U7QQexKawjsB89Ouke2EDsnkNgZbIIwGj3TktJmRNzrXUsv2mKS1J0ELfyHOA51ZPRYRcyBfCVGpVe8fYH2KRudhwS66MtCquOuOsOEyBnNp+xOW8Id3KUzhsgD7oLltxA7ydsKiw/5ZNJlskxfUlFMDX033yhgT/Z9yGKksOVC2KFfBWoTKq13hzP4BLRQ/IoYQ5Iaefto9jZF3nDrFGzXZYEJ6la2rFLyuCT20xK3DU6UuWrzfPu1hYJTJiUZFmFh3jYVA6+Tg6XhkDjDtebnCokig+VwweAOnhRMUGAC6QOexF5Uf9s2RDkUX9SGtf9MGumT6ApLUHu6JjULEwwy2kdoJBH2ZWelxweVEyiln4jDyyUPV2P6dLbe9alTLaxOrBF8ZDqodFKeUWgn3WRj3wg17d3KEpuvc2vdLF8hVi0a2SIadyu6ucEJ4TxISRR9ncAynt+XbapYhjmq6pd3uRs/1vTxv50cs8T30OrdLef/5qyj7qP8jcZR9jZDNYl1z4LmptGG5slNLbSopjsoc5qb3qV8EkGpNqzXYZ9Is7TFc4ZJfOUBUc7/vDz14oSLXrwaJCCwBqiPwFG12TaQneDLMWH0fAsQ4qQ/qCxKBDBABgwsrEUgBGH3O3WFOBBQGZd9Ww6s8qN9nue4MLLkBp7EHsXeMEw9L4wMfjCK0ZgMNZhFNmi+7QWFLUV6JY99WrSZC39xyLnVvTV6//H0r28Pz08UbieTAujLyxIO4aDqMGWdlONGpMO/aqrDfKu7ciTXbyi7X+eTj7rPLtb91Gi1vsXRNaD+9GTtA2uZ0c9+HUmn0Unjse7wjtyRONorFHHrgND6oIOxzgaZjrhHCCrfwAkl3WT0K/24IPIiFjFWVEucCtQHSAxbbPel1Iu1okgkN1UItDS46Z+XZ2qLFi77Zo1pLjlfxJCh17P61/8CtVqCPg6JoLbv233xJsDLqpqrHNnzZNPoKIUYq0e8xnulsYK8peeUbIEj00SDdmKtIUFuxJgkMUhXzz4GK/KWkBxtQtoWrnJszCzlfZqj7thUFNG8j6qwMkt5MoHXoEOr0ll6UuXGpnHPrZNoYkcu0iNffNUjVaCP3oI1axJqkHOyIeCDtkijOR44NYg9JB8iN21OLzGhXJMjDWPNWEmYGDWYsDnAZy7bvsQZKpyK3TAYY9/UbEgEike7nJREwu2tELK9iGzVGBFjRIzuu6oBmKjUM61QbPa8ZS29vmTE17UEOMDoBSlvMR/VOxXtu1SO7BNkrvJCdtP67hXmnfrI/yfhiUsLQtySqiI2DyHd+pZQkmsnBydAK4tjowGM9MrY0MpmDo9Qcpzks64WwEAAcZpS7IrQcEjhRomekT8yY0+yzILFJhUOglTnoQfZzgAcqOYmSNducRwxZdW6Jtq7s4BI5g1E08AyEGsKOtxGdDJJ2ARqUhHNATtaPzGhj0VvGaC8qLvjpOQEBmpdhyEUdNXkLc0aj0rMY5wQBaD5qxAWw57hStUI8k2oIhoNatu2u/yM2nlbSKdM+ryDHl4Ez3iuNPl/0Kw3IPo1QFFkVLhAhPzARn36wqw+u5zMP2+haBszQnuQTiSptyLBa6T6RGSMuIOHm3eH4lDNoJvIBW93x/PiJt5OJsGZlLWUmMcfkKvrYNgdG4/v0+rJR9Zj/AC0x5bsIh7GQL21E+RpuBpssfhY4bHSjPPPZLtd+9dw/oidGbUwOzDZ48xTp07P1z4kT0ZkB1jVIxx1so91g54uqmQ0BYelEEWolrGfvK3GSFw1kBUJAfmdci7A89bDHkaeWHBHEbr8AQWgs7Md0hz0qSXiIlOoOrrl6uF7WI/4OSFGGD5BSpd7e2lk8BAiL4q+AjmZjI2VgbTBtBl3C1rMC46ppNFq7OZwnDxtNkQCxCx41ti5V4NgiVOPGaWuxU2ozVgFJjU2xFolOEzndzVib+jxWy2i0zBCb5rjEVNifmAIxD/qmd5EZ3p45vcc5GugayS7tqp60Sj1sHj9v/z5OjwWWMvrl3sa38iaxeOF9Ucq8p5pKTjqk3RaIhRiIBOCMPEBrMSqhGWIr3pb5+YD5GXwoYqscEFH2kYy3YdQ5d/XTVwFJ272kLhQMkh1OX7rlXp7JYa0MoEdSCgDgRpxb1oePA3+jKDAg4rnd6tt9ENr/Okmjz+0uH8rP1JIQMbtgfbXNrtOHBsCLImyZzBJWsUeik4h/b3IzNqiRItJoyBcAtfMiNmEn6FpBjrMu6G29W9t5m/Yv0abcpVwGiePEewIx1Yev8L7AiqlCa7LRhhJ3Y06ttFqFMb8Tu+zx6E+JqvS6S9MY16hASAsB/QbqVAwsVVRfNqwQIWSdKDtxL00GR+L9+AAVKPrIXjMZyDXPaIrmt8Znp0FDSy/RizBuknIJlU/54LKF65ptMm7uGXF5SMFpNYKAEEBl0Oya2q9EGY9zU1Pspc3amI9Es7XKfRuQ5NGu2iUHbdVtHGCwfPvyJkNqg2JMiKucIjt8OZfuV4uA4YWbQaWtWco3rpzXdsohC3XS4bbOYDFkNq4PbLR9i7OoZKxGWPvW7ZdPMQhlytqUBNW70IqJgS1Ew5yi4Er3k5IBMaSxipS3lBvpP6XNFU91ltyUFa4mZIHWZImSBCiYve1wVhhJDDNjN94skoYv8KHVO2LX063tPrlOXaani6K9C2P6CU8+2LVO4ekMF018Wuv9Ol+ulHBW9KY/5+q7gY3iiQJwzD3P9JeYDBgDDOzmgFjwMY2bRvbrOYC+0Y8qLUrtVrV1VmRv5UZP19ESKbavrHRUScaTvQHmX435VPO9myR83pkY6Ec4sbqQxdikff9+Wbw8rWhcam6DTU+vgy01cVmYSrolfqy5UVZifiB5j3iC5lPod9TWrjh4H/ebDsBwCvWd32Jgmg5MdGNYrtard1im1BdTPnHpywNKHez78ankmNFOHS/f+/7WYHWgVHq00YUL9JFlNOD1Lu2+TouHk59nNoH8/6owd1sB4q++O9VPdD1NX4szVHxa1LbJ8r1t+tUyo18o82EcKSTpNrwtoA2drxoNvf9250i8/RshRufur/9+plsWwyfKFcsvHwUejCaUa55vfCNua5d7lh10djKFrvRh56ZcCbOOzmfgYlQRhu7wSCzcI31EBKGqYifYK9jdLsQRQ5cU5xMR2FXTr3lQn44Yii96LGO8A86PegGqK+W8qZAH0Xf/0E+uPmu+NlrdAxPzQsIbKP5Bo+Uo8XWxRO/AvVZdmRopwdsEMFiQM+zH/CMw084m/rUzphooZeh/KZ3Sq5Vv3+BE6FePaXS6mpZL+gZfOMZXoO9snGuR7TTjnjEawlGqhntDuLgHguMns72L+15/4ovR0UC8l+Z5rsWVoAdM5rmi6NlLAcbgI2Zh3TPdr3p4itjYYg2Q+Qc5qThrb/tmjgwpltm+wOH1YvDC4m19JaLt+gUtaAOb+QJ7ssjEbBJQzL1ojTczt3IJTkiDbu9qKkZjgZdb22S/PIgpjtKxM7D2K5lSUrPQQgCe4FtcJrowzHcEEtD10U6Om2ondIajF/oSuz80taWMgxyldU70fRh/P/Zc8QRII4ol73mr/IEEfrYJskxASbFlnDMq9g7TYbtm7QYBatzj+bpyxHlvEz6OMYZ7V4jDizkRAo8k9rkNfQ1oE8VSYSGhZCdgPdA/eWCyyMtsm0E8v9AzFYjiVJaXsmzcH7RNC9EGXjDlST0fZZjh5MDuorI45D4faqRHuA4bol8w2P1NpA2ORR0LWGQ+CozFhucWRmJ+WXdVTE8ZPc7hskFVlsdrq3VUQFwXh7V5vKerjnK6yUry4OIWTWj9EDskpmUWgTdaQ6gegxW9dY8L/R25pFssUCRgb60tkjgYJO7Pdz9MwM3mgJa/qPul2Cx+nGmidl7qMIhQhf9MnLujh3JayRK/n1DZGOQcsKhEAcPhBeV1QKOg3MRiBEMd9UFMTq6FAjiYJ6EheGIIWIAMEIvUhNcG0AmGToZUuG5F+15L3oWCH/VNQ7SFlviLKcSt86etGwfQCUYldDGNk4BL0QEjg6JkiMMvlDAczCn+v7m4u4F3r4f9hUpX0Xu6iispvogMpvjjOvIvv2jlPIKEkyoSeFbQiVUJicW6k3Ou3e7qdjPWOWO8Tw3EdIRwGkzn0GRa+92DZpiwoiwQEqihbJQwOhohJt764NmtQLemfiMHoRJZ7nCgQocOjzEbjPcJRgV2DSi0IQ748SrlSiK1qfC/YuTrXyVskkktTHTflu1rZ1DzlimPQ4mcSr1QhwEtkJNYg+FTusOP5+4b8MFn96zszJGlpyoQVCps6B5PM9b98ujhH6b/lbM3/pbMVjW2obP6bwW8CyVL5QUNypieBc1vn6FgqkZlD6a1zc5oIr+uH5+YfgqjSfggSMXnMzsYntiv46BZcQJZoXoWWcTux634yquGIMXGBOrS5QdKwJRiJnJP3GdKeIQB9QxZ99KQFLN8i5a36lhvcUXZfbhAt9yYcNq6VCu8pTibL1ypSwP9xQEHAGaRc4aO9YDTaF6pVdzQLAf9C3ne9XJC9d0TsLizSlX4XhkklpNsrsTh826IEc8f36hcHfclm2YZUcxoam1yhFM2xk3YyuKLIuC/sZbkwqrglxWpxyLPdFsyuLRFsU3k9K/F1uZBiepn50bsOAYx4GLRLMQHYHyIFe7WXtABxpJri5NGYbSguZz8f7q8YVMCsZXHgpOLFE3Sdzko44Tl326dytRgo2ZOEoJOYtsSTXQ1SQwNV0Ud3jlpf0VDoTWFM1FmU5w0ZorsILDUaYhMSyTrQxxdkPOVQarKsBXbP7dYXeTYaouDPAtejVgBXUqnNiUHZd5H2qziEvWK+RqdBgMxJOp3mgyb0/t66NXyyEqIX2poIYI5mwdlEXI4bojYF/0LcGYCnBZfjjCTmtni7V6XVeX8aQsxWW2Q8N/Wq/RpH3dtTigsXXfPfD3ZIeIJWBogRFt9fAuPDrFCI2exF0zWLUZVBzNY7eNwuPcsWbUjo2m7vq9HQscRfxP6IgqABU/Jo2V/I5kUcnVko1USFRZ/ex01SbfnWpqoGkgewRvIZ62YA1pByh1uMLREwKRRqTpF9DhmAipvySH6qkOaAAgZ26N52zZdb2KPeeX4u2stxVTXt6KXncSJT8nTlRUzJuj61lUrd5LRkzShoTCi+4adFAU6D+PKukOdzYcjpAMo5SWm274l9fkEpwDmpF7HcjGv15otcobZy5+zZwjuPK2fxMkYpttjHK1B1kg7IsAn93pOBN52zzyDICb7d9Gsq6JjinNiQwXDcM6rci1OzwDUybZ3GszAMxlH6uaMpmvpf6eff3xoh+Os1Zid4WhkvVkj8IRWA4r8R6hL5WhMqDkbDnbiunQt4kDXiPSA4n3EogmAlc0rrC7fI+JX2RpV6ZNuBmKr5II6Wn/ZRXY4Dtjja89bNImWDqnnopvCAhvW+1ZOtVd/eoamz8JSDwj/kw2myS7CBIIGhYmqehTVLawmMbhauyyXYjS0UD3FO41+hSwRmaPs7He1AzbidQV2IZazo/ymPuDUwkYkhdYN/FYjS1wy+7045OIp97NY7xX9KuFtRD1EY8gtMBpuha/szo7Rh36Tg/sgaApSYUCr2ElsSJkYY90QNdZaufGBBvA9a3PSIWu2H34X7O1yfC0OtxZtvQR+Dje8e1J3WS6luCZBZ63OFsS695hBwsIX5iA9kLSpT2J9RpQvzsddjIfU8SLPPPwTFZNIzfU/pefNX+mKqVo61hmdq4jPJxorkUZpTZjJIgOPrdPKt/eP1JSFJyD3XfENEngNECewpFZZN1PZhSSz1qsPMd/m+JG7Z6TiAyxdj0OxMPkpWDsm8TdgMsZI/lvzWZ13fKiyU3fDRq5TxhE6g9gQzbfNZyTuMW/vF9PzCcaHL6BvT/WDcokdO50IuSIPmTiWI0xqe1nmwGEkxV4y/TdXnuagvT365/vr57eXBwKltXvk4/XJx+/nZxfv/1899vfV28+fe+T08Xr85ssiyED++Tcc/rl4eS8zBYPr89vW55leyqeaRQqk99+kOeX57ddd//0S498j+bLv66iWZlqfPnhpuuigZc8OMpl0393+ePV+c3p59uT7ny6fXX+rfs9eLZk3w2R2+6keXv18fbNxfdqKVbOq4+VOdQAFGrbyw/X3X9//fT+6sfJh+uoVebt5X3tPL24ff3pULGE4UpG5O3lg6f6vPty/+rToaE4u/zx9vLHDMu35/fXzzVgu/xw1s35+dhF33/c/OftV8We5ubVk+tK9vnzpnCJQ3l7cZhWXT6+nV7UgIezITiV9kit7fF96q7Hm4jua0Cf6uqvd1dPUattpxd33VEmgkN/77z+9P3d14cGMGr+bfC7U39f/n3VOBcUtHrry29/XcZZV6yxrVVVUeHqrcaGojnq/umFWTg0fdFsEIp3daYvO6EVbvatnNZGBKd309TG6r5x+9e/D/8F2XTR8EdmgKoAAAAASUVORK5CYII=';

var piePatternImg = new Image();
piePatternImg.src = piePatternSrc;
var bgPatternImg = new Image();
bgPatternImg.src = bgPatternSrc;

var itemStyle = {
    normal: {
        opacity: 0.7,
        color: {
            image: piePatternImg,
            repeat: 'repeat'
        },
        borderWidth: 3,
        borderColor: '#235894'
    }
};
</script>
<div id="echart-8" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-8'));
                        // 指定图表的配置项和数据
                        var option = {
    backgroundColor: {
        image: bgPatternImg,
        repeat: 'repeat'
    },
    title: {
        text: '饼图纹理',
        textStyle: {
            color: '#235894'
        }
    },
    tooltip: {},
    series: [{
        name: 'pie',
        type: 'pie',
        selectedMode: 'single',
        selectedOffset: 30,
        clockwise: true,
        label: {
            fontSize: 18,
            color: '#235894'
        },
        labelLine: {
            lineStyle: {
                color: '#235894'
            }
        },
        data: [
            {value: 335, name: '直接访问'},
            {value: 310, name: '邮件营销'},
            {value: 234, name: '联盟广告'},
            {value: 135, name: '视频广告'},
            {value: 1548, name: '搜索引擎'}
        ],
        itemStyle: itemStyle
    }]
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<h2 id="地图map">地图Map</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=effectScatter-bmap">Air Quality - Baidu Map</a></p>
<iframe src="/custom_html/echarts/lines-bmap-bus.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame">
</iframe>
<h2 id="k线图candlestick">K线图Candlestick</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=candlestick-brush">Candlestick Brush</a></p>
<iframe src="/custom_html/echarts/candlestick-brush.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame">
</iframe>
<h2 id="雷达图radar">雷达图Radar</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=radar2">Proportion of Browsers</a></p>
<div id="echart-9" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-9'));
                        // 指定图表的配置项和数据
                        var option = {
    title: {
        text: '浏览器占比变化',
        subtext: '纯属虚构',
        top: 10,
        left: 10
    },
    tooltip: {
        trigger: 'item',
        backgroundColor: 'rgba(0,0,250,0.2)'
    },
    legend: {
        type: 'scroll',
        bottom: 10,
        data: (function (){
            var list = [];
            for (var i = 1; i <=28; i++) {
                list.push(i + 2000 + '');
            }
            return list;
        })()
    },
    visualMap: {
        top: 'middle',
        right: 10,
        color: ['red', 'yellow'],
        calculable: true
    },
    radar: {
        indicator: [
            { text: 'IE8-', max: 400},
            { text: 'IE9+', max: 400},
            { text: 'Safari', max: 400},
            { text: 'Firefox', max: 400},
            { text: 'Chrome', max: 400}
        ]
    },
    series: (function (){
        var series = [];
        for (var i = 1; i <= 28; i++) {
            series.push({
                name: '浏览器（数据纯属虚构）',
                type: 'radar',
                symbol: 'none',
                lineStyle: {
                    width: 1
                },
                emphasis: {
                    areaStyle: {
                        color: 'rgba(0,250,0,0.3)'
                    }
                },
                data: [{
                    value: [
                        (40 - i) * 10,
                        (38 - i) * 4 + 60,
                        i * 5 + 10,
                        i * 9,
                        i * i /2
                    ],
                    name: i + 2000 + ''
                }]
            });
        }
        return series;
    })()
};;
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<h2 id="关系图graph">关系图Graph</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=graph-webkit-dep">Graph Webkit Dep</a></p>
<iframe src="/custom_html/echarts/graph-webkit-dep.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame">
</iframe>
<h2 id="树图tree">树图Tree</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=tree-legend">Multiple Trees</a></p>
<script>
var data = {
    "name": "flare",
    "children": [
        {
            "name": "data",
            "children": [
                {
                     "name": "converters",
                     "children": [
                      {"name": "Converters", "value": 721},
                      {"name": "DelimitedTextConverter", "value": 4294}
                     ]
                },
                {
                    "name": "DataUtil",
                    "value": 3322
                }
            ]
        },
        {
            "name": "display",
            "children": [
                {"name": "DirtySprite", "value": 8833},
                {"name": "LineSprite", "value": 1732},
                {"name": "RectSprite", "value": 3623}
           ]
        },
        {
            "name": "flex",
            "children": [
                {"name": "FlareVis", "value": 4116}
            ]
        },
        {
           "name": "query",
           "children": [
            {"name": "AggregateExpression", "value": 1616},
            {"name": "And", "value": 1027},
            {"name": "Arithmetic", "value": 3891},
            {"name": "Average", "value": 891},
            {"name": "BinaryExpression", "value": 2893},
            {"name": "Comparison", "value": 5103},
            {"name": "CompositeExpression", "value": 3677},
            {"name": "Count", "value": 781},
            {"name": "DateUtil", "value": 4141},
            {"name": "Distinct", "value": 933},
            {"name": "Expression", "value": 5130},
            {"name": "ExpressionIterator", "value": 3617},
            {"name": "Fn", "value": 3240},
            {"name": "If", "value": 2732},
            {"name": "IsA", "value": 2039},
            {"name": "Literal", "value": 1214},
            {"name": "Match", "value": 3748},
            {"name": "Maximum", "value": 843},
            {
             "name": "methods",
             "children": [
              {"name": "add", "value": 593},
              {"name": "and", "value": 330},
              {"name": "average", "value": 287},
              {"name": "count", "value": 277},
              {"name": "distinct", "value": 292},
              {"name": "div", "value": 595},
              {"name": "eq", "value": 594},
              {"name": "fn", "value": 460},
              {"name": "gt", "value": 603},
              {"name": "gte", "value": 625},
              {"name": "iff", "value": 748},
              {"name": "isa", "value": 461},
              {"name": "lt", "value": 597},
              {"name": "lte", "value": 619},
              {"name": "max", "value": 283},
              {"name": "min", "value": 283},
              {"name": "mod", "value": 591},
              {"name": "mul", "value": 603},
              {"name": "neq", "value": 599},
              {"name": "not", "value": 386},
              {"name": "or", "value": 323},
              {"name": "orderby", "value": 307},
              {"name": "range", "value": 772},
              {"name": "select", "value": 296},
              {"name": "stddev", "value": 363},
              {"name": "sub", "value": 600},
              {"name": "sum", "value": 280},
              {"name": "update", "value": 307},
              {"name": "variance", "value": 335},
              {"name": "where", "value": 299},
              {"name": "xor", "value": 354},
              {"name": "_", "value": 264}
             ]
            },
            {"name": "Minimum", "value": 843},
            {"name": "Not", "value": 1554},
            {"name": "Or", "value": 970},
            {"name": "Query", "value": 13896},
            {"name": "Range", "value": 1594},
            {"name": "StringUtil", "value": 4130},
            {"name": "Sum", "value": 791},
            {"name": "Variable", "value": 1124},
            {"name": "Variance", "value": 1876},
            {"name": "Xor", "value": 1101}
           ]
          },
        {
           "name": "scale",
           "children": [
            {"name": "IScaleMap", "value": 2105},
            {"name": "LinearScale", "value": 1316},
            {"name": "LogScale", "value": 3151},
            {"name": "OrdinalScale", "value": 3770},
            {"name": "QuantileScale", "value": 2435},
            {"name": "QuantitativeScale", "value": 4839},
            {"name": "RootScale", "value": 1756},
            {"name": "Scale", "value": 4268},
            {"name": "ScaleType", "value": 1821},
            {"name": "TimeScale", "value": 5833}
           ]
        }
    ]
};

var data2 = {
    "name": "flare",
    "children": [
        {
            "name": "flex",
            "children": [
                {"name": "FlareVis", "value": 4116}
            ]
        },
        {
            "name": "scale",
            "children": [
                {"name": "IScaleMap", "value": 2105},
                {"name": "LinearScale", "value": 1316},
                {"name": "LogScale", "value": 3151},
                {"name": "OrdinalScale", "value": 3770},
                {"name": "QuantileScale", "value": 2435},
                {"name": "QuantitativeScale", "value": 4839},
                {"name": "RootScale", "value": 1756},
                {"name": "Scale", "value": 4268},
                {"name": "ScaleType", "value": 1821},
                {"name": "TimeScale", "value": 5833}
           ]
        },
        {
            "name": "display",
            "children": [
                {"name": "DirtySprite", "value": 8833}
           ]
        }
    ]
};
</script>
<div id="echart-10" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-10'));
                        // 指定图表的配置项和数据
                        var option = {
    tooltip: {
        trigger: 'item',
        triggerOn: 'mousemove'
    },
    legend: {
        top: '2%',
        left: '3%',
        orient: 'vertical',
        data: [{
            name: 'tree1',
            icon: 'rectangle'
        },
        {
            name: 'tree2',
            icon: 'rectangle'
        }],
        borderColor: '#c23531'
    },
    series:[
        {
            type: 'tree',

            name: 'tree1',
    
            data: [data],
    
            top: '5%',
            left: '7%',
            bottom: '2%',
            right: '60%',
    
            symbolSize: 7,
    
            label: {
                position: 'left',
                verticalAlign: 'middle',
                align: 'right'
            },
    
            leaves: {
                label: {
                    position: 'right',
                    verticalAlign: 'middle',
                    align: 'left'
                }
            },
    
            expandAndCollapse: true,
    
            animationDuration: 550,
            animationDurationUpdate: 750
    
        },
        {
            type: 'tree',
            name: 'tree2',
            data: [data2],
    
            top: '20%',
            left: '60%',
            bottom: '22%',
            right: '18%',
    
            symbolSize: 7,
    
            label: {
                position: 'left',
                verticalAlign: 'middle',
                align: 'right'
            },
    
            leaves: {
                label: {
                    position: 'right',
                    verticalAlign: 'middle',
                    align: 'left'
                }
            },
    
            expandAndCollapse: true,
    
            animationDuration: 550,
            animationDurationUpdate: 750
        }
    ]
};
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<h2 id="日历坐标系calendar">日历坐标系Calendar</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=calendar-horizontal">Calendar Hearmap Horizontal</a></p>
<script>
function getVirtulData(year) {
    year = year || '2017';
    var date = +echarts.number.parseDate(year + '-01-01');
    var end = +echarts.number.parseDate((+year + 1) + '-01-01');
    var dayTime = 3600 * 24 * 1000;
    var data = [];
    for (var time = date; time < end; time += dayTime) {
        data.push([
            echarts.format.formatTime('yyyy-MM-dd', time),
            Math.floor(Math.random() * 1000)
        ]);
    }
    return data;
}
</script>
<div id="echart-11" style="width:80%;height:400px;margin: 0 auto">

</div>
<script data-pjax type="text/javascript">
                        // 基于准备好的dom,初始化echarts实例
                        var myChart = echarts.init(document.getElementById('echart-11'));
                        // 指定图表的配置项和数据
                        var option = {
    tooltip: {
        position: 'top'
    },
    visualMap: {
        min: 0,
        max: 1000,
        calculable: true,
        orient: 'horizontal',
        left: 'center',
        top: 'top'
    },

    calendar: [{
        range: '2020',
        cellSize: ['auto', 15]
    },
    {
        top: 260,
        range: '2019',
        cellSize: ['auto', 15]
    }],
    
    series: [{
        type: 'heatmap',
        coordinateSystem: 'calendar',
        calendarIndex: 0,
        data: getVirtulData(2020)
    }, {
        type: 'heatmap',
        coordinateSystem: 'calendar',
        calendarIndex: 1,
        data: getVirtulData(2019)
    }]
};;
                        // 使用刚指定的配置项和数据显示图表。
                        myChart.setOption(option);
                        </script>
<h2 id="d图">3D图</h2>
<p><a href="https://echarts.apache.org/examples/zh/editor.html?c=bar3d-simplex-noise&amp;gl=1&amp;theme=dark">Bar3D - Simple Noise</a></p>
<iframe src="/custom_html/echarts/bar-3D-simplex-noise.html" width="100%" height="600" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame">
</iframe>
<h1 id="音乐">音乐</h1>
<h2 id="abc五线谱">abc五线谱</h2>
<p>有很多音乐都没有abc的谱子，这时候可以通过下载midi或者musicxml格式的歌曲，然后通过工具转换成abc格式。<br>
<a href="https://github.com/marmooo/midi2abc?tab=readme-ov-file">midi2abc</a>,以及其<a href="https://marmooo.github.io/midi2abc/">在线工具</a></p>
<p>musicxml转abc的工具(这两个工具我还没有试过)：<br>
<a href="https://wim.vree.org/svgParse/xml2abc.html">xml2abc</a><br>
<a href="https://github.com/iammatthi/musicXML-to-simplifiedAbc">musicXML-to-simplifiedAbc</a></p>
<p>
<br>
</p>
<div id="abcjs-audio0" class="abcjs-audio-container">

</div>
<p class="abcjs-buttons-div"><button id="transpose-down0" class="abcjs-buttons">-1</button><button id="transpose-up0" class="abcjs-buttons">+1</button><button id="transpose-to-c0" class="abcjs-buttons">Key to C</button><button id="reset-transpose0" class="abcjs-buttons">Reset Key</button><button id="transpose-up-octave0" class="abcjs-buttons">+Octave</button><button id="transpose-down-octave0" class="abcjs-buttons">-Octave</button>
</p>
<div id="abcjs-paper0" class="abcjs-paper-container">

</div>
<script data-pjax type="text/javascript">
        if(typeof abcString0 === 'undefined') {
            var abcString0 =  "X: 22\nT:Money Lost\nM:3/4\nL:1/8\nQ:1/4=100\nC:Paul Rosen\nS:Copyright 2007, Paul Rosen\nR:Klezmer\nK:Dm\nAde|:\"Dm\"(f2d)e gf|\"A7\"e2^c4|\"Gm\"B>>^c BA BG|\"A\"A3Ade|\"Dm\"(f2d)e gf|\"A7\"e2^c4|\n\"Gm\"A>>B \"A7\"AG FE|1\"Dm\"D3Ade:|2\"Dm\"D3DEF||:\"Gm\"(G2D)E FG|\"Dm\"A2F4|\"Gm\"B>>c \"A7\"BA BG|\n\"Dm\"A3 DEF|\"Gm\"(G2D)EFG|\"Dm\"A2F4|\"E°\"E>>Fy \"(A7)\"ED^C2|1\"Dm\"D3DEF:|2\"Dm\"D6||";
        };

        if(typeof transposeHalfSteps0 === 'undefined') {
            var transposeHalfSteps0 = 0;
        };

        function CursorControl0() {
            var self = this;

            self.onReady = function() {
                // var downloadLink = document.querySelector(".download");
                // downloadLink.addEventListener("click", download);
                // downloadLink.setAttribute("style", "");
                // var clickEl = document.querySelector(".click-explanation")
                // clickEl.setAttribute("style", "");
            };
            self.onStart = function() {
                var svg = document.querySelector("#abcjs-paper0 svg");
                var cursor = document.createElementNS("http://www.w3.org/2000/svg", "line");
                cursor.setAttribute("class", "abcjs-cursor");
                cursor.setAttributeNS(null, 'x1', 0);
                cursor.setAttributeNS(null, 'y1', 0);
                cursor.setAttributeNS(null, 'x2', 0);
                cursor.setAttributeNS(null, 'y2', 0);
                svg.appendChild(cursor);

            };
            self.beatSubdivisions = 2;
            // self.onBeat = function(beatNumber, totalBeats, totalTime) {
            //  if (!self.beatDiv)
            //      self.beatDiv = document.querySelector(".beat");
            //  self.beatDiv.innerText = "Beat: " + beatNumber + " Total: " + totalBeats + " Total time: " + totalTime;
            // };
            self.onEvent = function(ev) {
                if (ev.measureStart && ev.left === null)
                    return; // this was the second part of a tie across a measure line. Just ignore it.

                var lastSelection = document.querySelectorAll("#abcjs-paper0 svg .abcjs-highlight");
                for (var k = 0; k < lastSelection.length; k++)
                    lastSelection[k].classList.remove("abcjs-highlight");

                // var el = document.querySelector(".feedback").innerHTML = "<div class='label'>Current Note:</div>" + JSON.stringify(ev, null, 4);
                for (var i = 0; i < ev.elements.length; i++ ) {
                    var note = ev.elements[i];
                    for (var j = 0; j < note.length; j++) {
                        note[j].classList.add("abcjs-highlight");
                    };
                }

                var cursor = document.querySelector("#abcjs-paper0 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", ev.left - 2);
                    cursor.setAttribute("x2", ev.left - 2);
                    cursor.setAttribute("y1", ev.top);
                    cursor.setAttribute("y2", ev.top + ev.height);
                }
            };
            self.onFinished = function() {
                var els = document.querySelectorAll("#abcjs-paper0 svg .abcjs-highlight");
                for (var i = 0; i < els.length; i++ ) {
                    els[i].classList.remove("abcjs-highlight");
                }
                var cursor = document.querySelector("abcjs-paper0 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", 0);
                    cursor.setAttribute("x2", 0);
                    cursor.setAttribute("y1", 0);
                    cursor.setAttribute("y2", 0);
                }
            };
        }

        function clickListener0(abcElem, tuneNumber, classes, analysis, drag, mouseEvent) {
            var lastClicked = abcElem.midiPitches;
            if (!lastClicked)
                return;

            ABCJS.synth.playEvent(lastClicked, abcElem.midiGraceNotePitches, synthControl0.visualObj.millisecondsPerMeasure()).then(function (response) {
                console.log("note played");
            }).catch(function (error) {
                console.log("error playing note", error);
            });
        }

        if(typeof cursorControl0 === 'undefined'){
            var cursorControl0 = new CursorControl0();
        };

        if(typeof synthControl0 === 'undefined'){
            if (ABCJS.synth.supportsAudio()) {
                var synthControl0 = new ABCJS.synth.SynthController();
            }
        }   

        if(typeof abcOptions0 === 'undefined'){
            var abcOptions0 = {
                add_classes: true,
                clickListener: clickListener0,
                responsive: "resize"
            };
        }

        function setTune0(userAction) {

            synthControl0.disable(true);
            
            var visualObj = ABCJS.renderAbc("abcjs-paper0", abcString0, Object.assign({}, abcOptions0, {visualTranspose: transposeHalfSteps0}))[0];
            // var midi = ABCJS.synth.getMidiFile(abcString);
            // var midiButton = document.querySelector(".midi");
            // midiButton.innerHTML = midi;

            // TODO-PER: This will allow the callback function to have access to timing info - this should be incorporated into the render at some point.
            var midiBuffer = new ABCJS.synth.CreateSynth();
            midiBuffer.init({
                //audioContext: new AudioContext(),
                visualObj: visualObj,
                // sequence: [],
                // millisecondsPerMeasure: 1000,
                // debugCallback: function(message) { console.log(message) },
                options: {
                    // soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/" ,
                    // sequenceCallback: function(noteMapTracks, callbackContext) { return noteMapTracks; },
                    // callbackContext: this,
                    // onEnded: function(callbackContext),
                    // pan: [ -0.5, 0.5 ]
                }
            }).then(function (response) {
            console.log(response);
            if (synthControl0) {
                synthControl0.setTune(visualObj, userAction, {midiTranspose:transposeHalfSteps0}).then(function (response) {
                    console.log("Audio successfully loaded.")
                }).catch(function (error) {
                    console.warn("Audio problem:", error);
                });
            }
            }).catch(function (error) {
                console.warn("Audio problem:", error);
            });

        }

        function transposeToC0() {
            const keyMap = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };

            const keyMatch = abcString0.match(/K: ?([A-G][b#]?)/);
            if (keyMatch) {
                const originalKey = keyMatch[1];
                const halfStepsToC = -keyMap[originalKey];
                transposeHalfSteps0 = halfStepsToC;
                setTune0(true);
            } else {
                console.error('Could not find key in abc string');
            }
        }

        document.getElementById('transpose-up0').addEventListener('click', function() {
            transposeHalfSteps0++;
            setTune0(true);
        });

        document.getElementById('transpose-down0').addEventListener('click', function() {
            transposeHalfSteps0--;
            setTune0(true);
        });

        document.getElementById('transpose-to-c0').addEventListener('click', transposeToC0);

        document.getElementById('reset-transpose0').addEventListener('click', function() {
            transposeHalfSteps0 = 0;
            setTune0(true);
        });

        document.getElementById('transpose-up-octave0').addEventListener('click', function() {
            transposeHalfSteps0 += 12;
            setTune0(true);
        });

        document.getElementById('transpose-down-octave0').addEventListener('click', function() {
            transposeHalfSteps0 -= 12;
            setTune0(true);
        });

        if (ABCJS.synth.supportsAudio()) {
            synthControl0.load("#abcjs-audio0", cursorControl0, {displayLoop: true, displayRestart: true, displayPlay: true, displayProgress: true, displayWarp: true});
        } else {
            document.querySelector("#abcjs-audio0").innerHTML = "<div class='audio-error'>Audio is not supported in this browser.</div>";
        }
        setTune0(false);
</script>
<p>
<br>
</p>
<div id="abcjs-audio1" class="abcjs-audio-container">

</div>
<p class="abcjs-buttons-div"><button id="transpose-down1" class="abcjs-buttons">-1</button><button id="transpose-up1" class="abcjs-buttons">+1</button><button id="transpose-to-c1" class="abcjs-buttons">Key to C</button><button id="reset-transpose1" class="abcjs-buttons">Reset Key</button><button id="transpose-up-octave1" class="abcjs-buttons">+Octave</button><button id="transpose-down-octave1" class="abcjs-buttons">-Octave</button>
</p>
<div id="abcjs-paper1" class="abcjs-paper-container">

</div>
<script data-pjax type="text/javascript">
        if(typeof abcString1 === 'undefined') {
            var abcString1 =  "X: 1\nT: Cooley's\nM: 4/4\nL: 1/8\nK: Emin\n|:D2|\"Em\"EBBA B2 EB|\\\n    ~B2 AB dBAG|\\\n    \"D\"FDAD BDAD|\\\n    FDAD dAFD|\n\"Em\"EBBA B2 EB|\\\n    B2 AB defg|\\\n    \"D\"afe^c dBAF|\\\n    \"Em\"DEFD E2:|\n|:gf|\"Em\"eB B2 efge|\\\n    eB B2 gedB|\\\n    \"D\"A2 FA DAFA|\\\n    A2 FA defg|\n\"Em\"eB B2 eBgB|\\\n    eB B2 defg|\\\n    \"D\"afe^c dBAF|\\\n    \"Em\"DEFD E2:|";
        };

        if(typeof transposeHalfSteps1 === 'undefined') {
            var transposeHalfSteps1 = 0;
        };

        function CursorControl1() {
            var self = this;

            self.onReady = function() {
                // var downloadLink = document.querySelector(".download");
                // downloadLink.addEventListener("click", download);
                // downloadLink.setAttribute("style", "");
                // var clickEl = document.querySelector(".click-explanation")
                // clickEl.setAttribute("style", "");
            };
            self.onStart = function() {
                var svg = document.querySelector("#abcjs-paper1 svg");
                var cursor = document.createElementNS("http://www.w3.org/2000/svg", "line");
                cursor.setAttribute("class", "abcjs-cursor");
                cursor.setAttributeNS(null, 'x1', 0);
                cursor.setAttributeNS(null, 'y1', 0);
                cursor.setAttributeNS(null, 'x2', 0);
                cursor.setAttributeNS(null, 'y2', 0);
                svg.appendChild(cursor);

            };
            self.beatSubdivisions = 2;
            // self.onBeat = function(beatNumber, totalBeats, totalTime) {
            //  if (!self.beatDiv)
            //      self.beatDiv = document.querySelector(".beat");
            //  self.beatDiv.innerText = "Beat: " + beatNumber + " Total: " + totalBeats + " Total time: " + totalTime;
            // };
            self.onEvent = function(ev) {
                if (ev.measureStart && ev.left === null)
                    return; // this was the second part of a tie across a measure line. Just ignore it.

                var lastSelection = document.querySelectorAll("#abcjs-paper1 svg .abcjs-highlight");
                for (var k = 0; k < lastSelection.length; k++)
                    lastSelection[k].classList.remove("abcjs-highlight");

                // var el = document.querySelector(".feedback").innerHTML = "<div class='label'>Current Note:</div>" + JSON.stringify(ev, null, 4);
                for (var i = 0; i < ev.elements.length; i++ ) {
                    var note = ev.elements[i];
                    for (var j = 0; j < note.length; j++) {
                        note[j].classList.add("abcjs-highlight");
                    };
                }

                var cursor = document.querySelector("#abcjs-paper1 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", ev.left - 2);
                    cursor.setAttribute("x2", ev.left - 2);
                    cursor.setAttribute("y1", ev.top);
                    cursor.setAttribute("y2", ev.top + ev.height);
                }
            };
            self.onFinished = function() {
                var els = document.querySelectorAll("#abcjs-paper1 svg .abcjs-highlight");
                for (var i = 0; i < els.length; i++ ) {
                    els[i].classList.remove("abcjs-highlight");
                }
                var cursor = document.querySelector("abcjs-paper1 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", 0);
                    cursor.setAttribute("x2", 0);
                    cursor.setAttribute("y1", 0);
                    cursor.setAttribute("y2", 0);
                }
            };
        }

        function clickListener1(abcElem, tuneNumber, classes, analysis, drag, mouseEvent) {
            var lastClicked = abcElem.midiPitches;
            if (!lastClicked)
                return;

            ABCJS.synth.playEvent(lastClicked, abcElem.midiGraceNotePitches, synthControl1.visualObj.millisecondsPerMeasure()).then(function (response) {
                console.log("note played");
            }).catch(function (error) {
                console.log("error playing note", error);
            });
        }

        if(typeof cursorControl1 === 'undefined'){
            var cursorControl1 = new CursorControl1();
        };

        if(typeof synthControl1 === 'undefined'){
            if (ABCJS.synth.supportsAudio()) {
                var synthControl1 = new ABCJS.synth.SynthController();
            }
        }   

        if(typeof abcOptions1 === 'undefined'){
            var abcOptions1 = {
                add_classes: true,
                clickListener: clickListener1,
                responsive: "resize"
            };
        }

        function setTune1(userAction) {

            synthControl1.disable(true);
            
            var visualObj = ABCJS.renderAbc("abcjs-paper1", abcString1, Object.assign({}, abcOptions1, {visualTranspose: transposeHalfSteps1}))[0];
            // var midi = ABCJS.synth.getMidiFile(abcString);
            // var midiButton = document.querySelector(".midi");
            // midiButton.innerHTML = midi;

            // TODO-PER: This will allow the callback function to have access to timing info - this should be incorporated into the render at some point.
            var midiBuffer = new ABCJS.synth.CreateSynth();
            midiBuffer.init({
                //audioContext: new AudioContext(),
                visualObj: visualObj,
                // sequence: [],
                // millisecondsPerMeasure: 1000,
                // debugCallback: function(message) { console.log(message) },
                options: {
                    // soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/" ,
                    // sequenceCallback: function(noteMapTracks, callbackContext) { return noteMapTracks; },
                    // callbackContext: this,
                    // onEnded: function(callbackContext),
                    // pan: [ -0.5, 0.5 ]
                }
            }).then(function (response) {
            console.log(response);
            if (synthControl1) {
                synthControl1.setTune(visualObj, userAction, {midiTranspose:transposeHalfSteps1}).then(function (response) {
                    console.log("Audio successfully loaded.")
                }).catch(function (error) {
                    console.warn("Audio problem:", error);
                });
            }
            }).catch(function (error) {
                console.warn("Audio problem:", error);
            });

        }

        function transposeToC1() {
            const keyMap = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };

            const keyMatch = abcString1.match(/K: ?([A-G][b#]?)/);
            if (keyMatch) {
                const originalKey = keyMatch[1];
                const halfStepsToC = -keyMap[originalKey];
                transposeHalfSteps1 = halfStepsToC;
                setTune1(true);
            } else {
                console.error('Could not find key in abc string');
            }
        }

        document.getElementById('transpose-up1').addEventListener('click', function() {
            transposeHalfSteps1++;
            setTune1(true);
        });

        document.getElementById('transpose-down1').addEventListener('click', function() {
            transposeHalfSteps1--;
            setTune1(true);
        });

        document.getElementById('transpose-to-c1').addEventListener('click', transposeToC1);

        document.getElementById('reset-transpose1').addEventListener('click', function() {
            transposeHalfSteps1 = 0;
            setTune1(true);
        });

        document.getElementById('transpose-up-octave1').addEventListener('click', function() {
            transposeHalfSteps1 += 12;
            setTune1(true);
        });

        document.getElementById('transpose-down-octave1').addEventListener('click', function() {
            transposeHalfSteps1 -= 12;
            setTune1(true);
        });

        if (ABCJS.synth.supportsAudio()) {
            synthControl1.load("#abcjs-audio1", cursorControl1, {displayLoop: true, displayRestart: true, displayPlay: true, displayProgress: true, displayWarp: true});
        } else {
            document.querySelector("#abcjs-audio1").innerHTML = "<div class='audio-error'>Audio is not supported in this browser.</div>";
        }
        setTune1(false);
</script>
<p>
<br>
</p>
<div id="abcjs-audio2" class="abcjs-audio-container">

</div>
<p class="abcjs-buttons-div"><button id="transpose-down2" class="abcjs-buttons">-1</button><button id="transpose-up2" class="abcjs-buttons">+1</button><button id="transpose-to-c2" class="abcjs-buttons">Key to C</button><button id="reset-transpose2" class="abcjs-buttons">Reset Key</button><button id="transpose-up-octave2" class="abcjs-buttons">+Octave</button><button id="transpose-down-octave2" class="abcjs-buttons">-Octave</button>
</p>
<div id="abcjs-paper2" class="abcjs-paper-container">

</div>
<script data-pjax type="text/javascript">
        if(typeof abcString2 === 'undefined') {
            var abcString2 =  "X:1\nQ:1/4=60\nL:1/16\nM:3/4\nK:C clef=G2\nT:When the Swallows Homeward Fly\nV:1\n%%MIDI program 0\nB,3CD6G2|B3AG8|A2E2D4DG^FE|D3CB,4z4|\nB,2^D2E6E2|^F3B,G8|GBGED3A,^F4-|^F2E2D4z4|\nD3E^F6D2|^F2G2A8|^F3GA6^G2|A2B2c8-|\nc4B8|(3:2A2B2A2G8|D4D4E2^F2|G2A2B8|\nz4E4B4-|B2A2D8|G4^F4G4|A4B8-|\nB4d6c2|E2A2A8|G4^F4B4-|B2A2G8|\nL:1/16\nM:3/4\nK:C clef=G2\nV:2\n%%MIDI program 0\nB,3C[B,D]6[B,G]2|[DB]3[CA][B,G]8|[C^F]2E2[B,D]4DG^FE|D3CB,4z4|\nB,2^D2E6E2|^F3B,G8|GBGED3A,^F4-|^F2E2D4z4|\nD3E[D^F]6D2|^F2G2[DA]8|^F3G[^FA]6^G2|A2B2[D-^F-c-]8|\n[D^Fc]4[DGB]8|(3:2[CA]2[DB]2[CA]2[B,G]8|[B,D]4[C-D]4[C-E]2[C^F]2|G2A2[BGD]8|\nz4[C-E]4[C-B-]4|[CB]2[CA]2D8|G4^F4[EG]4|[^FA]4[G-B-]8|\n[GB]4[EAd]6c2|E2A2[B,-A]8|[B,G]4[^FC]4[B-D-]4|[BD]2[AC]2[GB,]8|\nL:1/16\nM:3/4\nK:C clef=F4\nV:3\n%%MIDI program 0\nz4G,,2D,2G,2D,2|G,2D,2G,,2D,2G,2D,2|G,2D,2D,,2D,2G,2D,2|^F,2D,2G,,2D,2G,2D,2|\nG,2[^F,A,]2[E,G,]2B,,2[E,G,]2B,,2|[^D,A,]2B,,2E,,2E,2[B,G,]2E,2|[B,G,]2E,2A,,2D,2[A,^F,]2D,2|[G,^C]2A,,2D,,2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2|\n[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2|D,2E,2^F,2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2|[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2[F,D,]2|[^F,D,]2[G,D,]2[A,D,]2[A,^F,D,]2[A,^F,D,]2[A,^F,D,]2|\n[A,^F,D,]2[A,^F,D,]2G,,2D,2G,2D,2|^F,2D,2D,,2D,2G,2D,2|G,2D,2D,,2D,2[A,^F,]2D,2|[A,^F,]2D,2G,,2D,2G,2D,2|\nG,2D,2C,2[A,E,]2[A,E,]2[A,E,]2|[A,E,]2[A,E,]2D,2[B,G,]2[B,G,]2[B,G,]2|[B,G,]2[B,G,]2D,2D2^C2A,2|C2A,2G,,2D,2G,2D,2|\nB,,2G,,2C,,2E,2[CA,]2E,2|[CA,]2E,2D,,2D,2G,2D,2|G,2D,2D,,2D,2^F,2D,2|^F,2D,2G,4G,,4|";
        };

        if(typeof transposeHalfSteps2 === 'undefined') {
            var transposeHalfSteps2 = 0;
        };

        function CursorControl2() {
            var self = this;

            self.onReady = function() {
                // var downloadLink = document.querySelector(".download");
                // downloadLink.addEventListener("click", download);
                // downloadLink.setAttribute("style", "");
                // var clickEl = document.querySelector(".click-explanation")
                // clickEl.setAttribute("style", "");
            };
            self.onStart = function() {
                var svg = document.querySelector("#abcjs-paper2 svg");
                var cursor = document.createElementNS("http://www.w3.org/2000/svg", "line");
                cursor.setAttribute("class", "abcjs-cursor");
                cursor.setAttributeNS(null, 'x1', 0);
                cursor.setAttributeNS(null, 'y1', 0);
                cursor.setAttributeNS(null, 'x2', 0);
                cursor.setAttributeNS(null, 'y2', 0);
                svg.appendChild(cursor);

            };
            self.beatSubdivisions = 2;
            // self.onBeat = function(beatNumber, totalBeats, totalTime) {
            //  if (!self.beatDiv)
            //      self.beatDiv = document.querySelector(".beat");
            //  self.beatDiv.innerText = "Beat: " + beatNumber + " Total: " + totalBeats + " Total time: " + totalTime;
            // };
            self.onEvent = function(ev) {
                if (ev.measureStart && ev.left === null)
                    return; // this was the second part of a tie across a measure line. Just ignore it.

                var lastSelection = document.querySelectorAll("#abcjs-paper2 svg .abcjs-highlight");
                for (var k = 0; k < lastSelection.length; k++)
                    lastSelection[k].classList.remove("abcjs-highlight");

                // var el = document.querySelector(".feedback").innerHTML = "<div class='label'>Current Note:</div>" + JSON.stringify(ev, null, 4);
                for (var i = 0; i < ev.elements.length; i++ ) {
                    var note = ev.elements[i];
                    for (var j = 0; j < note.length; j++) {
                        note[j].classList.add("abcjs-highlight");
                    };
                }

                var cursor = document.querySelector("#abcjs-paper2 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", ev.left - 2);
                    cursor.setAttribute("x2", ev.left - 2);
                    cursor.setAttribute("y1", ev.top);
                    cursor.setAttribute("y2", ev.top + ev.height);
                }
            };
            self.onFinished = function() {
                var els = document.querySelectorAll("#abcjs-paper2 svg .abcjs-highlight");
                for (var i = 0; i < els.length; i++ ) {
                    els[i].classList.remove("abcjs-highlight");
                }
                var cursor = document.querySelector("abcjs-paper2 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", 0);
                    cursor.setAttribute("x2", 0);
                    cursor.setAttribute("y1", 0);
                    cursor.setAttribute("y2", 0);
                }
            };
        }

        function clickListener2(abcElem, tuneNumber, classes, analysis, drag, mouseEvent) {
            var lastClicked = abcElem.midiPitches;
            if (!lastClicked)
                return;

            ABCJS.synth.playEvent(lastClicked, abcElem.midiGraceNotePitches, synthControl2.visualObj.millisecondsPerMeasure()).then(function (response) {
                console.log("note played");
            }).catch(function (error) {
                console.log("error playing note", error);
            });
        }

        if(typeof cursorControl2 === 'undefined'){
            var cursorControl2 = new CursorControl2();
        };

        if(typeof synthControl2 === 'undefined'){
            if (ABCJS.synth.supportsAudio()) {
                var synthControl2 = new ABCJS.synth.SynthController();
            }
        }   

        if(typeof abcOptions2 === 'undefined'){
            var abcOptions2 = {
                add_classes: true,
                clickListener: clickListener2,
                responsive: "resize"
            };
        }

        function setTune2(userAction) {

            synthControl2.disable(true);
            
            var visualObj = ABCJS.renderAbc("abcjs-paper2", abcString2, Object.assign({}, abcOptions2, {visualTranspose: transposeHalfSteps2}))[0];
            // var midi = ABCJS.synth.getMidiFile(abcString);
            // var midiButton = document.querySelector(".midi");
            // midiButton.innerHTML = midi;

            // TODO-PER: This will allow the callback function to have access to timing info - this should be incorporated into the render at some point.
            var midiBuffer = new ABCJS.synth.CreateSynth();
            midiBuffer.init({
                //audioContext: new AudioContext(),
                visualObj: visualObj,
                // sequence: [],
                // millisecondsPerMeasure: 1000,
                // debugCallback: function(message) { console.log(message) },
                options: {
                    // soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/" ,
                    // sequenceCallback: function(noteMapTracks, callbackContext) { return noteMapTracks; },
                    // callbackContext: this,
                    // onEnded: function(callbackContext),
                    // pan: [ -0.5, 0.5 ]
                }
            }).then(function (response) {
            console.log(response);
            if (synthControl2) {
                synthControl2.setTune(visualObj, userAction, {midiTranspose:transposeHalfSteps2}).then(function (response) {
                    console.log("Audio successfully loaded.")
                }).catch(function (error) {
                    console.warn("Audio problem:", error);
                });
            }
            }).catch(function (error) {
                console.warn("Audio problem:", error);
            });

        }

        function transposeToC2() {
            const keyMap = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };

            const keyMatch = abcString2.match(/K: ?([A-G][b#]?)/);
            if (keyMatch) {
                const originalKey = keyMatch[1];
                const halfStepsToC = -keyMap[originalKey];
                transposeHalfSteps2 = halfStepsToC;
                setTune2(true);
            } else {
                console.error('Could not find key in abc string');
            }
        }

        document.getElementById('transpose-up2').addEventListener('click', function() {
            transposeHalfSteps2++;
            setTune2(true);
        });

        document.getElementById('transpose-down2').addEventListener('click', function() {
            transposeHalfSteps2--;
            setTune2(true);
        });

        document.getElementById('transpose-to-c2').addEventListener('click', transposeToC2);

        document.getElementById('reset-transpose2').addEventListener('click', function() {
            transposeHalfSteps2 = 0;
            setTune2(true);
        });

        document.getElementById('transpose-up-octave2').addEventListener('click', function() {
            transposeHalfSteps2 += 12;
            setTune2(true);
        });

        document.getElementById('transpose-down-octave2').addEventListener('click', function() {
            transposeHalfSteps2 -= 12;
            setTune2(true);
        });

        if (ABCJS.synth.supportsAudio()) {
            synthControl2.load("#abcjs-audio2", cursorControl2, {displayLoop: true, displayRestart: true, displayPlay: true, displayProgress: true, displayWarp: true});
        } else {
            document.querySelector("#abcjs-audio2").innerHTML = "<div class='audio-error'>Audio is not supported in this browser.</div>";
        }
        setTune2(false);
</script>
<p>
<br>
</p>
<div id="abcjs-audio3" class="abcjs-audio-container">

</div>
<p class="abcjs-buttons-div"><button id="transpose-down3" class="abcjs-buttons">-1</button><button id="transpose-up3" class="abcjs-buttons">+1</button><button id="transpose-to-c3" class="abcjs-buttons">Key to C</button><button id="reset-transpose3" class="abcjs-buttons">Reset Key</button><button id="transpose-up-octave3" class="abcjs-buttons">+Octave</button><button id="transpose-down-octave3" class="abcjs-buttons">-Octave</button>
</p>
<div id="abcjs-paper3" class="abcjs-paper-container">

</div>
<script data-pjax type="text/javascript">
        if(typeof abcString3 === 'undefined') {
            var abcString3 =  "X:1\nQ:1/4=70\nL:1/16\nM:4/4\nK:C clef=G2\nT:Canon in E flat\nV:1\n%%MIDI program 0\n[^A,G]8F8|[G,^D]8^A,8|[^G,C]8[G,^D]8|[^G,C]8[^A,D]8|\n[G^dg]8[Fdf]8|[^Dc^d]8[D^Ad]8|[C^Gc]8[^A,G^A]8|[C^Gc]8[D^Ad]8|\n[G^dg]8[d-f-^A]4[df^G]4|[Gc^d]8[^A-d-G]4[^AdF]4|[C^Dc]8[^A,-^A-^D]4[^A,^AG]4|[C^Dc]8[D-d-^A]4[Dd^G]4|\n[G^d]8[d-^A]4[d^G]4|[G^d]4[cg]4[g^a]4[fc']4|[c-^g-]4[c^g^d]4[g-^A]4[g^A]4|[F^G]4[c^d]4[^A^d]4^d2d2|\n[G-^d]2[G-d]2[G^d]2G2[D^A]4[^Gd]4|[G^d]4[cg]4[d-^a]2[dg]2[f-^a]2[fc']2|[c-^g]2[c-g]2[c-f]2[c^g]2[^A-g]2[^A-f]2[^A-^d]2[^Ad]2|[^Gc]2[F^G]2[c^d]4[^d-^A]2[^d^G]2[G^d]2[Fd]2|\n[G-^d]2[G-d]2[G-^d]2[G^G]2[^D^A]2D2[^Ad]2^G2|[G^d]4[g-c]2[g^d]2[d-^a]2[dg]2[f-^a]2[fc']2|[c-^g]2[cg]2[d-f]2[d^g]2[^dg]2[df]2[c^d]2[^Ad]2|[^Gc]2[G^A]2[F-^G]2[F^d]2[^A^d]3Fd2f[^A-]|\n[^Ag]3^Ag^A^d[^Af]4[^Ag][^A^g]gf[G-]|[G^d]3[G^d]2G[Gd][G^d][Gd]2^AG2^A2^D|[^Gc]^D2[^Ad]2^D^d^D^A7^D|[^Gc]^D2^D^Gc^dF^dF2[Fd]2^df[^A-]|\n[^Ag]4[^Ag][^Af][^A^d][^Af]2^A2[^Ag][^A^g]gf[G-]|[Gf]3[G^d]2G[Gd][G^d][Gd]2^AG2^A2^D|[^Ac]^D2^d2c^g^Ag^Af^d4^D|[^Gc]^D2^D^Gc^dFdF2^d3f^d|\n^a2g^g^a2g^g[d^a][^Ad]cd^dfg^g|g2^dfg2G^G^Ac^A^G^A^dd^d|c2^ddc2^A^G^A^GG^G^Acd^d|c2^dd^d2d^ddcd^df[^dg][f^g][g^a]|\n[g^a]2[^dg][f^g][g^a]2[fg][^d^g][df^a][^Ad]cd^dfg[d^g]|[^dg]2[c^d][df][^dg]2[^DG][F^G][G^A][^Gc][G^A][F^G][G^A]^dd^d|[^Gc]2[c^d][^Ad][^Gc]2[G^A][F^G][G^A][F^G][^DG][F^G][G^A][^Gc][^Ad][c^d]|[^Gc]2[c^d][^Ad][c^d]2[^Ad][c^d][^Ad][^Gc][^Ad][c^d][df][^dg][f^g][g^a]|\n[g^a]2[^dg][f^g][g^a]2[fg][^d^g][df^a][^Ad][c^d][df][^dg][df][^dg][d^g]|[^dg]2[c^d][df][^dg]2[^DG][F^G][G^A][^Gc][G^A][F^G][G^A][G^d][^Gd][^A^d]|[^Gc]2[c^d][^Ad][^Gc]2[G^A][F^G][G^A][F^G][^DG][F^G][G^A][^Gc][^Ad][c^d]|[^Gc]2[c^d][^Ad][c^d]2[^Ad][c^d][^Ad][^Gc][^Ad][c^d][df][^dg][c^g][d^a]|\n[^A-^dg]2[^A-^d][^A-f][^A-g]2[^A-f][^A^d][^A-f][^A-d][^A-^d][^A-f][^A-g][^A-f][^A-^d][^Ad]|[G-^d]2[G-c][G-d][G-^d]2[G^D]F[D-G][D-^G][D-G][D-F][G-D][G-^d][G-d][G^d]|[^G-c]2[^G-^d][^G-d][^Gc]2^A^G[^D-^A][^D-^G][^D-G][^D-^G][^D-^A][^D-c][^D-d][^D^d]|[^G-c]2[^G-^d][^G-d][^G^d]2dc[^A-d][^A-^d][^A-f][^A-^d][^A-d][^A-^d][^A-c][^Ad]|\n[^d-^D]2[^d-^A,]2[^d-^D]2[^dG]2z2F,2^A,2D2|z2G,2C2^D2z2^A,2D2G2|z2^D,2^G,2C2[^D,-]2[^D,-G,]2[^D,-^A,]2[^D,^D]2|z2F,2C2^D2z2F,2^A,2D2|\nz2[^dg][f^g][g^a]2[^dg]2z2[^Ad][c^d][df]2[^Ad]2|zc[c^d][df][^dg]2^d2zc[^dg][df][c^d]2[^Ad]2|z^G[^Gc][^Ad][c^d]2[^Gc]2zG[G^A][^Gc]c/4[c^d]7/4[G^A]2|z[^Gc][^Ad][^Ad][c^d]2[^Gc]^A2^A[^Ad][c^d][df]2[^Ad]2|\nz^d[^dg][f^g][g^a]2[^dg]2z2[df][^dg][f^g]dfc-|cc[c^d][cf][cg]2^dd2d[g^a][f^g]gd[g^a]^d|[^gc']^d[^gc']^a^g2[^gc']^d[g^a]^d[g^a]^gg^d[g^a]^d|[^gc'][g^a][^d^g][^gc'][g^a][^d^g][^gc']f[^ad'][^gc']f^Ad[^A^d][^Af]^A|\ng^A2^A[^Ag][^Af][^A^d][^Af]2^A2[^Ag][^A^g]gf[G-]|[G^d]3[G^d]2G[Gd][G^d][Gd]2^AG2^A2^D|[^Gc]^D2[^Ad]2^D^d^D^A3[^A^d]2[^A^d][^A^d][^A^d]|[^Gc]^D2^D^Gc^dFdF2[F^d]2Ff^A|\ng^A2^A[^Ag][^Af][^A^d][^Af]2^A2[^Ag][^A^g]gf[G-]|[Gf]3[G^d]2G[Fd]^dG^Ad^dg^ad'^d'|d'c'^a^g^a^ggf[g^a]f^dd^ddc^A|c^A^G^Ac^G^d^Adc^A^d2^Af^A|\ng^A2^Ag^A^g^A[d^a]c[^dc']^A[d^a]^A[d^g]F|[cg]G2G[G^d][G^d]fG[^Ag]^G^gGgFf^D|[^Gc]^D2^D[^Dc]d^d[^D^A]2^d2^d[^A^d][^A^d]2^d|[^Gc]^D2^D^Gc^dF^dF2[Fd]2^df^A|\n[^dg]^A2^A[^dg]^A[f^g]^A[d^a]c[^dc']^A[d^a]^A[d^g]G|[^dg]G2G[G^d][G^d]fG[^Ag]^G^gG[^Ag]G[^Af]^D|[^Gc]^D2^D[^Dc]d^d[^D^A]2^dd^d[G-^A-][G-^A^d][G-d][G^d]|[^G-c][^G-^d][^G-d][^G^d][^G-c][^G-^d][^G-d][^G^d][Fd]^AF[F^d]2Ff^A|\ng^A2^A[^Ag][^Ag][^A^g]^A[d^a]c[^dc']^A[d^a]^A[c^g]G|[d^dg]G2G[G^d][G^d][Gf]G[^Ag]^G^gG[^cg]Gf^G|[c^d]^G2^Gcd^d[G-^A^d]2[G-^d][G-d][G^d][G-^A][G-^d][G-d][G^d]|[^G-c][^G-^d][^G-d][^G^d][^G-c][^G-^d][^G-d][^G^d][Fd]^AF[F^d]2F[Ff]^A|\ng^d^A^A[^dg]^A[^d^g]^A[d^a]c[^dc']^A[d^a]^A[c^g]G|[d^dg]G2G[Gd^d][Gd^d][Gf]G[^Ag]G^gG[^cg]Gf^G|^d^G2^Gcd^d[G-^A^d]2[G-^d][G-d][G^d][G-^A][G-^d][G-d][G^d]|[^G-c][^G-^d][^G-d][^G^d][^G-c][^G-^d][^G-d][^G^d]d^AF[F^d]2F[Ff]2|\ng/2g/2g/2g/2g/2g3/4g3/8g/2g/2g/2g/2g/2g/2g3/4g3/8g/4f/2f/2f/2f/2f/2f3/4f3/8f/2f/2f/2f/2f/2f/2f3/4f3/8f/4|^d/2^d/2^d/2^d/2^d/2^d3/4^d3/8^d/2^d/2^d/2^d/2^d/2^d/2^d3/4^d3/8^d/4d/2d/2d/2d/2d/2d3/4d3/8d/2d/2d/2d/2d/2d/2d3/4d3/8d/4|c/2c/2c/2c/2c/2c3/4c3/8c/2c/2c/2c/2c/2c/2c3/4c3/8c/4^A/2^A/2^A/2^A/2^A/2^A3/4^A3/8^A/2^A/2^A/2^A/2^A/2^A/2^A3/4^A3/8^A/4|c/2c/2c/2c/2c/2c3/4c3/8c/2c/2c/2c/2c/2c/2c3/4c3/8c/4d/2d/2d/2d/2d/2d3/4d3/8d/2d/2d/2d/2d/2d/2d3/4d3/8d/4|\ng/2g/2g/2g/2g/2g3/4g3/8g/2g/2g/2g/2g/2g/2g3/4g3/8g/4f/2f/2f/2f/2f/2f3/4f3/8f/2f/2f/2f/2f/2f/2f3/4f3/8f/4|^d/2^d/2^d/2^d/2^d/2^d3/4^d3/8^d/2^d/2^d/2^d/2^d/2^d/2^d3/4^d3/8^d/4d/2d/2d/2d/2d/2d3/4d3/8d/2d/2d/2d/2d/2d/2d3/4d3/8d/4|c/2c/2c/2c/2c/2c3/4c3/8c/2c/2c/2c/2c/2c/2c3/4c3/8c/4^A/2^A/2^A/2^A/2^A/2^A3/4^A3/8^A/2^A/2^A/2^A/2^A/2^A/2^A3/4^A3/8^A/4|c/2c/2c/2c/2c/2c3/4c3/8c/2c/2c/2c/2c/2c/2c3/4c3/8c/4d/2d/2d/2d/2d/2d3/4d3/8d/2d/2d/2d/2d/2d/2d3/4d3/8d/4|\n[G-^d-]16|[G^d]4\nL:1/16\nM:4/4\nK:C clef=F4\nV:2\n%%MIDI program 0\n^D,8[^A,,F,]8|C,8[G,,D,]8|[^G,,^D,]8[^D,,^D,]8|[^G,,^D,]8[^A,,F,]8|\n[^D,^A,^D]8[^A,,F,^A,]8|[C,G,C]8[G,,^D,G,]8|[^G,,^D,^G,]8[G,,^D,G,]8|[^G,,^D,^G,]8[^A,,F,^A,]8|\n[^D,^A,^D]8[^A,,F,^A,]8|[C,G,C]8[G,,D,G,]8|[^G,,^D,^G,]8[^D,,^A,,^D,]8|[^G,,^D,^G,]8[^A,,F,^A,]8|\n^D,2^A,2^D4^A,,2F,2^A,4|C,2G,2C4G,,2D,2G,4|^G,,2^D,2^G,4^D,2^A,2^D4|^G,,2^D,2^G,4^A,,2F,2^A,4|\n^D,2^A,2^D4^A,,2F,2D4|C,2G,2^D2G,2G,,2D,2^A,2D,2|^G,,2^D,2^G,2^D,2^D,2^A,2G2^A,2|^G,,2^D,2C2^D,2^A,,2F,2D2F,2|\n[^D,,^D,]2G,2^A,2^D2^A,,2F,2^A,2D2|C,2G,2C2^D2[G,,G,]2^A,2D2G2|^G,,2^G,2C2^D2[^D,,^D,]2^A,2^D2G2|^G,,2F,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^D,2^G,2C2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^D,2^G,2C2[^D,,^D,]2G,2^A,2^D2|^G,,2^D,2^G,2C2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]2^A,2^D2G2^A,,2F,2^A,2D2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]8[^A,,,^A,,]8|[C,,C,]8[G,,,G,,]8|[^G,,,^G,,]8[^D,,,^D,,]8|[^G,,,^G,,]8[^A,,,^A,,]8|\n[^D,,^D,]2^A,2^D2G2[^A,,,^A,,]2F,2^A,2D2|[C,,C,]2G,2C2^D2[G,,G,]2^A,2D2G2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2F,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2^A,2D2F2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^D,2^G,2C2[^D,,^D,]2G,2^A,2^D2|^G,,2F,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^D,2^G,2C2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2^A,2D2F2|C,2G,2C2^D2G,,2G,2^A,2^C2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2F,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2F,2^A,2D2|C,2G,2C2^D2G,,2G,2^A,2^C2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2^G,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2F,2^A,2D2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[^D,,^D,]2G,2^A,2^D2|^G,,2F,2C2^D2^A,,2F,2^A,2D2|\n[^D,,^D,]2^A,2^D2G2^A,,2F,2^A,2D2|C,2G,2C2^D2G,,2G,2^A,2D2|^G,,2^G,2C2^D2[G,,,G,,]2G,2^A,2^D2|[F,,,F,,]2^G,2C2^D2[^A,,,^A,,]2F,2^A,2D2|\n[^D,-^A,-]16|[^D,^A,]4";
        };

        if(typeof transposeHalfSteps3 === 'undefined') {
            var transposeHalfSteps3 = 0;
        };

        function CursorControl3() {
            var self = this;

            self.onReady = function() {
                // var downloadLink = document.querySelector(".download");
                // downloadLink.addEventListener("click", download);
                // downloadLink.setAttribute("style", "");
                // var clickEl = document.querySelector(".click-explanation")
                // clickEl.setAttribute("style", "");
            };
            self.onStart = function() {
                var svg = document.querySelector("#abcjs-paper3 svg");
                var cursor = document.createElementNS("http://www.w3.org/2000/svg", "line");
                cursor.setAttribute("class", "abcjs-cursor");
                cursor.setAttributeNS(null, 'x1', 0);
                cursor.setAttributeNS(null, 'y1', 0);
                cursor.setAttributeNS(null, 'x2', 0);
                cursor.setAttributeNS(null, 'y2', 0);
                svg.appendChild(cursor);

            };
            self.beatSubdivisions = 2;
            // self.onBeat = function(beatNumber, totalBeats, totalTime) {
            //  if (!self.beatDiv)
            //      self.beatDiv = document.querySelector(".beat");
            //  self.beatDiv.innerText = "Beat: " + beatNumber + " Total: " + totalBeats + " Total time: " + totalTime;
            // };
            self.onEvent = function(ev) {
                if (ev.measureStart && ev.left === null)
                    return; // this was the second part of a tie across a measure line. Just ignore it.

                var lastSelection = document.querySelectorAll("#abcjs-paper3 svg .abcjs-highlight");
                for (var k = 0; k < lastSelection.length; k++)
                    lastSelection[k].classList.remove("abcjs-highlight");

                // var el = document.querySelector(".feedback").innerHTML = "<div class='label'>Current Note:</div>" + JSON.stringify(ev, null, 4);
                for (var i = 0; i < ev.elements.length; i++ ) {
                    var note = ev.elements[i];
                    for (var j = 0; j < note.length; j++) {
                        note[j].classList.add("abcjs-highlight");
                    };
                }

                var cursor = document.querySelector("#abcjs-paper3 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", ev.left - 2);
                    cursor.setAttribute("x2", ev.left - 2);
                    cursor.setAttribute("y1", ev.top);
                    cursor.setAttribute("y2", ev.top + ev.height);
                }
            };
            self.onFinished = function() {
                var els = document.querySelectorAll("#abcjs-paper3 svg .abcjs-highlight");
                for (var i = 0; i < els.length; i++ ) {
                    els[i].classList.remove("abcjs-highlight");
                }
                var cursor = document.querySelector("abcjs-paper3 svg .abcjs-cursor");
                if (cursor) {
                    cursor.setAttribute("x1", 0);
                    cursor.setAttribute("x2", 0);
                    cursor.setAttribute("y1", 0);
                    cursor.setAttribute("y2", 0);
                }
            };
        }

        function clickListener3(abcElem, tuneNumber, classes, analysis, drag, mouseEvent) {
            var lastClicked = abcElem.midiPitches;
            if (!lastClicked)
                return;

            ABCJS.synth.playEvent(lastClicked, abcElem.midiGraceNotePitches, synthControl3.visualObj.millisecondsPerMeasure()).then(function (response) {
                console.log("note played");
            }).catch(function (error) {
                console.log("error playing note", error);
            });
        }

        if(typeof cursorControl3 === 'undefined'){
            var cursorControl3 = new CursorControl3();
        };

        if(typeof synthControl3 === 'undefined'){
            if (ABCJS.synth.supportsAudio()) {
                var synthControl3 = new ABCJS.synth.SynthController();
            }
        }   

        if(typeof abcOptions3 === 'undefined'){
            var abcOptions3 = {
                add_classes: true,
                clickListener: clickListener3,
                responsive: "resize"
            };
        }

        function setTune3(userAction) {

            synthControl3.disable(true);
            
            var visualObj = ABCJS.renderAbc("abcjs-paper3", abcString3, Object.assign({}, abcOptions3, {visualTranspose: transposeHalfSteps3}))[0];
            // var midi = ABCJS.synth.getMidiFile(abcString);
            // var midiButton = document.querySelector(".midi");
            // midiButton.innerHTML = midi;

            // TODO-PER: This will allow the callback function to have access to timing info - this should be incorporated into the render at some point.
            var midiBuffer = new ABCJS.synth.CreateSynth();
            midiBuffer.init({
                //audioContext: new AudioContext(),
                visualObj: visualObj,
                // sequence: [],
                // millisecondsPerMeasure: 1000,
                // debugCallback: function(message) { console.log(message) },
                options: {
                    // soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/" ,
                    // sequenceCallback: function(noteMapTracks, callbackContext) { return noteMapTracks; },
                    // callbackContext: this,
                    // onEnded: function(callbackContext),
                    // pan: [ -0.5, 0.5 ]
                }
            }).then(function (response) {
            console.log(response);
            if (synthControl3) {
                synthControl3.setTune(visualObj, userAction, {midiTranspose:transposeHalfSteps3}).then(function (response) {
                    console.log("Audio successfully loaded.")
                }).catch(function (error) {
                    console.warn("Audio problem:", error);
                });
            }
            }).catch(function (error) {
                console.warn("Audio problem:", error);
            });

        }

        function transposeToC3() {
            const keyMap = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
                'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };

            const keyMatch = abcString3.match(/K: ?([A-G][b#]?)/);
            if (keyMatch) {
                const originalKey = keyMatch[1];
                const halfStepsToC = -keyMap[originalKey];
                transposeHalfSteps3 = halfStepsToC;
                setTune3(true);
            } else {
                console.error('Could not find key in abc string');
            }
        }

        document.getElementById('transpose-up3').addEventListener('click', function() {
            transposeHalfSteps3++;
            setTune3(true);
        });

        document.getElementById('transpose-down3').addEventListener('click', function() {
            transposeHalfSteps3--;
            setTune3(true);
        });

        document.getElementById('transpose-to-c3').addEventListener('click', transposeToC3);

        document.getElementById('reset-transpose3').addEventListener('click', function() {
            transposeHalfSteps3 = 0;
            setTune3(true);
        });

        document.getElementById('transpose-up-octave3').addEventListener('click', function() {
            transposeHalfSteps3 += 12;
            setTune3(true);
        });

        document.getElementById('transpose-down-octave3').addEventListener('click', function() {
            transposeHalfSteps3 -= 12;
            setTune3(true);
        });

        if (ABCJS.synth.supportsAudio()) {
            synthControl3.load("#abcjs-audio3", cursorControl3, {displayLoop: true, displayRestart: true, displayPlay: true, displayProgress: true, displayWarp: true});
        } else {
            document.querySelector("#abcjs-audio3").innerHTML = "<div class='audio-error'>Audio is not supported in this browser.</div>";
        }
        setTune3(false);
</script>
<h2 id="嵌入musescore">嵌入musescore</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">直接去musescore的官网，找到谱子，然后点进去，点击分享，就可以获得如下的嵌入链接</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;score-iframe&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;394&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://musescore.com/user/16006641/scores/4197961/embed&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span> <span class="attr">allow</span>=<span class="string">&quot;autoplay; fullscreen&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://musescore.com/user/16006641/scores/4197961&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Merry-Go-Round of Life: Howl&#x27;s Moving Castle Piano Tutorial<span class="tag">&lt;/<span class="name">a</span>&gt;</span> by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://musescore.com/user/16006641&quot;</span>&gt;</span>PianoChannel<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe id="score-iframe" width="100%" height="394" src="https://musescore.com/user/16006641/scores/4197961/embed" frameborder="0" allowfullscreen allow="autoplay; fullscreen">
</iframe>
<p><span><a href="https://musescore.com/user/16006641/scores/4197961" target="_blank">Merry-Go-Round of Life: Howl's Moving Castle Piano Tutorial</a> by <a href="https://musescore.com/user/16006641">PianoChannel</a></span></p>
<h1 id="kroki画图">kroki画图</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用语法,其中&#123;kroki=true&#125;可有可无(当前还不行，改成这样以后，会导致hexo渲染的时候卡死，还没找到原因，大概率跟wavedrom可以被kroki渲染，也可以被我写的脚本渲染)</span></span><br><span class="line">```language &#123;kroki=<span class="literal">true</span>&#125;</span><br><span class="line">code</span><br><span class="line">code</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>kroki所支持的language如下，其中plantuml的功能非常丰富，还可以绘制脑图</p>
<ul>
<li>actdiag</li>
<li>blockdiag</li>
<li>bpmn</li>
<li>bytefield</li>
<li>c4plantuml</li>
<li>d2</li>
<li>dbml</li>
<li>ditaa</li>
<li>erd</li>
<li>excalidraw</li>
<li>graphviz</li>
<li>mermaid</li>
<li>nomnoml</li>
<li>nwdiag</li>
<li>packetdiag</li>
<li>pikchr</li>
<li>plantuml</li>
<li>rackdiag</li>
<li>seqdiag</li>
<li>structurizr</li>
<li>svgbob</li>
<li>tikz</li>
<li>vega</li>
<li>vegalite</li>
<li>wavedrom</li>
<li>wireviz</li>
</ul>
<img class="kroki" src="https://kroki.io/plantuml/svg/eNplj7EOwjAMRPd8hekEAwEqsUEk2NnYkduaEjVJo8YqA-LfSasKpbDdOffsS2i089ihhQ5dE8hDvhULfpAl6HURhyzCN1N5Dbt8n0w8lg3WdNVs6GR07Sw5BkN3FqKjktHVhiC7oHYZvATA0kYpe03P1eCCHgLcupV4p8AZA01AEaUsW-tbF3eP1NzZtiLzwx8KNR7icNgUKgMMMPgbByESHKRU_xemJByPatY30bBeq1mP9E2OW5OvJTqCAzl1_gBqpn1h">
<img class="kroki" src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lIAgmoFpbzE3FQlKwUlzwB_JR2gkFJSZkkxUMBCR0EpsaSkCCQX5K-kUKsD1YEBYDrMYWqQjXUK8kYx1hTZ2HCglFJJZQFIpQk23c4BqLoNsSrKSU0sApkEVWSMrAjmG4VarthaAJo1Ov8=">
<img class="kroki" src="https://kroki.io/wavedrom/svg/eNqrVijOTM9LzFGwUojmUlCoVshLzE21UlBKzslW0lFQKE8sA_EK9MBASaFWB1lRUmkxkqIKPWMTPdMKkIhCSmJJIlAoIzUxRSEpP6VSoSQxMwdde3lmUSpQNVS7gZ6hnp4BxI7YWgCIfSmP">
<img class="kroki" src="https://kroki.io/bytefield/svg/eNqtlU1vmzAYx-_5FI_cSzggAaG05bpddt9OiIMJ5kUxNjNmIav47jOGQAIkadUlUqyYv39-3tnGJMFSigr8KDVTQQiDdz_JKQX0hK0kwRZqjc1me6U7EUr5cRImyQ1hmbPDpSyyVmX7E76-Fid4jVaLkpJJSNzoOXkZhQxigY_KCV6XJsURoWZGcEzEZgNBVaor9Gao_m61MuINbCVpZP8AAr_AMuv4nEmzyv8SsJ02NNSOPq5__IgLxazg6b0FPyN5mkmw3da4tkKQgksSRxcmHHIWAxZpNVmw57Qu2KCpjHF_6QM8A6okFhI9Uv1sfny_L9oBkqeS3Bc5gDpb74tsRcJnEVORNIWqC_vVuIqx1dj2VF_zZ68vzs59wwSCIcxuO4nDG6S-Ao2VVPb-g06lMWf2x5ZQa6zWGTIjjamxOnlul30aT1inHQ8uoFYy1vYtaBdgFegBuq5W1rkX1b_qstV_9qgryAaCwC8pztm5ko99kSLaLUpzUd5eGwKCre0YKFxEq78xvGW9N5keqLUxk1xUcnmSV-Q3BH-wajBPHdqBN3x3YdcJq-xOPaMLQrHqqCv-4gILrDlU7z8gjMEelBTPHNHNvdLXKj3ui-XA2yg4l-lsw7EtF8bwPlB_VDiknxKWygwN8ytUa1VHYE-Da8lxv8pJcQnoW00Aq76gnJdQ8pxJiE6S6Hkw0VlOQUdVDQ7ds3cDtfM-6T2ri7nJKOMS3XP_w6B9TT4PWo-j85_y4dzOxy92YPzIhiQoVZGzYWD3b5oKvMurpeSF8Q90BX7x">
<h1 id="table中插入wavedrom">Table中插入wavedrom</h1>
<p>当前渲染使用的pandoc版本为3.3</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 40%">
<col style="width: 42%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">符号</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">样例</th>
<th style="text-align: center;">渲染结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>.</code></td>
<td style="text-align: center;">与上一周期状态相同</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "p..." &#125;]&#125;</code></td>
<td style="text-align: center;"><p>test</p> <script type="WaveDrom"> { signal : [{ name: ".", wave: "p..." }]}</script></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>p</code></td>
<td style="text-align: center;">在周期开始时为上升沿的时钟信号</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "p.pp" &#125;]&#125;</code></td>
<td style="text-align: center;"><a href="https://google.com">a link</a></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>P</code></td>
<td style="text-align: center;">在周期开始时为上升沿的时钟信号，上升沿有箭头</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "P.PP" &#125;]&#125;</code></td>
<td style="text-align: center;"><em>one</em></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>n</code></td>
<td style="text-align: center;">在周期开始时为下降沿的时钟信号</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "n.nn" &#125;]&#125;</code></td>
<td style="text-align: center;">n</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>N</code></td>
<td style="text-align: center;">在周期开始时为下降沿的时钟信号，下降沿有箭头</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "N.NN" &#125;]&#125;</code></td>
<td style="text-align: center;">N</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>0</code></td>
<td style="text-align: center;">低电平，有过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "0.01" &#125;]&#125;</code></td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>l</code></td>
<td style="text-align: center;">低电平，无过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "l.lh" &#125;]&#125;</code></td>
<td style="text-align: center;">l</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1</code></td>
<td style="text-align: center;">高电平，有过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "1.10" &#125;]&#125;</code></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>h</code></td>
<td style="text-align: center;">高电平，无过渡</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "h.hl" &#125;]&#125;</code></td>
<td style="text-align: center;">h</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>z</code></td>
<td style="text-align: center;">高阻态</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "z.zz" &#125;]&#125;</code></td>
<td style="text-align: center;">z</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>d</code></td>
<td style="text-align: center;">下拉（弱 0）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "d.dd" &#125;]&#125;</code></td>
<td style="text-align: center;">d</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>u</code></td>
<td style="text-align: center;">上拉（弱 1）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "u.uu" &#125;]&#125;</code></td>
<td style="text-align: center;">u</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>x</code></td>
<td style="text-align: center;">未定义</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: ".", wave: "x.xx" &#125;]&#125;</code></td>
<td style="text-align: center;">x</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>2</code>/<code>=</code></td>
<td style="text-align: center;">值（颜色为 2）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "2", wave: "2.22" &#125;]&#125;</code></td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>3</code></td>
<td style="text-align: center;">值（颜色为 3）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "3", wave: "3.33" &#125;]&#125;</code></td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>4</code>/<code>5</code>/<code>6</code></td>
<td style="text-align: center;">值（颜色为 4/5/6）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "4/5/6", wave: "4.56" &#125;]&#125;</code></td>
<td style="text-align: center;">4/5/6</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>7</code>/<code>8</code>/<code>9</code></td>
<td style="text-align: center;">值（颜色为 7/8/9）</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "7/8/9", wave: "7.89" &#125;]&#125;</code></td>
<td style="text-align: center;">7/8/9</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>|</code></td>
<td style="text-align: center;">延长前一个周期并绘制间隙</td>
<td style="text-align: center;"><code>&#123; signal : [&#123; name: "|", wave: "xx|x" &#125;]&#125;</code></td>
<td style="text-align: center;">|</td>
</tr>
</tbody>
</table>
<h1 id="pseudocode">pseudocode</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">```pseudocode</span><br><span class="line">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)</span><br><span class="line">    \begin&#123;algorithm&#125;</span><br><span class="line">    \caption&#123;Quicksort&#125;</span><br><span class="line">    \begin&#123;algorithmic&#125;</span><br><span class="line">    \PROCEDURE&#123;Quicksort&#125;&#123;<span class="variable">$A</span>, p, r$&#125;</span><br><span class="line">        \IF&#123;<span class="variable">$p</span> &lt; r$&#125; </span><br><span class="line">            \STATE <span class="variable">$q</span> = $ \CALL&#123;Partition&#125;&#123;<span class="variable">$A</span>, p, r$&#125;</span><br><span class="line">            \STATE \CALL&#123;Quicksort&#125;&#123;<span class="variable">$A</span>, p, q - 1$&#125;</span><br><span class="line">            \STATE \CALL&#123;Quicksort&#125;&#123;<span class="variable">$A</span>, q + 1, r$&#125;</span><br><span class="line">        \ENDIF</span><br><span class="line">    \ENDPROCEDURE</span><br><span class="line">    \PROCEDURE&#123;Partition&#125;&#123;<span class="variable">$A</span>, p, r$&#125;</span><br><span class="line">        \STATE <span class="variable">$x</span> = A[r]$</span><br><span class="line">        \STATE <span class="variable">$i</span> = p - 1$</span><br><span class="line">        \FOR&#123;<span class="variable">$j</span> = p$ \TO <span class="variable">$r</span> - 1$&#125;</span><br><span class="line">            \IF&#123;<span class="variable">$A</span>[j] &lt; x$&#125;</span><br><span class="line">                \STATE <span class="variable">$i</span> = i + 1$</span><br><span class="line">                \STATE exchange</span><br><span class="line">                <span class="variable">$A</span>[i]$ with <span class="variable">$A</span>[j]$</span><br><span class="line">            \ENDIF</span><br><span class="line">            \STATE exchange <span class="variable">$A</span>[i]$ with <span class="variable">$A</span>[r]$</span><br><span class="line">        \ENDFOR</span><br><span class="line">    \ENDPROCEDURE</span><br><span class="line">    \end&#123;algorithmic&#125;</span><br><span class="line">    \end&#123;algorithm&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)</span><br><span class="line">    \begin&#123;algorithm&#125;</span><br><span class="line">    \caption&#123;Quicksort&#125;</span><br><span class="line">    \begin&#123;algorithmic&#125;</span><br><span class="line">    \PROCEDURE&#123;Quicksort&#125;&#123;$A, p, r$&#125;</span><br><span class="line">        \IF&#123;$p &lt; r$&#125; </span><br><span class="line">            \STATE $q = $ \CALL&#123;Partition&#125;&#123;$A, p, r$&#125;</span><br><span class="line">            \STATE \CALL&#123;Quicksort&#125;&#123;$A, p, q - 1$&#125;</span><br><span class="line">            \STATE \CALL&#123;Quicksort&#125;&#123;$A, q + 1, r$&#125;</span><br><span class="line">        \ENDIF</span><br><span class="line">    \ENDPROCEDURE</span><br><span class="line">    \PROCEDURE&#123;Partition&#125;&#123;$A, p, r$&#125;</span><br><span class="line">        \STATE $x = A[r]$</span><br><span class="line">        \STATE $i = p - 1$</span><br><span class="line">        \FOR&#123;$j = p$ \TO $r - 1$&#125;</span><br><span class="line">            \IF&#123;$A[j] &lt; x$&#125;</span><br><span class="line">                \STATE $i = i + 1$</span><br><span class="line">                \STATE exchange</span><br><span class="line">                $A[i]$ with $A[j]$</span><br><span class="line">            \ENDIF</span><br><span class="line">            \STATE exchange $A[i]$ with $A[r]$</span><br><span class="line">        \ENDFOR</span><br><span class="line">    \ENDPROCEDURE</span><br><span class="line">    \end&#123;algorithmic&#125;</span><br><span class="line">    \end&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">&quot;quicksort&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pseudocode&quot;</span>&gt;</span></span><br><span class="line">    % This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)</span><br><span class="line">    \begin&#123;algorithm&#125;</span><br><span class="line">    \caption&#123;Quicksort&#125;</span><br><span class="line">    \begin&#123;algorithmic&#125;</span><br><span class="line">    \PROCEDURE&#123;Quicksort&#125;&#123;$A, p, r$&#125;</span><br><span class="line">        \IF&#123;$p &lt; r$&#125; </span><br><span class="line">            \STATE $q = $ \CALL&#123;Partition&#125;&#123;$A, p, r$&#125;</span><br><span class="line">            \STATE \CALL&#123;Quicksort&#125;&#123;$A, p, q - 1$&#125;</span><br><span class="line">            \STATE \CALL&#123;Quicksort&#125;&#123;$A, q + 1, r$&#125;</span><br><span class="line">        \ENDIF</span><br><span class="line">    \ENDPROCEDURE</span><br><span class="line">    \PROCEDURE&#123;Partition&#125;&#123;$A, p, r$&#125;</span><br><span class="line">        \STATE $x = A[r]$</span><br><span class="line">        \STATE $i = p - 1$</span><br><span class="line">        \FOR&#123;$j = p$ \TO $r - 1$&#125;</span><br><span class="line">            \IF&#123;$A[j] &lt; x$&#125;</span><br><span class="line">                \STATE $i = i + 1$</span><br><span class="line">                \STATE exchange</span><br><span class="line">                $A[i]$ with $A[j]$</span><br><span class="line">            \ENDIF</span><br><span class="line">            \STATE exchange $A[i]$ with $A[r]$</span><br><span class="line">        \ENDFOR</span><br><span class="line">    \ENDPROCEDURE</span><br><span class="line">    \end&#123;algorithmic&#125;</span><br><span class="line">    \end&#123;algorithm&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre id="quicksort" class="pseudocode">
    % This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
    \begin{algorithm}
    \caption{Quicksort}
    \begin{algorithmic}
    \PROCEDURE{Quicksort}{$A, p, r$}
        \IF{$p < r$} 
            \STATE $q = $ \CALL{Partition}{$A, p, r$}
            \STATE \CALL{Quicksort}{$A, p, q - 1$}
            \STATE \CALL{Quicksort}{$A, q + 1, r$}
        \ENDIF
    \ENDPROCEDURE
    \PROCEDURE{Partition}{$A, p, r$}
        \STATE $x = A[r]$
        \STATE $i = p - 1$
        \FOR{$j = p$ \TO $r - 1$}
            \IF{$A[j] < x$}
                \STATE $i = i + 1$
                \STATE exchange
                $A[i]$ with $A[j]$
            \ENDIF
            \STATE exchange $A[i]$ with $A[r]$
        \ENDFOR
    \ENDPROCEDURE
    \end{algorithmic}
    \end{algorithm}
</pre>
<h1 id="交叉引用">交叉引用</h1>
<p>引用与打标签的语法需要安装<code>pandoc-crossref</code>，表格标题的语法不需要</p>
<p><a href="https://lierdakil.github.io/pandoc-crossref/">参考链接</a></p>
<p>原则上，在添加标签的时候，<code>&#123;</code>与<code>#</code>之间是不需要空格的，但是由于hexo的问题，如果不加空格的话，会导致其截断后面的内容（<a href="https://github.com/hexojs/hexo/issues/4658"><code>&#123; and # without space</code> is interpreted as a comment of the nunjucks template by Hexo</a>），可以通过在博客的Front-matter中添加<code>disableNunjucks: true</code>来解决这个问题，但是添加了这个之后，很多插件就失效了。因此比较好的方案是使用<code>&lt;span id="HTML-anchor"&gt;&lt;/span&gt;</code>来添加标签</p>
<h2 id="图片交叉引用">图片交叉引用</h2>
<p><a href="#fig:label">fig ref</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">创建标签语法</span><br><span class="line">![<span class="string">fig Caption</span>](<span class="link">link</span>)&#123;#fig:label&#125;</span><br><span class="line"></span><br><span class="line">引用语法</span><br><span class="line">[<span class="string">fig ref</span>](<span class="link">#fig:label</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://labuladong.online/algo/logo.svg" id="fig:label" alt="fig"></p>
<h2 id="表格交叉引用">表格交叉引用</h2>
<table>
<caption>Caption</caption>
<thead>
<tr class="header">
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="even">
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>下面Caption上的那个空行不能少</p>
<p><a href="#tbl:label">table ref</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">创建标签语法</span><br><span class="line">a   b   c</span><br><span class="line">--- --- ---</span><br><span class="line">1   2   3</span><br><span class="line">4   5   6</span><br><span class="line"></span><br><span class="line">: Caption &#123;#tbl:label&#125;</span><br><span class="line"></span><br><span class="line">引用标签语法[<span class="string">text</span>](<span class="link">#tbl:label</span>)</span><br></pre></td></tr></table></figure>
<table>
<caption>Caption { #tbl:label)}</caption>
<thead>
<tr class="header">
<th style="text-align: left;">a</th>
<th style="text-align: left;">b</th>
<th style="text-align: left;">c</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">3</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">6</td>
</tr>
</tbody>
</table>
<h2 id="公式交叉引用">公式交叉引用</h2>
<p><a href="#eq:label">math ref</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$ math $$ &#123;#eq:label&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[ math \]</span> { #eq:label}</p>
<p><span class="math display">\[\cssId{Overlinev}{\overline{v}}:\overline{S}\to\{F,T\}\]</span></p>
<p>test公式<a href="#Overlinev">ref</a></p>
<h2 id="代码块交叉引用">代码块交叉引用</h2>
<p><a href="#lst:code">code ref</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```haskell</span><br><span class="line">main :: IO ()</span><br><span class="line">main = putStrLn &quot;Hello World!&quot;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">: Listing caption &#123;#lst:code&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = putStrLn <span class="string">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>: Listing caption { #lst:code}</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>脚注测试<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>english<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"></li>
</ol>
</section>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>论文写作的一些技巧与经验</title>
    <url>/2025/11/26/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="图片相关">图片相关</h1>
<p>这部分主要介绍在论文写作过程中，如何绘图、图片中使用的字体与字号、以及如何对图片进行后处理。</p>
<h2 id="绘图">绘图</h2>
<h3 id="pyplot绘图">pyplot绘图</h3>
<p>图片的宽度，对于单栏的图片来说，建议设置为3.5英寸（约8.89厘米）；对于双栏的图片来说，建议设置为7.16英寸（约18.19厘米），图片的分辨率建议设置为600dpi。</p>
<p>对于图片的高度，不要超过8.5英寸（约21.59厘米），一般而言，单栏图片的高度设置为2.4英寸（约6.1厘米），一种比较适合的配置如下代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">FIG_W = <span class="number">3.5</span>  <span class="comment"># 单栏图片宽度，单位：英寸</span></span><br><span class="line">FIG_H = <span class="number">2.4</span>  <span class="comment"># 图片高度，单位：英寸</span></span><br><span class="line"></span><br><span class="line">plt.rcParams.update(&#123;</span><br><span class="line">    <span class="string">&quot;font.family&quot;</span>: <span class="string">&quot;Times New Roman&quot;</span>,   <span class="comment"># 字体设置</span></span><br><span class="line">    <span class="string">&quot;font.size&quot;</span>: <span class="number">8</span>,                     <span class="comment"># 默认字体大小 </span></span><br><span class="line">    <span class="string">&quot;axes.labelsize&quot;</span>: <span class="number">8</span>,                <span class="comment"># 坐标轴标签字体大小</span></span><br><span class="line">    <span class="string">&quot;axes.titlesize&quot;</span>: <span class="number">8</span>,                <span class="comment"># 坐标轴标题字体大小</span></span><br><span class="line">    <span class="string">&quot;legend.fontsize&quot;</span>: <span class="number">7</span>,               <span class="comment"># 图例字体大小</span></span><br><span class="line">    <span class="string">&quot;xtick.labelsize&quot;</span>: <span class="number">7</span>,               <span class="comment"># x轴刻度字体大小</span></span><br><span class="line">    <span class="string">&quot;ytick.labelsize&quot;</span>: <span class="number">7</span>,               <span class="comment"># y轴刻度字体大小</span></span><br><span class="line">    <span class="string">&quot;pdf.fonttype&quot;</span>: <span class="number">42</span>,                 <span class="comment"># 保存为pdf时，字体类型设置(图片中的字是矢量的，而且可以被选中复制)</span></span><br><span class="line">    <span class="string">&quot;ps.fonttype&quot;</span>: <span class="number">42</span>,                  <span class="comment"># 保存为ps时，字体类型设置(图片中的字是矢量的，而且可以被选中复制)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(FIG_W, FIG_H))</span><br></pre></td></tr></table></figure>
<p>可以使用如下的配色：（其中红蓝主要作为对比色）</p>
<ul>
<li><span style="display:inline-flex;align-items:center;gap:.4em;font-family:monospace;"><i style="width:.9em;height:.9em;background:#a50f15;border:1px solid #a50f15;border-radius:2px;display:inline-block;"></i><span style="color:#a50f15;font-weight:600;">#a50f15</span></span></li>
<li><span style="display:inline-flex;align-items:center;gap:.4em;font-family:monospace;"><i style="width:.9em;height:.9em;background:#fdd0a2;border:1px solid #fdd0a2;border-radius:2px;display:inline-block;"></i><span style="color:#fdd0a2;font-weight:600;">#fdd0a2</span></span></li>
<li><span style="display:inline-flex;align-items:center;gap:.4em;font-family:monospace;"><i style="width:.9em;height:.9em;background:#fcae91;border:1px solid #fcae91;border-radius:2px;display:inline-block;"></i><span style="color:#fcae91;font-weight:600;">#fcae91</span></span></li>
<li><span style="display:inline-flex;align-items:center;gap:.4em;font-family:monospace;"><i style="width:.9em;height:.9em;background:#08519c;border:1px solid #08519c;border-radius:2px;display:inline-block;"></i><span style="color:#08519c;font-weight:600;">#08519c</span></span></li>
<li><span style="display:inline-flex;align-items:center;gap:.4em;font-family:monospace;"><i style="width:.9em;height:.9em;background:#6baed6;border:1px solid #6baed6;border-radius:2px;display:inline-block;"></i><span style="color:#6baed6;font-weight:600;">#6baed6</span></span></li>
</ul>
<h2 id="图片处理">图片处理</h2>
<p>使用PPT或者使用Visio绘图之后，可以将绘制的内容导出为pdf，而且可以<a href="https://support.microsoft.com/zh-cn/office/%E5%B0%86-powerpoint-%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF%E5%8F%A6%E5%AD%98%E4%B8%BA-pdf-%E6%96%87%E4%BB%B6-9b5c786b-9c6e-4fe6-81f6-9372f77c47c8">导出指定页面</a>, 但是还是存在一个问题，就是导出的pdf可能会存在大量的空白，这时候可以Tex Live自带的<code>pdfcrop</code>命令进行裁剪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pdfcrop input.pdf output.pdf</span><br></pre></td></tr></table></figure>
<div class="admonition admonition-note">
<p class="admonition-title">建议导出格式
</p>
<p>虽然PPT可以将选中的内容直接导出为图片，但是当导出为svg格式时，其文字排版会出现问题，因此建议导出为pdf格式。而且latex原生就支持pdf格式的内容插入，如果是svg的话，还需要引入额外的宏包进行支持。</p>
<p>至于png格式，只建议在使用word的时候使用，这时候可以使用<code>ghostscript</code>或者<code>convert</code>将pdf转换为png格式。</p>
<div class="admonition admonition-note">
<p class="admonition-title">pdf转png命令
</p>
<p>使用Tex Live自带的<code>ghostscript</code>命令如下：<br>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gs -dNOPAUSE -dBATCH -dSAFER -sDEVICE=pngalpha -r600 -sOutputFile=output-%03d.png input.pdf</span><br></pre></td></tr></table></figure></p>
<p>使用ImageMagick的<code>convert</code>命令如下：<br>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">convert -density 600 input.pdf -quality 100 output.png</span><br></pre></td></tr></table></figure></p>
</div>
</div>
<h1 id="投稿相关">投稿相关</h1>
<p><a href="https://ieee.atyponrex.com/submission">IEEE期刊投稿地址</a></p>
<h2 id="不同期刊的要求">不同期刊的要求</h2>
<h3 id="tacd">TACD</h3>
<p><a href="https://ieee-ceda.org/publications/tcad/tcad-paper-submissions">参考文献</a></p>
<p>论文提交地址：<a href="https://ieee.atyponrex.com/journal/tcad">tcad</a></p>
<p>提交的稿件要求：</p>
<ol type="1">
<li>论文模板下载地址：<a href="http://www.ieeeauthorcenter.ieee.org">tcad模板</a></li>
<li>论文最大页数：Research Articles: 14 pages, Brief Papers: 5 pages</li>
<li>包含100-250字的摘要，4-8个关键词</li>
</ol>
]]></content>
      <categories>
        <category>OTHERS</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象代数之基本概念</title>
    <url>/2022/05/02/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="近世代数-基本概念">近世代数-基本概念</h1>
<h2 id="集合">集合</h2>
<p><strong>笛卡尔积：</strong> <span class="math inline">\(A_1 \times A_2 \times \cdots \times A_n = \{ (a_1,a_2,\cdots,a_n ) | a_i \in A_i\}\)</span>为<span class="math inline">\(n\)</span>个集合<span class="math inline">\(A_1,A_2,\cdots,A_n\)</span>​的积（或笛卡尔积）。一般的，如果<span class="math inline">\(|A|=m,|B|=n,那么 |A \times B|=mn\)</span>.其中<span class="math inline">\(|A|读作A的阶，表示集合A当中元素的个数\)</span></p>
<span id="more"></span>
<h2 id="映射">映射</h2>
<p><span class="math display">\[
\begin{aligned}
&amp;假设\phi是从笛卡尔积A_1 \times A_2 \times \cdots \times A_n到集合D的一个法则,如果A_1 \times A_2\\
&amp;\times \cdots \times A_n中的每一个元素(a_1,a_2,\cdots,a_n )都有D中唯一的元素d与之对应，\\
&amp;那么则称\phi是从A_1 \times A_2 \times \cdots \times A_n到D的一个映射。
\end{aligned}
\]</span></p>
<h2 id="代数运算">代数运算</h2>
<p><strong>定义1：</strong>一个从<span class="math inline">\(A \times B\)</span>到D的映射叫做<span class="math inline">\(A\times B\)</span>​到D的代数运算。</p>
<p><strong>定义2：</strong>我们称<span class="math inline">\(A\times A\)</span>到<span class="math inline">\(A\)</span>的代数运算<span class="math inline">\(\omicron\)</span>为<span class="math inline">\(A\)</span>上的代数运算，或<span class="math inline">\(A\)</span>上的二元运算，有时候也说集合<span class="math inline">\(A\)</span>对于代数运算<span class="math inline">\(\omicron\)</span>来说是封闭的，或<span class="math inline">\(\omicron\)</span>​具有封闭性。</p>
<h2 id="运算律">运算律</h2>
<p><strong>（1）结合律：</strong>如果对于<span class="math inline">\(\forall a,b,c \in A\)</span>​,都有<br>
<span class="math display">\[
(a\,\omicron\, b)\,\omicron\,c = a\,\omicron\,(b\,\omicron\,c)
\]</span><br>
则称<span class="math inline">\(\omicron\)</span>​适合结合律。</p>
<p><strong>（2）交换律：</strong>如果对于<span class="math inline">\(\forall a,b\in A\)</span>都有<br>
<span class="math display">\[
a\,\omicron\,b=b\,\omicron\,a
\]</span><br>
则称<span class="math inline">\(\omicron\)</span>​​适合交换律。</p>
<p><strong>（3）消去律：</strong></p>
<p>​ ①，若<br>
<span class="math display">\[
a\,\omicron\, b=a\,\omicron\,c \quad\Rightarrow \quad b=c
\]</span><br>
​ 则称<span class="math inline">\(\omicron\)</span>​适合左消去律;</p>
<p>​ ②，若<br>
<span class="math display">\[
b\,\omicron\, a=c\,\omicron\,a \quad\Rightarrow \quad b=c
\]</span><br>
则称<span class="math inline">\(\omicron\)</span>​适合右消去律;</p>
<p>​ ③，若<span class="math inline">\(\omicron\)</span>既适合左消去律又适合右消去律，则称<span class="math inline">\(\omicron\)</span>​适合消去律。</p>
<p><strong>（4）分配律：</strong></p>
<p>设<span class="math inline">\(\otimes,\oplus\)</span>​是集合A上的两个代数运算，<span class="math inline">\(\forall a_1,a_2,b \in A\)</span>.</p>
<p>①若 <span class="math inline">\(b\otimes(a_1\oplus a_2)=(b\otimes a_1)\oplus (b\otimes a_2)\)</span>​则称<span class="math inline">\(\otimes\)</span>​对于<span class="math inline">\(\oplus\)</span>​适合左分配律，或第一分配律。</p>
<p>②若 <span class="math inline">\((a_1\oplus a_2)\otimes b=(a_1\otimes b)\oplus (a_2\otimes b)\)</span>则称<span class="math inline">\(\otimes\)</span>对于<span class="math inline">\(\oplus\)</span>适合又分配律，或第二分配律。</p>
<p>③若<span class="math inline">\(\otimes对于\oplus\)</span>既适合左分配律又适合右分配律，则称<span class="math inline">\(\otimes 对于\oplus\)</span>​适合分配律。</p>
<h2 id="映射与变换">映射与变换</h2>
<p><strong>定义一：</strong><br>
<span class="math display">\[
\begin{aligned}
&amp;设\phi :A\to \overline{A}是一个 映射，对于任意的a,b\in A,如果a \neq b \Rightarrow \phi(a) \neq \phi(b)\\&amp;则称\phi是A到\overline{A}的单射。
\end{aligned}
\]</span><br>
<strong>定理一：</strong><br>
<span class="math display">\[
\begin{aligned}
\phi :A\to \overline{A}是单射当且仅当对于任意的a,b\in A \phi(a)=\phi(b)\Rightarrow a=b
\end{aligned}
\]</span></p>
<p><strong>定义二：</strong><br>
<span class="math display">\[
\begin{aligned}
&amp;设\phi :A\to \overline{A}是一个 映射，对于任意的b\in \overline{A},都存在a\in A,有b=\phi(a),则\\&amp;称\phi是从A到\overline{A}的满射。\color{red}{既是单设又是满射的映射称为一一映射（双射）。}
\end{aligned}
\]</span><br>
<strong>定义三：</strong><br>
<span class="math display">\[
\begin{aligned}
&amp;设f:A\to B和g:B\to C是两个映射，规定g \,\omicron\,f:A\to C为对于任意的\\&amp;x\in A,g \,\omicron\,f(x)=g(f(x)),则称g \,\omicron\,f为f与g的复合映射。
\end{aligned}
\]</span><br>
<strong>定义四：</strong><br>
<span class="math display">\[
\begin{aligned}
&amp;设f:A\to B和g:B\to A是两个映射，如果f\, \omicron\,g=id_B:B\to B\\
&amp;且g\,\omicron\, f=id_A:A\to A,则称f与g互为逆映射。
\\&amp; \tiny{_{id_x表示恒等映射，即自己映射为自己本身}}
\end{aligned}
\]</span><br>
<strong>定理二：</strong>单射的复合是单射，满射的复合是满射，双射的复合式双射。</p>
<p><strong>定理三：</strong>双射存在唯一的逆映射，且这个逆映射也是双射。</p>
<p><strong>定义五：</strong>一个<span class="math inline">\(A\)</span>到<span class="math inline">\(A\)</span>的映射叫做<span class="math inline">\(A\)</span>的一个<em>变换</em>，一个<span class="math inline">\(A\)</span>到<span class="math inline">\(A\)</span>的单射、满射或者一一映射叫做<span class="math inline">\(A\)</span>的一个单射变换、满射变换或者一一变换。</p>
<h2 id="同态">同态</h2>
<p><strong>定义一：</strong>设<span class="math inline">\((A,\omicron),(\overline{A},\overline{\omicron})\)</span>是两个代数系统，<span class="math inline">\(\phi:A\to \overline{A}\)</span>是一个映射，若对于任意的<span class="math inline">\(a,b\in A\)</span>，都有</p>
<p><span class="math inline">\(\phi(a\omicron b)=\phi(a)\overline{\omicron}\phi(b)\)</span>,(乘积的像等于像的乘积)，则称<span class="math inline">\(\phi\)</span>是从<span class="math inline">\(A\)</span>到<span class="math inline">\(\overline{A}\)</span>的同态映射，满的同态映射也称为同态满射，或满同态，若<span class="math inline">\(A\)</span>到<span class="math inline">\(\overline{A}\)</span>存在满同态，则称两个代数系统<span class="math inline">\(A,\overline{A}\)</span>是同态的，记为<span class="math inline">\(A\,\sim\,\overline{A}\)</span>​。</p>
<p><strong>定理一：</strong>设<span class="math inline">\((A,\omicron),(\overline{A},\overline{\omicron})\)</span>是两个代数系统，若<span class="math inline">\(A \sim \overline{A}\)</span>则</p>
<p>​ ①若<span class="math inline">\(\omicron\)</span>适合结合律，那么<span class="math inline">\(\overline{\omicron}\)</span>也适合结合律。</p>
<p>​ ②若<span class="math inline">\(\omicron\)</span>适合交换律，那么<span class="math inline">\(\overline{\omicron}\)</span>​也适合交换律。</p>
<p><strong>定理二：</strong>设<span class="math inline">\((A,\odot,\oplus),(\overline{A},\overline{\odot},\overline{\oplus})\)</span>是两个代数系统，<span class="math inline">\(\varphi:A\to \overline{A}\)</span>是满射，若对于任意的<span class="math inline">\(a,b\in A\)</span>，有<span class="math inline">\(\varphi(a\odot b)=\varphi(a)\overline{\odot}\varphi(b)),\quad \varphi(a\oplus b)=\varphi(a)\overline{\oplus}\varphi(b)\)</span>，则:</p>
<p>​ ①若<span class="math inline">\(\odot,\oplus\)</span>满足第一分配律，那么<span class="math inline">\(\overline{\odot},\overline{\oplus}\)</span>也适合第一分配律。</p>
<p>​ ②若<span class="math inline">\(\odot,\oplus\)</span>满足第二分配律，那么<span class="math inline">\(\overline{\odot},\overline{\oplus}\)</span>也适合第二分配律。</p>
<p><strong>定理三：</strong>同态映射的复合映射必定是同态映射（满同态的复合一定是满同态，单同态的复合一定是单同态，同构的复合一定是同构）</p>
<h2 id="同构与自同构">同构与自同构</h2>
<p><strong>定义一：</strong></p>
<p>​ 设<span class="math inline">\((A,\omicron),(\overline{A},\overline{\omicron})\)</span>是两个代数系统，<span class="math inline">\(\varphi:A\to\overline{A}\)</span>是两个系统之间的一个映射，如果<span class="math inline">\(\varphi\)</span>既是双射又是同态映射，则称<span class="math inline">\(\varphi\)</span>是从<span class="math inline">\(A\)</span>到<span class="math inline">\(\overline{A}\)</span>的同构映射。</p>
<p>​ 若<span class="math inline">\(A,\overline{A}\)</span>之间存在同构映射，则称<span class="math inline">\(A\)</span>与<span class="math inline">\(\overline{A}\)</span>同构，记为<span class="math inline">\(A\cong\overline{A}\)</span>。特别的，当<span class="math inline">\(\overline{A}=A,\overline{\omicron}=\omicron\)</span>时，我们也称同构映射<span class="math inline">\(\varphi:A\to\overline{A}\)</span>为A上的自同构。</p>
<p><strong>定理一：</strong></p>
<p>​ 同构具有以下 性质：</p>
<p>​ ①<span class="math inline">\(A\cong A\)</span>;(<span class="math inline">\(id_a\)</span>);</p>
<p>​ ②若<span class="math inline">\(A\cong\overline{A}\)</span>，则<span class="math inline">\(\overline{A}\cong A\)</span>​​;</p>
<p>​ ③若<span class="math inline">\(A\cong\overline{A},\overline{A}\cong\overline{\overline{A}}\)</span>，则<span class="math inline">\(A\cong\overline{\overline{A}}\)</span>​​​.​</p>
<p><strong>定理二：</strong></p>
<p>​ 设<span class="math inline">\((A,\omicron),(\overline{A},\overline{\omicron})\)</span>是两个代数系统，若<span class="math inline">\(A \cong \overline{A}\)</span>则</p>
<p>​ ①<span class="math inline">\(\omicron\)</span>适合结合律当且仅当<span class="math inline">\(\overline{\omicron}\)</span>也适合结合律。</p>
<p>​ ②<span class="math inline">\(\omicron\)</span>适合交换律当且仅当<span class="math inline">\(\overline{\omicron}\)</span>也适合交换律。</p>
<p>​ ③<span class="math inline">\(\omicron\)</span>适合左(右)消去律当且仅当<span class="math inline">\(\overline{\omicron}\)</span>也适合左(右)消去律。</p>
<p><strong>定理三：</strong>设<span class="math inline">\((A,\odot,\oplus),(\overline{A},\overline{\odot},\overline{\oplus})\)</span>是两个代数系统，如果<span class="math inline">\(A\cong\overline{A}\)</span>,那么<span class="math inline">\(\odot,\oplus\)</span>适合左(右)分配律当且仅当<span class="math inline">\(\overline{\odot},\overline{\oplus}\)</span>​也适合左(右)分配律。</p>
<p><strong>推论：</strong>设<span class="math inline">\((A,\omicron),(\overline{A},\overline{\omicron})\)</span>是两个代数系统，如果<span class="math inline">\(\omicron\)</span>适合某种运算律<span class="math inline">\(P\)</span>而<span class="math inline">\(\omicron\)</span>不适合运算律<span class="math inline">\(P\)</span>，那么<span class="math inline">\(A\)</span>与<span class="math inline">\(\overline{A}\)</span>​​不同构。</p>
<h2 id="等价关系与集合分类">等价关系与集合分类</h2>
<p><strong>定义一：</strong>设<span class="math inline">\(A\)</span>是一个集合，<span class="math inline">\(D=\{对,错\}\)</span>，则称映射<span class="math inline">\(R:A\times A\to D\)</span>为集合A上的一个关系，当<span class="math inline">\(R(a,b)=对\)</span>时，称<span class="math inline">\(a\)</span>与<span class="math inline">\(b\)</span>有关系<span class="math inline">\(R\)</span>，记为<span class="math inline">\(aRb\)</span>​；当<span class="math inline">\(R(a,b)=错\)</span>时，称<span class="math inline">\(a\)</span>​​与<span class="math inline">\(b\)</span>没有关系<span class="math inline">\(R\)</span>。</p>
<p><strong>定义二：</strong>设<span class="math inline">\(A\)</span>是一个非空集合，我们把<span class="math inline">\(A\times A\)</span>的一个子集<span class="math inline">\(\overline{R}\)</span>称为<span class="math inline">\(A\)</span>上的一个关系，对于任意的<span class="math inline">\((a,b\in A\times A)\)</span>当<span class="math inline">\((a,b)\in\overline{R}\)</span>，称<span class="math inline">\(a\)</span>与<span class="math inline">\(b\)</span>有关系<span class="math inline">\(\overline{R}\)</span>，记为<span class="math inline">\(a\overline{R}b\)</span>；当<span class="math inline">\((a,b)\notin\overline{R}\)</span>时，称<span class="math inline">\(a\)</span>与<span class="math inline">\(b\)</span>没有关系<span class="math inline">\(R\)</span>。</p>
<p><strong>定理一：</strong>关系的两个定义等价。</p>
<p><strong>定义三：</strong>设<span class="math inline">\(\sim\)</span>是集合<span class="math inline">\(A\)</span>上的一个关系，如果<span class="math inline">\(\sim\)</span>还满足：</p>
<p>​ ①自反性：<span class="math inline">\(a\sim a\)</span>；(反射律)</p>
<p>​ ②对称性：若<span class="math inline">\(a\sim b\)</span>则，<span class="math inline">\(b\sim a\)</span>；(对称律)</p>
<p>​ ③传递性：若<span class="math inline">\(a\sim b,b\sim c\)</span>，则<span class="math inline">\(a\sim c\)</span>；(推移律)</p>
<p>则称<span class="math inline">\(\sim\)</span>为A上的一个等价关系，若<span class="math inline">\(a\sim b\)</span>则称a与b等价。</p>
<p><strong>定义四：</strong>设<span class="math inline">\(A\)</span>是一个集合，<span class="math inline">\(S=\{S_i|S_i\subseteq A\}\)</span>。若</p>
<p>​ ①<span class="math inline">\(\cup S_i=A\)</span>；</p>
<p>​ ②对于任意的<span class="math inline">\(i,j,S_i\cap S_j=\emptyset\)</span>，</p>
<p>则称<span class="math inline">\(S\)</span>为<span class="math inline">\(A\)</span>上的一个分类(划分)，每一个<span class="math inline">\(S_i\)</span>都称为是<span class="math inline">\(S\)</span>的一个类(块)。</p>
<p><strong>定理二：</strong> <span class="math inline">\(A\)</span>的一个分类决定了<span class="math inline">\(A\)</span>上的一个等价关系。（例如：<span class="math inline">\(a\sim b\)</span>​当且仅当a,b属于S中的一个类）</p>
<p><strong>定理三：</strong> <span class="math inline">\(A\)</span>上的一个等价关系决定<span class="math inline">\(A\)</span>​的一个分类。</p>
<p><strong>定义五：</strong>设<span class="math inline">\(S=\{S_i\}\)</span>是集合A的一个分类，任意的<span class="math inline">\(A\in S_i\)</span>都叫做<span class="math inline">\(S_i\)</span>的代表，刚好有每一类的一个代表构成的集合叫做一个<span class="math inline">\(全体代表团\)</span>。</p>
<h1 id="近世代数-群论">近世代数-群论</h1>
<h2 id="群的定义">群的定义</h2>
<p><strong>定义一（群的第一定义）：</strong>设<span class="math inline">\(G\neq\emptyset\)</span>​，<span class="math inline">\(\omicron\)</span>​是定义在<span class="math inline">\(G\)</span>​上的一个映射，若：</p>
<p>​ Ⅰ，对于任意的<span class="math inline">\(a,b\in G\)</span>​，都有<span class="math inline">\(a\omicron b\in G\)</span>​；</p>
<p>​ Ⅱ，对于任意的<span class="math inline">\(a,b,c\in G\)</span>​，都有<span class="math inline">\((a\omicron b)\omicron c=a\omicron(b\omicron c)\)</span>​​；</p>
<p>​ Ⅲ，对于任意的<span class="math inline">\(a,b\in G\)</span>​，方程<span class="math inline">\(a\omicron x=b\)</span>​和<span class="math inline">\(y\omicron a=b\)</span>​在G中都有解</p>
<p>则称<span class="math inline">\(G\)</span>​关于<span class="math inline">\(\omicron\)</span>​构成一个群，记为<span class="math inline">\((G,\omicron)\)</span>​，<span class="math inline">\(\omicron\)</span>​也称为<span class="math inline">\(G\)</span>​​​​上的乘法。</p>
<p><strong>定理一：</strong></p>
<p>​ Ⅳ，存在<span class="math inline">\(e\in G\)</span>，对于任意的<span class="math inline">\(a\in G\)</span>，有<span class="math inline">\(ea=a\)</span>。(称<span class="math inline">\(e\)</span>为群<span class="math inline">\(G\)</span>的左单元)。</p>
<p><strong>定理二：</strong></p>
<p>​ Ⅴ，对于任意的<span class="math inline">\(a\in G\)</span>​，存在<span class="math inline">\(a^{-1}\in G\)</span>​，有<span class="math inline">\(a^{-1}a=e\)</span>​(称<span class="math inline">\(a^{-1}\)</span>​为群<span class="math inline">\(G\)</span>​中元素<span class="math inline">\(a\)</span>​​的左逆元​）</p>
<p><strong>定义二：</strong>设<span class="math inline">\(G\neq \emptyset\)</span>，<span class="math inline">\(\omicron\)</span>是定义在G上的一个映射，若：</p>
<p>​ Ⅰ，对于任意的<span class="math inline">\(a,b\in G\)</span>，都有<span class="math inline">\(a\omicron b\in G\)</span>；</p>
<p>​ Ⅱ，对于任意的<span class="math inline">\(a,b,c\in G\)</span>，都有<span class="math inline">\((a\omicron b)\omicron c=a\omicron(b\omicron c)\)</span>；</p>
<p>​ Ⅳ，存在<span class="math inline">\(e\in G\)</span>，对于任意的<span class="math inline">\(a\in G\)</span>，有<span class="math inline">\(ea=a\)</span>。(称<span class="math inline">\(e\)</span>为群<span class="math inline">\(G\)</span>的左单元)。</p>
<p>​ Ⅴ，对于任意的<span class="math inline">\(a\in G\)</span>，存在<span class="math inline">\(a^{-1}\in G\)</span>，有<span class="math inline">\(a^{-1}a=e\)</span>(称<span class="math inline">\(a^{-1}\)</span>为群<span class="math inline">\(G\)</span>中元素<span class="math inline">\(a\)</span>的左逆元）</p>
<p>则称<span class="math inline">\(G\)</span>关于<span class="math inline">\(\omicron\)</span>构成一个群，记为<span class="math inline">\((G,\omicron)\)</span>，<span class="math inline">\(\omicron\)</span>也称为<span class="math inline">\(G\)</span>​上的乘法。</p>
<p><strong>定理三：</strong> <span class="math inline">\(a\)</span>的左逆元<span class="math inline">\(a^{-1}\)</span>必定也是<span class="math inline">\(a\)</span>的右逆元。</p>
<p><strong>定理四：</strong> <span class="math inline">\(G\)</span>的左单位元<span class="math inline">\(e\)</span>必定也是<span class="math inline">\(G\)</span>的右单位元。</p>
<p>​</p>
<p><strong>注记：</strong></p>
<p>​ （1）元素有限的群称为有限群，元素无限的群称为无限群。</p>
<p>​ （2）满足交换律的群称为交换群，也称之为阿贝尔群。</p>
<p><strong>定义三：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(a\in G\)</span>，则称<span class="math inline">\(a^n=\underbrace{a\cdot a\cdots \cdot \cdot a}_{n个}\)</span>为<span class="math inline">\(a\)</span>的<span class="math inline">\(n\)</span>次幂（<span class="math inline">\(n\)</span>为正整数）。</p>
<p><strong>定理五：</strong>设<span class="math inline">\(a,b\)</span>是群<span class="math inline">\(G\)</span>中的元素，<span class="math inline">\(m,n\in \mathbb{Z_+}\)</span>，则有</p>
<p>​ （1）<span class="math inline">\(\displaystyle{a^{m+n}=a^ma^n,\qquad (a^m)^n=a^{mn}}\)</span></p>
<p>​ （2）当<span class="math inline">\(G\)</span>是交换群时，<span class="math inline">\((ab)^n=a^nb^n\)</span></p>
<h2 id="单位元逆元和消去律">单位元、逆元和消去律</h2>
<p><strong>定理一：</strong>左单位元<span class="math inline">\(e\)</span>存在且唯一（<span class="math inline">\(e\)</span>也称为单位元）</p>
<p><strong>定理二：</strong>元素<span class="math inline">\(a\)</span>的左逆元<span class="math inline">\(a^{-1}\)</span>存在且唯一（<span class="math inline">\(a^{-1}\)</span>也称为逆元）</p>
<p><strong>注记：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(e\)</span>是单位元，<span class="math inline">\(a,b\in G\)</span>，那么若<span class="math inline">\(ab=e\)</span>，则<span class="math inline">\(a,b\)</span>互为逆元，特别的，若<span class="math inline">\(a^{2}=a\)</span>，则<span class="math inline">\(a^{-1}=a\)</span>，进而<span class="math inline">\(e^{-1}=e\)</span>。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(a,b\in G\)</span>，则：</p>
<p>​ （1）<span class="math inline">\((a^{-1})^{-1}=a;\)</span></p>
<p>​ （2）<span class="math inline">\((ab)^{-1}=b^{-1}a^{-1}\)</span>，一般的，有<span class="math inline">\((a_1a_2\cdots a_n)^{-1}=a_n^{-1}\cdots a_2^{-1}a_1^{-1})\)</span>​进而<span class="math inline">\((a^n)^{-1}=(a^{-1})^n\)</span>。</p>
<p><strong>定义一：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(a\in G,n\in \mathbb{Z^-}\)</span>，规定：<span class="math inline">\(a^0=e,\quad a^n=(a^{-1})^{-n}=\underbrace{a^{-1}\cdot a^{-1}\cdots a^{-1}}_{(-n)个}\)</span>​.</p>
<p><strong>定理四：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(a\in G ,m,n\in \mathbb{Z}\)</span>，则:</p>
<p>​ （1）<span class="math inline">\(a^ma^n=a^{m+m}\)</span></p>
<p>​ （2）<span class="math inline">\((a^m)^n=a^{mn}\)</span></p>
<p><strong>定理五：</strong>设<span class="math inline">\(G\)</span>是一个交换群，<span class="math inline">\(a\in G,n\in \mathbb{Z}\)</span>，则<span class="math inline">\((ab)^n=a^nb^n\)</span></p>
<p><strong>定义二：</strong>设<span class="math inline">\(a\in G\)</span>，则称使得等式<span class="math inline">\(a^m=e\)</span>成立的最小的正整数<span class="math inline">\(m\)</span>为<span class="math inline">\(a\)</span>的阶，记为<span class="math inline">\(|a|\)</span>或者<span class="math inline">\(\omicron(a)\)</span>。若这样的阶不存在，则称<span class="math inline">\(a\)</span>是无限阶的，记为<span class="math inline">\(|a|=\infty\)</span>。​</p>
<p><strong>定理六：</strong>在群<span class="math inline">\(G\)</span>中，<span class="math inline">\(a\in G\)</span>则：</p>
<p>​ （1）一个元的阶为1当且仅当这个元就是单位元；</p>
<p>​ （2）一个元的逆元等于自身当且仅当它的平方是单位元。</p>
<p><strong>定理七：</strong>在群<span class="math inline">\(G\)</span>中，<span class="math inline">\(a\in G\)</span>，则<span class="math inline">\(|a|=|a^{-1}|\)</span>​。</p>
<p><strong>定理八：</strong>群的乘法适合消去律，即：</p>
<p>​ <span class="math inline">\(Ⅲ&#39;:\)</span>若<span class="math inline">\(ax=ax&#39;\)</span>，则<span class="math inline">\(x=x&#39;\)</span>（左消去律）</p>
<p>​ 若<span class="math inline">\(ya=y&#39;a\)</span>，则<span class="math inline">\(y=y&#39;\)</span>（右消去律)</p>
<p><strong>定理九：</strong>一个有限群的每一个元的阶都有限。</p>
<h2 id="有限群的另一定义">有限群的另一定义</h2>
<p><strong>定理一：</strong>设<span class="math inline">\(G\)</span>是有限集，<span class="math inline">\(\cdot\)</span>是定义在<span class="math inline">\(G\)</span>上的映射，若<span class="math inline">\(\cdot\)</span>适合公理Ⅰ、Ⅱ、<span class="math inline">\(Ⅲ&#39;\)</span>​，那么它也适合Ⅲ。</p>
<p><strong>定义一（有限群的第三定义）：</strong>设<span class="math inline">\(G\neq \emptyset\)</span>，<span class="math inline">\(\omicron\)</span>是定义在<span class="math inline">\(G\)</span>上的一个映射，若满足公理Ⅰ、Ⅱ、<span class="math inline">\(Ⅲ&#39;\)</span>，则称<span class="math inline">\(G\)</span>关于<span class="math inline">\(\omicron\)</span>构成一个有限群。</p>
<h2 id="群的同态">群的同态</h2>
<p><strong>定理一:</strong>设<span class="math inline">\((G,\omicron)\)</span>是一个群，<span class="math inline">\((\overline{G},\overline{\omicron})\)</span>是一个代数系统，如果<span class="math inline">\(G\sim \overline{G}\)</span>，那么<span class="math inline">\(\overline{G}\)</span>也是一个群。</p>
<p><strong>定理二：</strong>设<span class="math inline">\(\phi\)</span>是群<span class="math inline">\(G\)</span>到群<span class="math inline">\(\overline{G}\)</span>的同态映射，那么<span class="math inline">\(G\)</span>的单位元的像是<span class="math inline">\(\overline{G}\)</span>的单位元；<span class="math inline">\(a\in G\)</span>的逆元<span class="math inline">\(a^{-1}\)</span>的像是<span class="math inline">\(a\)</span>的像<span class="math inline">\(\phi(a)\)</span>的逆元。</p>
<h2 id="变换群">变换群</h2>
<p><strong>定理一：</strong>集合<span class="math inline">\(A\)</span>上的所有一一变换的集合<span class="math inline">\(G\)</span>关于变换的乘法（复合）构成群。</p>
<strong>定理二：</strong>设<span class="math inline">\(\sigma:\mathbb{R^2\to R^2}\)</span>定义为：<br>
$$<br>

<span class="math display">\[\begin{aligned}
\sigma
\begin{pmatrix}
x\\
y
\end{pmatrix}
=
\begin{pmatrix}
\cos\theta &amp;{-\sin\theta}\\
\sin\theta &amp;\cos\theta
\end{pmatrix}

\begin{pmatrix}
x\\
y
\end{pmatrix}
\quad
(\theta \in \mathbb{R})
\end{aligned}\]</span>
<p>$$</p>
<p>证明：<span class="math inline">\(\sigma\)</span>是<span class="math inline">\(\mathbb{R^2}\)</span>上的一一变换，也称<span class="math inline">\(\sigma\)</span>为以原点为中心的<em>旋转变换</em>，简称<em>旋转</em>。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(\sigma:\mathbb{R^2\to R^2}\)</span>定义为：</p>
$$<br>

<span class="math display">\[\begin{aligned}
\sigma
\begin{pmatrix}
x\\
y
\end{pmatrix}
=
\begin{pmatrix}
\lambda &amp;0\\
0 &amp;\lambda
\end{pmatrix}

\begin{pmatrix}
x\\
y
\end{pmatrix}
=
\begin{pmatrix}
\lambda x\\
\lambda y
\end{pmatrix}
\quad
(\lambda \neq 0)
\end{aligned}\]</span>
<p>$$</p>
<p>证明：<span class="math inline">\(\sigma\)</span>是<span class="math inline">\(\mathbb{R^2}\)</span>上的一一变换，也称<span class="math inline">\(\sigma\)</span>为以原点为中心的<em>位似变换</em>，简称<em>位似</em>。</p>
<p><strong>定理四：</strong>设<span class="math inline">\(\sigma:\mathbb{R^2\to R^2}\)</span>定义为：<br>
<span class="math display">\[
\sigma
\begin{pmatrix}
x\\
y
\end{pmatrix}
=
\begin{pmatrix}
x\\
y
\end{pmatrix}
+
\begin{pmatrix}
a\\
b
\end{pmatrix}
=
\begin{pmatrix}
x+a\\
y+a
\end{pmatrix}
\]</span></p>
<p>证明：<span class="math inline">\(\sigma\)</span>是<span class="math inline">\(\mathbb{R^2}\)</span>上的一一变换，也称<span class="math inline">\(\sigma\)</span>为以原点为中心的<em>平移变换</em>，简称<em>平移</em>。</p>
<p><strong>定义一：</strong>若集合<span class="math inline">\(A\)</span>上的若干一一变换对于变换的乘法作成群，则称这样的群为变换群。</p>
<p><strong>定理五（凯莱定理）：</strong>任何一个群<span class="math inline">\(G\)</span>​都同构于一个变换群（该群所有的一一变换构成的变换群）。</p>
<h2 id="置换群">置换群</h2>
<p><strong>定义一：</strong>有限集上的一一变换叫做置换，同一集合上的若干置换构成的群叫做置换群。包含<span class="math inline">\(n\)</span>个元素的集合上的全体置换作成的群，称为<span class="math inline">\(n\)</span>次对称群，记为<span class="math inline">\(S_n\)</span>。</p>
<p><strong>定理一（有限群的凯莱定理）：</strong>任何一个有限群都同构与一个置换群。</p>
<p><strong>定理二：</strong> <span class="math inline">\(n\)</span>次对称群<span class="math inline">\(S_n\)</span>的阶是<span class="math inline">\(n!\)</span>，即<span class="math inline">\(|S_n|=n!\)</span>。</p>
<p><strong>定理三：</strong>置换可以表示为若干个不相交（没有相同的元素，例如(12)(34)）循环置换的乘积。</p>
<p><strong>定理四：</strong>任何一个循环置换都可以表示为若干个对换的乘积。（k循环可以表示为至少k-1个对换的乘积）</p>
<p><strong>定义二：</strong>在<span class="math inline">\(S_n\)</span>中，能够表示为奇数多个对换乘积的置换称为奇置换，能够表示为偶数个对换乘积的置换称为偶置换，并且把所有偶置换的集合记为<span class="math inline">\(A_n\)</span></p>
<p><strong>定理五：</strong> <span class="math inline">\(n\geq2\)</span>时，<span class="math inline">\(S_n\)</span>中奇置换和偶置换各占一半，即<span class="math inline">\(|A_n|=\frac{n!}{2}\)</span>。</p>
<p><strong>定理六：</strong>两个不相交的循环置换的乘积可以交换</p>
<p><strong>定理七：</strong> <span class="math inline">\(k\)</span>循环的逆元等于反序写出的循环，即：<span class="math inline">\((i_1i_2\cdots i_k)^{-1}=(i_k\cdots i_2i_1)=(i_1i_k\cdots i_2)\)</span>。特别地，对换的逆元等于自身。</p>
<p><strong>定理八：</strong></p>
<p>​ （1）k循环的阶等于k;</p>
<p>​ （2）如果一个置换可以表示为一个k循环和一个l循环的乘积，那么<span class="math inline">\(|\sigma|=lcm(k,l)\)</span>，这里<span class="math inline">\(lcm(k,l)\)</span>表示<span class="math inline">\(k,l\)</span>的最小公倍数。</p>
<h2 id="循环群">循环群</h2>
<p><strong>注解：</strong>欧拉函数<span class="math inline">\(\phi(n)\)</span>定义为小于n且与n互素的非负整数的个数。</p>
<p><strong>定义一：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(a\in G\)</span>，如果对于任意的<span class="math inline">\(b\in G\)</span>，都存在<span class="math inline">\(m\in \mathbb{Z}\)</span>，有<span class="math inline">\(b=a^m\)</span>，则称<span class="math inline">\(a\)</span>为群<span class="math inline">\(G\)</span>的生成元，群<span class="math inline">\(G\)</span>为一个循环群，记为<span class="math inline">\(G=(a)\)</span>。</p>
<p><strong>注解：</strong>整数加群<span class="math inline">\((\mathbb{Z},+)\)</span>是一个循环群。</p>
<p><strong>定理一(循环群基本定理)：</strong>设<span class="math inline">\(G=(a)\)</span>，则</p>
<p>​ （1）若<span class="math inline">\(|a|=\infty\)</span>，则<span class="math inline">\(G\cong(\mathbb{Z},+)\)</span>;</p>
<p>​ （2）若<span class="math inline">\(|a|=n\)</span>，则<span class="math inline">\(G\cong(\mathbb{Z}_n,+)\)</span></p>
<p><strong>推论</strong>假设<span class="math inline">\(G=(a)\)</span>，则</p>
<p>​ (1)若<span class="math inline">\(|a|=\infty\)</span>，则<span class="math inline">\(G\)</span>恰好有两个生成元<span class="math inline">\(a,a^{-1}\)</span>；</p>
<p>​ (2)若<span class="math inline">\(|a|=n\)</span>，则<span class="math inline">\(G\)</span>至少有两个生成元<span class="math inline">\(a,a^{-1}\)</span>(分别对应[1]，[n-1])；</p>
<p>​ (3)<span class="math inline">\(|a|=\infty\)</span>当且仅当<span class="math inline">\(|G|=\infty\)</span>；</p>
<p>​ (4)<span class="math inline">\(|a|=n\)</span>当且仅当<span class="math inline">\(|G|=n\)</span>；</p>
<p><strong>定理二：</strong>设<span class="math inline">\(G=(a)\)</span>是一个<span class="math inline">\(n\)</span>阶循环群，则</p>
<p>​ (1)<span class="math inline">\(|a^r|=\frac{n}{(r,n)}\)</span>；</p>
<p>​ (2)当<span class="math inline">\((r,n)=1\)</span>时，<span class="math inline">\(a^r\)</span>也是一个生成元；</p>
<p>​ (3)<span class="math inline">\(G\)</span>中有欧拉函数<span class="math inline">\(\varphi{(n)}\)</span>个生成元。（<span class="math inline">\(\varphi{(n)}\)</span>表示小于<span class="math inline">\(n\)</span>，且与<span class="math inline">\(n\)</span>互素的非负整数的个数）</p>
<p><strong>推论：</strong>循环群一定是交换群</p>
<h2 id="子群">子群</h2>
<p><strong>定义一：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的一个非空子集，如果<span class="math inline">\(H\)</span>关于<span class="math inline">\(G\)</span>的乘法也能做成群，则称<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的子群，记为<span class="math inline">\(H\leq G\)</span>。如果子群<span class="math inline">\(H\)</span>真包含于G，也称<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的真子群，记为<span class="math inline">\(H&lt;G\)</span>。</p>
<p><strong>定理一（子群第一判定定理）：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的一个非空子集，则<span class="math inline">\(H\leq G\)</span>当且仅当</p>
<p>​ (1)<span class="math inline">\(a,b\in H\)</span>，都有<span class="math inline">\(ab\in H\)</span>；</p>
<p>​ (2)<span class="math inline">\(a\in H\)</span>，有<span class="math inline">\(a^{-1}\in H\)</span>。</p>
<p><strong>推论：</strong>设<span class="math inline">\(H\leq G\)</span>，则<span class="math inline">\(e_H=e_G,a_H^{-1}=a_G^{-1}\)</span>。</p>
<p><strong>定理二（子群第二判定定理）：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的一个非空子集，则<span class="math inline">\(H\leq G\)</span>当且仅当<span class="math inline">\(a,b\in H\)</span>，有<span class="math inline">\(ab^{-1}\in H\)</span>。</p>
<p><strong>定理三（子群第三判定定理）：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的一个非空<em>有限</em>子集，则<span class="math inline">\(H\leq G\)</span>当且仅当<span class="math inline">\(a,b\in H\)</span>，有<span class="math inline">\(ab\in H\)</span>。</p>
<p><strong>推论：</strong>设<span class="math inline">\(G\)</span>是一个有限群，<span class="math inline">\(H\)</span>是<span class="math inline">\(G\)</span>的非空子集，则<span class="math inline">\(H\leq G\)</span>当且仅当<span class="math inline">\(a,b\in H\)</span>，有<span class="math inline">\(ab\in H\)</span>。</p>
<p><strong>定理四：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(S\)</span>是<span class="math inline">\(G\)</span>的一个非空子集，则<span class="math inline">\((S)=\{\underbrace{a^mb^n\cdots c^k}_{有限个}|a,b,\cdots ,c \in S,m,n,k\in \mathbb{Z}\}\)</span>是<span class="math inline">\(G\)</span>的一个子群，且是包含<span class="math inline">\(S\)</span>的最小子群（称为<span class="math inline">\(S\)</span>的生成子群）</p>
<h2 id="子群的陪集">子群的陪集</h2>
<p><strong>定义一：</strong>设<span class="math inline">\(H\leq G,a\in G\)</span>，称<span class="math inline">\(aH=\{ah|h\in H\} \quad (Ha=\{ha|h\in H\})\)</span>为子群<span class="math inline">\(H\)</span>的左陪集（右陪集）。如果<span class="math inline">\(aH=Ha\)</span>，则称它们为子群<span class="math inline">\(H\)</span>的陪集。</p>
<p><strong>命题一：</strong>设$ HG,a,bG$，则</p>
<p>​ (1)<span class="math inline">\(a\in aH \quad (a\in Ha)\)</span></p>
<p>​ (2)<span class="math inline">\(a\in bH \Leftrightarrow aH=bH \Leftrightarrow a^{-1}b\in H\)</span>( <span class="math inline">\(a\in Hb \Leftrightarrow Ha=Hb \Leftrightarrow ab^{-1}\in H\)</span>)</p>
<p>​ (3)<span class="math inline">\(|aH|=|Ha|=|H|\)</span></p>
<p><strong>定理一：</strong>设<span class="math inline">\(S_l,S_r\)</span>分别是群<span class="math inline">\(G\)</span>关于子群<span class="math inline">\(H\)</span>的左、右陪集分解，则<span class="math inline">\(|S_l|=|S_r|\)</span></p>
<p><strong>定义二：</strong>设<span class="math inline">\(H\leq G,s_l,S_r\)</span>分别是<span class="math inline">\(G\)</span>关于<span class="math inline">\(H\)</span>的左、右陪集分解，称<span class="math inline">\(|S_l|=|S_r|\)</span>为<span class="math inline">\(H\)</span>在<span class="math inline">\(G\)</span>中的指数，记为<span class="math inline">\([G:H]\)</span>。</p>
<p><strong>定理二（拉格朗日定理）：</strong>设<span class="math inline">\(G\)</span>是一个有限群，<span class="math inline">\(H\leq G\)</span>，则<span class="math inline">\([G:H]=\frac{|G|}{|H|},\quad (|G|=|H|\cdot [G:H])\)</span>，即<span class="math inline">\(|H|,[G:H]\)</span>都整除<span class="math inline">\(|G|\)</span>。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(G\)</span>是一个有限群，<span class="math inline">\(a\in G\)</span>，则<span class="math inline">\(|a|\)</span>整除<span class="math inline">\(|G|\)</span>。</p>
<p><strong>命题二：</strong>设<span class="math inline">\(G\)</span>是一个群，<span class="math inline">\(e\)</span>是单位元，<span class="math inline">\(a\in G,m,n,k\)</span>都是正整数，则</p>
<p>​ (1)若<span class="math inline">\(|a|=k,a^m=e\)</span>，则<span class="math inline">\(k|m\)</span>；</p>
<p>​ (2)若<span class="math inline">\(m|k,n|k,(m,n)=1\)</span>，则<span class="math inline">\(mn|k\)</span>；</p>
<p>​ (3)若<span class="math inline">\(m|kn,(m,n)=1\)</span>，则<span class="math inline">\(m|k\)</span>。</p>
<h2 id="不变子群和商群">不变子群和商群</h2>
<p><strong>定义一：</strong>设<span class="math inline">\(N\leq G\)</span>，如果对于任意的<span class="math inline">\(a\in G\)</span>，都有<span class="math inline">\(aN=Na\)</span>，则称群<span class="math inline">\(N\)</span>是群<span class="math inline">\(G\)</span>的不变子群（或正规子群），记为<span class="math inline">\(N\vartriangleleft G\)</span>。<span class="math inline">\(N\)</span>的一个左陪集（也是右陪集）称为<span class="math inline">\(N\)</span>的一个陪集。</p>
<p><strong>推论一：</strong></p>
<p>​ (1)循环群的子群都是不变子群。</p>
<p>​ (2)素数阶群的任何子群都是不变子群。</p>
<p><strong>定义二：</strong>设<span class="math inline">\(S_1,S_2,\cdots ,S_m \subseteq G\)</span>，称<span class="math inline">\(S_1S_2\cdots S_m=\{s_1s_2\cdots s_m|s_i\in S_i\}\)</span>为<span class="math inline">\(G\)</span>的子集<span class="math inline">\(S_1,S_2,\cdots ,S_m\)</span>的乘积。</p>
<p><strong>命题一：</strong>群中子集的乘积满足结合律，即<span class="math inline">\((S_1S_2)S_3=S_1(S_2S_3)\)</span></p>
<p><strong>定理一：</strong>设<span class="math inline">\(N\leq G\)</span>，则<span class="math inline">\(N\vartriangleleft G\)</span>当且仅当对于任意的<span class="math inline">\(a\in G\)</span>，有<span class="math inline">\(aNa^{-1}=N\)</span>。</p>
<p><strong>定理二：</strong>设<span class="math inline">\(N\leq G\)</span>，则<span class="math inline">\(N\vartriangleleft G\)</span>当且仅当对于任意的<span class="math inline">\(a\in G\)</span>和任意的<span class="math inline">\(n\in N\)</span>，有<span class="math inline">\(ana^{-1}\in N\)</span>。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(N\vartriangleleft G\)</span>，<span class="math inline">\(G/N=\{aN,bN,\cdots\}\)</span>是群<span class="math inline">\(G\)</span>关于其不变子群<span class="math inline">\(N\)</span>的一个陪集分解，对于任意的<span class="math inline">\(xN,yN\in S\)</span>，定义<span class="math inline">\(xN\cdot yN=(xy)N\)</span>，则<span class="math inline">\(G/N\)</span>关于上述法则作成一个群，称之为群<span class="math inline">\(G\)</span>关于不变子群<span class="math inline">\(N\)</span>的商群。</p>
<p><strong>推论二：</strong>设<span class="math inline">\(G\)</span>是有限群，<span class="math inline">\(N\vartriangleleft G\)</span>，则<span class="math inline">\(|G/N|=\frac{|G|}{|N|}\)</span>。</p>
<h2 id="同态与不变子群">同态与不变子群</h2>
<p><strong>定理一：</strong>一个群<span class="math inline">\(G\)</span>同它的每一个商群<span class="math inline">\(G/N\)</span>同态。</p>
<p><strong>推论一：</strong>交换群的每一个商群都是交换群。</p>
<p><strong>定义一：</strong>设<span class="math inline">\(G,\bar{G}\)</span>都是群，<span class="math inline">\(\phi:G\to \bar{G}\)</span>是一个满同态，则称<span class="math inline">\(ker\phi=\{a\in G|\phi(a)=\bar{e}\}\)</span>为满同态<span class="math inline">\(\phi\)</span>的核。</p>
<p><strong>定理二（同态基本定理：）</strong>设<span class="math inline">\(G,\bar{G}\)</span>都是群，<span class="math inline">\(\phi:G\to \bar{G}\)</span>是一个满同态，则<span class="math inline">\(N=ker\phi\vartriangleleft G\)</span>，且$G/N {G} $。</p>
<p><strong>定义二：</strong>设<span class="math inline">\(\phi:A\to \bar{A}\)</span>是一个满射</p>
<p>​ (1)如果<span class="math inline">\(S\subseteq A\)</span>，则称<span class="math inline">\(\phi(S)=\{\phi(a)|a\in A\}\)</span>为<span class="math inline">\(S\)</span>在<span class="math inline">\(\phi\)</span>下的象。</p>
<p>​ (2)如果<span class="math inline">\(\bar{S}\subseteq \bar{A}\)</span>，则称<span class="math inline">\(\phi^{-1}(\bar{S})=\{\phi^{-1}(\bar{a})|\bar{a}\in \bar{A}\}\)</span>为<span class="math inline">\(\bar{S}\)</span>在<span class="math inline">\(\phi\)</span>下的逆象，或者原象。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(G,\bar{G}\)</span>都是群，<span class="math inline">\(\phi:G\to \bar{G}\)</span>是一个满同态，则</p>
<p>​ (1)若<span class="math inline">\(H\leq G\)</span>，则<span class="math inline">\(\phi(H)\leq \bar{G}\)</span>；</p>
<p>​ (2)若<span class="math inline">\(N\vartriangleleft G\)</span>，则<span class="math inline">\(\phi(N)\vartriangleleft \bar{G}\)</span></p>
<p><strong>定理四：</strong>设<span class="math inline">\(G,\bar{G}\)</span>都是群，<span class="math inline">\(\phi:G\to \bar{G}\)</span>是一个满同态，则</p>
<p>​ (1)若<span class="math inline">\(\bar{H}\leq \bar{G}\)</span>，则<span class="math inline">\(\phi^{-1}(\bar{H})\leq G\)</span>；</p>
<p>​ (2)若<span class="math inline">\(\bar{N}\vartriangleleft \bar{G}\)</span>，则<span class="math inline">\(\phi^{-1}(\bar{N})\vartriangleleft G\)</span><br>
​</p>
<h1 id="近世代数-环与域">近世代数-环与域</h1>
<h2 id="环的定义">环的定义</h2>
<p><strong>定义一：</strong>设集合<span class="math inline">\(R\neq \emptyset , + ,\cdot\)</span>是<span class="math inline">\(R\)</span>上定义的两个映射，如果</p>
<p>​ (1)<span class="math inline">\((R,+)\)</span>构成交换群；</p>
<p>​ (2)<span class="math inline">\((R,\cdot)\)</span>中群公理Ⅰ，Ⅱ成立（构成半群）；</p>
<p>​ (3)左右分配律<span class="math inline">\(c\cdot(a+b)=c\cdot a+a\cdot b,\quad(a+b)\cdot c=a\cdot c+b\cdot c\)</span>成立，</p>
<p>则称<span class="math inline">\(R\)</span>关于<span class="math inline">\(+,\cdot\)</span>作成一个环，记为<span class="math inline">\((R,+,\cdot)\)</span>。</p>
<p><em>ps：加群当中的单位元改称为零元，记为0，元素</em><span class="math inline">\(a\)</span><em>在加群中的逆元改称为负元记为</em><span class="math inline">\(-a\)</span>，<span class="math inline">\(a+(-b)\)</span><em>简写为</em><span class="math inline">\(a-b\)</span><em>，读作</em><span class="math inline">\(a\)</span><em>减</em><span class="math inline">\(b\)</span>。</p>
<p><strong>注记：</strong>我们把所有非零元关于乘法能作成交换群的环叫做<em>域</em>。<br>
<img src="/2022/05/02/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/域的定义的补充.webp" alt="域的定义的补充"></p>
<p><strong>定理一：</strong>环<span class="math inline">\((R,+,\cdot)\)</span>具有一下性质：</p>
<p>​ (1)<span class="math inline">\(0+a=a+0=a\)</span>；</p>
<p>​ (2)<span class="math inline">\(-a+a=a-a=0\)</span>；</p>
<p>​ (3)<span class="math inline">\(-(-a)=a\)</span>；</p>
<p>​ (4)<span class="math inline">\(a+c=b\)</span>等价于<span class="math inline">\(c=b-a\)</span>；</p>
<p>​ (5)<span class="math inline">\(-(a+b)=-a-b,-(a-b)=-a+b\)</span>。</p>
<p><strong>定义二：</strong>设<span class="math inline">\((R,+,\cdot)\)</span>是一个环，<span class="math inline">\(n\in \mathbb{Z_+}\)</span>，称<span class="math inline">\(na=\underbrace{a+a+\cdots+a}_{n个}\)</span>为<span class="math inline">\(a\)</span>的<span class="math inline">\(n\)</span>倍，简称<span class="math inline">\(n\)</span>倍<span class="math inline">\(a\)</span>。</p>
<p><strong>定义三：</strong>设<span class="math inline">\((R,+,\cdot)\)</span>是一个环，<span class="math inline">\(n\in \mathbb{Z_-}\)</span>，规定<span class="math inline">\(0a=0,\quad na=\underbrace{(-a)+(-a)+\cdots+(-a)}_{-n个}\)</span>这里<span class="math inline">\(0a=0\)</span>中，第一个<span class="math inline">\(0\)</span>是整数零，第二个<span class="math inline">\(0\)</span>是环中的零元。</p>
<p><strong>定理二：</strong> 设<span class="math inline">\((R,+,\cdot)\)</span>是一个环，<span class="math inline">\(a\in R,n\in \mathbb{Z_+}\)</span>，则<span class="math inline">\((-n)a=n(-a)=-(na)\)</span>。</p>
<p><strong>定理三：</strong>环<span class="math inline">\((R,+,\cdot)\)</span>具有以下性质：</p>
<p>​ (6)<span class="math inline">\(ma+na=(m+n)a,\quad m\cdot na=mn\cdot a,\quad n(a+b)=na+nb\)</span></p>
<p><strong>定理四：</strong>环<span class="math inline">\((R,+,\cdot)\)</span>具有以下性质：</p>
<p>​ (7)<span class="math inline">\((a-b)c=ac-bc,c(a-b)=ca-cb\)</span>；</p>
<p>​ (8)<span class="math inline">\(0a=a0=0\)</span>；（这里的<span class="math inline">\(0\)</span>指的是零元）</p>
<p>​ (9)<span class="math inline">\((-a)b=a(-b)=-ab\)</span>；</p>
<p>​ (10)<span class="math inline">\((-a)(-b)=ab\)</span>；</p>
<p>​ (11.1)<span class="math inline">\(a(b_1+b_2+\cdots+b_n)=ab_1+ab_2+\cdots+ab_n\)</span>；</p>
<p>​ (11.2)<span class="math inline">\((b_1+b_2+\cdots+b_n)a=b_1a+b_2a+\cdots+b_na\)</span>；</p>
<p>​ (12)<span class="math inline">\((a_1+a_2+\cdots+a_m)(b_1+b_2+\cdots+b_n)=a_1b_1+\cdots+a_1b_n+\cdots+a_mb_1+\cdots+a_mb_n\)</span>；</p>
<p>​ (13)<span class="math inline">\((na)b=a(nb)=n(ab)\)</span>；(<span class="math inline">\(n\)</span>是任意整数)</p>
<p>​ (14)<span class="math inline">\(a^ma^n=a^{m+n},\quad (a^m)^n=a^{mn}\)</span>。（<span class="math inline">\(m.n\)</span>是任意整数）</p>
<h2 id="零因子环和环的分类">零因子环和环的分类</h2>
<p><strong>定义一：</strong>设<span class="math inline">\(R\)</span>是一个换，<span class="math inline">\(a,b\)</span>是<span class="math inline">\(R\)</span>中的两个非零元，如果<span class="math inline">\(ab=0\)</span>，则称<span class="math inline">\(a\)</span>是<span class="math inline">\(R\)</span>的一个<em>左零因子</em>，<span class="math inline">\(b\)</span>是<span class="math inline">\(R\)</span>的一个<em>右零因子</em>，如果一个元素既是左零因子又是右零因子，则称它为一个零因子。</p>
<p><strong>定理一：</strong>在一个无零因子的环中，乘法消去律成立：</p>
<p>​ (1)<span class="math inline">\(a\neq0,\quad ab=ac \Rightarrow b=c\)</span>；</p>
<p>​ (2)<span class="math inline">\(a\neq 0,\quad ba=ca\Rightarrow b=c\)</span>。<br>
反过来，在一个环里，如果有一个消去律成立，那么这个环 没有零因子。</p>
<p><strong>推论一：</strong>在一个环中，如果有一个消去律成立，那么另一个消去律也成立。</p>
<p><strong>定义二：</strong>设<span class="math inline">\(R\)</span>是一个环，</p>
<p>​ (1)如果<span class="math inline">\(R\)</span>的乘法适合交换率，则称<span class="math inline">\(R\)</span>是<em>交换环</em>；</p>
<p>​ (2)如果<span class="math inline">\(R\)</span>有乘法单位元，则称<span class="math inline">\(R\)</span>是<em>含幺环</em>；</p>
<p>​ (3)如果<span class="math inline">\(R\)</span>不含任何零因子，则称<span class="math inline">\(R\)</span>是<em>无零因子环</em>；</p>
<p>​ (4)同时满足(1)、(2)、(3)条件的环，称为<em>整环</em>。</p>
<p><strong>定义三：</strong>设<span class="math inline">\(R\)</span>是一个环，如果</p>
<p>​ (1)<span class="math inline">\(R\)</span>至少包含一个非零元；</p>
<p>​ (2)<span class="math inline">\(R\)</span>有乘法单位元；</p>
<p>​ (3)<span class="math inline">\(R\)</span>的每一个非零元都有乘法逆元。</p>
<p>则称<span class="math inline">\(R\)</span>是一个<em>除环</em>，交换除环称为域。</p>
<h2 id="除环和域的例子与性质">除环和域的例子与性质</h2>
<p><strong>命题一：</strong>一个至少有两个元而且没有零因子的有限环是一个除环。</p>
<p><strong>命题二：</strong>除环是无零因子环。</p>
<p><strong>命题三：</strong>设<span class="math inline">\((R,+,\cdot)\)</span>是一个除环。，<span class="math inline">\(R^*=R-\{0\}\)</span>，则<span class="math inline">\((R^*,\cdot)\)</span>作成一个群，我们将<span class="math inline">\(R^*\)</span>称为除环<span class="math inline">\(R\)</span>的乘群</p>
<p><strong>定义一（域的第二定义）：</strong>设非空集合<span class="math inline">\(F\)</span>上定义有两种法则<span class="math inline">\(+,\cdot\)</span>，如果<span class="math inline">\((F,+),(F^*,\cdot)\)</span>都是交换群，且<span class="math inline">\(+,\cdot\)</span>适合分配律，则称<span class="math inline">\(F\)</span>是一个域。</p>
<p><strong>命题四</strong>在一个域<span class="math inline">\(F\)</span>中，<span class="math inline">\(a,b,c,d\in F,b\neq 0,d\neq 0\)</span>，则：</p>
<p>​ (1)<span class="math inline">\(\frac{a}{b}=\frac{c}{d} \Leftrightarrow ad=bc\)</span>；</p>
<p>​ (2)<span class="math inline">\(\frac{a}{b}+\frac{c}{d}=\frac{ad+bc}{bd}\)</span>；</p>
<p>​ (3)<span class="math inline">\(\frac{a}{b}\cdot \frac{c}{d}=\frac{ac}{bd}\)</span>。</p>
<h2 id="无零因子环的特征">无零因子环的特征</h2>
<p><strong>规则：</strong>在一个环<span class="math inline">\((R,+,\cdot)\)</span>中，我们规定：</p>
<p>​ (1)<span class="math inline">\(\forall a\neq0,\forall m \in\mathbb{Z_+},ma=\underbrace{a+a+\cdots+a}_{m个} \neq0\)</span>，即<em>非零元的加法阶都是无限大</em></p>
<p><strong>定理一：</strong>设<span class="math inline">\(R\)</span>是一个无零因子环，则<span class="math inline">\(R\)</span>中所有非零元对于加法来说，阶都相同（无限大认为是相同的）。</p>
<p><strong>定义一：</strong>一个无零因子环<span class="math inline">\(R\)</span>的非零元的相同的（对于加法来说）阶叫做环<span class="math inline">\(R\)</span>的特征。</p>
<p><strong>定理二：</strong>如果无零因子环<span class="math inline">\(R\)</span>的特征是有限整数<span class="math inline">\(n\)</span>，那么<span class="math inline">\(n\)</span>是素数。</p>
<p><strong>推论一：</strong>整环，除环以及域的特征或是无限大，或是一个素数<span class="math inline">\(P\)</span></p>
<p><strong>命题一：</strong>在一个特征是<span class="math inline">\(P\)</span>的交换环里，有<span class="math inline">\((a+b)^p=a^p+b^p\)</span>。</p>
<h2 id="子环和环的同态">子环和环的同态</h2>
<p><strong>定义一：</strong>设<span class="math inline">\((R,+,\cdot)\)</span>是一个环，<span class="math inline">\(\neq S \subseteq R\)</span>，如果<span class="math inline">\((S,+,\cdot)\)</span>也是一个环，则称<span class="math inline">\(S\)</span>是环<span class="math inline">\(R\)</span>的一个子环，记作<span class="math inline">\(S\leq R\)</span>。</p>
<p>​ <em>PS：类似的还可以定义子除环、子整环、子域</em></p>
<p><strong>定理一：</strong></p>
<p>​ (1)设<span class="math inline">\(R\)</span>是一个环，则<span class="math inline">\(\neq S \subseteq R\)</span>是R的子环，当且仅当对于任意的<span class="math inline">\(a,b\in S,a-b\in S,ab\in S\)</span>；</p>
<p>​ (2)设<span class="math inline">\(R\)</span>是除环（域），则<span class="math inline">\(\neq S \subseteq R\)</span>是R的子除环（子域），当且仅当对于任意的<span class="math inline">\(a,b\in S,a-b\in S\)</span>，且任意的<span class="math inline">\(a,b\in S,b\neq0,ab^{-1}\in S\)</span>。</p>
<p><strong>定理二：</strong>设<span class="math inline">\(R\)</span>是一个环，<span class="math inline">\(\neq \bar{R}\)</span>上有两种代数运算：<span class="math inline">\(\bigoplus,\bigotimes\)</span>。如果纯在漫射<span class="math inline">\(\phi:R\to \bar{R}\)</span>，使得<span class="math inline">\(\phi\)</span>对于一对加法和一队乘法都是同态映射，则<span class="math inline">\(\bar{R}\)</span>也是一个环。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(R,\bar{R}\)</span>是两个环，且<span class="math inline">\(\phi:R\to \bar{R}\)</span>是满同态映射（对于两种运算），则</p>
<p>​ (1)零元的同态像是零元；</p>
<p>​ (2)负元的同态像是负元；</p>
<p>​ (3)单位元的同态像是单位元；</p>
<p>​ (4)<span class="math inline">\(R\)</span>是交换环，则<span class="math inline">\(\bar{R}\)</span>也是交换环。</p>
<p><strong>定理四：</strong>假定<span class="math inline">\(R,\bar{R}\)</span>是两个环，且<span class="math inline">\(R \cong \bar{R}\)</span>，那么</p>
<p>​ (1)若<span class="math inline">\(R\)</span>是整环，则<span class="math inline">\(\bar{R}\)</span>也是整环；</p>
<p>​ (2)若<span class="math inline">\(R\)</span>是除环，则<span class="math inline">\(\bar{R}\)</span>也是除环；</p>
<p>​ (3)若<span class="math inline">\(R\)</span>是域，则<span class="math inline">\(\bar{R}\)</span>也是域。</p>
<p><strong>定理五：</strong>设<span class="math inline">\(A,\bar{A}\)</span>是两个非空集合，<span class="math inline">\(\phi:A\to \bar{A}\)</span>是一一映射，如果<span class="math inline">\(A\)</span>有加法<span class="math inline">\(+\)</span>和乘法<span class="math inline">\(\cdot\)</span>，那么适当的为<span class="math inline">\(\bar{A}\)</span>规定加法和乘法，可以使得<span class="math inline">\(A \cong \bar{A}\)</span>。</p>
<p><strong>定理六（补足定理）：</strong>设<span class="math inline">\(S\)</span>是环<span class="math inline">\(R\)</span>的子环，<span class="math inline">\(S\cong \bar{S}\)</span>，且<span class="math inline">\((R-S)\bigcap\bar{S}=????\)</span>，则存在环<span class="math inline">\(\bar{R}\)</span>与<span class="math inline">\(R\)</span>同构，且<span class="math inline">\(\bar{S}\leq\bar{R}\)</span>。</p>
<h2 id="多项式环">多项式环</h2>
<p><strong>定理一：</strong>设<span class="math inline">\(F\)</span>是一个域，则关于数域上的行列式理论，多项式理论，线性方程组理论，矩阵运算理论，线性空间和线性变换理论在域<span class="math inline">\(F\)</span>上都成立。</p>
<p><strong>定义一：</strong>设<span class="math inline">\(R_0\)</span>是一个有单位元的交换环，<span class="math inline">\(R\leq R_0\)</span>，且<span class="math inline">\(R\)</span>包含<span class="math inline">\(R_0\)</span>的单位元，<span class="math inline">\(\alpha \in R_0\)</span>，则称<span class="math inline">\(a_0+a_1\alpha+\cdots+a_n\alpha^n(a_i\in R)\)</span>为<span class="math inline">\(R\)</span>上的<span class="math inline">\(\alpha\)</span>的一个多项式，<span class="math inline">\(a_i\)</span>叫做多项式的系数。</p>
<p><strong>命题一：</strong> <span class="math inline">\(R[\alpha]=\{f(\alpha)=a_0+a_1\alpha+\cdots+a_n\alpha^n| a_i\in R,\alpha\in R_0,n是非负整数\}\)</span>是<span class="math inline">\(R_0\)</span>的包含<span class="math inline">\(R\)</span>和<span class="math inline">\(\alpha\)</span>的最小子环。（称<span class="math inline">\(R[\alpha]\)</span>为R上的多项式环）</p>
<p><strong>推论一：</strong>多项式环<span class="math inline">\(R[\alpha]\)</span>是有单位元的交换环。</p>
<p><strong>定义二：</strong>设<span class="math inline">\(x\in R_0\)</span>，如果不存在不全为零的元<span class="math inline">\(a_0,a_1,\cdots,a_n\)</span>使得<span class="math inline">\(a_0+a_1x+\cdots+a_nx^n=0\)</span>，则称<span class="math inline">\(x\)</span>为<span class="math inline">\(R\)</span>上的一个未定元。</p>
<p><strong>命题二：</strong> <span class="math inline">\(x\in R_0\)</span>为<span class="math inline">\(R\)</span>上的一个未定元，当且仅当，若<span class="math inline">\(R\)</span>上<span class="math inline">\(x\)</span>的多项式<span class="math inline">\(a0+a_1x+\cdots+a_nx^n=0\)</span>，则系数<span class="math inline">\(a_0=a_1=a_2=\cdots=a_n=0\)</span>。（即零多项式的表示法唯一）</p>
<p><strong>命题三：</strong>环<span class="math inline">\(R\)</span>上未定元<span class="math inline">\(x\)</span>的多项式<span class="math inline">\(f(x)\)</span>的表示法唯一。</p>
<p><strong>定义三：</strong>设<span class="math inline">\(a_0+a_1x+\cdots+a_nx^n,a_n=0\)</span>是环<span class="math inline">\(R\)</span>上的一个一元多项式，那么非负整数<span class="math inline">\(n\)</span>叫做这个多项式的次数。规定多项式0没有次数。.</p>
<p><strong>定理二：</strong>设<span class="math inline">\(R\)</span>是一个含幺交换环，则<span class="math inline">\(R\)</span>上必定存在未定元<span class="math inline">\(x\)</span>，因此也就有<span class="math inline">\(R\)</span>上的多项式环<span class="math inline">\(R[x]\)</span>存在。</p>
<p><strong>定义四：</strong>形如<span class="math inline">\(\Sigma_{i_1,i_2,\cdots,i_n}a_{i_1,i_2,\cdots,i_n} \alpha_1^{i_1}\alpha_2^{i_2}\cdots\alpha_n^{i_n}\)</span>的元叫做<span class="math inline">\(R\)</span>上的元<span class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_n\)</span>的一个多项式，<span class="math inline">\(a_{i_1,i_2,\cdots,i_n}\)</span>叫做多项式的系数（这里<span class="math inline">\(a_{i_1,i_2,\cdots,i_n}\in R\)</span>但是只有有限个不为0）</p>
<p>环<span class="math inline">\(R[\alpha_1,\alpha_2,\cdots,\alpha_3]=R[\alpha_1][\alpha_2]\cdots[\alpha_n]\)</span>叫做<span class="math inline">\(R\)</span>上的<span class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_3\)</span>的多项式。</p>
<p><strong>命题四：</strong>多项式环<span class="math inline">\(R[\alpha_1,\alpha_2]\)</span>中，<span class="math inline">\(\alpha_1\alpha_2=\alpha_2\alpha_1\)</span>。</p>
<p><strong>定义五：</strong>设<span class="math inline">\(n\)</span>个元<span class="math inline">\(x_1,x_2,\cdots,x_n\in R_0\)</span>，如果任何一个<span class="math inline">\(R\)</span>上的<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>的多项式都不会等于<span class="math inline">\(0\)</span>，除非这个多项式的所有系数都等于<span class="math inline">\(0\)</span>，那么则称<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>为<span class="math inline">\(R\)</span>上的无关未定元。</p>
<p><strong>定理三：</strong>设<span class="math inline">\(R\)</span>是一个含幺交换环，<span class="math inline">\(n\in\mathbb{Z_+}\)</span>，则<span class="math inline">\(R\)</span>上无关未定元<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>必定存在，<span class="math inline">\(R\)</span>上的多项式环也一定存在。</p>
<p><strong>定理四：</strong>设<span class="math inline">\(R[x_1,x_2,\cdots,x_n]\)</span>和都<span class="math inline">\(R[x_1,x_2,\cdots,x_n]\)</span>是有单位元的交换环<span class="math inline">\(R\)</span>上的环多项式，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>是<span class="math inline">\(R\)</span>上的无关未定元，<span class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_n\)</span>是<span class="math inline">\(R\)</span>上的任意元，那么多项式环<span class="math inline">\(R[x_1,x_2,\cdots,x_n]\)</span><span class="math inline">\(\sim\)</span><span class="math inline">\(R[x_1,x_2,\cdots,x_n]\)</span>。</p>
<h2 id="理想">理想</h2>
<p><strong>定义一：</strong>设 <span class="math inline">\(\emptyset \neq \mathscr{U} \subseteq\)</span> 环<span class="math inline">\(R\)</span>，如果</p>
<p>​ (1)对于任意的<span class="math inline">\(a,b\in\mathscr{U}\)</span>都有，<span class="math inline">\(a-b\in \mathscr{U}\)</span>；</p>
<p>​ (2)对于任意的<span class="math inline">\(a\in\mathscr{U},r\in R\)</span>吗，都有<span class="math inline">\(ra,ar\in\mathscr{U}\)</span>(强闭合性)</p>
<p>则称<span class="math inline">\(\mathscr{U}\)</span>是环<span class="math inline">\(R\)</span>的理想子环，简称理想，记作<span class="math inline">\(\mathscr{U}\vartriangleleft R\)</span>。</p>
<p><strong>命题一：</strong>理想必定是子环。</p>
<p><strong>注解一：</strong>子环未必是理想，反例：整数环<span class="math inline">\(\mathbb{Z}\)</span>是有理数环<span class="math inline">\(\mathbb{Q}\)</span>的子环，但是不是有理数环<span class="math inline">\(\mathbb{Q}\)</span>的理想。</p>
<p><strong>定理一：</strong>除环和域只有平凡理想。</p>
<p><strong>注解二：</strong>两个理想的并未必还是理想。</p>
<p><strong>命题二：</strong>设<span class="math inline">\(R\)</span>是一个环，<span class="math inline">\(a\in R\)</span>，则</p>
<p>​ <span class="math inline">\(\mathscr{U}=\{(\displaystyle\sum_{i=1}^mx_iay_i)+sa+at+na|x_i,y_i,s,t\in R,n\in\mathbb{Z}\}\)</span>是<span class="math inline">\(R\)</span>包含<span class="math inline">\(a\)</span>的最小的理想，记为<span class="math inline">\((a)\)</span>。<span class="math inline">\((a)\)</span>称为<span class="math inline">\(R\)</span>的元<span class="math inline">\(a\)</span>生成的主理想。</p>
<p><strong>推论一：</strong>设<span class="math inline">\(R\)</span>是一个环，<span class="math inline">\(a\in R\)</span>，则</p>
<p>​ (1)若<span class="math inline">\(R\)</span>是交换环，则<span class="math inline">\((a)=\{ra+na|r\in R,n\in\mathbb{Z}\}\)</span></p>
<p>​ (2)若<span class="math inline">\(R\)</span>是含幺环，则<span class="math inline">\((a)=\{\displaystyle\sum_{i=1}^mx_iay_i|x_1,y_i\in R\}\)</span></p>
<p>​ (3)若<span class="math inline">\(R\)</span>是有单位元的交换环，则<span class="math inline">\((a)=\{ra|r\in R\}\)</span>。</p>
<p><strong>推论二：</strong>整数环<span class="math inline">\(\mathbb{Z}\)</span>的每一个理想<span class="math inline">\(\mathscr{U}\)</span>是它的主理想。</p>
<p><strong>注解三：</strong></p>
<p>​ (1)当<span class="math inline">\(k=0\)</span>时，整数环<span class="math inline">\(\mathbb{Z}\)</span>的主理想<span class="math inline">\((0)=\{r0|r\in\mathbb{Z}\}={0}\)</span>是零理想</p>
<p>​ (2)当<span class="math inline">\(k=1\)</span>时，整数环<span class="math inline">\(\mathbb{Z}\)</span>的主理想<span class="math inline">\((1)=\{r1=r|r\in\mathbb{Z}\}=\mathbb{Z}\)</span>是单位理想</p>
<p><strong>命题三：</strong> <span class="math inline">\(\mathbb{Z}_n\)</span>的理想都是主理想，并且<span class="math inline">\(\mathbb{Z}_n\)</span>的理想的个数等于<span class="math inline">\(n\)</span>的正因子的个数。</p>
<p><strong>命题四：</strong>设<span class="math inline">\(R\)</span>是一个环，<span class="math inline">\(a_1,a_2,\cdots,a_m\in R\)</span>，<span class="math inline">\(\mathscr{U}=\{s_1+s_2+\cdots+s_m|s_i\in(a_i)\}\)</span>则<span class="math inline">\(\mathscr{U}\)</span>是<span class="math inline">\(R\)</span>的包含<span class="math inline">\(a_1,a_2,\cdots,a_m\)</span>的最小理想，称<span class="math inline">\(\mathscr{U}\)</span>为<span class="math inline">\(R\)</span>的由<span class="math inline">\(a_1,a_2,\cdots,a_m\)</span>确定的生成理想，记为<span class="math inline">\((a_1,a_2,\cdots,a_m)\)</span>。</p>
<p><strong>注解四：</strong>更一般的结论是：在整数环中，生成理想<span class="math inline">\((k,l)\)</span>等于主理想<span class="math inline">\((a)\)</span>，并且<span class="math inline">\(a\)</span>是<span class="math inline">\(k,l\)</span>的最大公因数。</p>
<h2 id="剩余类环商环同态与理想">剩余类环（商环），同态与理想</h2>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>抽象代数</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机数值表示</title>
    <url>/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="计算机数值表示">计算机数值表示</h1>
<h2 id="符号定义">符号定义</h2>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 5%">
<col style="width: 29%">
<col style="width: 57%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Symbol</th>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Meaning</th>
<th style="text-align: center;">Defineition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(B2T_w\)</span></td>
<td style="text-align: center;">函数</td>
<td style="text-align: center;">Binary to two's complement</td>
<td style="text-align: center;"><span class="math inline">\(\vec{x} = [x_{w-1},x_{w-2},\cdots,x_0];\;B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(B2U_w\)</span></td>
<td style="text-align: center;">函数</td>
<td style="text-align: center;">Binary to unsigned</td>
<td style="text-align: center;"><span class="math inline">\(\vec{x} = [x_{w-1},x_{w-2},\cdots,x_0];\;B2U_w(\vec{x})=\sum\limits_{i=0}^{w-1}x_i2^i\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(U2B_w\)</span></td>
<td style="text-align: center;">函数</td>
<td style="text-align: center;">Unsigned to binary</td>
<td style="text-align: center;"><span class="math inline">\(B2U_w\)</span>的反函数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(U2T_w\)</span></td>
<td style="text-align: center;">函数</td>
<td style="text-align: center;">Unsigned to two's complement</td>
<td style="text-align: center;"><span class="math display">\[0\leq u\leq UMax_w;U2T_w(u)=B2T_w(U2B_w(u))=\begin{cases}u, u\leq TMax_w \\ u-2^w,  u&gt;TMax_w\end{cases}\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(T2B_w\)</span></td>
<td style="text-align: center;">函数</td>
<td style="text-align: center;">Two's complement to binary</td>
<td style="text-align: center;"><span class="math inline">\(B2T_w\)</span>的反函数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(T2U_w\)</span></td>
<td style="text-align: center;">函数</td>
<td style="text-align: center;">Two's complement to unsigned</td>
<td style="text-align: center;"><span class="math display">\[TMin_w \leq x \leq TMax_w; T2U_{w}(x) = B2U_{w}(T2B_{w}(x))= \begin{cases} x+2^w, x&lt;0\\x, x\geq 0 \end{cases}\]</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(TMin_w\)</span></td>
<td style="text-align: center;">常数</td>
<td style="text-align: center;">Minimum two's-complement value</td>
<td style="text-align: center;"><span class="math inline">\(-2^{w-1}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(TMax_w\)</span></td>
<td style="text-align: center;">常数</td>
<td style="text-align: center;">Maximum two's-complement value</td>
<td style="text-align: center;"><span class="math inline">\(2^{w-1}-1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(UMax_w\)</span></td>
<td style="text-align: center;">常数</td>
<td style="text-align: center;">Maximum unsigned value</td>
<td style="text-align: center;"><span class="math inline">\(2^w-1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(+_w^t\)</span></td>
<td style="text-align: center;">操作符</td>
<td style="text-align: center;">Two's-complement addition</td>
<td style="text-align: center;">Let us deﬁne the operation <span class="math inline">\(+_w^t\)</span> for arguments <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, where <span class="math inline">\(-2^{w-1} \leq x, y \leq 2^{w-1}-1\)</span>, as the result of truncating the integer sum <span class="math inline">\(x + y\)</span> to be <span class="math inline">\(w\)</span> bits long and then viewing the result as a two’s-complement number.</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(+_w^u\)</span></td>
<td style="text-align: center;">操作符</td>
<td style="text-align: center;">Unsigned addition</td>
<td style="text-align: center;">Let us deﬁne the operation <span class="math inline">\(+_w^u\)</span> for arguments <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, where <span class="math inline">\(0 \leq x, y &lt; 2^w\)</span>, as the result of truncating the integer sum <span class="math inline">\(x + y\)</span> to be <span class="math inline">\(w\)</span> bits long and then viewing the result as an unsigned number</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(*_w^t\)</span></td>
<td style="text-align: center;">操作符</td>
<td style="text-align: center;">Two's-complement multiplication</td>
<td style="text-align: center;"><span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>相乘，然后截断<span class="math inline">\(w\)</span>比特，将剩余的比特按照补码解析。等效于<span class="math inline">\(x \; *_w^t \; y=U2T_w((x ·y)\; mod \; 2^w)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(*_w^u\)</span></td>
<td style="text-align: center;">操作符</td>
<td style="text-align: center;">Unsigned multiplication</td>
<td style="text-align: center;"><span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>相乘，然后截断<span class="math inline">\(w\)</span>比特，将剩余的比特按照无符号数解析。等效于<span class="math inline">\(x \; *_w^u \; y=(x ·y)\; mod \; 2^w\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(-_w^t\)</span></td>
<td style="text-align: center;">操作符</td>
<td style="text-align: center;">Two's-complement negation</td>
<td style="text-align: center;">补码数的逆元运算符，满足<span class="math inline">\(-_w^tx+_w^tx=0\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(-_w^u\)</span></td>
<td style="text-align: center;">操作符</td>
<td style="text-align: center;">Unsigned negation</td>
<td style="text-align: center;">无符号数的逆元运算符，满足<span class="math inline">\(-_w^ux+_w^ux=0\)</span></td>
</tr>
</tbody>
</table>
<p>PS:w表示数据的位宽，<span class="math inline">\(\vec{x}\)</span>表示二进制bits序列</p>
<h2 id="数值截断">数值截断</h2>
<h3 id="无符号数截断">无符号数截断</h3>
<p><span class="math inline">\(\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]\)</span>，为<span class="math inline">\(w\)</span>比特的二进制矢量；<span class="math inline">\(\vec{x}^\prime = [x_{k-1},x_{k-2},\cdots,x_0]\)</span>，表示被截断之后的<span class="math inline">\(k\)</span>比特二进制矢量，其中<span class="math inline">\(w\geq k\)</span>。定义<span class="math inline">\(x=B2U_w(\vec{x});x^\prime=B2U_k(\vec{x}^\prime)\)</span>，则可以得<span class="math inline">\(x^\prime = x\;mod\;2^k\)</span>。记<span class="math inline">\(x^\prime=C_k^ux\)</span></p>
<p>证明如下：<br>
<span class="math display">\[
\begin{align*}
B2U_w([x_{w-1},x_{w-2},\cdots,x_0])\;mod\; 2^k &amp;=\left[\sum_{i=0}^{w-1}x_i2^i\right]\; mod \; 2^k \\
&amp;=\left[\sum_{i=0}^{k-1}x_i2^i\right]\; mod \; 2^k \\
&amp;= \sum_{i=0}^{k-1}x_i2^i \\
&amp;=B2U_k([x_{k-1},x_{k-2},\cdots,x_0])
\end{align*}
\]</span></p>
<p>因此可以得到：<br>
<span class="math display">\[
\begin{align*}
x^\prime = C_k^ux=x\; mod\; 2^k
\end{align*}
\]</span></p>
<h3 id="截断补码">截断补码</h3>
<p><span class="math inline">\(\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]\)</span>，为<span class="math inline">\(w\)</span>比特的二进制矢量；<span class="math inline">\(\vec{x}^\prime = [x_{k-1},x_{k-2},\cdots,x_0]\)</span>，表示被截断之后的<span class="math inline">\(k\)</span>比特二进制矢量，其中<span class="math inline">\(w\geq k\)</span>。定义<span class="math inline">\(x=B2T_w(\vec{x});x^\prime=B2T_k(\vec{x}^\prime)\)</span>，则可以得<span class="math inline">\(x^\prime = U2T_k(x\;mod\;2^k)\)</span>。记<span class="math inline">\(x^\prime=C_k^tx\)</span></p>
<p>证明如下：<br>
<span class="math display">\[
\begin{align*}
U2T_k(x\;mod\;2^k) 
&amp;= U2T_k(B2T_w([x_{w-1},x_{w-2},\cdots,x_0])\;mod\;2^k) \\
&amp;=U2T_k\left(\left[-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i\right]\; mod \; 2^k\right) \\
&amp;=U2T_k\left(\left[\sum_{i=0}^{k-1}x_i2^i\right]\; mod \; 2^k\right) \\
&amp;= U2T_k\left(\sum_{i=0}^{k-1}x_i2^i \right)\\
&amp;= U2T_k\left(B2U_k([x_{k-1},x_{k-2},\cdots,x_0])\right)\\
&amp;= B2T_k(U2B_k(B2U_k[x_{k-1},x_{k-2},\cdots,x_0]))\\
&amp;= B2T_k([x_{k-1},x_{k-2},\cdots,x_0])\\
&amp;= x^\prime
\end{align*}
\]</span></p>
<p>因此可以得到：<br>
<span class="math display">\[
\begin{align*}
x^\prime = C_k^tx=U2T_k(x\; mod \; 2^k)
\end{align*}
\]</span></p>
<h2 id="整数运算">整数运算</h2>
<h3 id="无符号加">无符号加</h3>
<p>Let us deﬁne the operation <span class="math inline">\(+_w^u\)</span> for arguments x and y, where <span class="math inline">\(0 \leq x, y &lt; 2^w\)</span>, as the result of truncating the integer sum <span class="math inline">\(x + y\)</span> to be <span class="math inline">\(w\)</span> bits long and then viewing the result as an unsigned number。</p>
<p>上述定义等效如下数学等式：其中<span class="math inline">\(C_w^u\)</span>为一个运算符，将无符号数截断为<span class="math inline">\(w\)</span>比特。<br>
<span class="math display">\[
\begin{align*}
x\;+_w^u\;y = C_w^u(x+y)=(x+y) \; mod \; 2^w
\end{align*}
\]</span></p>
<p>从而可以推导出无符号加法具有下面的性质：<br>
<span class="math display">\[
\begin{equation*}
x\;+_w^u\;y = 
\begin{cases}
x+y,&amp;x+y&lt;2^w &amp;Normal\\
x+y-2^w, &amp;2^w\leq x+y&lt; 2^{w+1} &amp; Overflow
\end{cases}
\end{equation*}
\]</span><br>
无符号加法本质上是模<span class="math inline">\(2^w\)</span>加法。</p>
<p><strong>溢出检测：</strong></p>
<p><span class="math inline">\(0\leq x,y&lt; UMax_w\)</span>，记<span class="math inline">\(s=x \; +_w^u \; y\)</span>，当且仅当<span class="math inline">\(s&lt;x\)</span>(或者等效的<span class="math inline">\(s&lt;y\)</span>)时，计算是溢出的（充要条件）</p>
<h3 id="无符号减无符号加的逆">无符号减（无符号加的逆）</h3>
<p>对于任意的<span class="math inline">\(x(0\leq x&lt;2^w)\)</span>，其<span class="math inline">\(w\)</span>比特的逆元<span class="math inline">\(-_w^ux\)</span>定义如下：<br>
<span class="math display">\[
\begin{equation*}
-_w^ux =
\begin{cases}
x,&amp;x=0\\
2^w-x,&amp;x&gt;0
\end{cases}
\end{equation*}
\]</span></p>
<h3 id="补码加">补码加</h3>
<p>Let us deﬁne the operation <span class="math inline">\(+_w^t\)</span> for arguments <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, where <span class="math inline">\(-2^{w-1} \leq x, y \leq 2^{w-1}-1\)</span>, as the result of truncating the integer sum <span class="math inline">\(x + y\)</span> to be <span class="math inline">\(w\)</span> bits long and then viewing the result as a two’s-complement number.</p>
<p>上述定义等效如下数学等式：其中<span class="math inline">\(C_w^t\)</span>为一个运算符，将补码截断为<span class="math inline">\(w\)</span>比特。<br>
<span class="math display">\[
\begin{align*}
x \; +_w^t \; y=C_w^t(x+y)=U2T_w((x+y)\; mod \; 2^w)
\end{align*}
\]</span><br>
对于<span class="math inline">\(-2^{w-1} \leq x, y \leq 2^{w-1}-1\)</span>，<span class="math inline">\(+_w^t\)</span>具有如下的性质：<br>
<span class="math display">\[
\begin{equation*}
x \; +_w^t \; y=
\begin{cases}
x+y-2^w, &amp; 2^{w-1}-1 &lt; x+y &amp; Positive \; overflow \\
x+y, &amp; -2^{w-1} \leq x+y \leq 2^{w-1}-1 &amp;Normal \\
x+y+2^w, &amp; x+y&lt;-2^{w-1} &amp; Negative \; overflow
\end{cases}
\end{equation*}
\]</span><br>
除此之外，由于补码加法与无符号的加法有相同的比特级的表示(依据补码加法的定义)，因此：<br>
<span class="math display">\[
\begin{equation*}
x \; +_w^t \; y=U2T_w(T2U_w(x) \; +_w^u \; T2U_w(y))
\end{equation*}
\]</span><br>
由于<span class="math inline">\(T2U_w(x)=x_{w-1}2^w+x\)</span>，所以：<br>
<span class="math display">\[
\begin{align*}
x \; +_w^t \; y &amp;= U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y) \; mod \;  2^w]\\
&amp;=U2T_w[(x+y) \; mod \; 2^w]
\end{align*}
\]</span></p>
<p><strong>溢出检测:</strong></p>
<p><span class="math inline">\(TMin_w\leq x,y \leq TMax_w\)</span>，记<span class="math inline">\(s=x \; +_w^t \; y\)</span>，当且仅当<span class="math inline">\(x&gt;0\)</span>，<span class="math inline">\(y&gt;0\)</span>，但是<span class="math inline">\(s\leq 0\)</span>时，计算是上溢的（充要条件）。当且仅当<span class="math inline">\(x&lt;0\)</span>，<span class="math inline">\(y&lt;0\)</span>，但是<span class="math inline">\(s\geq 0\)</span>时，计算是下溢的（充要条件）。</p>
<h3 id="补码减补码加的逆">补码减（补码加的逆）</h3>
<p>对于每一个<span class="math inline">\(x(TMin_w\leq x \leq Tmax_w)\)</span>，都存在一个<span class="math inline">\(+_w^t\)</span>运算的逆，其表示为<span class="math inline">\(-_w^tx\)</span>，其定义如下：<br>
<span class="math display">\[
\begin{equation*}
-_w^tx = 
\begin{cases}
TMin_x, &amp;x=TMin_w\\
-x, &amp; x&gt;TMin_w
\end{cases}
\end{equation*}
\]</span></p>
<h3 id="无符号加与补码加的比特级等效性">无符号加与补码加的比特级等效性</h3>
<p>定义<span class="math inline">\(\vec{x}\)</span>和<span class="math inline">\(\vec{y}\)</span>是长度为<span class="math inline">\(w\)</span>的向量；定义整数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>表示该向量以补码解释的整数值（<span class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span class="math inline">\(y=B2T_w(\vec{y})\)</span>）；定义非负整数<span class="math inline">\(x^\prime\)</span>和<span class="math inline">\(y^\prime\)</span>表示该向量以无符号数解释的整数值（<span class="math inline">\(x ^ \prime = B2U_w(\vec{x})\)</span>，<span class="math inline">\(y^\prime=B2U_w(\vec{y})\)</span>）。则具有以下性质：<br>
<span class="math display">\[
\begin{equation*}
T2B_w(x\; +_w^t \; y)=U2B_w(x^\prime \; +_w^u \; y^\prime)
\end{equation*}
\]</span><br>
示例如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(Mode\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x\)</span></th>
<th style="text-align: center;"><span class="math inline">\(y\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x + y\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Truncated\;\;x + y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Unsigned</td>
<td style="text-align: center;">5 [101]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">8 [1000]</td>
<td style="text-align: center;">0 [000]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Two's complement</td>
<td style="text-align: center;">−3 [101]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">0 [0000]</td>
<td style="text-align: center;">0 [000]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Unsigned</td>
<td style="text-align: center;">4 [100]</td>
<td style="text-align: center;">7 [111]</td>
<td style="text-align: center;">11 [1011]</td>
<td style="text-align: center;">3 [011]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Two's complement</td>
<td style="text-align: center;">−4 [100]</td>
<td style="text-align: center;">−1 [111]</td>
<td style="text-align: center;">-5 [1011]</td>
<td style="text-align: center;">3 [011]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Unsigned</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">6 [0110]</td>
<td style="text-align: center;">6 [110]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Two's complement</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">6 [0110]</td>
<td style="text-align: center;">-2 [110]</td>
</tr>
</tbody>
</table>
<p>证明如下：</p>
<p><strong>证明1</strong>：<br>
<span class="math display">\[
\begin{align*}
\because x^\prime=x+x_{w-1}2^w \;\;\;\; y^\prime=y+y_{w-1}2^w \\
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\therefore (x^\prime+y^\prime)\;mod \; 2^w &amp;=[(x+x_{w-1}2^w)+(y+y_{w-1}2^w)]\; mod \; 2^w \\
&amp;=[x+y+(x_{w-1}+y_{w-1})2^w]\; mod \; 2^w\\
&amp;=(x+y)\; mod \; 2^w
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\because x \; +_w^t \; y=U2T_w((x+y)\; mod \; 2^w)
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\therefore T2U_w(x \; +_w^t \; y)=T2U_w(U2T_w((x+y)\; mod\; 2^w))=(x+y)\;mod\; 2^w
\end{align*}
\]</span></p>
<p>综合上述推导可以得到：<br>
<span class="math display">\[
\begin{align*}
T2U_w(x \; +_w^t \; y)=(x+y)\;mod \; 2^w=(x^\prime+y^\prime)\;mod \; 2^w=x^\prime \; +_w^u \; y^\prime
\end{align*}
\]</span><br>
对等式两边同时运用<span class="math inline">\(U2B_w\)</span>算子，可以得到：<br>
<span class="math display">\[
\begin{align*}
U2B_w(T2U_w(x \; +_w^t \; y))=T2B_w(x \; +_w^t \; y)=U2B_w(x^\prime \; +_w^u \; y^\prime)
\end{align*}
\]</span><br>
<strong>证明2：</strong></p>
<p><span class="math display">\[
\begin{align*}
\because x=x^\prime-x_{w-1}2^w \;\;\;\; y=y^\prime-y_{w-1}2^w\\
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\therefore
x \; +_w^t \; y=C_w^t(x+y)&amp;=U2T_w((x+y)\; mod \; 2^w) \\
&amp;=U2T_w(((x^\prime-x_{w-1}2^w)+(y^\prime-y_{w-1}2^w)) \; mod \; 2^w) \\
&amp;=U2T_w((x^\prime+y^\prime-(x_{w-1}+y_{w-1})2^w) \; mod \; 2^w)\\
&amp;=U2T_w((x^\prime+y^\prime) \; mod \; 2^w) \\
&amp;=U2T_w(x^\prime\;+_w^u\;y^\prime)
\end{align*}
\]</span></p>
<p>对等式两边同时运用<span class="math inline">\(T2B_w\)</span>算子，可以得到：<br>
<span class="math display">\[
\begin{align*}
T2B_w(x \; +_w^t \; y)=T2B_w(U2T_w(x^\prime\;+_w^u\;y^\prime))=U2B_w(x^\prime\;+_w^u\;y^\prime)
\end{align*}
\]</span></p>
<h3 id="无符号乘法">无符号乘法</h3>
<p>对于<span class="math inline">\(0\leq x,y \leq UMax_w\)</span>，其无符号乘法定义如下：<br>
<span class="math display">\[
\begin{equation*}
x \; *_w^u \; y=C_w^u(x·y)=(x ·y)\; mod \; 2^w
\end{equation*}
\]</span></p>
<h3 id="补码乘法">补码乘法</h3>
<p>对于<span class="math inline">\(TMin_w \leq x,y \leq TMax_w\)</span>，其补码乘法定义如下：<br>
<span class="math display">\[
\begin{equation*}
x \; *_w^t \; y=C_w^t(x·y)=U2T_w((x ·y)\; mod \; 2^w)
\end{equation*}
\]</span></p>
<h3 id="无符号乘法与补码乘法的比特级等效性">无符号乘法与补码乘法的比特级等效性</h3>
<p>定义<span class="math inline">\(\vec{x}\)</span>和<span class="math inline">\(\vec{y}\)</span>是长度为<span class="math inline">\(w\)</span>的向量；定义整数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>表示该向量以补码解释的整数值（<span class="math inline">\(x=B2T_w(\vec{x})\)</span>，<span class="math inline">\(y=B2T_w(\vec{y})\)</span>）；定义非负整数<span class="math inline">\(x^\prime\)</span>和<span class="math inline">\(y^\prime\)</span>表示该向量以无符号数解释的整数值（<span class="math inline">\(x ^ \prime = B2U_w(\vec{x})\)</span>，<span class="math inline">\(y^\prime=B2U_w(\vec{y})\)</span>）。则具有以下性质：<br>
<span class="math display">\[
\begin{equation*}
T2B_w(x\; *_w^t \; y)=U2B_w(x^\prime \; *_w^u \; y^\prime)
\end{equation*}
\]</span><br>
示例如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(Mode\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x\)</span></th>
<th style="text-align: center;"><span class="math inline">\(y\)</span></th>
<th style="text-align: center;"><span class="math inline">\(x · y\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Truncated\;\;x · y\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Unsigned</td>
<td style="text-align: center;">5 [101]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">15 [001111]</td>
<td style="text-align: center;">7 [111]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Two's complement</td>
<td style="text-align: center;">−3 [101]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">−9 [110111]</td>
<td style="text-align: center;">−1 [111]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Unsigned</td>
<td style="text-align: center;">4 [100]</td>
<td style="text-align: center;">7 [111]</td>
<td style="text-align: center;">28 [011100]</td>
<td style="text-align: center;">4 [100]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Two's complement</td>
<td style="text-align: center;">−4 [100]</td>
<td style="text-align: center;">−1 [111]</td>
<td style="text-align: center;">4 [000100]</td>
<td style="text-align: center;">−4 [100]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Unsigned</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">9 [001001]</td>
<td style="text-align: center;">1 [001]</td>
</tr>
<tr class="even">
<td style="text-align: center;">Two's complement</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">3 [011]</td>
<td style="text-align: center;">9 [001001]</td>
<td style="text-align: center;">1 [001]</td>
</tr>
</tbody>
</table>
<p>证明如下：<br>
<span class="math display">\[
\begin{align*}
&amp;\because x^\prime=x+x_{w-1}2^w \;\;\;\; y^\prime=y+y_{w-1}2^w &amp;\\
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\therefore (x^\prime·y^\prime)\;mod \; 2^w &amp;=[(x+x_{w-1}2^w)·(y+y_{w-1}2^w)]\; mod \; 2^w \\
&amp;=[x·y+(x_{w-1}y+y_{w-1}x)2^w+x_{w-1}y_{w-1}w^{2w}]\; mod \; 2^w\\
&amp;=(x·y)\; mod \; 2^w
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\because x \; *_w^t \; y=U2T_w((x ·y)\; mod \; 2^w)
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\therefore T2U_w(x \; *_w^t \; y)=T2U_w(U2T_w((x·y)\; mod\; 2^w))=(x·y)\;mod\; 2^w
\end{align*}
\]</span></p>
<p>综合上述推导可以得到：<br>
<span class="math display">\[
\begin{align*}
T2U_w(x \; *_w^t \; y)=(x·y)\;mod \; 2^w=(x^\prime ·y^\prime)\;mod \; 2^w=x^\prime \; *_w^u \; y^\prime
\end{align*}
\]</span></p>
<p>对等式两边同时运用<span class="math inline">\(U2B_w\)</span>算子，可以得到：<br>
<span class="math display">\[
\begin{align*}
U2B_w(T2U_w(x \; *_w^t \; y))=T2B_w(x \; *_w^t \; y)=U2B_w(x^\prime \; *_w^u \; y^\prime)
\end{align*}
\]</span></p>
]]></content>
      <categories>
        <category>math</category>
        <category>CS</category>
      </categories>
      <tags>
        <tag>数值表示</tag>
        <tag>数值计算</tag>
      </tags>
  </entry>
</search>
